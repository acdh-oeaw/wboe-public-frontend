!function(I){var g={};function n(t){if(g[t])return g[t].exports;var i=g[t]={i:t,l:!1,exports:{}};return I[t].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=I,n.c=g,n.d=function(I,g,t){n.o(I,g)||Object.defineProperty(I,g,{enumerable:!0,get:t})},n.r=function(I){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},n.t=function(I,g){if(1&g&&(I=n(I)),8&g)return I;if(4&g&&"object"==typeof I&&I&&I.__esModule)return I;var t=Object.create(null);if(n.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:I}),2&g&&"string"!=typeof I)for(var i in I)n.d(t,i,function(g){return I[g]}.bind(null,i));return t},n.n=function(I){var g=I&&I.__esModule?function(){return I.default}:function(){return I};return n.d(g,"a",g),g},n.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},n.p="/dist/",n(n.s=11)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.5.17\n * (c) 2014-2018 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value e.g. [object Object]\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it... e.g.\n * PhantomJS 1.x. Technically we don't need this anymore since native bind is\n * now more performant in most browsers, but removing it would be breaking for\n * code that was able to run in PhantomJS 1.x, so this must be kept for\n * backwards compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n})\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (false) { var repeat, classify, classifyRE, hasConsole; }\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  if (!getter && arguments.length === 2) {\n    val = obj[key];\n  }\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {}\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (false\n  ) {}\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n     false && false;\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (false\n  ) {}\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n     false && false;\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n       false && false;\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n     false && false;\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (false) {}\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && \"production\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'can only contain alphanumeric characters and the hyphen, ' +\n      'and must start with a letter.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {}\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (false) {}\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (false) {}\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {}\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {}\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  if (\n    false\n  ) {}\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (false) {}\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n      \" Expected \" + (expectedTypes.map(capitalize).join(', ')) +\n      \", got \" + (toRawType(value)) + \".\",\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (vm) {\n    var cur = vm;\n    while ((cur = cur.$parent)) {\n      var hooks = cur.$options.errorCaptured;\n      if (hooks) {\n        for (var i = 0; i < hooks.length; i++) {\n          try {\n            var capture = hooks[i].call(cur, err, vm, info) === false;\n            if (capture) { return }\n          } catch (e) {\n            globalHandleError(e, cur, 'errorCaptured hook');\n          }\n        }\n      }\n    }\n  }\n  globalHandleError(err, vm, info);\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      logError(e, null, 'config.errorHandler');\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (false) {}\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n/* globals MessageChannel */\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using both microtasks and (macro) tasks.\n// In < 2.4 we used microtasks everywhere, but there are some scenarios where\n// microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690) or even between bubbling of the same\n// event (#6566). However, using (macro) tasks everywhere also has subtle problems\n// when state is changed right before repaint (e.g. #6813, out-in transitions).\n// Here we use microtask by default, but expose a way to force (macro) task when\n// needed (e.g. in event handlers attached by v-on).\nvar microTimerFunc;\nvar macroTimerFunc;\nvar useMacroTask = false;\n\n// Determine (macro) task defer implementation.\n// Technically setImmediate should be the ideal choice, but it's only available\n// in IE. The only polyfill that consistently queues the callback after all DOM\n// events triggered in the same loop is by using MessageChannel.\n/* istanbul ignore if */\nif (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  macroTimerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else if (typeof MessageChannel !== 'undefined' && (\n  isNative(MessageChannel) ||\n  // PhantomJS\n  MessageChannel.toString() === '[object MessageChannelConstructor]'\n)) {\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = flushCallbacks;\n  macroTimerFunc = function () {\n    port.postMessage(1);\n  };\n} else {\n  /* istanbul ignore next */\n  macroTimerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\n// Determine microtask defer implementation.\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  microTimerFunc = function () {\n    p.then(flushCallbacks);\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n} else {\n  // fallback to macro\n  microTimerFunc = macroTimerFunc;\n}\n\n/**\n * Wrap a function so that if any code inside triggers state change,\n * the changes are queued using a (macro) task instead of a microtask.\n */\nfunction withMacroTask (fn) {\n  return fn._withTask || (fn._withTask = function () {\n    useMacroTask = true;\n    var res = fn.apply(null, arguments);\n    useMacroTask = false;\n    return res\n  })\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    if (useMacroTask) {\n      macroTimerFunc();\n    } else {\n      microTimerFunc();\n    }\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (false) { var perf; }\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) { var getHandler, hasHandler, isBuiltInModifier, hasProxy, warnNonPresent, allowedGlobals; }\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, def, cur, old, event;\n  for (name in on) {\n    def = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    /* istanbul ignore if */\n    if (isUndef(cur)) {\n       false && false;\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (false) { var keyInLowerCase; }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n       false && false;\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                 false\n                  ? (undefined)\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once) {\n  if (once) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$off(event[i], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    if (fn) {\n      // specific handler\n      var cb;\n      var i$1 = cbs.length;\n      while (i$1--) {\n        cb = cbs[i$1];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i$1, 1);\n          break\n        }\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (false) { var lowerCaseEvent; }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\n        }\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (false) {}\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (false) {} else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (false) {}\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (false) {}\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (false) {}\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {}\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$1 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$1; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? undefined\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n       false && false;\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (false) { var hyphenatedKey; } else {\n      defineReactive(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n     false && false;\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (false) {}\n    if (props && hasOwn(props, key)) {\n       false && false;\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (false) {}\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {}\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : userDef;\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  if (false) {}\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (false) {}\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (false) {}\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {} else {\n        defineReactive(vm, key, result[key]);\n      }\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject).filter(function (key) {\n        /* istanbul ignore next */\n        return Object.getOwnPropertyDescriptor(inject, key).enumerable\n      })\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (false) {}\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (false) {}\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes) {\n      if (false) {}\n      slotNodes._rendered = true;\n    }\n    nodes = slotNodes || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n       false && false;\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n       false && false;\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () { return resolveSlots(children, parent); };\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = data.scopedSlots || emptyObject;\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n\n\n\n// Register the component hook to weex native render engine.\n// The hook will be triggered by native, not javascript.\n\n\n// Updates the state of the component to weex native render engine.\n\n/*  */\n\n// https://github.com/Hanks10100/weex-native-directive/tree/master/component\n\n// listening on native callback\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (false) {}\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  // Weex specific: invoke recycle-list optimized @render function for\n  // extracting cell-slot template.\n  // https://github.com/Hanks10100/weex-native-directive/tree/master/component\n  /* istanbul ignore if */\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    _parentVnode: vnode,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    hooks[key] = componentVNodeHooks[key];\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n     false && false;\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (false\n  ) {}\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (false) {} else {\n    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n  }\n}\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    // reset _rendered flag on slots for duplicate slot check\n    if (false) { var key; }\n\n    if (_parentVnode) {\n      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (false) {} else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {}\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (false) {}\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {} else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (false) {}\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue (options) {\n  if (false\n  ) {}\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (false) {}\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {}\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache, key, this$1.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n}\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n}\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {}\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.5.17';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n       false && false;\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n}\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove () {\n      if (--remove.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove.listeners = listeners;\n    return remove\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {}\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {}\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (false) {}\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (false) {}\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (false) {}\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (false\n              ) {}\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (false\n              ) {}\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {}\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n}\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n]\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n}\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n}\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value) {\n  el.attrsMap[name] = value;\n  el.attrsList.push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n  el.plain = false;\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    false\n  ) {}\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (name === 'click') {\n    if (modifiers.right) {\n      name = 'contextmenu';\n      delete modifiers.right;\n    } else if (modifiers.middle) {\n      name = 'mouseup';\n    }\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = {\n    value: value.trim()\n  };\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n      \"? \" + baseValueExpression + \".trim()\" +\n      \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (false) {}\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (false) {}\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n      \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n  if (false) { var binding, typeBinding, value$1; }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler (handler, event, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  handler = withMacroTask(handler);\n  if (once$$1) { handler = createOnceHandler(handler, event, capture); }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    event,\n    handler._withTask || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n}\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.lazy) {\n      // inputs with lazy should only be updated when not in focus\n      return false\n    }\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n}\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n}\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def) {\n  if (!def) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def === 'object') {\n    var res = {};\n    if (def.css !== false) {\n      extend(res, autoCssTransition(def.name || 'v'));\n    }\n    extend(res, def);\n    return res\n  } else if (typeof def === 'string') {\n    return autoCssTransition(def)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (false) {}\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (false) {}\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {}\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n]\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n     false && false;\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n}\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n}\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {}\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false\n    ) {}\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n}\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) { var name, opts; }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n}\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n}\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\n        false\n      ) {}\n    }\n    if (false\n    ) {}\n  }, 0);\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (false) { var res; }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n}\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) { var res; }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n}\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n}\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being pased as HTML comment when inlined in page\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('--\x3e');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!\\--([\\s\\S]*?)--\x3e/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (false) {}\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (false\n        ) {}\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /([^]*?)\\s+(?:in|of)\\s+([^]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(he.decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function closeElement (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n         false && false;\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        // element-scope stuff\n        processElement(element, options);\n      }\n\n      function checkRootConstraints (el) {\n        if (false) {}\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (false) {}\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      closeElement(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (false) {}\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var res;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    },\n    comment: function comment (text) {\n      currentParent.children.push({\n        type: 3,\n        text: text,\n        isComment: true\n      });\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (element, options) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = !element.key && !element.attrsList.length;\n\n  processRef(element);\n  processSlot(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (false) {}\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else if (false) {}\n  }\n}\n\n\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '');\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {}\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (false) {}\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (false) {}\n  } else {\n    var slotScope;\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n      if (false) {}\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n      /* istanbul ignore if */\n      if (false) {}\n      el.slotScope = slotScope;\n    }\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget);\n      }\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (false) {}\n      }\n    } else {\n      // literal attribute\n      if (false) { var res; }\n      addAttr(el, name, JSON.stringify(value));\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true');\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      false\n    ) {}\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\n/**\n * Expand input[v-model] with dyanmic type bindings into v-if-else chains\n * Turn this:\n *   <input v-model=\"data[type]\" :type=\"type\">\n * into this:\n *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\n *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\n *   <input v-else :type=\"type\" v-model=\"data[type]\">\n */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (!map['v-model']) {\n      return\n    }\n\n    var typeBinding;\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + (map['v-bind']) + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$2 = {\n  preTransformNode: preTransformNode\n}\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$2\n]\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n}\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n// KeyboardEvent.keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// KeyboardEvent.key aliases\nvar keyNames = {\n  esc: 'Escape',\n  tab: 'Tab',\n  enter: 'Enter',\n  space: ' ',\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  'delete': ['Backspace', 'Delete']\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    /* istanbul ignore if */\n    return (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? (\"return \" + (handler.value) + \"($event)\")\n      : isFunctionExpression\n        ? (\"return (\" + (handler.value) + \")($event)\")\n        : handler.value;\n    /* istanbul ignore if */\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(keyCode)) + \",\" +\n    \"$event.key,\" +\n    \"\" + (JSON.stringify(keyName)) +\n    \")\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (false) {}\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n}\n\n/*  */\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data = el.plain ? undefined : genData$2(el, state);\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n       false && false;\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (false\n  ) {}\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, state.warn)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, state.warn)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (false) {}\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  slots,\n  state\n) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state)\n    }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (\n  key,\n  el,\n  state\n) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el, state)\n  }\n  var fn = \"function(\" + (String(el.slotScope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if\n        ? ((el.if) + \"?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  return (\"{key:\" + key + \",fn:\" + fn + \"}\")\n}\n\nfunction genForScopedSlot (\n  key,\n  el,\n  state\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el, state)) +\n    '})'\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return (altGenElement || genElement)(el$1, state)\n    }\n    var normalizationType = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    /* istanbul ignore if */\n    {\n      res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n    }\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  errors\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n    }\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim())\n      );\n    } else {\n      errors.push(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\"\n      );\n    }\n  }\n}\n\n/*  */\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    if (false) {}\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (false) {}\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (false) {}\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n      finalOptions.warn = function (msg, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      var compiled = baseCompile(template, finalOptions);\n      if (false) {}\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue.prototype.$mount;\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n     false && false;\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (false) {}\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {}\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (false) {}\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (false) {}\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vue);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4), __webpack_require__(5).setImmediate))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcz9hMDI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQsc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFr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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsS0FBcUMsRUFBRSx1QkFXMUM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUMsRUFBRSxFQWdCMUM7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQW1FLEVBQUUsRUFpQnhFO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHVGQUF1RjtBQUM1RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUMsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0I7QUFDL0YsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxNQUFxQyxJQUFJLEtBSXhDO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FDc0Q7QUFDNUQsSUFBSSxFQVFEO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsb0JBQW9CLG9CQUFvQjtBQUN4QyxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QjtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2Q0FBNkM7QUFDOUU7QUFDQTtBQUNBLDZDQUE2Qyw0Q0FBNEM7O0FBRXpGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FBcUMsRUFBRSxFQU8xQztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsS0FBcUMsRUFBRSxZQUsxQzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQXFDLEVBQUUsRUFXMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUE2RCxFQUFFLEVBTWxFO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxLQUFtRSxFQUFFLEVBSXhFOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUMsRUFBRSxFQUUxQztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQSxRQUFRLEtBQW1FLEVBQUUsRUFJeEU7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sS0FDb0I7QUFDMUIsSUFBSSxFQUVEO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLEtBQTZDLEVBQUUsRUFFbEQ7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxZQUFZLEtBQTZELEVBQUUsRUFFbEU7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDJCQUEyQixFQUFFO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBLDBDQUEwQyw0QkFBNEIsRUFBRTtBQUN4RSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUMsTUFBTSxLQUFxQyxFQUFFLEVBTTFDO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQXFDLEVBQUUsRUFZMUM7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLEtBQXlELEVBQUUsRUFFOUQ7QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLEtBQXFDLEVBQUUsRUFFMUM7QUFDUCxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtB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REFBcUQ7QUFDckQsR0FBRztBQUNILHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QixFQUFFO0FBQzNFLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLCtCQUErQixFQUFFO0FBQzlFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxLQUFzRSxFQUFFLEVBRTNFOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEtBQXFFLEVBQUUsRUFFMUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHFDQUFxQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVDQUF1QyxFQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQ0FBMkMsRUFBRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxNQUFxQyxJQUFJLEtBSXhDO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyw4QkFBOEIsRUFBRTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZD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Q0E7QUFDQSxxREFBcUQsMkRBQTJEOztBQUVoSDtBQUNBO0FBQ0EsNkNBQTZDLDJCQUEyQixFQUFFO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsS0FBc0UsRUFBRSxFQUUzRTtBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLE1BQXFDLElBQUksS0FFeEM7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBa0QsRUFBRSxFQUt2RDtBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLFlBQVksS0FBcUMsRUFBRSxFQUUxQztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQW1FLEVBQUUsRUFFeEU7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsS0FBbUUsRUFBRSxFQUd4RTtBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsa0VBQUcsRUFBQyIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuNS4xN1xuICogKGMpIDIwMTQtMjAxOCBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlIGUuZy4gW29iamVjdCBPYmplY3RdXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdC4uLiBlLmcuXG4gKiBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZSBzaW5jZSBuYXRpdmUgYmluZCBpc1xuICogbm93IG1vcmUgcGVyZm9ybWFudCBpbiBtb3N0IGJyb3dzZXJzLCBidXQgcmVtb3ZpbmcgaXQgd291bGQgYmUgYnJlYWtpbmcgZm9yXG4gKiBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvclxuICogYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IChub29wKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bSB8fCB7fTtcbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgdmFyIGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zLFxuICBhc3luY0ZhY3Rvcnlcbikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuICB0aGlzLmVsbSA9IGVsbTtcbiAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG52YXIgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5c1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICBpZiAoIWdldHRlciAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJwcm9wc1xcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShwcm9wcykpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucywgdm0pIHtcbiAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChpbmplY3QpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGluamVjdCkge1xuICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgdmFyIHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICB2YXIgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlICYmIGlzT2JqZWN0KHZhbHVlKSAmJiAoJ0BiaW5kaW5nJyBpbiB2YWx1ZSkpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKSArXG4gICAgICBcIiwgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTFcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIHZhciBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTWVzc2FnZUNoYW5uZWwgKi9cblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgYm90aCBtaWNyb3Rhc2tzIGFuZCAobWFjcm8pIHRhc2tzLlxuLy8gSW4gPCAyLjQgd2UgdXNlZCBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGJ1dCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Mgd2hlcmVcbi8vIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwKSBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWVcbi8vIGV2ZW50ICgjNjU2NikuIEhvd2V2ZXIsIHVzaW5nIChtYWNybykgdGFza3MgZXZlcnl3aGVyZSBhbHNvIGhhcyBzdWJ0bGUgcHJvYmxlbXNcbi8vIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludCAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEhlcmUgd2UgdXNlIG1pY3JvdGFzayBieSBkZWZhdWx0LCBidXQgZXhwb3NlIGEgd2F5IHRvIGZvcmNlIChtYWNybykgdGFzayB3aGVuXG4vLyBuZWVkZWQgKGUuZy4gaW4gZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgYnkgdi1vbikuXG52YXIgbWljcm9UaW1lckZ1bmM7XG52YXIgbWFjcm9UaW1lckZ1bmM7XG52YXIgdXNlTWFjcm9UYXNrID0gZmFsc2U7XG5cbi8vIERldGVybWluZSAobWFjcm8pIHRhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vLyBUZWNobmljYWxseSBzZXRJbW1lZGlhdGUgc2hvdWxkIGJlIHRoZSBpZGVhbCBjaG9pY2UsIGJ1dCBpdCdzIG9ubHkgYXZhaWxhYmxlXG4vLyBpbiBJRS4gVGhlIG9ubHkgcG9seWZpbGwgdGhhdCBjb25zaXN0ZW50bHkgcXVldWVzIHRoZSBjYWxsYmFjayBhZnRlciBhbGwgRE9NXG4vLyBldmVudHMgdHJpZ2dlcmVkIGluIHRoZSBzYW1lIGxvb3AgaXMgYnkgdXNpbmcgTWVzc2FnZUNoYW5uZWwuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNZXNzYWdlQ2hhbm5lbCkgfHxcbiAgLy8gUGhhbnRvbUpTXG4gIE1lc3NhZ2VDaGFubmVsLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE1lc3NhZ2VDaGFubmVsQ29uc3RydWN0b3JdJ1xuKSkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2hDYWxsYmFja3M7XG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UoMSk7XG4gIH07XG59IGVsc2Uge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgfTtcbn1cblxuLy8gRGV0ZXJtaW5lIG1pY3JvdGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgbWljcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBmYWxsYmFjayB0byBtYWNyb1xuICBtaWNyb1RpbWVyRnVuYyA9IG1hY3JvVGltZXJGdW5jO1xufVxuXG4vKipcbiAqIFdyYXAgYSBmdW5jdGlvbiBzbyB0aGF0IGlmIGFueSBjb2RlIGluc2lkZSB0cmlnZ2VycyBzdGF0ZSBjaGFuZ2UsXG4gKiB0aGUgY2hhbmdlcyBhcmUgcXVldWVkIHVzaW5nIGEgKG1hY3JvKSB0YXNrIGluc3RlYWQgb2YgYSBtaWNyb3Rhc2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhNYWNyb1Rhc2sgKGZuKSB7XG4gIHJldHVybiBmbi5fd2l0aFRhc2sgfHwgKGZuLl93aXRoVGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICB1c2VNYWNyb1Rhc2sgPSB0cnVlO1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuICAgIHJldHVybiByZXNcbiAgfSlcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICBpZiAodXNlTWFjcm9UYXNrKSB7XG4gICAgICBtYWNyb1RpbWVyRnVuYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWNyb1RpbWVyRnVuYygpO1xuICAgIH1cbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0cyA9IGZhY3RvcnkuY29udGV4dHMgPSBbY29udGV4dF07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwgbnVsbCwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgdmFyIHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDE7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcbiAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG4gIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IHVzZXJEZWY7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5qZWN0LCBrZXkpLmVudW1lcmFibGVcbiAgICAgIH0pXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIGlmIChpc0RlZihyZXQpKSB7XG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2Rlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdE5vZGVzLl9yZW5kZXJlZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZXMgPSBzbG90Tm9kZXMgfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgdmFyIG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xuICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gdHJlZVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICB0aGlzLl9yZW5kZXJQcm94eSxcbiAgICBudWxsLFxuICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudCk7IH07XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IGRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucykge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChkYXRhLnNsb3QpIHtcbiAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cblxuLy8gUmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBob29rIHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG4vLyBUaGUgaG9vayB3aWxsIGJlIHRyaWdnZXJlZCBieSBuYXRpdmUsIG5vdCBqYXZhc2NyaXB0LlxuXG5cbi8vIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBjb21wb25lbnQgdG8gd2VleCBuYXRpdmUgcmVuZGVyIGVuZ2luZS5cblxuLyogICovXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcblxuLy8gbGlzdGVuaW5nIG9uIG5hdGl2ZSBjYWxsYmFja1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKFxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlXG4gICAgKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgdmFyIGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IsIGNvbnRleHQpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnMgJiBzbG90XG5cbiAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICAvLyBXZWV4IHNwZWNpZmljOiBpbnZva2UgcmVjeWNsZS1saXN0IG9wdGltaXplZCBAcmVuZGVyIGZ1bmN0aW9uIGZvclxuICAvLyBleHRyYWN0aW5nIGNlbGwtc2xvdCB0ZW1wbGF0ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhbmtzMTAxMDAvd2VleC1uYXRpdmUtZGlyZWN0aXZlL3RyZWUvbWFzdGVyL2NvbXBvbmVudFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyAoZGF0YSkge1xuICB2YXIgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIGhvb2tzW2tleV0gPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChpc0RlZihucykpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgIGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyByZWYgIzUzMThcbi8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4vLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MgKGRhdGEpIHtcbiAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIC8vIHJlc2V0IF9yZW5kZXJlZCBmbGFnIG9uIHNsb3RzIGZvciBkdXBsaWNhdGUgc2xvdCBjaGVja1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICB2bS4kc2xvdHNba2V5XS5fcmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCBlbXB0eU9iamVjdDtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlclwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZSwga2V5LCB0aGlzJDEua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufVxuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmVcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbn0pO1xuXG5WdWUudmVyc2lvbiA9ICcyLjUuMTcnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUsIGNoaWxkcmVuLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICB9XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBmYWxzZSwgdm5vZGVzLCBzdGFydElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX3VwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlU2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgLy8gaW1tZWRpYXRlbHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFxuICAgICAgaXNJRSAmJiAhaXNJRTkgJiZcbiAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG4gICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gIH1cblxuICAvLyBzZXQgdGhlIGNsYXNzXG4gIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcbiAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICB9XG59XG5cbnZhciBrbGFzcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufVxuXG4vKiAgKi9cblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyAoZXhwKSB7XG4gIHZhciBpblNpbmdsZSA9IGZhbHNlO1xuICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgdmFyIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgdmFyIGluUmVnZXggPSBmYWxzZTtcbiAgdmFyIGN1cmx5ID0gMDtcbiAgdmFyIHNxdWFyZSA9IDA7XG4gIHZhciBwYXJlbiA9IDA7XG4gIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICB2YXIgYywgcHJldiwgaSwgZXhwcmVzc2lvbiwgZmlsdGVycztcblxuICBmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJldiA9IGM7XG4gICAgYyA9IGV4cC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChpblNpbmdsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSB7IGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5SZWdleCkge1xuICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgIHZhciBwID0gKHZvaWQgMCk7XG4gICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgIGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyAoYXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3MpKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnKSB7XG4gIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSBjb21waWxlcl06IFwiICsgbXNnKSk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG4vLyBhZGQgYSByYXcgYXR0ciAodXNlIHRoaXMgaW4gcHJlVHJhbnNmb3JtcylcbmZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuXG4pIHtcbiAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJ1xuICAgICk7XG4gIH1cblxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSAnJicgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBwYXNzaXZlXG4gIH1cblxuICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgLy8gdGhpcyBpcyB0ZWNobmljYWxseSBicm93c2VyLXNwZWNpZmljLCBidXQgYXQgbGVhc3QgZm9yIG5vdyBicm93c2VycyBhcmVcbiAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xuICAgICAgbmFtZSA9ICdtb3VzZXVwJztcbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG5cbiAgdmFyIG5ld0hhbmRsZXIgPSB7XG4gICAgdmFsdWU6IHZhbHVlLnRyaW0oKVxuICB9O1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG5cbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlRnJvbU1hcCkge1xuICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuXG4gIHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgIFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgIGV4cHJlc3Npb246IChcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLFxuICAgIGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIHZhciByZXMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKHJlcy5rZXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCIkc2V0KFwiICsgKHJlcy5leHApICsgXCIsIFwiICsgKHJlcy5rZXkpICsgXCIsIFwiICsgYXNzaWdubWVudCArIFwiKVwiKVxuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSB2LW1vZGVsIGV4cHJlc3Npb24gaW50byBhIGJhc2UgcGF0aCBhbmQgYSBmaW5hbCBrZXkgc2VnbWVudC5cbiAqIEhhbmRsZXMgYm90aCBkb3QtcGF0aCBhbmQgcG9zc2libGUgc3F1YXJlIGJyYWNrZXRzLlxuICpcbiAqIFBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2tleV1cbiAqIC0gdGVzdFt0ZXN0MVtrZXldXVxuICogLSB0ZXN0W1wiYVwiXVtrZXldXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFba2V5XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtrZXldXVxuICpcbiAqL1xuXG52YXIgbGVuO1xudmFyIHN0cjtcbnZhciBjaHI7XG52YXIgaW5kZXgkMTtcbnZhciBleHByZXNzaW9uUG9zO1xudmFyIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICB2YWwgPSB2YWwudHJpbSgpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuY29uY2F0KFskJHZdKScpKSArIFwiKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKScpKSArIFwiKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgLy8gZXhjZXB0IGZvciBpbnB1dHMgd2l0aCB2LWJpbmQ6dHlwZVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB2YWx1ZSQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcbiAgICB2YXIgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodmFsdWUkMSAmJiAhdHlwZUJpbmRpbmcpIHtcbiAgICAgIHZhciBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYmluZGluZyArIFwiPVxcXCJcIiArIHZhbHVlJDEgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IFwiICtcbiAgICAgICAgJ2JlY2F1c2UgdGhlIGxhdHRlciBhbHJlYWR5IGV4cGFuZHMgdG8gYSB2YWx1ZSBiaW5kaW5nIGludGVybmFsbHknXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChoYW5kbGVyLCBldmVudCwgY2FwdHVyZSkge1xuICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkJDEgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgb25jZSQkMSxcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIGhhbmRsZXIgPSB3aXRoTWFjcm9UYXNrKGhhbmRsZXIpO1xuICBpZiAob25jZSQkMSkgeyBoYW5kbGVyID0gY3JlYXRlT25jZUhhbmRsZXIoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpOyB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgZXZlbnQsXG4gICAgaGFuZGxlci5fd2l0aFRhc2sgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubGF6eSkge1xuICAgICAgLy8gaW5wdXRzIHdpdGggbGF6eSBzaG91bGQgb25seSBiZSB1cGRhdGVkIHdoZW4gbm90IGluIGZvY3VzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufVxuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn1cblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZikge1xuICBpZiAoIWRlZikge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZi5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgOiBzZXRUaW1lb3V0XG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge31cblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXVxuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3c6IHNob3dcbn1cblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn1cblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICBpc0Nocm9tZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufVxuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbnZhciBoZSA9IHtcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLyohXG4gKiBIVE1MIFBhcnNlciBCeSBKb2huIFJlc2lnIChlam9obi5vcmcpXG4gKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG52YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG52YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFwiXjxcIiArIHFuYW1lQ2FwdHVyZSkpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG52YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCdcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShsYXN0VGFnLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpIC8vICM3Mjk4XG4gICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfSk7XG4gICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdCQxO1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICB9O1xuICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxuICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG4gICAgICAgIGlmIChhcmdzWzNdID09PSAnJykgeyBkZWxldGUgYXJnc1szXTsgfVxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cbiAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgPyBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZlxuICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycyB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcbnZhciBmb3JBbGlhc1JFID0gLyhbXl0qPylcXHMrKD86aW58b2YpXFxzKyhbXl0qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbnZhciBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICB0YWcsXG4gIGF0dHJzLFxuICBwYXJlbnRcbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDEsXG4gICAgdGFnOiB0YWcsXG4gICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcblxuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VFbGVtZW50IChlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgLy8gZWxlbWVudC1zY29wZSBzdHVmZlxuICAgICAgICBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcgJiYgIWluUHJlKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxuICAgICAgICA/IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0KSB7XG4gICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICB0eXBlOiAzLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoO1xuXG4gIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm4kMihcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHJlcy5mb3IgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJyk7XG4gICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgaWYgKGVsc2VpZikge1xuICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gIGlmIChvbmNlJCQxICE9IG51bGwpIHtcbiAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG4gICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzbG90U2NvcGU7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xuICAgICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICAgIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgICB9XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgKFxuICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyKTtcbiAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcbiAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIEV4cGFuZCBpbnB1dFt2LW1vZGVsXSB3aXRoIGR5YW5taWMgdHlwZSBiaW5kaW5ncyBpbnRvIHYtaWYtZWxzZSBjaGFpbnNcbiAqIFR1cm4gdGhpczpcbiAqICAgPGlucHV0IHYtbW9kZWw9XCJkYXRhW3R5cGVdXCIgOnR5cGU9XCJ0eXBlXCI+XG4gKiBpbnRvIHRoaXM6XG4gKiAgIDxpbnB1dCB2LWlmPVwidHlwZSA9PT0gJ2NoZWNrYm94J1wiIHR5cGU9XCJjaGVja2JveFwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKiAgIDxpbnB1dCB2LWVsc2UtaWY9XCJ0eXBlID09PSAncmFkaW8nXCIgdHlwZT1cInJhZGlvXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqICAgPGlucHV0IHYtZWxzZSA6dHlwZT1cInR5cGVcIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICovXG5cbmZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICB2YXIgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIHR5cGVCaW5kaW5nO1xuICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHlwZScpO1xuICAgIH1cbiAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IFwiKFwiICsgKG1hcFsndi1iaW5kJ10pICsgXCIpLnR5cGVcIjtcbiAgICB9XG5cbiAgICBpZiAodHlwZUJpbmRpbmcpIHtcbiAgICAgIHZhciBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XG4gICAgICB2YXIgaWZDb25kaXRpb25FeHRyYSA9IGlmQ29uZGl0aW9uID8gKFwiJiYoXCIgKyBpZkNvbmRpdGlvbiArIFwiKVwiKSA6IFwiXCI7XG4gICAgICB2YXIgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgdmFyIGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcbiAgICAgIC8vIDEuIGNoZWNrYm94XG4gICAgICB2YXIgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXG4gICAgICBwcm9jZXNzRm9yKGJyYW5jaDApO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XG4gICAgICBicmFuY2gwLnByb2Nlc3NlZCA9IHRydWU7IC8vIHByZXZlbnQgaXQgZnJvbSBkb3VibGUtcHJvY2Vzc2VkXG4gICAgICBicmFuY2gwLmlmID0gXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdjaGVja2JveCdcIiArIGlmQ29uZGl0aW9uRXh0cmE7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogYnJhbmNoMC5pZixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgIH0pO1xuICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXG4gICAgICB2YXIgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdyYWRpbydcIiArIGlmQ29uZGl0aW9uRXh0cmEsXG4gICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICB9KTtcbiAgICAgIC8vIDMuIG90aGVyXG4gICAgICB2YXIgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDIsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gyLCAnOnR5cGUnLCB0eXBlQmluZGluZyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBpZkNvbmRpdGlvbixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzRWxzZSkge1xuICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbHNlSWZDb25kaXRpb24pIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlaWYgPSBlbHNlSWZDb25kaXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBicmFuY2gwXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lQVNURWxlbWVudCAoZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KVxufVxuXG52YXIgbW9kZWwkMiA9IHtcbiAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxufVxuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxLFxuICBtb2RlbCQyXG5dXG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsOiBtb2RlbCxcbiAgdGV4dDogdGV4dCxcbiAgaHRtbDogaHRtbFxufVxuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycycgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJ1teJ10qPyddfFxcW1wiW15cIl0qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKiQvO1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXkgYWxpYXNlc1xudmFyIGtleU5hbWVzID0ge1xuICBlc2M6ICdFc2NhcGUnLFxuICB0YWI6ICdUYWInLFxuICBlbnRlcjogJ0VudGVyJyxcbiAgc3BhY2U6ICcgJyxcbiAgLy8gIzc4MDY6IElFMTEgdXNlcyBrZXkgbmFtZXMgd2l0aG91dCBgQXJyb3dgIHByZWZpeCBmb3IgYXJyb3cga2V5cy5cbiAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gIHJpZ2h0OiBbJ1JpZ2h0JywgJ0Fycm93UmlnaHQnXSxcbiAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAnZGVsZXRlJzogWydCYWNrc3BhY2UnLCAnRGVsZXRlJ11cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcbiAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcbiAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbn07XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcbiAgZXZlbnRzLFxuICBpc05hdGl2ZSxcbiAgd2FyblxuKSB7XG4gIHZhciByZXMgPSBpc05hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgZXZlbnRzW25hbWVdKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAoXCIkZXZlbnQuXCIgKyBrZXlNb2RpZmllciArIFwiS2V5XCIpOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIoJGV2ZW50KVwiKVxuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcInJldHVybiAoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICByZXR1cm4gKFxuICAgIFwiX2soJGV2ZW50LmtleUNvZGUsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgIFwiJGV2ZW50LmtleSxcIiArXG4gICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xuICAgIFwiKVwiXG4gIClcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59XG5cbi8qICAqL1xuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgXCIsXCIgKyBrZXkgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JZiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxufVxuXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICBjb25kaXRpb25zLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRFbXB0eVxuKSB7XG4gIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gIH1cblxuICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiAoXCIoXCIgKyAoY29uZGl0aW9uLmV4cCkgKyBcIik/XCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSArIFwiOlwiICsgKGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBhbHRHZW5cbiAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgIDogZWwub25jZVxuICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxuICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgYWx0R2VuLFxuICBhbHRIZWxwZXJcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICk7XG4gIH1cblxuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIChhbHRIZWxwZXIgfHwgJ19sJykgKyBcIigoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IFwicHJlOnRydWUsXCI7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gXCJhdHRyczp7XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwifSxcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOntcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGlmIChlbC5ldmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCBzdGF0ZS53YXJuKSkgKyBcIixcIjtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcbiAgfVxuICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgaWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIC8vIHYtb24gZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUnVudGltZSkge1xuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ10nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUgKGVsLCBzdGF0ZSkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHN0YXRlLndhcm4oJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgc3RhdGVcbikge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldLCBzdGF0ZSlcbiAgICB9KS5qb2luKCcsJykpICsgXCJdKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSlcbiAgfVxuICB2YXIgZm4gPSBcImZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5zbG90U2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmXG4gICAgICAgID8gKChlbC5pZikgKyBcIj9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIGtleSArIFwiLGZuOlwiICsgZm4gKyBcIn1cIilcbn1cblxuZnVuY3Rpb24gZ2VuRm9yU2NvcGVkU2xvdCAoXG4gIGtleSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICByZXR1cm4gKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0gaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyAmJiAoXCJ7XCIgKyAoZWwuYXR0cnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGNhbWVsaXplKGEubmFtZSkpICsgXCI6XCIgKyAoYS52YWx1ZSkpOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YSQyKGVsLCBzdGF0ZSkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCkge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCBlcnJvcnMpO1xuICB9XG4gIHJldHVybiBlcnJvcnNcbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIGVycm9ycykge1xuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICBlcnJvcnNcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkgKyBcIlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICA6IHRlbXBsYXRlO1xuICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICByZXR1cm4gY2FjaGVba2V5XVxuICAgIH1cblxuICAgIC8vIGNvbXBpbGVcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgdGVtcGxhdGUgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbnZhciBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_RESULT__;/* Web Font Loader v1.6.28 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.o=b||a;this.c=this.o.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}\nfunction w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\\s+/g," ").replace(/^\\s+|\\s+$/,"")}function y(a,b){for(var c=a.className.split(/\\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}\nfunction ea(a){return a.o.location.hostname||a.a.location.hostname}function z(a,b,c){function d(){m&&e&&f&&(m(g),m=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,m=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}\nfunction A(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function B(){this.a=0;this.c=null}function C(a){a.a++;return function(){a.a--;D(a)}}function E(a,b){a.c=b;D(a)}function D(a){0==a.a&&a.c&&(a.c(),a.c=null)};function F(a){this.a=a||"-"}F.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\\W_]+/g,"").toLowerCase());return b.join(this.a)};function G(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return H(a)+" "+(a.f+"00")+" 300px "+I(a.c)}function I(a){var b=[];a=a.split(/,\\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/[\'"]/g,"");-1!=d.indexOf(" ")||/^\\d/.test(d)?b.push("\'"+d+"\'"):b.push(d)}return b.join(",")}function J(a){return a.a+a.f}function H(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}\nfunction ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.o.document.documentElement;this.h=b;this.a=new F("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);K(a,"loading")}function L(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}K(a,"inactive")}function K(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,J(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function M(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function N(a){u(a.c,"body",a.a)}function O(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+I(a.c)+";"+("font-style:"+H(a)+";font-weight:"+(a.f+"00")+";")};function P(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}P.prototype.start=function(){var a=this.c.o.document,b=this,c=q(),d=new Promise(function(d,e){function f(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(f,25)},function(){e()})}f()}),e=null,f=new Promise(function(a,d){e=setTimeout(d,b.f)});Promise.race([f,d]).then(function(){e&&(clearTimeout(e),e=null);b.g(b.a)},function(){b.j(b.a)})};function Q(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.m=this.j=this.h=this.g=null;this.g=new M(this.c,this.s);this.h=new M(this.c,this.s);this.j=new M(this.c,this.s);this.m=new M(this.c,this.s);a=new G(this.a.c+",serif",J(this.a));a=O(a);this.g.a.style.cssText=a;a=new G(this.a.c+",sans-serif",J(this.a));a=O(a);this.h.a.style.cssText=a;a=new G("serif",J(this.a));a=O(a);this.j.a.style.cssText=a;a=new G("sans-serif",J(this.a));a=\nO(a);this.m.a.style.cssText=a;N(this.g);N(this.h);N(this.j);N(this.m)}var R={D:"serif",C:"sans-serif"},S=null;function T(){if(null===S){var a=/AppleWebKit\\/([0-9]+)(?:\\.([0-9]+))/.exec(window.navigator.userAgent);S=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return S}Q.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.m.a.offsetWidth;this.A=q();U(this)};\nfunction la(a,b,c){for(var d in R)if(R.hasOwnProperty(d)&&b===a.f[R[d]]&&c===a.f[R[d]])return!0;return!1}function U(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=T()&&la(a,b,c));d?q()-a.A>=a.w?T()&&la(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):ma(a):V(a,a.v)}function ma(a){setTimeout(p(function(){U(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.m.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.m=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,J(a).toString(),"active")],[b.a.c("wf",a.c,J(a).toString(),"loading"),b.a.c("wf",a.c,J(a).toString(),"inactive")]);K(b,"fontactive",a);this.m=!0;na(this)};\nW.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,J(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,J(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,J(a).toString(),"inactive"));w(b.f,d,e)}K(b,"fontinactive",a);na(this)};function na(a){0==--a.f&&a.j&&(a.m?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),K(a,"active")):L(a.a))};function oa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}oa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;pa(this,new ha(this.c,a),a)};\nfunction qa(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,m=d||null||{};if(0===c.length&&f)L(b.a);else{b.f+=c.length;f&&(b.j=f);var h,l=[];for(h=0;h<c.length;h++){var k=c[h],n=m[k.c],r=b.a,x=k;r.g&&w(r.f,[r.a.c("wf",x.c,J(x).toString(),"loading")]);K(r,"fontloading",x);r=null;if(null===X)if(window.FontFace){var x=/Gecko.*Firefox\\/(\\d+)/.exec(window.navigator.userAgent),xa=/OS X.*Version\\/10\\..*Safari/.exec(window.navigator.userAgent)&&/Apple/.exec(window.navigator.vendor);\nX=x?42<parseInt(x[1],10):xa?!1:!0}else X=!1;X?r=new P(p(b.g,b),p(b.h,b),b.c,k,b.s,n):r=new Q(p(b.g,b),p(b.h,b),b.c,k,b.s,a,n);l.push(r)}for(h=0;h<l.length;h++)l[h].start()}},0)}function pa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){qa(a,f,b,d,c)})};function ra(a,b){this.c=a;this.a=b}\nra.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var l=0;l<c.length;l++){var k=c[l].fontfamily;void 0!=c[l].fontStyle&&void 0!=c[l].fontWeight?(h=c[l].fontStyle+c[l].fontWeight,e.push(new G(k,h))):e.push(new G(k))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.o;A(this.c,(c.a.api||"https://fast.fonts.net/jsapi")+"/"+d+".js"+(e?"?v="+e:""),function(e){e?a([]):(f["__MonotypeConfiguration__"+\nd]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+d}else a([])};function sa(a,b){this.c=a;this.a=b}sa.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new B;b=0;for(c=d.length;b<c;b++)z(this.c,d[b],C(g));var m=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),l=0;l<h.length;l+=1)m.push(new G(d[0],h[l]));else m.push(new G(d[0]));E(g,function(){a(m,f)})};function ta(a,b){a?this.c=a:this.c=ua;this.a=[];this.f=[];this.g=b||""}var ua="https://fonts.googleapis.com/css";function va(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}\nfunction wa(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function ya(a){this.f=a;this.a=[];this.c={}}\nvar za={latin:"BESbswy","latin-ext":"\\u00e7\\u00f6\\u00fc\\u011f\\u015f",cyrillic:"\\u0439\\u044f\\u0416",greek:"\\u03b1\\u03b2\\u03a3",khmer:"\\u1780\\u1781\\u1782",Hanuman:"\\u1780\\u1781\\u1782"},Aa={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Ba={i:"i",italic:"i",n:"n",normal:"n"},\nCa=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;\nfunction Da(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\\+/g," "),f=["n4"];if(2<=d.length){var g;var m=d[1];g=[];if(m)for(var m=m.split(","),h=m.length,l=0;l<h;l++){var k;k=m[l];if(k.match(/^[\\w-]+$/)){var n=Ca.exec(k.toLowerCase());if(null==n)k="";else{k=n[2];k=null==k||""==k?"n":Ba[k];n=n[1];if(null==n||""==n)n="4";else var r=Aa[n],n=r?r:isNaN(n)?"4":n.substr(0,1);k=[k,n].join("")}}else k="";k&&g.push(k)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):\ng,0<d.length&&(d=za[d[0]])&&(a.c[e]=d))}a.c[e]||(d=za[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new G(e,f[d]))}};function Ea(a,b){this.c=a;this.a=b}var Fa={Arimo:!0,Cousine:!0,Tinos:!0};Ea.prototype.load=function(a){var b=new B,c=this.c,d=new ta(this.a.api,this.a.text),e=this.a.families;va(d,e);var f=new ya(e);Da(f);z(c,wa(d),C(b));E(b,function(){a(f.a,f.c,Fa)})};function Ga(a,b){this.c=a;this.a=b}Ga.prototype.load=function(a){var b=this.a.id,c=this.c.o;b?A(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],m=b[f+1],h=0;h<m.length;h++)e.push(new G(g,m[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(l){}a(e)}},2E3):a([])};function Ha(a,b){this.c=a;this.f=b;this.a=[]}Ha.prototype.load=function(a){var b=this.f.id,c=this.c.o,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,m=c.fonts.length;g<m;++g){var h=c.fonts[g];d.a.push(new G(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},A(this.c,(this.f.api||"https://f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new oa(window);Y.a.c.custom=function(a,b){return new sa(b,a)};Y.a.c.fontdeck=function(a,b){return new Ha(b,a)};Y.a.c.monotype=function(a,b){return new ra(b,a)};Y.a.c.typekit=function(a,b){return new Ga(b,a)};Y.a.c.google=function(a,b){return new Ea(b,a)};var Z={load:p(Y.load,Y)}; true?!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return Z}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined;}());\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2ViZm9udGxvYWRlci93ZWJmb250bG9hZGVyLmpzPzI3ZDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNEhBQTBGLG1CQUFtQixzQ0FBc0MsbUJBQW1CLG9CQUFvQix1QkFBdUIsOENBQThDLGtCQUFrQiw0Q0FBNEMsbUNBQW1DLHFCQUFxQixrQkFBa0IsNkJBQTZCLGtCQUFrQiwrRkFBK0YsK0JBQStCLDJCQUEyQixpQkFBaUIsaUJBQWlCLFNBQVMsWUFBWSx1QkFBdUIseUJBQXlCLG9CQUFvQix1QkFBdUIsa0dBQWtHLHdDQUF3QyxTQUFTLGtCQUFrQixpQ0FBaUMsZ0NBQWdDLDhCQUE4QixjQUFjO0FBQ24vQixrQkFBa0IsUUFBUSxRQUFRLHVDQUF1QyxXQUFXLE1BQU0saUJBQWlCLFdBQVcscUJBQXFCLEtBQUssTUFBTSxnQkFBZ0IsS0FBSyxRQUFRLFdBQVcsTUFBTSxLQUFLLFFBQVEsV0FBVyxxQkFBcUIsS0FBSyxNQUFNLGdCQUFnQixvRUFBb0UsZ0JBQWdCLGtEQUFrRCxJQUFJLHdCQUF3QjtBQUM5YSxlQUFlLG9EQUFvRCxrQkFBa0IsYUFBYSx1QkFBdUIsY0FBYyxvQ0FBb0MsRUFBRSwrQkFBK0Isd0JBQXdCLEtBQUssSUFBSSxzQkFBc0IsS0FBSyxxQ0FBcUMsSUFBSSx3QkFBd0IsS0FBSyxJQUFJLElBQUk7QUFDdFYsb0JBQW9CLDBDQUEwQyxNQUFNLG9CQUFvQixNQUFNLE9BQU8seUNBQXlDLGlMQUFpTCxpQkFBaUIsc0JBQXNCLDZDQUE2QyxTQUFTLFNBQVMsYUFBYSxhQUFhLFNBQVMsWUFBWSxjQUFjLE1BQU0sa0JBQWtCLE1BQU0sTUFBTSxnQkFBZ0IsTUFBTSxLQUFLLGNBQWMsK0JBQStCLGNBQWMsY0FBYywwQkFBMEIsaUJBQWlCLG1CQUFtQiw2REFBNkQsdUJBQXVCLGdCQUFnQixTQUFTLFNBQVMsV0FBVywyQ0FBMkMsMENBQTBDLGVBQWUsNENBQTRDLGNBQWMsU0FBUyxr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LFFBQVEsOEtBQThLLEtBQUssNFJBQTRSLEtBQUssa0NBQWtDO0FBQzlmO0FBQ0EsZUFBZSx5QkFBeUIsSUFBSSxLQUFLLDJEQUEyRCxnQkFBZ0IsTUFBTSxXQUFXLEtBQUssMkNBQTJDLElBQUksS0FBSyxNQUFNLE9BQU8sd0JBQXdCLCtCQUErQixnQkFBZ0IsS0FBSyxPQUFPLDJCQUEyQixPQUFPLHdCQUF3QixrREFBa0Qsa0JBQWtCLFVBQVUsYUFBYSxrQkFBa0I7QUFDN2Msd0NBQXdDLDhCQUE4QixRQUFRLFdBQVcsK0JBQStCLGlCQUFpQixTQUFTLFNBQVMsUUFBUSw4QkFBOEIsOEJBQThCLHdFQUF3RSxRQUFRLGdCQUFnQixNQUFNLGdCQUFnQixlQUFlLGNBQWMsR0FBRyxpQkFBaUIsU0FBUyxTQUFTLDhCQUE4QiwyQkFBMkIsMkVBQTJFLFdBQVcsMERBQTBELHNCQUFzQixpQkFBaUIsV0FBVyxpQ0FBaUMsV0FBVywwQkFBMEIsSUFBSSxnQkFBZ0IsOEJBQThCLEVBQUUsVUFBVSxNQUFNLGFBQWEsaUJBQWlCLFNBQVMsU0FBUyxVQUFVLDhCQUE4QixrQ0FBa0MsK0RBQStELCtDQUErQyw2QkFBNkIsSUFBSSxLQUFLLGlCQUFpQixtREFBbUQsd0JBQXdCLE9BQU8sOEZBQThGLFNBQVMsVUFBVSxxQkFBcUIsMkJBQTJCLG9CQUFvQiw2QkFBNkIsb0JBQW9CLDZCQUE2QixvQkFBb0IsNEJBQTRCLG9CQUFvQiwyQkFBMkIsb0JBQW9CLE9BQU8sa0JBQWtCLEtBQXNDLENBQUMsbUNBQU8sV0FBVyxTQUFTO0FBQUEsb0dBQUMsQ0FBQyxTQUFrSSxFQUFFIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBXZWIgRm9udCBMb2FkZXIgdjEuNi4yOCAtIChjKSBBZG9iZSBTeXN0ZW1zLCBHb29nbGUuIExpY2Vuc2U6IEFwYWNoZSAyLjAgKi8oZnVuY3Rpb24oKXtmdW5jdGlvbiBhYShhLGIsYyl7cmV0dXJuIGEuY2FsbC5hcHBseShhLmJpbmQsYXJndW1lbnRzKX1mdW5jdGlvbiBiYShhLGIsYyl7aWYoIWEpdGhyb3cgRXJyb3IoKTtpZigyPGFyZ3VtZW50cy5sZW5ndGgpe3ZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO0FycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGMsZCk7cmV0dXJuIGEuYXBwbHkoYixjKX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkoYixhcmd1bWVudHMpfX1mdW5jdGlvbiBwKGEsYixjKXtwPUZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kJiYtMSE9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIik/YWE6YmE7cmV0dXJuIHAuYXBwbHkobnVsbCxhcmd1bWVudHMpfXZhciBxPURhdGUubm93fHxmdW5jdGlvbigpe3JldHVybituZXcgRGF0ZX07ZnVuY3Rpb24gY2EoYSxiKXt0aGlzLmE9YTt0aGlzLm89Ynx8YTt0aGlzLmM9dGhpcy5vLmRvY3VtZW50fXZhciBkYT0hIXdpbmRvdy5Gb250RmFjZTtmdW5jdGlvbiB0KGEsYixjLGQpe2I9YS5jLmNyZWF0ZUVsZW1lbnQoYik7aWYoYylmb3IodmFyIGUgaW4gYyljLmhhc093blByb3BlcnR5KGUpJiYoXCJzdHlsZVwiPT1lP2Iuc3R5bGUuY3NzVGV4dD1jW2VdOmIuc2V0QXR0cmlidXRlKGUsY1tlXSkpO2QmJmIuYXBwZW5kQ2hpbGQoYS5jLmNyZWF0ZVRleHROb2RlKGQpKTtyZXR1cm4gYn1mdW5jdGlvbiB1KGEsYixjKXthPWEuYy5nZXRFbGVtZW50c0J5VGFnTmFtZShiKVswXTthfHwoYT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO2EuaW5zZXJ0QmVmb3JlKGMsYS5sYXN0Q2hpbGQpfWZ1bmN0aW9uIHYoYSl7YS5wYXJlbnROb2RlJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9XG5mdW5jdGlvbiB3KGEsYixjKXtiPWJ8fFtdO2M9Y3x8W107Zm9yKHZhciBkPWEuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyksZT0wO2U8Yi5sZW5ndGg7ZSs9MSl7Zm9yKHZhciBmPSExLGc9MDtnPGQubGVuZ3RoO2crPTEpaWYoYltlXT09PWRbZ10pe2Y9ITA7YnJlYWt9Znx8ZC5wdXNoKGJbZV0pfWI9W107Zm9yKGU9MDtlPGQubGVuZ3RoO2UrPTEpe2Y9ITE7Zm9yKGc9MDtnPGMubGVuZ3RoO2crPTEpaWYoZFtlXT09PWNbZ10pe2Y9ITA7YnJlYWt9Znx8Yi5wdXNoKGRbZV0pfWEuY2xhc3NOYW1lPWIuam9pbihcIiBcIikucmVwbGFjZSgvXFxzKy9nLFwiIFwiKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC8sXCJcIil9ZnVuY3Rpb24geShhLGIpe2Zvcih2YXIgYz1hLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspaWYoY1tkXT09YilyZXR1cm4hMDtyZXR1cm4hMX1cbmZ1bmN0aW9uIGVhKGEpe3JldHVybiBhLm8ubG9jYXRpb24uaG9zdG5hbWV8fGEuYS5sb2NhdGlvbi5ob3N0bmFtZX1mdW5jdGlvbiB6KGEsYixjKXtmdW5jdGlvbiBkKCl7bSYmZSYmZiYmKG0oZyksbT1udWxsKX1iPXQoYSxcImxpbmtcIix7cmVsOlwic3R5bGVzaGVldFwiLGhyZWY6YixtZWRpYTpcImFsbFwifSk7dmFyIGU9ITEsZj0hMCxnPW51bGwsbT1jfHxudWxsO2RhPyhiLm9ubG9hZD1mdW5jdGlvbigpe2U9ITA7ZCgpfSxiLm9uZXJyb3I9ZnVuY3Rpb24oKXtlPSEwO2c9RXJyb3IoXCJTdHlsZXNoZWV0IGZhaWxlZCB0byBsb2FkXCIpO2QoKX0pOnNldFRpbWVvdXQoZnVuY3Rpb24oKXtlPSEwO2QoKX0sMCk7dShhLFwiaGVhZFwiLGIpfVxuZnVuY3Rpb24gQShhLGIsYyxkKXt2YXIgZT1hLmMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO2lmKGUpe3ZhciBmPXQoYSxcInNjcmlwdFwiLHtzcmM6Yn0pLGc9ITE7Zi5vbmxvYWQ9Zi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtnfHx0aGlzLnJlYWR5U3RhdGUmJlwibG9hZGVkXCIhPXRoaXMucmVhZHlTdGF0ZSYmXCJjb21wbGV0ZVwiIT10aGlzLnJlYWR5U3RhdGV8fChnPSEwLGMmJmMobnVsbCksZi5vbmxvYWQ9Zi5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxcIkhFQURcIj09Zi5wYXJlbnROb2RlLnRhZ05hbWUmJmUucmVtb3ZlQ2hpbGQoZikpfTtlLmFwcGVuZENoaWxkKGYpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtnfHwoZz0hMCxjJiZjKEVycm9yKFwiU2NyaXB0IGxvYWQgdGltZW91dFwiKSkpfSxkfHw1RTMpO3JldHVybiBmfXJldHVybiBudWxsfTtmdW5jdGlvbiBCKCl7dGhpcy5hPTA7dGhpcy5jPW51bGx9ZnVuY3Rpb24gQyhhKXthLmErKztyZXR1cm4gZnVuY3Rpb24oKXthLmEtLTtEKGEpfX1mdW5jdGlvbiBFKGEsYil7YS5jPWI7RChhKX1mdW5jdGlvbiBEKGEpezA9PWEuYSYmYS5jJiYoYS5jKCksYS5jPW51bGwpfTtmdW5jdGlvbiBGKGEpe3RoaXMuYT1hfHxcIi1cIn1GLnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPTA7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKyliLnB1c2goYXJndW1lbnRzW2NdLnJlcGxhY2UoL1tcXFdfXSsvZyxcIlwiKS50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gYi5qb2luKHRoaXMuYSl9O2Z1bmN0aW9uIEcoYSxiKXt0aGlzLmM9YTt0aGlzLmY9NDt0aGlzLmE9XCJuXCI7dmFyIGM9KGJ8fFwibjRcIikubWF0Y2goL14oW25pb10pKFsxLTldKSQvaSk7YyYmKHRoaXMuYT1jWzFdLHRoaXMuZj1wYXJzZUludChjWzJdLDEwKSl9ZnVuY3Rpb24gZmEoYSl7cmV0dXJuIEgoYSkrXCIgXCIrKGEuZitcIjAwXCIpK1wiIDMwMHB4IFwiK0koYS5jKX1mdW5jdGlvbiBJKGEpe3ZhciBiPVtdO2E9YS5zcGxpdCgvLFxccyovKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YVtjXS5yZXBsYWNlKC9bJ1wiXS9nLFwiXCIpOy0xIT1kLmluZGV4T2YoXCIgXCIpfHwvXlxcZC8udGVzdChkKT9iLnB1c2goXCInXCIrZCtcIidcIik6Yi5wdXNoKGQpfXJldHVybiBiLmpvaW4oXCIsXCIpfWZ1bmN0aW9uIEooYSl7cmV0dXJuIGEuYSthLmZ9ZnVuY3Rpb24gSChhKXt2YXIgYj1cIm5vcm1hbFwiO1wib1wiPT09YS5hP2I9XCJvYmxpcXVlXCI6XCJpXCI9PT1hLmEmJihiPVwiaXRhbGljXCIpO3JldHVybiBifVxuZnVuY3Rpb24gZ2EoYSl7dmFyIGI9NCxjPVwiblwiLGQ9bnVsbDthJiYoKGQ9YS5tYXRjaCgvKG5vcm1hbHxvYmxpcXVlfGl0YWxpYykvaSkpJiZkWzFdJiYoYz1kWzFdLnN1YnN0cigwLDEpLnRvTG93ZXJDYXNlKCkpLChkPWEubWF0Y2goLyhbMS05XTAwfG5vcm1hbHxib2xkKS9pKSkmJmRbMV0mJigvYm9sZC9pLnRlc3QoZFsxXSk/Yj03Oi9bMS05XTAwLy50ZXN0KGRbMV0pJiYoYj1wYXJzZUludChkWzFdLnN1YnN0cigwLDEpLDEwKSkpKTtyZXR1cm4gYytifTtmdW5jdGlvbiBoYShhLGIpe3RoaXMuYz1hO3RoaXMuZj1hLm8uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O3RoaXMuaD1iO3RoaXMuYT1uZXcgRihcIi1cIik7dGhpcy5qPSExIT09Yi5ldmVudHM7dGhpcy5nPSExIT09Yi5jbGFzc2VzfWZ1bmN0aW9uIGlhKGEpe2EuZyYmdyhhLmYsW2EuYS5jKFwid2ZcIixcImxvYWRpbmdcIildKTtLKGEsXCJsb2FkaW5nXCIpfWZ1bmN0aW9uIEwoYSl7aWYoYS5nKXt2YXIgYj15KGEuZixhLmEuYyhcIndmXCIsXCJhY3RpdmVcIikpLGM9W10sZD1bYS5hLmMoXCJ3ZlwiLFwibG9hZGluZ1wiKV07Ynx8Yy5wdXNoKGEuYS5jKFwid2ZcIixcImluYWN0aXZlXCIpKTt3KGEuZixjLGQpfUsoYSxcImluYWN0aXZlXCIpfWZ1bmN0aW9uIEsoYSxiLGMpe2lmKGEuaiYmYS5oW2JdKWlmKGMpYS5oW2JdKGMuYyxKKGMpKTtlbHNlIGEuaFtiXSgpfTtmdW5jdGlvbiBqYSgpe3RoaXMuYz17fX1mdW5jdGlvbiBrYShhLGIsYyl7dmFyIGQ9W10sZTtmb3IoZSBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoZSkpe3ZhciBmPWEuY1tlXTtmJiZkLnB1c2goZihiW2VdLGMpKX1yZXR1cm4gZH07ZnVuY3Rpb24gTShhLGIpe3RoaXMuYz1hO3RoaXMuZj1iO3RoaXMuYT10KHRoaXMuYyxcInNwYW5cIix7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifSx0aGlzLmYpfWZ1bmN0aW9uIE4oYSl7dShhLmMsXCJib2R5XCIsYS5hKX1mdW5jdGlvbiBPKGEpe3JldHVyblwiZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTk5OTlweDtsZWZ0Oi05OTk5cHg7Zm9udC1zaXplOjMwMHB4O3dpZHRoOmF1dG87aGVpZ2h0OmF1dG87bGluZS1oZWlnaHQ6bm9ybWFsO21hcmdpbjowO3BhZGRpbmc6MDtmb250LXZhcmlhbnQ6bm9ybWFsO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpcIitJKGEuYykrXCI7XCIrKFwiZm9udC1zdHlsZTpcIitIKGEpK1wiO2ZvbnQtd2VpZ2h0OlwiKyhhLmYrXCIwMFwiKStcIjtcIil9O2Z1bmN0aW9uIFAoYSxiLGMsZCxlLGYpe3RoaXMuZz1hO3RoaXMuaj1iO3RoaXMuYT1kO3RoaXMuYz1jO3RoaXMuZj1lfHwzRTM7dGhpcy5oPWZ8fHZvaWQgMH1QLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuYy5vLmRvY3VtZW50LGI9dGhpcyxjPXEoKSxkPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGQsZSl7ZnVuY3Rpb24gZigpe3EoKS1jPj1iLmY/ZSgpOmEuZm9udHMubG9hZChmYShiLmEpLGIuaCkudGhlbihmdW5jdGlvbihhKXsxPD1hLmxlbmd0aD9kKCk6c2V0VGltZW91dChmLDI1KX0sZnVuY3Rpb24oKXtlKCl9KX1mKCl9KSxlPW51bGwsZj1uZXcgUHJvbWlzZShmdW5jdGlvbihhLGQpe2U9c2V0VGltZW91dChkLGIuZil9KTtQcm9taXNlLnJhY2UoW2YsZF0pLnRoZW4oZnVuY3Rpb24oKXtlJiYoY2xlYXJUaW1lb3V0KGUpLGU9bnVsbCk7Yi5nKGIuYSl9LGZ1bmN0aW9uKCl7Yi5qKGIuYSl9KX07ZnVuY3Rpb24gUShhLGIsYyxkLGUsZixnKXt0aGlzLnY9YTt0aGlzLkI9Yjt0aGlzLmM9Yzt0aGlzLmE9ZDt0aGlzLnM9Z3x8XCJCRVNic3d5XCI7dGhpcy5mPXt9O3RoaXMudz1lfHwzRTM7dGhpcy51PWZ8fG51bGw7dGhpcy5tPXRoaXMuaj10aGlzLmg9dGhpcy5nPW51bGw7dGhpcy5nPW5ldyBNKHRoaXMuYyx0aGlzLnMpO3RoaXMuaD1uZXcgTSh0aGlzLmMsdGhpcy5zKTt0aGlzLmo9bmV3IE0odGhpcy5jLHRoaXMucyk7dGhpcy5tPW5ldyBNKHRoaXMuYyx0aGlzLnMpO2E9bmV3IEcodGhpcy5hLmMrXCIsc2VyaWZcIixKKHRoaXMuYSkpO2E9TyhhKTt0aGlzLmcuYS5zdHlsZS5jc3NUZXh0PWE7YT1uZXcgRyh0aGlzLmEuYytcIixzYW5zLXNlcmlmXCIsSih0aGlzLmEpKTthPU8oYSk7dGhpcy5oLmEuc3R5bGUuY3NzVGV4dD1hO2E9bmV3IEcoXCJzZXJpZlwiLEoodGhpcy5hKSk7YT1PKGEpO3RoaXMuai5hLnN0eWxlLmNzc1RleHQ9YTthPW5ldyBHKFwic2Fucy1zZXJpZlwiLEoodGhpcy5hKSk7YT1cbk8oYSk7dGhpcy5tLmEuc3R5bGUuY3NzVGV4dD1hO04odGhpcy5nKTtOKHRoaXMuaCk7Tih0aGlzLmopO04odGhpcy5tKX12YXIgUj17RDpcInNlcmlmXCIsQzpcInNhbnMtc2VyaWZcIn0sUz1udWxsO2Z1bmN0aW9uIFQoKXtpZihudWxsPT09Uyl7dmFyIGE9L0FwcGxlV2ViS2l0XFwvKFswLTldKykoPzpcXC4oWzAtOV0rKSkvLmV4ZWMod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1M9ISFhJiYoNTM2PnBhcnNlSW50KGFbMV0sMTApfHw1MzY9PT1wYXJzZUludChhWzFdLDEwKSYmMTE+PXBhcnNlSW50KGFbMl0sMTApKX1yZXR1cm4gU31RLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbigpe3RoaXMuZi5zZXJpZj10aGlzLmouYS5vZmZzZXRXaWR0aDt0aGlzLmZbXCJzYW5zLXNlcmlmXCJdPXRoaXMubS5hLm9mZnNldFdpZHRoO3RoaXMuQT1xKCk7VSh0aGlzKX07XG5mdW5jdGlvbiBsYShhLGIsYyl7Zm9yKHZhciBkIGluIFIpaWYoUi5oYXNPd25Qcm9wZXJ0eShkKSYmYj09PWEuZltSW2RdXSYmYz09PWEuZltSW2RdXSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBVKGEpe3ZhciBiPWEuZy5hLm9mZnNldFdpZHRoLGM9YS5oLmEub2Zmc2V0V2lkdGgsZDsoZD1iPT09YS5mLnNlcmlmJiZjPT09YS5mW1wic2Fucy1zZXJpZlwiXSl8fChkPVQoKSYmbGEoYSxiLGMpKTtkP3EoKS1hLkE+PWEudz9UKCkmJmxhKGEsYixjKSYmKG51bGw9PT1hLnV8fGEudS5oYXNPd25Qcm9wZXJ0eShhLmEuYykpP1YoYSxhLnYpOlYoYSxhLkIpOm1hKGEpOlYoYSxhLnYpfWZ1bmN0aW9uIG1hKGEpe3NldFRpbWVvdXQocChmdW5jdGlvbigpe1UodGhpcyl9LGEpLDUwKX1mdW5jdGlvbiBWKGEsYil7c2V0VGltZW91dChwKGZ1bmN0aW9uKCl7dih0aGlzLmcuYSk7dih0aGlzLmguYSk7dih0aGlzLmouYSk7dih0aGlzLm0uYSk7Yih0aGlzLmEpfSxhKSwwKX07ZnVuY3Rpb24gVyhhLGIsYyl7dGhpcy5jPWE7dGhpcy5hPWI7dGhpcy5mPTA7dGhpcy5tPXRoaXMuaj0hMTt0aGlzLnM9Y312YXIgWD1udWxsO1cucHJvdG90eXBlLmc9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hO2IuZyYmdyhiLmYsW2IuYS5jKFwid2ZcIixhLmMsSihhKS50b1N0cmluZygpLFwiYWN0aXZlXCIpXSxbYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJsb2FkaW5nXCIpLGIuYS5jKFwid2ZcIixhLmMsSihhKS50b1N0cmluZygpLFwiaW5hY3RpdmVcIildKTtLKGIsXCJmb250YWN0aXZlXCIsYSk7dGhpcy5tPSEwO25hKHRoaXMpfTtcblcucHJvdG90eXBlLmg9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hO2lmKGIuZyl7dmFyIGM9eShiLmYsYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJhY3RpdmVcIikpLGQ9W10sZT1bYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJsb2FkaW5nXCIpXTtjfHxkLnB1c2goYi5hLmMoXCJ3ZlwiLGEuYyxKKGEpLnRvU3RyaW5nKCksXCJpbmFjdGl2ZVwiKSk7dyhiLmYsZCxlKX1LKGIsXCJmb250aW5hY3RpdmVcIixhKTtuYSh0aGlzKX07ZnVuY3Rpb24gbmEoYSl7MD09LS1hLmYmJmEuaiYmKGEubT8oYT1hLmEsYS5nJiZ3KGEuZixbYS5hLmMoXCJ3ZlwiLFwiYWN0aXZlXCIpXSxbYS5hLmMoXCJ3ZlwiLFwibG9hZGluZ1wiKSxhLmEuYyhcIndmXCIsXCJpbmFjdGl2ZVwiKV0pLEsoYSxcImFjdGl2ZVwiKSk6TChhLmEpKX07ZnVuY3Rpb24gb2EoYSl7dGhpcy5qPWE7dGhpcy5hPW5ldyBqYTt0aGlzLmg9MDt0aGlzLmY9dGhpcy5nPSEwfW9hLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3RoaXMuYz1uZXcgY2EodGhpcy5qLGEuY29udGV4dHx8dGhpcy5qKTt0aGlzLmc9ITEhPT1hLmV2ZW50czt0aGlzLmY9ITEhPT1hLmNsYXNzZXM7cGEodGhpcyxuZXcgaGEodGhpcy5jLGEpLGEpfTtcbmZ1bmN0aW9uIHFhKGEsYixjLGQsZSl7dmFyIGY9MD09LS1hLmg7KGEuZnx8YS5nKSYmc2V0VGltZW91dChmdW5jdGlvbigpe3ZhciBhPWV8fG51bGwsbT1kfHxudWxsfHx7fTtpZigwPT09Yy5sZW5ndGgmJmYpTChiLmEpO2Vsc2V7Yi5mKz1jLmxlbmd0aDtmJiYoYi5qPWYpO3ZhciBoLGw9W107Zm9yKGg9MDtoPGMubGVuZ3RoO2grKyl7dmFyIGs9Y1toXSxuPW1bay5jXSxyPWIuYSx4PWs7ci5nJiZ3KHIuZixbci5hLmMoXCJ3ZlwiLHguYyxKKHgpLnRvU3RyaW5nKCksXCJsb2FkaW5nXCIpXSk7SyhyLFwiZm9udGxvYWRpbmdcIix4KTtyPW51bGw7aWYobnVsbD09PVgpaWYod2luZG93LkZvbnRGYWNlKXt2YXIgeD0vR2Vja28uKkZpcmVmb3hcXC8oXFxkKykvLmV4ZWMod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLHhhPS9PUyBYLipWZXJzaW9uXFwvMTBcXC4uKlNhZmFyaS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkmJi9BcHBsZS8uZXhlYyh3aW5kb3cubmF2aWdhdG9yLnZlbmRvcik7XG5YPXg/NDI8cGFyc2VJbnQoeFsxXSwxMCk6eGE/ITE6ITB9ZWxzZSBYPSExO1g/cj1uZXcgUChwKGIuZyxiKSxwKGIuaCxiKSxiLmMsayxiLnMsbik6cj1uZXcgUShwKGIuZyxiKSxwKGIuaCxiKSxiLmMsayxiLnMsYSxuKTtsLnB1c2gocil9Zm9yKGg9MDtoPGwubGVuZ3RoO2grKylsW2hdLnN0YXJ0KCl9fSwwKX1mdW5jdGlvbiBwYShhLGIsYyl7dmFyIGQ9W10sZT1jLnRpbWVvdXQ7aWEoYik7dmFyIGQ9a2EoYS5hLGMsYS5jKSxmPW5ldyBXKGEuYyxiLGUpO2EuaD1kLmxlbmd0aDtiPTA7Zm9yKGM9ZC5sZW5ndGg7YjxjO2IrKylkW2JdLmxvYWQoZnVuY3Rpb24oYixkLGMpe3FhKGEsZixiLGQsYyl9KX07ZnVuY3Rpb24gcmEoYSxiKXt0aGlzLmM9YTt0aGlzLmE9Yn1cbnJhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtpZihmW1wiX19tdGlfZm50THN0XCIrZF0pe3ZhciBjPWZbXCJfX210aV9mbnRMc3RcIitkXSgpLGU9W10saDtpZihjKWZvcih2YXIgbD0wO2w8Yy5sZW5ndGg7bCsrKXt2YXIgaz1jW2xdLmZvbnRmYW1pbHk7dm9pZCAwIT1jW2xdLmZvbnRTdHlsZSYmdm9pZCAwIT1jW2xdLmZvbnRXZWlnaHQ/KGg9Y1tsXS5mb250U3R5bGUrY1tsXS5mb250V2VpZ2h0LGUucHVzaChuZXcgRyhrLGgpKSk6ZS5wdXNoKG5ldyBHKGspKX1hKGUpfWVsc2Ugc2V0VGltZW91dChmdW5jdGlvbigpe2IoKX0sNTApfXZhciBjPXRoaXMsZD1jLmEucHJvamVjdElkLGU9Yy5hLnZlcnNpb247aWYoZCl7dmFyIGY9Yy5jLm87QSh0aGlzLmMsKGMuYS5hcGl8fFwiaHR0cHM6Ly9mYXN0LmZvbnRzLm5ldC9qc2FwaVwiKStcIi9cIitkK1wiLmpzXCIrKGU/XCI/dj1cIitlOlwiXCIpLGZ1bmN0aW9uKGUpe2U/YShbXSk6KGZbXCJfX01vbm90eXBlQ29uZmlndXJhdGlvbl9fXCIrXG5kXT1mdW5jdGlvbigpe3JldHVybiBjLmF9LGIoKSl9KS5pZD1cIl9fTW9ub3R5cGVBUElTY3JpcHRfX1wiK2R9ZWxzZSBhKFtdKX07ZnVuY3Rpb24gc2EoYSxiKXt0aGlzLmM9YTt0aGlzLmE9Yn1zYS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihhKXt2YXIgYixjLGQ9dGhpcy5hLnVybHN8fFtdLGU9dGhpcy5hLmZhbWlsaWVzfHxbXSxmPXRoaXMuYS50ZXN0U3RyaW5nc3x8e30sZz1uZXcgQjtiPTA7Zm9yKGM9ZC5sZW5ndGg7YjxjO2IrKyl6KHRoaXMuYyxkW2JdLEMoZykpO3ZhciBtPVtdO2I9MDtmb3IoYz1lLmxlbmd0aDtiPGM7YisrKWlmKGQ9ZVtiXS5zcGxpdChcIjpcIiksZFsxXSlmb3IodmFyIGg9ZFsxXS5zcGxpdChcIixcIiksbD0wO2w8aC5sZW5ndGg7bCs9MSltLnB1c2gobmV3IEcoZFswXSxoW2xdKSk7ZWxzZSBtLnB1c2gobmV3IEcoZFswXSkpO0UoZyxmdW5jdGlvbigpe2EobSxmKX0pfTtmdW5jdGlvbiB0YShhLGIpe2E/dGhpcy5jPWE6dGhpcy5jPXVhO3RoaXMuYT1bXTt0aGlzLmY9W107dGhpcy5nPWJ8fFwiXCJ9dmFyIHVhPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3NcIjtmdW5jdGlvbiB2YShhLGIpe2Zvcih2YXIgYz1iLmxlbmd0aCxkPTA7ZDxjO2QrKyl7dmFyIGU9YltkXS5zcGxpdChcIjpcIik7Mz09ZS5sZW5ndGgmJmEuZi5wdXNoKGUucG9wKCkpO3ZhciBmPVwiXCI7Mj09ZS5sZW5ndGgmJlwiXCIhPWVbMV0mJihmPVwiOlwiKTthLmEucHVzaChlLmpvaW4oZikpfX1cbmZ1bmN0aW9uIHdhKGEpe2lmKDA9PWEuYS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJObyBmb250cyB0byBsb2FkIVwiKTtpZigtMSE9YS5jLmluZGV4T2YoXCJraXQ9XCIpKXJldHVybiBhLmM7Zm9yKHZhciBiPWEuYS5sZW5ndGgsYz1bXSxkPTA7ZDxiO2QrKyljLnB1c2goYS5hW2RdLnJlcGxhY2UoLyAvZyxcIitcIikpO2I9YS5jK1wiP2ZhbWlseT1cIitjLmpvaW4oXCIlN0NcIik7MDxhLmYubGVuZ3RoJiYoYis9XCImc3Vic2V0PVwiK2EuZi5qb2luKFwiLFwiKSk7MDxhLmcubGVuZ3RoJiYoYis9XCImdGV4dD1cIitlbmNvZGVVUklDb21wb25lbnQoYS5nKSk7cmV0dXJuIGJ9O2Z1bmN0aW9uIHlhKGEpe3RoaXMuZj1hO3RoaXMuYT1bXTt0aGlzLmM9e319XG52YXIgemE9e2xhdGluOlwiQkVTYnN3eVwiLFwibGF0aW4tZXh0XCI6XCJcXHUwMGU3XFx1MDBmNlxcdTAwZmNcXHUwMTFmXFx1MDE1ZlwiLGN5cmlsbGljOlwiXFx1MDQzOVxcdTA0NGZcXHUwNDE2XCIsZ3JlZWs6XCJcXHUwM2IxXFx1MDNiMlxcdTAzYTNcIixraG1lcjpcIlxcdTE3ODBcXHUxNzgxXFx1MTc4MlwiLEhhbnVtYW46XCJcXHUxNzgwXFx1MTc4MVxcdTE3ODJcIn0sQWE9e3RoaW46XCIxXCIsZXh0cmFsaWdodDpcIjJcIixcImV4dHJhLWxpZ2h0XCI6XCIyXCIsdWx0cmFsaWdodDpcIjJcIixcInVsdHJhLWxpZ2h0XCI6XCIyXCIsbGlnaHQ6XCIzXCIscmVndWxhcjpcIjRcIixib29rOlwiNFwiLG1lZGl1bTpcIjVcIixcInNlbWktYm9sZFwiOlwiNlwiLHNlbWlib2xkOlwiNlwiLFwiZGVtaS1ib2xkXCI6XCI2XCIsZGVtaWJvbGQ6XCI2XCIsYm9sZDpcIjdcIixcImV4dHJhLWJvbGRcIjpcIjhcIixleHRyYWJvbGQ6XCI4XCIsXCJ1bHRyYS1ib2xkXCI6XCI4XCIsdWx0cmFib2xkOlwiOFwiLGJsYWNrOlwiOVwiLGhlYXZ5OlwiOVwiLGw6XCIzXCIscjpcIjRcIixiOlwiN1wifSxCYT17aTpcImlcIixpdGFsaWM6XCJpXCIsbjpcIm5cIixub3JtYWw6XCJuXCJ9LFxuQ2E9L14odGhpbnwoPzooPzpleHRyYXx1bHRyYSktPyk/bGlnaHR8cmVndWxhcnxib29rfG1lZGl1bXwoPzooPzpzZW1pfGRlbWl8ZXh0cmF8dWx0cmEpLT8pP2JvbGR8YmxhY2t8aGVhdnl8bHxyfGJ8WzEtOV0wMCk/KG58aXxub3JtYWx8aXRhbGljKT8kLztcbmZ1bmN0aW9uIERhKGEpe2Zvcih2YXIgYj1hLmYubGVuZ3RoLGM9MDtjPGI7YysrKXt2YXIgZD1hLmZbY10uc3BsaXQoXCI6XCIpLGU9ZFswXS5yZXBsYWNlKC9cXCsvZyxcIiBcIiksZj1bXCJuNFwiXTtpZigyPD1kLmxlbmd0aCl7dmFyIGc7dmFyIG09ZFsxXTtnPVtdO2lmKG0pZm9yKHZhciBtPW0uc3BsaXQoXCIsXCIpLGg9bS5sZW5ndGgsbD0wO2w8aDtsKyspe3ZhciBrO2s9bVtsXTtpZihrLm1hdGNoKC9eW1xcdy1dKyQvKSl7dmFyIG49Q2EuZXhlYyhrLnRvTG93ZXJDYXNlKCkpO2lmKG51bGw9PW4paz1cIlwiO2Vsc2V7az1uWzJdO2s9bnVsbD09a3x8XCJcIj09az9cIm5cIjpCYVtrXTtuPW5bMV07aWYobnVsbD09bnx8XCJcIj09biluPVwiNFwiO2Vsc2UgdmFyIHI9QWFbbl0sbj1yP3I6aXNOYU4obik/XCI0XCI6bi5zdWJzdHIoMCwxKTtrPVtrLG5dLmpvaW4oXCJcIil9fWVsc2Ugaz1cIlwiO2smJmcucHVzaChrKX0wPGcubGVuZ3RoJiYoZj1nKTszPT1kLmxlbmd0aCYmKGQ9ZFsyXSxnPVtdLGQ9ZD9kLnNwbGl0KFwiLFwiKTpcbmcsMDxkLmxlbmd0aCYmKGQ9emFbZFswXV0pJiYoYS5jW2VdPWQpKX1hLmNbZV18fChkPXphW2VdKSYmKGEuY1tlXT1kKTtmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCs9MSlhLmEucHVzaChuZXcgRyhlLGZbZF0pKX19O2Z1bmN0aW9uIEVhKGEsYil7dGhpcy5jPWE7dGhpcy5hPWJ9dmFyIEZhPXtBcmltbzohMCxDb3VzaW5lOiEwLFRpbm9zOiEwfTtFYS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihhKXt2YXIgYj1uZXcgQixjPXRoaXMuYyxkPW5ldyB0YSh0aGlzLmEuYXBpLHRoaXMuYS50ZXh0KSxlPXRoaXMuYS5mYW1pbGllczt2YShkLGUpO3ZhciBmPW5ldyB5YShlKTtEYShmKTt6KGMsd2EoZCksQyhiKSk7RShiLGZ1bmN0aW9uKCl7YShmLmEsZi5jLEZhKX0pfTtmdW5jdGlvbiBHYShhLGIpe3RoaXMuYz1hO3RoaXMuYT1ifUdhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYS5pZCxjPXRoaXMuYy5vO2I/QSh0aGlzLmMsKHRoaXMuYS5hcGl8fFwiaHR0cHM6Ly91c2UudHlwZWtpdC5uZXRcIikrXCIvXCIrYitcIi5qc1wiLGZ1bmN0aW9uKGIpe2lmKGIpYShbXSk7ZWxzZSBpZihjLlR5cGVraXQmJmMuVHlwZWtpdC5jb25maWcmJmMuVHlwZWtpdC5jb25maWcuZm4pe2I9Yy5UeXBla2l0LmNvbmZpZy5mbjtmb3IodmFyIGU9W10sZj0wO2Y8Yi5sZW5ndGg7Zis9Milmb3IodmFyIGc9YltmXSxtPWJbZisxXSxoPTA7aDxtLmxlbmd0aDtoKyspZS5wdXNoKG5ldyBHKGcsbVtoXSkpO3RyeXtjLlR5cGVraXQubG9hZCh7ZXZlbnRzOiExLGNsYXNzZXM6ITEsYXN5bmM6ITB9KX1jYXRjaChsKXt9YShlKX19LDJFMyk6YShbXSl9O2Z1bmN0aW9uIEhhKGEsYil7dGhpcy5jPWE7dGhpcy5mPWI7dGhpcy5hPVtdfUhhLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZi5pZCxjPXRoaXMuYy5vLGQ9dGhpcztiPyhjLl9fd2ViZm9udGZvbnRkZWNrbW9kdWxlX198fChjLl9fd2ViZm9udGZvbnRkZWNrbW9kdWxlX189e30pLGMuX193ZWJmb250Zm9udGRlY2ttb2R1bGVfX1tiXT1mdW5jdGlvbihiLGMpe2Zvcih2YXIgZz0wLG09Yy5mb250cy5sZW5ndGg7ZzxtOysrZyl7dmFyIGg9Yy5mb250c1tnXTtkLmEucHVzaChuZXcgRyhoLm5hbWUsZ2EoXCJmb250LXdlaWdodDpcIitoLndlaWdodCtcIjtmb250LXN0eWxlOlwiK2guc3R5bGUpKSl9YShkLmEpfSxBKHRoaXMuYywodGhpcy5mLmFwaXx8XCJodHRwczovL2YuZm9udGRlY2suY29tL3MvY3NzL2pzL1wiKStlYSh0aGlzLmMpK1wiL1wiK2IrXCIuanNcIixmdW5jdGlvbihiKXtiJiZhKFtdKX0pKTphKFtdKX07dmFyIFk9bmV3IG9hKHdpbmRvdyk7WS5hLmMuY3VzdG9tPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBzYShiLGEpfTtZLmEuYy5mb250ZGVjaz1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgSGEoYixhKX07WS5hLmMubW9ub3R5cGU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IHJhKGIsYSl9O1kuYS5jLnR5cGVraXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IEdhKGIsYSl9O1kuYS5jLmdvb2dsZT1mdW5jdGlvbihhLGIpe3JldHVybiBuZXcgRWEoYixhKX07dmFyIFo9e2xvYWQ6cChZLmxvYWQsWSl9O1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIFp9KTpcInVuZGVmaW5lZFwiIT09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9Wjood2luZG93LldlYkZvbnQ9Wix3aW5kb3cuV2ViRm9udENvbmZpZyYmWS5sb2FkKHdpbmRvdy5XZWJGb250Q29uZmlnKSk7fSgpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){eval('/*!\n * Vue-Lazyload.js v1.2.6\n * (c) 2018 Awe <hilongjw@gmail.com>\n * Released under the MIT License.\n */\n!function(t,e){ true?module.exports=e():undefined}(this,function(){"use strict";function t(t){return t.constructor&&"function"==typeof t.constructor.isBuffer&&t.constructor.isBuffer(t)}function e(t){t=t||{};var e=arguments.length,i=0;if(1===e)return t;for(;++i<e;){var o=arguments[i];g(t)&&(t=o),r(o)&&n(t,o)}return t}function n(t,n){m(t,n);for(var o in n)if("__proto__"!==o&&i(n,o)){var a=n[o];r(a)?("undefined"===L(t[o])&&"function"===L(a)&&(t[o]=a),t[o]=e(t[o]||{},a)):t[o]=a}return t}function r(t){return"object"===L(t)||"function"===L(t)}function i(t,e){return Object.prototype.hasOwnProperty.call(t,e)}function o(t,e){if(t.length){var n=t.indexOf(e);return n>-1?t.splice(n,1):void 0}}function a(t,e){for(var n=!1,r=0,i=t.length;r<i;r++)if(e(t[r])){n=!0;break}return n}function s(t,e){if("IMG"===t.tagName&&t.getAttribute("data-srcset")){var n=t.getAttribute("data-srcset"),r=[],i=t.parentNode,o=i.offsetWidth*e,a=void 0,s=void 0,u=void 0;n=n.trim().split(","),n.map(function(t){t=t.trim(),a=t.lastIndexOf(" "),-1===a?(s=t,u=999998):(s=t.substr(0,a),u=parseInt(t.substr(a+1,t.length-a-2),10)),r.push([u,s])}),r.sort(function(t,e){if(t[0]<e[0])return-1;if(t[0]>e[0])return 1;if(t[0]===e[0]){if(-1!==e[1].indexOf(".webp",e[1].length-5))return 1;if(-1!==t[1].indexOf(".webp",t[1].length-5))return-1}return 0});for(var l="",d=void 0,c=r.length,h=0;h<c;h++)if(d=r[h],d[0]>=o){l=d[1];break}return l}}function u(t,e){for(var n=void 0,r=0,i=t.length;r<i;r++)if(e(t[r])){n=t[r];break}return n}function l(){if(!E)return!1;var t=!0,e=document;try{var n=e.createElement("object");n.type="image/webp",n.style.visibility="hidden",n.innerHTML="!",e.body.appendChild(n),t=!n.offsetWidth,e.body.removeChild(n)}catch(e){t=!1}return t}function d(t,e){var n=null,r=0;return function(){if(!n){var i=Date.now()-r,o=this,a=arguments,s=function(){r=Date.now(),n=!1,t.apply(o,a)};i>=e?s():n=setTimeout(s,e)}}}function c(t){return null!==t&&"object"===(void 0===t?"undefined":p(t))}function h(t){if(!(t instanceof Object))return[];if(Object.keys)return Object.keys(t);var e=[];for(var n in t)t.hasOwnProperty(n)&&e.push(n);return e}function f(t){for(var e=t.length,n=[],r=0;r<e;r++)n.push(t[r]);return n}function v(){}var p="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},b=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")},y=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),g=function(t){return null==t||"function"!=typeof t&&"object"!==(void 0===t?"undefined":p(t))},m=function(t,e){if(null===t||void 0===t)throw new TypeError("expected first argument to be an object.");if(void 0===e||"undefined"==typeof Symbol)return t;if("function"!=typeof Object.getOwnPropertySymbols)return t;for(var n=Object.prototype.propertyIsEnumerable,r=Object(t),i=arguments.length,o=0;++o<i;)for(var a=Object(arguments[o]),s=Object.getOwnPropertySymbols(a),u=0;u<s.length;u++){var l=s[u];n.call(a,l)&&(r[l]=a[l])}return r},w=Object.prototype.toString,L=function(e){var n=void 0===e?"undefined":p(e);return"undefined"===n?"undefined":null===e?"null":!0===e||!1===e||e instanceof Boolean?"boolean":"string"===n||e instanceof String?"string":"number"===n||e instanceof Number?"number":"function"===n||e instanceof Function?void 0!==e.constructor.name&&"Generator"===e.constructor.name.slice(0,9)?"generatorfunction":"function":void 0!==Array.isArray&&Array.isArray(e)?"array":e instanceof RegExp?"regexp":e instanceof Date?"date":(n=w.call(e),"[object RegExp]"===n?"regexp":"[object Date]"===n?"date":"[object Arguments]"===n?"arguments":"[object Error]"===n?"error":"[object Promise]"===n?"promise":t(e)?"buffer":"[object Set]"===n?"set":"[object WeakSet]"===n?"weakset":"[object Map]"===n?"map":"[object WeakMap]"===n?"weakmap":"[object Symbol]"===n?"symbol":"[object Map Iterator]"===n?"mapiterator":"[object Set Iterator]"===n?"setiterator":"[object String Iterator]"===n?"stringiterator":"[object Array Iterator]"===n?"arrayiterator":"[object Int8Array]"===n?"int8array":"[object Uint8Array]"===n?"uint8array":"[object Uint8ClampedArray]"===n?"uint8clampedarray":"[object Int16Array]"===n?"int16array":"[object Uint16Array]"===n?"uint16array":"[object Int32Array]"===n?"int32array":"[object Uint32Array]"===n?"uint32array":"[object Float32Array]"===n?"float32array":"[object Float64Array]"===n?"float64array":"object")},_=e,E="undefined"!=typeof window,A=E&&"IntersectionObserver"in window,k={event:"event",observer:"observer"},z=function(){function t(t,e){e=e||{bubbles:!1,cancelable:!1,detail:void 0};var n=document.createEvent("CustomEvent");return n.initCustomEvent(t,e.bubbles,e.cancelable,e.detail),n}if(E)return"function"==typeof window.CustomEvent?window.CustomEvent:(t.prototype=window.Event.prototype,t)}(),j=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return E?window.devicePixelRatio||t:t},T=function(){if(E){var t=!1;try{var e=Object.defineProperty({},"passive",{get:function(){t=!0}});window.addEventListener("test",null,e)}catch(t){}return t}}(),S={on:function(t,e,n){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];T?t.addEventListener(e,n,{capture:r,passive:!0}):t.addEventListener(e,n,r)},off:function(t,e,n){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];t.removeEventListener(e,n,r)}},I=function(t,e,n){var r=new Image;r.src=t.src,r.onload=function(){e({naturalHeight:r.naturalHeight,naturalWidth:r.naturalWidth,src:r.src})},r.onerror=function(t){n(t)}},O=function(t,e){return"undefined"!=typeof getComputedStyle?getComputedStyle(t,null).getPropertyValue(e):t.style[e]},$=function(t){return O(t,"overflow")+O(t,"overflow-y")+O(t,"overflow-x")},x=function(t){if(E){if(!(t instanceof HTMLElement))return window;for(var e=t;e&&e!==document.body&&e!==document.documentElement&&e.parentNode;){if(/(scroll|auto)/.test($(e)))return e;e=e.parentNode}return window}},H={},Q=function(){function t(e){var n=e.el,r=e.src,i=e.error,o=e.loading,a=e.bindType,s=e.$parent,u=e.options,l=e.elRenderer;b(this,t),this.el=n,this.src=r,this.error=i,this.loading=o,this.bindType=a,this.attempt=0,this.naturalHeight=0,this.naturalWidth=0,this.options=u,this.rect=null,this.$parent=s,this.elRenderer=l,this.performanceData={init:Date.now(),loadStart:0,loadEnd:0},this.filter(),this.initState(),this.render("loading",!1)}return y(t,[{key:"initState",value:function(){"dataset"in this.el?this.el.dataset.src=this.src:this.el.setAttribute("data-src",this.src),this.state={error:!1,loaded:!1,rendered:!1}}},{key:"record",value:function(t){this.performanceData[t]=Date.now()}},{key:"update",value:function(t){var e=t.src,n=t.loading,r=t.error,i=this.src;this.src=e,this.loading=n,this.error=r,this.filter(),i!==this.src&&(this.attempt=0,this.initState())}},{key:"getRect",value:function(){this.rect=this.el.getBoundingClientRect()}},{key:"checkInView",value:function(){return this.getRect(),this.rect.top<window.innerHeight*this.options.preLoad&&this.rect.bottom>this.options.preLoadTop&&this.rect.left<window.innerWidth*this.options.preLoad&&this.rect.right>0}},{key:"filter",value:function(){var t=this;h(this.options.filter).map(function(e){t.options.filter[e](t,t.options)})}},{key:"renderLoading",value:function(t){var e=this;I({src:this.loading},function(n){e.render("loading",!1),t()},function(){t(),e.options.silent||console.warn("VueLazyload log: load failed with loading image("+e.loading+")")})}},{key:"load",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:v;return this.attempt>this.options.attempt-1&&this.state.error?(this.options.silent||console.log("VueLazyload log: "+this.src+" tried too more than "+this.options.attempt+" times"),void e()):this.state.loaded||H[this.src]?(this.state.loaded=!0,e(),this.render("loaded",!0)):void this.renderLoading(function(){t.attempt++,t.record("loadStart"),I({src:t.src},function(n){t.naturalHeight=n.naturalHeight,t.naturalWidth=n.naturalWidth,t.state.loaded=!0,t.state.error=!1,t.record("loadEnd"),t.render("loaded",!1),H[t.src]=1,e()},function(e){!t.options.silent&&console.error(e),t.state.error=!0,t.state.loaded=!1,t.render("error",!1)})})}},{key:"render",value:function(t,e){this.elRenderer(this,t,e)}},{key:"performance",value:function(){var t="loading",e=0;return this.state.loaded&&(t="loaded",e=(this.performanceData.loadEnd-this.performanceData.loadStart)/1e3),this.state.error&&(t="error"),{src:this.src,state:t,time:e}}},{key:"destroy",value:function(){this.el=null,this.src=null,this.error=null,this.loading=null,this.bindType=null,this.attempt=0}}]),t}(),C="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",R=["scroll","wheel","mousewheel","resize","animationend","transitionend","touchmove"],W={rootMargin:"0px",threshold:0},B=function(t){return function(){function e(t){var n=t.preLoad,r=t.error,i=t.throttleWait,o=t.preLoadTop,a=t.dispatchEvent,s=t.loading,u=t.attempt,c=t.silent,h=void 0===c||c,f=t.scale,v=t.listenEvents,p=(t.hasbind,t.filter),y=t.adapter,g=t.observer,m=t.observerOptions;b(this,e),this.version="1.2.6",this.mode=k.event,this.ListenerQueue=[],this.TargetIndex=0,this.TargetQueue=[],this.options={silent:h,dispatchEvent:!!a,throttleWait:i||200,preLoad:n||1.3,preLoadTop:o||0,error:r||C,loading:s||C,attempt:u||3,scale:f||j(f),ListenEvents:v||R,hasbind:!1,supportWebp:l(),filter:p||{},adapter:y||{},observer:!!g,observerOptions:m||W},this._initEvent(),this.lazyLoadHandler=d(this._lazyLoadHandler.bind(this),this.options.throttleWait),this.setMode(this.options.observer?k.observer:k.event)}return y(e,[{key:"config",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};_(this.options,t)}},{key:"performance",value:function(){var t=[];return this.ListenerQueue.map(function(e){t.push(e.performance())}),t}},{key:"addLazyBox",value:function(t){this.ListenerQueue.push(t),E&&(this._addListenerTarget(window),this._observer&&this._observer.observe(t.el),t.$el&&t.$el.parentNode&&this._addListenerTarget(t.$el.parentNode))}},{key:"add",value:function(e,n,r){var i=this;if(a(this.ListenerQueue,function(t){return t.el===e}))return this.update(e,n),t.nextTick(this.lazyLoadHandler);var o=this._valueFormatter(n.value),u=o.src,l=o.loading,d=o.error;t.nextTick(function(){u=s(e,i.options.scale)||u,i._observer&&i._observer.observe(e);var o=Object.keys(n.modifiers)[0],a=void 0;o&&(a=r.context.$refs[o],a=a?a.$el||a:document.getElementById(o)),a||(a=x(e));var c=new Q({bindType:n.arg,$parent:a,el:e,loading:l,error:d,src:u,elRenderer:i._elRenderer.bind(i),options:i.options});i.ListenerQueue.push(c),E&&(i._addListenerTarget(window),i._addListenerTarget(a)),i.lazyLoadHandler(),t.nextTick(function(){return i.lazyLoadHandler()})})}},{key:"update",value:function(e,n){var r=this,i=this._valueFormatter(n.value),o=i.src,a=i.loading,l=i.error;o=s(e,this.options.scale)||o;var d=u(this.ListenerQueue,function(t){return t.el===e});d&&d.update({src:o,loading:a,error:l}),this._observer&&(this._observer.unobserve(e),this._observer.observe(e)),this.lazyLoadHandler(),t.nextTick(function(){return r.lazyLoadHandler()})}},{key:"remove",value:function(t){if(t){this._observer&&this._observer.unobserve(t);var e=u(this.ListenerQueue,function(e){return e.el===t});e&&(this._removeListenerTarget(e.$parent),this._removeListenerTarget(window),o(this.ListenerQueue,e)&&e.destroy())}}},{key:"removeComponent",value:function(t){t&&(o(this.ListenerQueue,t),this._observer&&this._observer.unobserve(t.el),t.$parent&&t.$el.parentNode&&this._removeListenerTarget(t.$el.parentNode),this._removeListenerTarget(window))}},{key:"setMode",value:function(t){var e=this;A||t!==k.observer||(t=k.event),this.mode=t,t===k.event?(this._observer&&(this.ListenerQueue.forEach(function(t){e._observer.unobserve(t.el)}),this._observer=null),this.TargetQueue.forEach(function(t){e._initListen(t.el,!0)})):(this.TargetQueue.forEach(function(t){e._initListen(t.el,!1)}),this._initIntersectionObserver())}},{key:"_addListenerTarget",value:function(t){if(t){var e=u(this.TargetQueue,function(e){return e.el===t});return e?e.childrenCount++:(e={el:t,id:++this.TargetIndex,childrenCount:1,listened:!0},this.mode===k.event&&this._initListen(e.el,!0),this.TargetQueue.push(e)),this.TargetIndex}}},{key:"_removeListenerTarget",value:function(t){var e=this;this.TargetQueue.forEach(function(n,r){n.el===t&&(--n.childrenCount||(e._initListen(n.el,!1),e.TargetQueue.splice(r,1),n=null))})}},{key:"_initListen",value:function(t,e){var n=this;this.options.ListenEvents.forEach(function(r){return S[e?"on":"off"](t,r,n.lazyLoadHandler)})}},{key:"_initEvent",value:function(){var t=this;this.Event={listeners:{loading:[],loaded:[],error:[]}},this.$on=function(e,n){t.Event.listeners[e]||(t.Event.listeners[e]=[]),t.Event.listeners[e].push(n)},this.$once=function(e,n){function r(){i.$off(e,r),n.apply(i,arguments)}var i=t;t.$on(e,r)},this.$off=function(e,n){if(!n){if(!t.Event.listeners[e])return;return void(t.Event.listeners[e].length=0)}o(t.Event.listeners[e],n)},this.$emit=function(e,n,r){t.Event.listeners[e]&&t.Event.listeners[e].forEach(function(t){return t(n,r)})}}},{key:"_lazyLoadHandler",value:function(){var t=this,e=[];this.ListenerQueue.forEach(function(t,n){if(!t.state.error&&t.state.loaded)return e.push(t);t.checkInView()&&t.load()}),e.forEach(function(e){return o(t.ListenerQueue,e)})}},{key:"_initIntersectionObserver",value:function(){var t=this;A&&(this._observer=new IntersectionObserver(this._observerHandler.bind(this),this.options.observerOptions),this.ListenerQueue.length&&this.ListenerQueue.forEach(function(e){t._observer.observe(e.el)}))}},{key:"_observerHandler",value:function(t,e){var n=this;t.forEach(function(t){t.isIntersecting&&n.ListenerQueue.forEach(function(e){if(e.el===t.target){if(e.state.loaded)return n._observer.unobserve(e.el);e.load()}})})}},{key:"_elRenderer",value:function(t,e,n){if(t.el){var r=t.el,i=t.bindType,o=void 0;switch(e){case"loading":o=t.loading;break;case"error":o=t.error;break;default:o=t.src}if(i?r.style[i]=\'url("\'+o+\'")\':r.getAttribute("src")!==o&&r.setAttribute("src",o),r.setAttribute("lazy",e),this.$emit(e,t,n),this.options.adapter[e]&&this.options.adapter[e](t,this.options),this.options.dispatchEvent){var a=new z(e,{detail:t});r.dispatchEvent(a)}}}},{key:"_valueFormatter",value:function(t){var e=t,n=this.options.loading,r=this.options.error;return c(t)&&(t.src||this.options.silent||console.error("Vue Lazyload warning: miss src with "+t),e=t.src,n=t.loading||this.options.loading,r=t.error||this.options.error),{src:e,loading:n,error:r}}}]),e}()},D=function(t){return{props:{tag:{type:String,default:"div"}},render:function(t){return!1===this.show?t(this.tag):t(this.tag,null,this.$slots.default)},data:function(){return{el:null,state:{loaded:!1},rect:{},show:!1}},mounted:function(){this.el=this.$el,t.addLazyBox(this),t.lazyLoadHandler()},beforeDestroy:function(){t.removeComponent(this)},methods:{getRect:function(){this.rect=this.$el.getBoundingClientRect()},checkInView:function(){return this.getRect(),E&&this.rect.top<window.innerHeight*t.options.preLoad&&this.rect.bottom>0&&this.rect.left<window.innerWidth*t.options.preLoad&&this.rect.right>0},load:function(){this.show=!0,this.state.loaded=!0,this.$emit("show",this)}}}},V=function(){function t(e){var n=e.lazy;b(this,t),this.lazy=n,n.lazyContainerMananger=this,this._queue=[]}return y(t,[{key:"bind",value:function(t,e,n){var r=new N({el:t,binding:e,vnode:n,lazy:this.lazy});this._queue.push(r)}},{key:"update",value:function(t,e,n){var r=u(this._queue,function(e){return e.el===t});r&&r.update({el:t,binding:e,vnode:n})}},{key:"unbind",value:function(t,e,n){var r=u(this._queue,function(e){return e.el===t});r&&(r.clear(),o(this._queue,r))}}]),t}(),M={selector:"img"},N=function(){function t(e){var n=e.el,r=e.binding,i=e.vnode,o=e.lazy;b(this,t),this.el=null,this.vnode=i,this.binding=r,this.options={},this.lazy=o,this._queue=[],this.update({el:n,binding:r})}return y(t,[{key:"update",value:function(t){var e=this,n=t.el,r=t.binding;this.el=n,this.options=_({},M,r.value),this.getImgs().forEach(function(t){e.lazy.add(t,_({},e.binding,{value:{src:"dataset"in t?t.dataset.src:t.getAttribute("data-src"),error:"dataset"in t?t.dataset.error:t.getAttribute("data-error"),loading:"dataset"in t?t.dataset.loading:t.getAttribute("data-loading")}}),e.vnode)})}},{key:"getImgs",value:function(){return f(this.el.querySelectorAll(this.options.selector))}},{key:"clear",value:function(){var t=this;this.getImgs().forEach(function(e){return t.lazy.remove(e)}),this.vnode=null,this.binding=null,this.lazy=null}}]),t}(),P=function(t){return{props:{src:[String,Object],tag:{type:String,default:"img"}},render:function(t){return t(this.tag,{attrs:{src:this.renderSrc}},this.$slots.default)},data:function(){return{el:null,options:{src:"",error:"",loading:"",attempt:t.options.attempt},state:{loaded:!1,error:!1,attempt:0},rect:{},renderSrc:""}},watch:{src:function(){this.init(),t.addLazyBox(this),t.lazyLoadHandler()}},created:function(){this.init(),this.renderSrc=this.options.loading},mounted:function(){this.el=this.$el,t.addLazyBox(this),t.lazyLoadHandler()},beforeDestroy:function(){t.removeComponent(this)},methods:{init:function(){var e=t._valueFormatter(this.src),n=e.src,r=e.loading,i=e.error;this.state.loaded=!1,this.options.src=n,this.options.error=i,this.options.loading=r,this.renderSrc=this.options.loading},getRect:function(){this.rect=this.$el.getBoundingClientRect()},checkInView:function(){return this.getRect(),E&&this.rect.top<window.innerHeight*t.options.preLoad&&this.rect.bottom>0&&this.rect.left<window.innerWidth*t.options.preLoad&&this.rect.right>0},load:function(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:v;if(this.state.attempt>this.options.attempt-1&&this.state.error)return t.options.silent||console.log("VueLazyload log: "+this.options.src+" tried too more than "+this.options.attempt+" times"),void n();var r=this.options.src;I({src:r},function(t){var n=t.src;e.renderSrc=n,e.state.loaded=!0},function(t){e.state.attempt++,e.renderSrc=e.options.error,e.state.error=!0})}}}};return{install:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=B(t),r=new n(e),i=new V({lazy:r}),o="2"===t.version.split(".")[0];t.prototype.$Lazyload=r,e.lazyComponent&&t.component("lazy-component",D(r)),e.lazyImage&&t.component("lazy-image",P(r)),o?(t.directive("lazy",{bind:r.add.bind(r),update:r.update.bind(r),componentUpdated:r.lazyLoadHandler.bind(r),unbind:r.remove.bind(r)}),t.directive("lazy-container",{bind:i.bind.bind(i),update:i.update.bind(i),unbind:i.unbind.bind(i)})):(t.directive("lazy",{bind:r.lazyLoadHandler.bind(r),update:function(t,e){_(this.vm.$refs,this.vm.$els),r.add(this.el,{modifiers:this.modifiers||{},arg:this.arg,value:t,oldValue:e},{context:this.vm})},unbind:function(){r.remove(this.el)}}),t.directive("lazy-container",{update:function(t,e){i.update(this.el,{modifiers:this.modifiers||{},arg:this.arg,value:t,oldValue:e},{context:this.vm})},unbind:function(){i.unbind(this.el)}}))}}});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxhenlsb2FkL3Z1ZS1sYXp5bG9hZC5qcz8yODNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQW9ELG9CQUFvQixTQUFpRSxDQUFDLGlCQUFpQixhQUFhLGNBQWMsMkZBQTJGLGNBQWMsUUFBUSwyQkFBMkIsa0JBQWtCLEtBQUssTUFBTSxFQUFFLG1CQUFtQix5QkFBeUIsU0FBUyxnQkFBZ0IsT0FBTywyQ0FBMkMsV0FBVyx3RUFBd0UsWUFBWSxTQUFTLGNBQWMseUNBQXlDLGdCQUFnQixpREFBaUQsZ0JBQWdCLGFBQWEsbUJBQW1CLGtDQUFrQyxnQkFBZ0IsNEJBQTRCLElBQUksZ0JBQWdCLEtBQUssTUFBTSxTQUFTLGdCQUFnQixxREFBcUQscUdBQXFHLHdDQUF3QyxnSUFBZ0ksdUJBQXVCLHNCQUFzQixzQkFBc0IsZ0JBQWdCLHFEQUFxRCxxREFBcUQsU0FBUyxFQUFFLHFDQUFxQyxJQUFJLHVCQUF1QixPQUFPLE1BQU0sVUFBVSxnQkFBZ0IsZ0NBQWdDLElBQUksZ0JBQWdCLE9BQU8sTUFBTSxTQUFTLGFBQWEsZUFBZSxvQkFBb0IsSUFBSSxnQ0FBZ0MsNkhBQTZILFNBQVMsS0FBSyxTQUFTLGdCQUFnQixlQUFlLGtCQUFrQixPQUFPLG1EQUFtRCxnQ0FBZ0MsNkJBQTZCLGNBQWMsMERBQTBELGNBQWMsbUNBQW1DLHFDQUFxQyxTQUFTLDhDQUE4QyxTQUFTLGNBQWMsNEJBQTRCLElBQUksaUJBQWlCLFNBQVMsY0FBYyw4RUFBOEUsZ0JBQWdCLGFBQWEsb0dBQW9HLGlCQUFpQiw4RUFBOEUsY0FBYyxnQkFBZ0IsWUFBWSxXQUFXLEtBQUssV0FBVywrR0FBK0csdUJBQXVCLHdDQUF3QyxpQkFBaUIsK0VBQStFLGlCQUFpQix3RkFBd0YsbURBQW1ELDREQUE0RCxtRkFBbUYsTUFBTSxzRUFBc0UsV0FBVyxLQUFLLFdBQVcseUJBQXlC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QyxxQkFBcUIsa0JBQWtCLDRCQUE0QixpQ0FBaUMsRUFBRSxnQkFBZ0IsRUFBRSxtQkFBbUIsbUJBQW1CLEtBQUsiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLUxhenlsb2FkLmpzIHYxLjIuNlxuICogKGMpIDIwMTggQXdlIDxoaWxvbmdqd0BnbWFpbC5jb20+XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGUpOnQuVnVlTGF6eWxvYWQ9ZSgpfSh0aGlzLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdCh0KXtyZXR1cm4gdC5jb25zdHJ1Y3RvciYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciYmdC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih0KX1mdW5jdGlvbiBlKHQpe3Q9dHx8e307dmFyIGU9YXJndW1lbnRzLmxlbmd0aCxpPTA7aWYoMT09PWUpcmV0dXJuIHQ7Zm9yKDsrK2k8ZTspe3ZhciBvPWFyZ3VtZW50c1tpXTtnKHQpJiYodD1vKSxyKG8pJiZuKHQsbyl9cmV0dXJuIHR9ZnVuY3Rpb24gbih0LG4pe20odCxuKTtmb3IodmFyIG8gaW4gbilpZihcIl9fcHJvdG9fX1wiIT09byYmaShuLG8pKXt2YXIgYT1uW29dO3IoYSk/KFwidW5kZWZpbmVkXCI9PT1MKHRbb10pJiZcImZ1bmN0aW9uXCI9PT1MKGEpJiYodFtvXT1hKSx0W29dPWUodFtvXXx8e30sYSkpOnRbb109YX1yZXR1cm4gdH1mdW5jdGlvbiByKHQpe3JldHVyblwib2JqZWN0XCI9PT1MKHQpfHxcImZ1bmN0aW9uXCI9PT1MKHQpfWZ1bmN0aW9uIGkodCxlKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSl9ZnVuY3Rpb24gbyh0LGUpe2lmKHQubGVuZ3RoKXt2YXIgbj10LmluZGV4T2YoZSk7cmV0dXJuIG4+LTE/dC5zcGxpY2UobiwxKTp2b2lkIDB9fWZ1bmN0aW9uIGEodCxlKXtmb3IodmFyIG49ITEscj0wLGk9dC5sZW5ndGg7cjxpO3IrKylpZihlKHRbcl0pKXtuPSEwO2JyZWFrfXJldHVybiBufWZ1bmN0aW9uIHModCxlKXtpZihcIklNR1wiPT09dC50YWdOYW1lJiZ0LmdldEF0dHJpYnV0ZShcImRhdGEtc3Jjc2V0XCIpKXt2YXIgbj10LmdldEF0dHJpYnV0ZShcImRhdGEtc3Jjc2V0XCIpLHI9W10saT10LnBhcmVudE5vZGUsbz1pLm9mZnNldFdpZHRoKmUsYT12b2lkIDAscz12b2lkIDAsdT12b2lkIDA7bj1uLnRyaW0oKS5zcGxpdChcIixcIiksbi5tYXAoZnVuY3Rpb24odCl7dD10LnRyaW0oKSxhPXQubGFzdEluZGV4T2YoXCIgXCIpLC0xPT09YT8ocz10LHU9OTk5OTk4KToocz10LnN1YnN0cigwLGEpLHU9cGFyc2VJbnQodC5zdWJzdHIoYSsxLHQubGVuZ3RoLWEtMiksMTApKSxyLnB1c2goW3Usc10pfSksci5zb3J0KGZ1bmN0aW9uKHQsZSl7aWYodFswXTxlWzBdKXJldHVybi0xO2lmKHRbMF0+ZVswXSlyZXR1cm4gMTtpZih0WzBdPT09ZVswXSl7aWYoLTEhPT1lWzFdLmluZGV4T2YoXCIud2VicFwiLGVbMV0ubGVuZ3RoLTUpKXJldHVybiAxO2lmKC0xIT09dFsxXS5pbmRleE9mKFwiLndlYnBcIix0WzFdLmxlbmd0aC01KSlyZXR1cm4tMX1yZXR1cm4gMH0pO2Zvcih2YXIgbD1cIlwiLGQ9dm9pZCAwLGM9ci5sZW5ndGgsaD0wO2g8YztoKyspaWYoZD1yW2hdLGRbMF0+PW8pe2w9ZFsxXTticmVha31yZXR1cm4gbH19ZnVuY3Rpb24gdSh0LGUpe2Zvcih2YXIgbj12b2lkIDAscj0wLGk9dC5sZW5ndGg7cjxpO3IrKylpZihlKHRbcl0pKXtuPXRbcl07YnJlYWt9cmV0dXJuIG59ZnVuY3Rpb24gbCgpe2lmKCFFKXJldHVybiExO3ZhciB0PSEwLGU9ZG9jdW1lbnQ7dHJ5e3ZhciBuPWUuY3JlYXRlRWxlbWVudChcIm9iamVjdFwiKTtuLnR5cGU9XCJpbWFnZS93ZWJwXCIsbi5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCIsbi5pbm5lckhUTUw9XCIhXCIsZS5ib2R5LmFwcGVuZENoaWxkKG4pLHQ9IW4ub2Zmc2V0V2lkdGgsZS5ib2R5LnJlbW92ZUNoaWxkKG4pfWNhdGNoKGUpe3Q9ITF9cmV0dXJuIHR9ZnVuY3Rpb24gZCh0LGUpe3ZhciBuPW51bGwscj0wO3JldHVybiBmdW5jdGlvbigpe2lmKCFuKXt2YXIgaT1EYXRlLm5vdygpLXIsbz10aGlzLGE9YXJndW1lbnRzLHM9ZnVuY3Rpb24oKXtyPURhdGUubm93KCksbj0hMSx0LmFwcGx5KG8sYSl9O2k+PWU/cygpOm49c2V0VGltZW91dChzLGUpfX19ZnVuY3Rpb24gYyh0KXtyZXR1cm4gbnVsbCE9PXQmJlwib2JqZWN0XCI9PT0odm9pZCAwPT09dD9cInVuZGVmaW5lZFwiOnAodCkpfWZ1bmN0aW9uIGgodCl7aWYoISh0IGluc3RhbmNlb2YgT2JqZWN0KSlyZXR1cm5bXTtpZihPYmplY3Qua2V5cylyZXR1cm4gT2JqZWN0LmtleXModCk7dmFyIGU9W107Zm9yKHZhciBuIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShuKSYmZS5wdXNoKG4pO3JldHVybiBlfWZ1bmN0aW9uIGYodCl7Zm9yKHZhciBlPXQubGVuZ3RoLG49W10scj0wO3I8ZTtyKyspbi5wdXNoKHRbcl0pO3JldHVybiBufWZ1bmN0aW9uIHYoKXt9dmFyIHA9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0sYj1mdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9LHk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIua2V5LHIpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLHIpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLHImJnQoZSxyKSxlfX0oKSxnPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT10fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZcIm9iamVjdFwiIT09KHZvaWQgMD09PXQ/XCJ1bmRlZmluZWRcIjpwKHQpKX0sbT1mdW5jdGlvbih0LGUpe2lmKG51bGw9PT10fHx2b2lkIDA9PT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QuXCIpO2lmKHZvaWQgMD09PWV8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBTeW1ib2wpcmV0dXJuIHQ7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scylyZXR1cm4gdDtmb3IodmFyIG49T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSxyPU9iamVjdCh0KSxpPWFyZ3VtZW50cy5sZW5ndGgsbz0wOysrbzxpOylmb3IodmFyIGE9T2JqZWN0KGFyZ3VtZW50c1tvXSkscz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGEpLHU9MDt1PHMubGVuZ3RoO3UrKyl7dmFyIGw9c1t1XTtuLmNhbGwoYSxsKSYmKHJbbF09YVtsXSl9cmV0dXJuIHJ9LHc9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxMPWZ1bmN0aW9uKGUpe3ZhciBuPXZvaWQgMD09PWU/XCJ1bmRlZmluZWRcIjpwKGUpO3JldHVyblwidW5kZWZpbmVkXCI9PT1uP1widW5kZWZpbmVkXCI6bnVsbD09PWU/XCJudWxsXCI6ITA9PT1lfHwhMT09PWV8fGUgaW5zdGFuY2VvZiBCb29sZWFuP1wiYm9vbGVhblwiOlwic3RyaW5nXCI9PT1ufHxlIGluc3RhbmNlb2YgU3RyaW5nP1wic3RyaW5nXCI6XCJudW1iZXJcIj09PW58fGUgaW5zdGFuY2VvZiBOdW1iZXI/XCJudW1iZXJcIjpcImZ1bmN0aW9uXCI9PT1ufHxlIGluc3RhbmNlb2YgRnVuY3Rpb24/dm9pZCAwIT09ZS5jb25zdHJ1Y3Rvci5uYW1lJiZcIkdlbmVyYXRvclwiPT09ZS5jb25zdHJ1Y3Rvci5uYW1lLnNsaWNlKDAsOSk/XCJnZW5lcmF0b3JmdW5jdGlvblwiOlwiZnVuY3Rpb25cIjp2b2lkIDAhPT1BcnJheS5pc0FycmF5JiZBcnJheS5pc0FycmF5KGUpP1wiYXJyYXlcIjplIGluc3RhbmNlb2YgUmVnRXhwP1wicmVnZXhwXCI6ZSBpbnN0YW5jZW9mIERhdGU/XCJkYXRlXCI6KG49dy5jYWxsKGUpLFwiW29iamVjdCBSZWdFeHBdXCI9PT1uP1wicmVnZXhwXCI6XCJbb2JqZWN0IERhdGVdXCI9PT1uP1wiZGF0ZVwiOlwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1uP1wiYXJndW1lbnRzXCI6XCJbb2JqZWN0IEVycm9yXVwiPT09bj9cImVycm9yXCI6XCJbb2JqZWN0IFByb21pc2VdXCI9PT1uP1wicHJvbWlzZVwiOnQoZSk/XCJidWZmZXJcIjpcIltvYmplY3QgU2V0XVwiPT09bj9cInNldFwiOlwiW29iamVjdCBXZWFrU2V0XVwiPT09bj9cIndlYWtzZXRcIjpcIltvYmplY3QgTWFwXVwiPT09bj9cIm1hcFwiOlwiW29iamVjdCBXZWFrTWFwXVwiPT09bj9cIndlYWttYXBcIjpcIltvYmplY3QgU3ltYm9sXVwiPT09bj9cInN5bWJvbFwiOlwiW29iamVjdCBNYXAgSXRlcmF0b3JdXCI9PT1uP1wibWFwaXRlcmF0b3JcIjpcIltvYmplY3QgU2V0IEl0ZXJhdG9yXVwiPT09bj9cInNldGl0ZXJhdG9yXCI6XCJbb2JqZWN0IFN0cmluZyBJdGVyYXRvcl1cIj09PW4/XCJzdHJpbmdpdGVyYXRvclwiOlwiW29iamVjdCBBcnJheSBJdGVyYXRvcl1cIj09PW4/XCJhcnJheWl0ZXJhdG9yXCI6XCJbb2JqZWN0IEludDhBcnJheV1cIj09PW4/XCJpbnQ4YXJyYXlcIjpcIltvYmplY3QgVWludDhBcnJheV1cIj09PW4/XCJ1aW50OGFycmF5XCI6XCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiPT09bj9cInVpbnQ4Y2xhbXBlZGFycmF5XCI6XCJbb2JqZWN0IEludDE2QXJyYXldXCI9PT1uP1wiaW50MTZhcnJheVwiOlwiW29iamVjdCBVaW50MTZBcnJheV1cIj09PW4/XCJ1aW50MTZhcnJheVwiOlwiW29iamVjdCBJbnQzMkFycmF5XVwiPT09bj9cImludDMyYXJyYXlcIjpcIltvYmplY3QgVWludDMyQXJyYXldXCI9PT1uP1widWludDMyYXJyYXlcIjpcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiPT09bj9cImZsb2F0MzJhcnJheVwiOlwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI9PT1uP1wiZmxvYXQ2NGFycmF5XCI6XCJvYmplY3RcIil9LF89ZSxFPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3csQT1FJiZcIkludGVyc2VjdGlvbk9ic2VydmVyXCJpbiB3aW5kb3csaz17ZXZlbnQ6XCJldmVudFwiLG9ic2VydmVyOlwib2JzZXJ2ZXJcIn0sej1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtlPWV8fHtidWJibGVzOiExLGNhbmNlbGFibGU6ITEsZGV0YWlsOnZvaWQgMH07dmFyIG49ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtyZXR1cm4gbi5pbml0Q3VzdG9tRXZlbnQodCxlLmJ1YmJsZXMsZS5jYW5jZWxhYmxlLGUuZGV0YWlsKSxufWlmKEUpcmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50P3dpbmRvdy5DdXN0b21FdmVudDoodC5wcm90b3R5cGU9d2luZG93LkV2ZW50LnByb3RvdHlwZSx0KX0oKSxqPWZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOjE7cmV0dXJuIEU/d2luZG93LmRldmljZVBpeGVsUmF0aW98fHQ6dH0sVD1mdW5jdGlvbigpe2lmKEUpe3ZhciB0PSExO3RyeXt2YXIgZT1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJwYXNzaXZlXCIse2dldDpmdW5jdGlvbigpe3Q9ITB9fSk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsbnVsbCxlKX1jYXRjaCh0KXt9cmV0dXJuIHR9fSgpLFM9e29uOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXSYmYXJndW1lbnRzWzNdO1Q/dC5hZGRFdmVudExpc3RlbmVyKGUsbix7Y2FwdHVyZTpyLHBhc3NpdmU6ITB9KTp0LmFkZEV2ZW50TGlzdGVuZXIoZSxuLHIpfSxvZmY6ZnVuY3Rpb24odCxlLG4pe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdJiZhcmd1bWVudHNbM107dC5yZW1vdmVFdmVudExpc3RlbmVyKGUsbixyKX19LEk9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBJbWFnZTtyLnNyYz10LnNyYyxyLm9ubG9hZD1mdW5jdGlvbigpe2Uoe25hdHVyYWxIZWlnaHQ6ci5uYXR1cmFsSGVpZ2h0LG5hdHVyYWxXaWR0aDpyLm5hdHVyYWxXaWR0aCxzcmM6ci5zcmN9KX0sci5vbmVycm9yPWZ1bmN0aW9uKHQpe24odCl9fSxPPWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdldENvbXB1dGVkU3R5bGU/Z2V0Q29tcHV0ZWRTdHlsZSh0LG51bGwpLmdldFByb3BlcnR5VmFsdWUoZSk6dC5zdHlsZVtlXX0sJD1mdW5jdGlvbih0KXtyZXR1cm4gTyh0LFwib3ZlcmZsb3dcIikrTyh0LFwib3ZlcmZsb3cteVwiKStPKHQsXCJvdmVyZmxvdy14XCIpfSx4PWZ1bmN0aW9uKHQpe2lmKEUpe2lmKCEodCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlyZXR1cm4gd2luZG93O2Zvcih2YXIgZT10O2UmJmUhPT1kb2N1bWVudC5ib2R5JiZlIT09ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZlLnBhcmVudE5vZGU7KXtpZigvKHNjcm9sbHxhdXRvKS8udGVzdCgkKGUpKSlyZXR1cm4gZTtlPWUucGFyZW50Tm9kZX1yZXR1cm4gd2luZG93fX0sSD17fSxRPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXt2YXIgbj1lLmVsLHI9ZS5zcmMsaT1lLmVycm9yLG89ZS5sb2FkaW5nLGE9ZS5iaW5kVHlwZSxzPWUuJHBhcmVudCx1PWUub3B0aW9ucyxsPWUuZWxSZW5kZXJlcjtiKHRoaXMsdCksdGhpcy5lbD1uLHRoaXMuc3JjPXIsdGhpcy5lcnJvcj1pLHRoaXMubG9hZGluZz1vLHRoaXMuYmluZFR5cGU9YSx0aGlzLmF0dGVtcHQ9MCx0aGlzLm5hdHVyYWxIZWlnaHQ9MCx0aGlzLm5hdHVyYWxXaWR0aD0wLHRoaXMub3B0aW9ucz11LHRoaXMucmVjdD1udWxsLHRoaXMuJHBhcmVudD1zLHRoaXMuZWxSZW5kZXJlcj1sLHRoaXMucGVyZm9ybWFuY2VEYXRhPXtpbml0OkRhdGUubm93KCksbG9hZFN0YXJ0OjAsbG9hZEVuZDowfSx0aGlzLmZpbHRlcigpLHRoaXMuaW5pdFN0YXRlKCksdGhpcy5yZW5kZXIoXCJsb2FkaW5nXCIsITEpfXJldHVybiB5KHQsW3trZXk6XCJpbml0U3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe1wiZGF0YXNldFwiaW4gdGhpcy5lbD90aGlzLmVsLmRhdGFzZXQuc3JjPXRoaXMuc3JjOnRoaXMuZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1zcmNcIix0aGlzLnNyYyksdGhpcy5zdGF0ZT17ZXJyb3I6ITEsbG9hZGVkOiExLHJlbmRlcmVkOiExfX19LHtrZXk6XCJyZWNvcmRcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLnBlcmZvcm1hbmNlRGF0YVt0XT1EYXRlLm5vdygpfX0se2tleTpcInVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3JjLG49dC5sb2FkaW5nLHI9dC5lcnJvcixpPXRoaXMuc3JjO3RoaXMuc3JjPWUsdGhpcy5sb2FkaW5nPW4sdGhpcy5lcnJvcj1yLHRoaXMuZmlsdGVyKCksaSE9PXRoaXMuc3JjJiYodGhpcy5hdHRlbXB0PTAsdGhpcy5pbml0U3RhdGUoKSl9fSx7a2V5OlwiZ2V0UmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5yZWN0PXRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCl9fSx7a2V5OlwiY2hlY2tJblZpZXdcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFJlY3QoKSx0aGlzLnJlY3QudG9wPHdpbmRvdy5pbm5lckhlaWdodCp0aGlzLm9wdGlvbnMucHJlTG9hZCYmdGhpcy5yZWN0LmJvdHRvbT50aGlzLm9wdGlvbnMucHJlTG9hZFRvcCYmdGhpcy5yZWN0LmxlZnQ8d2luZG93LmlubmVyV2lkdGgqdGhpcy5vcHRpb25zLnByZUxvYWQmJnRoaXMucmVjdC5yaWdodD4wfX0se2tleTpcImZpbHRlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztoKHRoaXMub3B0aW9ucy5maWx0ZXIpLm1hcChmdW5jdGlvbihlKXt0Lm9wdGlvbnMuZmlsdGVyW2VdKHQsdC5vcHRpb25zKX0pfX0se2tleTpcInJlbmRlckxvYWRpbmdcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzO0koe3NyYzp0aGlzLmxvYWRpbmd9LGZ1bmN0aW9uKG4pe2UucmVuZGVyKFwibG9hZGluZ1wiLCExKSx0KCl9LGZ1bmN0aW9uKCl7dCgpLGUub3B0aW9ucy5zaWxlbnR8fGNvbnNvbGUud2FybihcIlZ1ZUxhenlsb2FkIGxvZzogbG9hZCBmYWlsZWQgd2l0aCBsb2FkaW5nIGltYWdlKFwiK2UubG9hZGluZytcIilcIil9KX19LHtrZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnY7cmV0dXJuIHRoaXMuYXR0ZW1wdD50aGlzLm9wdGlvbnMuYXR0ZW1wdC0xJiZ0aGlzLnN0YXRlLmVycm9yPyh0aGlzLm9wdGlvbnMuc2lsZW50fHxjb25zb2xlLmxvZyhcIlZ1ZUxhenlsb2FkIGxvZzogXCIrdGhpcy5zcmMrXCIgdHJpZWQgdG9vIG1vcmUgdGhhbiBcIit0aGlzLm9wdGlvbnMuYXR0ZW1wdCtcIiB0aW1lc1wiKSx2b2lkIGUoKSk6dGhpcy5zdGF0ZS5sb2FkZWR8fEhbdGhpcy5zcmNdPyh0aGlzLnN0YXRlLmxvYWRlZD0hMCxlKCksdGhpcy5yZW5kZXIoXCJsb2FkZWRcIiwhMCkpOnZvaWQgdGhpcy5yZW5kZXJMb2FkaW5nKGZ1bmN0aW9uKCl7dC5hdHRlbXB0KyssdC5yZWNvcmQoXCJsb2FkU3RhcnRcIiksSSh7c3JjOnQuc3JjfSxmdW5jdGlvbihuKXt0Lm5hdHVyYWxIZWlnaHQ9bi5uYXR1cmFsSGVpZ2h0LHQubmF0dXJhbFdpZHRoPW4ubmF0dXJhbFdpZHRoLHQuc3RhdGUubG9hZGVkPSEwLHQuc3RhdGUuZXJyb3I9ITEsdC5yZWNvcmQoXCJsb2FkRW5kXCIpLHQucmVuZGVyKFwibG9hZGVkXCIsITEpLEhbdC5zcmNdPTEsZSgpfSxmdW5jdGlvbihlKXshdC5vcHRpb25zLnNpbGVudCYmY29uc29sZS5lcnJvcihlKSx0LnN0YXRlLmVycm9yPSEwLHQuc3RhdGUubG9hZGVkPSExLHQucmVuZGVyKFwiZXJyb3JcIiwhMSl9KX0pfX0se2tleTpcInJlbmRlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5lbFJlbmRlcmVyKHRoaXMsdCxlKX19LHtrZXk6XCJwZXJmb3JtYW5jZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9XCJsb2FkaW5nXCIsZT0wO3JldHVybiB0aGlzLnN0YXRlLmxvYWRlZCYmKHQ9XCJsb2FkZWRcIixlPSh0aGlzLnBlcmZvcm1hbmNlRGF0YS5sb2FkRW5kLXRoaXMucGVyZm9ybWFuY2VEYXRhLmxvYWRTdGFydCkvMWUzKSx0aGlzLnN0YXRlLmVycm9yJiYodD1cImVycm9yXCIpLHtzcmM6dGhpcy5zcmMsc3RhdGU6dCx0aW1lOmV9fX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuZWw9bnVsbCx0aGlzLnNyYz1udWxsLHRoaXMuZXJyb3I9bnVsbCx0aGlzLmxvYWRpbmc9bnVsbCx0aGlzLmJpbmRUeXBlPW51bGwsdGhpcy5hdHRlbXB0PTB9fV0pLHR9KCksQz1cImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBN1wiLFI9W1wic2Nyb2xsXCIsXCJ3aGVlbFwiLFwibW91c2V3aGVlbFwiLFwicmVzaXplXCIsXCJhbmltYXRpb25lbmRcIixcInRyYW5zaXRpb25lbmRcIixcInRvdWNobW92ZVwiXSxXPXtyb290TWFyZ2luOlwiMHB4XCIsdGhyZXNob2xkOjB9LEI9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXt2YXIgbj10LnByZUxvYWQscj10LmVycm9yLGk9dC50aHJvdHRsZVdhaXQsbz10LnByZUxvYWRUb3AsYT10LmRpc3BhdGNoRXZlbnQscz10LmxvYWRpbmcsdT10LmF0dGVtcHQsYz10LnNpbGVudCxoPXZvaWQgMD09PWN8fGMsZj10LnNjYWxlLHY9dC5saXN0ZW5FdmVudHMscD0odC5oYXNiaW5kLHQuZmlsdGVyKSx5PXQuYWRhcHRlcixnPXQub2JzZXJ2ZXIsbT10Lm9ic2VydmVyT3B0aW9ucztiKHRoaXMsZSksdGhpcy52ZXJzaW9uPVwiMS4yLjZcIix0aGlzLm1vZGU9ay5ldmVudCx0aGlzLkxpc3RlbmVyUXVldWU9W10sdGhpcy5UYXJnZXRJbmRleD0wLHRoaXMuVGFyZ2V0UXVldWU9W10sdGhpcy5vcHRpb25zPXtzaWxlbnQ6aCxkaXNwYXRjaEV2ZW50OiEhYSx0aHJvdHRsZVdhaXQ6aXx8MjAwLHByZUxvYWQ6bnx8MS4zLHByZUxvYWRUb3A6b3x8MCxlcnJvcjpyfHxDLGxvYWRpbmc6c3x8QyxhdHRlbXB0OnV8fDMsc2NhbGU6Znx8aihmKSxMaXN0ZW5FdmVudHM6dnx8UixoYXNiaW5kOiExLHN1cHBvcnRXZWJwOmwoKSxmaWx0ZXI6cHx8e30sYWRhcHRlcjp5fHx7fSxvYnNlcnZlcjohIWcsb2JzZXJ2ZXJPcHRpb25zOm18fFd9LHRoaXMuX2luaXRFdmVudCgpLHRoaXMubGF6eUxvYWRIYW5kbGVyPWQodGhpcy5fbGF6eUxvYWRIYW5kbGVyLmJpbmQodGhpcyksdGhpcy5vcHRpb25zLnRocm90dGxlV2FpdCksdGhpcy5zZXRNb2RlKHRoaXMub3B0aW9ucy5vYnNlcnZlcj9rLm9ic2VydmVyOmsuZXZlbnQpfXJldHVybiB5KGUsW3trZXk6XCJjb25maWdcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtfKHRoaXMub3B0aW9ucyx0KX19LHtrZXk6XCJwZXJmb3JtYW5jZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9W107cmV0dXJuIHRoaXMuTGlzdGVuZXJRdWV1ZS5tYXAoZnVuY3Rpb24oZSl7dC5wdXNoKGUucGVyZm9ybWFuY2UoKSl9KSx0fX0se2tleTpcImFkZExhenlCb3hcIix2YWx1ZTpmdW5jdGlvbih0KXt0aGlzLkxpc3RlbmVyUXVldWUucHVzaCh0KSxFJiYodGhpcy5fYWRkTGlzdGVuZXJUYXJnZXQod2luZG93KSx0aGlzLl9vYnNlcnZlciYmdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0LmVsKSx0LiRlbCYmdC4kZWwucGFyZW50Tm9kZSYmdGhpcy5fYWRkTGlzdGVuZXJUYXJnZXQodC4kZWwucGFyZW50Tm9kZSkpfX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKGUsbixyKXt2YXIgaT10aGlzO2lmKGEodGhpcy5MaXN0ZW5lclF1ZXVlLGZ1bmN0aW9uKHQpe3JldHVybiB0LmVsPT09ZX0pKXJldHVybiB0aGlzLnVwZGF0ZShlLG4pLHQubmV4dFRpY2sodGhpcy5sYXp5TG9hZEhhbmRsZXIpO3ZhciBvPXRoaXMuX3ZhbHVlRm9ybWF0dGVyKG4udmFsdWUpLHU9by5zcmMsbD1vLmxvYWRpbmcsZD1vLmVycm9yO3QubmV4dFRpY2soZnVuY3Rpb24oKXt1PXMoZSxpLm9wdGlvbnMuc2NhbGUpfHx1LGkuX29ic2VydmVyJiZpLl9vYnNlcnZlci5vYnNlcnZlKGUpO3ZhciBvPU9iamVjdC5rZXlzKG4ubW9kaWZpZXJzKVswXSxhPXZvaWQgMDtvJiYoYT1yLmNvbnRleHQuJHJlZnNbb10sYT1hP2EuJGVsfHxhOmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG8pKSxhfHwoYT14KGUpKTt2YXIgYz1uZXcgUSh7YmluZFR5cGU6bi5hcmcsJHBhcmVudDphLGVsOmUsbG9hZGluZzpsLGVycm9yOmQsc3JjOnUsZWxSZW5kZXJlcjppLl9lbFJlbmRlcmVyLmJpbmQoaSksb3B0aW9uczppLm9wdGlvbnN9KTtpLkxpc3RlbmVyUXVldWUucHVzaChjKSxFJiYoaS5fYWRkTGlzdGVuZXJUYXJnZXQod2luZG93KSxpLl9hZGRMaXN0ZW5lclRhcmdldChhKSksaS5sYXp5TG9hZEhhbmRsZXIoKSx0Lm5leHRUaWNrKGZ1bmN0aW9uKCl7cmV0dXJuIGkubGF6eUxvYWRIYW5kbGVyKCl9KX0pfX0se2tleTpcInVwZGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsbil7dmFyIHI9dGhpcyxpPXRoaXMuX3ZhbHVlRm9ybWF0dGVyKG4udmFsdWUpLG89aS5zcmMsYT1pLmxvYWRpbmcsbD1pLmVycm9yO289cyhlLHRoaXMub3B0aW9ucy5zY2FsZSl8fG87dmFyIGQ9dSh0aGlzLkxpc3RlbmVyUXVldWUsZnVuY3Rpb24odCl7cmV0dXJuIHQuZWw9PT1lfSk7ZCYmZC51cGRhdGUoe3NyYzpvLGxvYWRpbmc6YSxlcnJvcjpsfSksdGhpcy5fb2JzZXJ2ZXImJih0aGlzLl9vYnNlcnZlci51bm9ic2VydmUoZSksdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZShlKSksdGhpcy5sYXp5TG9hZEhhbmRsZXIoKSx0Lm5leHRUaWNrKGZ1bmN0aW9uKCl7cmV0dXJuIHIubGF6eUxvYWRIYW5kbGVyKCl9KX19LHtrZXk6XCJyZW1vdmVcIix2YWx1ZTpmdW5jdGlvbih0KXtpZih0KXt0aGlzLl9vYnNlcnZlciYmdGhpcy5fb2JzZXJ2ZXIudW5vYnNlcnZlKHQpO3ZhciBlPXUodGhpcy5MaXN0ZW5lclF1ZXVlLGZ1bmN0aW9uKGUpe3JldHVybiBlLmVsPT09dH0pO2UmJih0aGlzLl9yZW1vdmVMaXN0ZW5lclRhcmdldChlLiRwYXJlbnQpLHRoaXMuX3JlbW92ZUxpc3RlbmVyVGFyZ2V0KHdpbmRvdyksbyh0aGlzLkxpc3RlbmVyUXVldWUsZSkmJmUuZGVzdHJveSgpKX19fSx7a2V5OlwicmVtb3ZlQ29tcG9uZW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7dCYmKG8odGhpcy5MaXN0ZW5lclF1ZXVlLHQpLHRoaXMuX29ic2VydmVyJiZ0aGlzLl9vYnNlcnZlci51bm9ic2VydmUodC5lbCksdC4kcGFyZW50JiZ0LiRlbC5wYXJlbnROb2RlJiZ0aGlzLl9yZW1vdmVMaXN0ZW5lclRhcmdldCh0LiRlbC5wYXJlbnROb2RlKSx0aGlzLl9yZW1vdmVMaXN0ZW5lclRhcmdldCh3aW5kb3cpKX19LHtrZXk6XCJzZXRNb2RlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztBfHx0IT09ay5vYnNlcnZlcnx8KHQ9ay5ldmVudCksdGhpcy5tb2RlPXQsdD09PWsuZXZlbnQ/KHRoaXMuX29ic2VydmVyJiYodGhpcy5MaXN0ZW5lclF1ZXVlLmZvckVhY2goZnVuY3Rpb24odCl7ZS5fb2JzZXJ2ZXIudW5vYnNlcnZlKHQuZWwpfSksdGhpcy5fb2JzZXJ2ZXI9bnVsbCksdGhpcy5UYXJnZXRRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UuX2luaXRMaXN0ZW4odC5lbCwhMCl9KSk6KHRoaXMuVGFyZ2V0UXVldWUuZm9yRWFjaChmdW5jdGlvbih0KXtlLl9pbml0TGlzdGVuKHQuZWwsITEpfSksdGhpcy5faW5pdEludGVyc2VjdGlvbk9ic2VydmVyKCkpfX0se2tleTpcIl9hZGRMaXN0ZW5lclRhcmdldFwiLHZhbHVlOmZ1bmN0aW9uKHQpe2lmKHQpe3ZhciBlPXUodGhpcy5UYXJnZXRRdWV1ZSxmdW5jdGlvbihlKXtyZXR1cm4gZS5lbD09PXR9KTtyZXR1cm4gZT9lLmNoaWxkcmVuQ291bnQrKzooZT17ZWw6dCxpZDorK3RoaXMuVGFyZ2V0SW5kZXgsY2hpbGRyZW5Db3VudDoxLGxpc3RlbmVkOiEwfSx0aGlzLm1vZGU9PT1rLmV2ZW50JiZ0aGlzLl9pbml0TGlzdGVuKGUuZWwsITApLHRoaXMuVGFyZ2V0UXVldWUucHVzaChlKSksdGhpcy5UYXJnZXRJbmRleH19fSx7a2V5OlwiX3JlbW92ZUxpc3RlbmVyVGFyZ2V0XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0aGlzLlRhcmdldFF1ZXVlLmZvckVhY2goZnVuY3Rpb24obixyKXtuLmVsPT09dCYmKC0tbi5jaGlsZHJlbkNvdW50fHwoZS5faW5pdExpc3RlbihuLmVsLCExKSxlLlRhcmdldFF1ZXVlLnNwbGljZShyLDEpLG49bnVsbCkpfSl9fSx7a2V5OlwiX2luaXRMaXN0ZW5cIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dGhpcy5vcHRpb25zLkxpc3RlbkV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHIpe3JldHVybiBTW2U/XCJvblwiOlwib2ZmXCJdKHQscixuLmxhenlMb2FkSGFuZGxlcil9KX19LHtrZXk6XCJfaW5pdEV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuRXZlbnQ9e2xpc3RlbmVyczp7bG9hZGluZzpbXSxsb2FkZWQ6W10sZXJyb3I6W119fSx0aGlzLiRvbj1mdW5jdGlvbihlLG4pe3QuRXZlbnQubGlzdGVuZXJzW2VdfHwodC5FdmVudC5saXN0ZW5lcnNbZV09W10pLHQuRXZlbnQubGlzdGVuZXJzW2VdLnB1c2gobil9LHRoaXMuJG9uY2U9ZnVuY3Rpb24oZSxuKXtmdW5jdGlvbiByKCl7aS4kb2ZmKGUsciksbi5hcHBseShpLGFyZ3VtZW50cyl9dmFyIGk9dDt0LiRvbihlLHIpfSx0aGlzLiRvZmY9ZnVuY3Rpb24oZSxuKXtpZighbil7aWYoIXQuRXZlbnQubGlzdGVuZXJzW2VdKXJldHVybjtyZXR1cm4gdm9pZCh0LkV2ZW50Lmxpc3RlbmVyc1tlXS5sZW5ndGg9MCl9byh0LkV2ZW50Lmxpc3RlbmVyc1tlXSxuKX0sdGhpcy4kZW1pdD1mdW5jdGlvbihlLG4scil7dC5FdmVudC5saXN0ZW5lcnNbZV0mJnQuRXZlbnQubGlzdGVuZXJzW2VdLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIHQobixyKX0pfX19LHtrZXk6XCJfbGF6eUxvYWRIYW5kbGVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9W107dGhpcy5MaXN0ZW5lclF1ZXVlLmZvckVhY2goZnVuY3Rpb24odCxuKXtpZighdC5zdGF0ZS5lcnJvciYmdC5zdGF0ZS5sb2FkZWQpcmV0dXJuIGUucHVzaCh0KTt0LmNoZWNrSW5WaWV3KCkmJnQubG9hZCgpfSksZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBvKHQuTGlzdGVuZXJRdWV1ZSxlKX0pfX0se2tleTpcIl9pbml0SW50ZXJzZWN0aW9uT2JzZXJ2ZXJcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXM7QSYmKHRoaXMuX29ic2VydmVyPW5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcih0aGlzLl9vYnNlcnZlckhhbmRsZXIuYmluZCh0aGlzKSx0aGlzLm9wdGlvbnMub2JzZXJ2ZXJPcHRpb25zKSx0aGlzLkxpc3RlbmVyUXVldWUubGVuZ3RoJiZ0aGlzLkxpc3RlbmVyUXVldWUuZm9yRWFjaChmdW5jdGlvbihlKXt0Ll9vYnNlcnZlci5vYnNlcnZlKGUuZWwpfSkpfX0se2tleTpcIl9vYnNlcnZlckhhbmRsZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuaXNJbnRlcnNlY3RpbmcmJm4uTGlzdGVuZXJRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2lmKGUuZWw9PT10LnRhcmdldCl7aWYoZS5zdGF0ZS5sb2FkZWQpcmV0dXJuIG4uX29ic2VydmVyLnVub2JzZXJ2ZShlLmVsKTtlLmxvYWQoKX19KX0pfX0se2tleTpcIl9lbFJlbmRlcmVyXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe2lmKHQuZWwpe3ZhciByPXQuZWwsaT10LmJpbmRUeXBlLG89dm9pZCAwO3N3aXRjaChlKXtjYXNlXCJsb2FkaW5nXCI6bz10LmxvYWRpbmc7YnJlYWs7Y2FzZVwiZXJyb3JcIjpvPXQuZXJyb3I7YnJlYWs7ZGVmYXVsdDpvPXQuc3JjfWlmKGk/ci5zdHlsZVtpXT0ndXJsKFwiJytvKydcIiknOnIuZ2V0QXR0cmlidXRlKFwic3JjXCIpIT09byYmci5zZXRBdHRyaWJ1dGUoXCJzcmNcIixvKSxyLnNldEF0dHJpYnV0ZShcImxhenlcIixlKSx0aGlzLiRlbWl0KGUsdCxuKSx0aGlzLm9wdGlvbnMuYWRhcHRlcltlXSYmdGhpcy5vcHRpb25zLmFkYXB0ZXJbZV0odCx0aGlzLm9wdGlvbnMpLHRoaXMub3B0aW9ucy5kaXNwYXRjaEV2ZW50KXt2YXIgYT1uZXcgeihlLHtkZXRhaWw6dH0pO3IuZGlzcGF0Y2hFdmVudChhKX19fX0se2tleTpcIl92YWx1ZUZvcm1hdHRlclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQsbj10aGlzLm9wdGlvbnMubG9hZGluZyxyPXRoaXMub3B0aW9ucy5lcnJvcjtyZXR1cm4gYyh0KSYmKHQuc3JjfHx0aGlzLm9wdGlvbnMuc2lsZW50fHxjb25zb2xlLmVycm9yKFwiVnVlIExhenlsb2FkIHdhcm5pbmc6IG1pc3Mgc3JjIHdpdGggXCIrdCksZT10LnNyYyxuPXQubG9hZGluZ3x8dGhpcy5vcHRpb25zLmxvYWRpbmcscj10LmVycm9yfHx0aGlzLm9wdGlvbnMuZXJyb3IpLHtzcmM6ZSxsb2FkaW5nOm4sZXJyb3I6cn19fV0pLGV9KCl9LEQ9ZnVuY3Rpb24odCl7cmV0dXJue3Byb3BzOnt0YWc6e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJkaXZcIn19LHJlbmRlcjpmdW5jdGlvbih0KXtyZXR1cm4hMT09PXRoaXMuc2hvdz90KHRoaXMudGFnKTp0KHRoaXMudGFnLG51bGwsdGhpcy4kc2xvdHMuZGVmYXVsdCl9LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57ZWw6bnVsbCxzdGF0ZTp7bG9hZGVkOiExfSxyZWN0Ont9LHNob3c6ITF9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dGhpcy5lbD10aGlzLiRlbCx0LmFkZExhenlCb3godGhpcyksdC5sYXp5TG9hZEhhbmRsZXIoKX0sYmVmb3JlRGVzdHJveTpmdW5jdGlvbigpe3QucmVtb3ZlQ29tcG9uZW50KHRoaXMpfSxtZXRob2RzOntnZXRSZWN0OmZ1bmN0aW9uKCl7dGhpcy5yZWN0PXRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpfSxjaGVja0luVmlldzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFJlY3QoKSxFJiZ0aGlzLnJlY3QudG9wPHdpbmRvdy5pbm5lckhlaWdodCp0Lm9wdGlvbnMucHJlTG9hZCYmdGhpcy5yZWN0LmJvdHRvbT4wJiZ0aGlzLnJlY3QubGVmdDx3aW5kb3cuaW5uZXJXaWR0aCp0Lm9wdGlvbnMucHJlTG9hZCYmdGhpcy5yZWN0LnJpZ2h0PjB9LGxvYWQ6ZnVuY3Rpb24oKXt0aGlzLnNob3c9ITAsdGhpcy5zdGF0ZS5sb2FkZWQ9ITAsdGhpcy4kZW1pdChcInNob3dcIix0aGlzKX19fX0sVj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7dmFyIG49ZS5sYXp5O2IodGhpcyx0KSx0aGlzLmxhenk9bixuLmxhenlDb250YWluZXJNYW5hbmdlcj10aGlzLHRoaXMuX3F1ZXVlPVtdfXJldHVybiB5KHQsW3trZXk6XCJiaW5kXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBOKHtlbDp0LGJpbmRpbmc6ZSx2bm9kZTpuLGxhenk6dGhpcy5sYXp5fSk7dGhpcy5fcXVldWUucHVzaChyKX19LHtrZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7dmFyIHI9dSh0aGlzLl9xdWV1ZSxmdW5jdGlvbihlKXtyZXR1cm4gZS5lbD09PXR9KTtyJiZyLnVwZGF0ZSh7ZWw6dCxiaW5kaW5nOmUsdm5vZGU6bn0pfX0se2tleTpcInVuYmluZFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj11KHRoaXMuX3F1ZXVlLGZ1bmN0aW9uKGUpe3JldHVybiBlLmVsPT09dH0pO3ImJihyLmNsZWFyKCksbyh0aGlzLl9xdWV1ZSxyKSl9fV0pLHR9KCksTT17c2VsZWN0b3I6XCJpbWdcIn0sTj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7dmFyIG49ZS5lbCxyPWUuYmluZGluZyxpPWUudm5vZGUsbz1lLmxhenk7Yih0aGlzLHQpLHRoaXMuZWw9bnVsbCx0aGlzLnZub2RlPWksdGhpcy5iaW5kaW5nPXIsdGhpcy5vcHRpb25zPXt9LHRoaXMubGF6eT1vLHRoaXMuX3F1ZXVlPVtdLHRoaXMudXBkYXRlKHtlbDpuLGJpbmRpbmc6cn0pfXJldHVybiB5KHQsW3trZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dC5lbCxyPXQuYmluZGluZzt0aGlzLmVsPW4sdGhpcy5vcHRpb25zPV8oe30sTSxyLnZhbHVlKSx0aGlzLmdldEltZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UubGF6eS5hZGQodCxfKHt9LGUuYmluZGluZyx7dmFsdWU6e3NyYzpcImRhdGFzZXRcImluIHQ/dC5kYXRhc2V0LnNyYzp0LmdldEF0dHJpYnV0ZShcImRhdGEtc3JjXCIpLGVycm9yOlwiZGF0YXNldFwiaW4gdD90LmRhdGFzZXQuZXJyb3I6dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVycm9yXCIpLGxvYWRpbmc6XCJkYXRhc2V0XCJpbiB0P3QuZGF0YXNldC5sb2FkaW5nOnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1sb2FkaW5nXCIpfX0pLGUudm5vZGUpfSl9fSx7a2V5OlwiZ2V0SW1nc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGYodGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5zZWxlY3RvcikpfX0se2tleTpcImNsZWFyXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuZ2V0SW1ncygpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQubGF6eS5yZW1vdmUoZSl9KSx0aGlzLnZub2RlPW51bGwsdGhpcy5iaW5kaW5nPW51bGwsdGhpcy5sYXp5PW51bGx9fV0pLHR9KCksUD1mdW5jdGlvbih0KXtyZXR1cm57cHJvcHM6e3NyYzpbU3RyaW5nLE9iamVjdF0sdGFnOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiaW1nXCJ9fSxyZW5kZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQodGhpcy50YWcse2F0dHJzOntzcmM6dGhpcy5yZW5kZXJTcmN9fSx0aGlzLiRzbG90cy5kZWZhdWx0KX0sZGF0YTpmdW5jdGlvbigpe3JldHVybntlbDpudWxsLG9wdGlvbnM6e3NyYzpcIlwiLGVycm9yOlwiXCIsbG9hZGluZzpcIlwiLGF0dGVtcHQ6dC5vcHRpb25zLmF0dGVtcHR9LHN0YXRlOntsb2FkZWQ6ITEsZXJyb3I6ITEsYXR0ZW1wdDowfSxyZWN0Ont9LHJlbmRlclNyYzpcIlwifX0sd2F0Y2g6e3NyYzpmdW5jdGlvbigpe3RoaXMuaW5pdCgpLHQuYWRkTGF6eUJveCh0aGlzKSx0LmxhenlMb2FkSGFuZGxlcigpfX0sY3JlYXRlZDpmdW5jdGlvbigpe3RoaXMuaW5pdCgpLHRoaXMucmVuZGVyU3JjPXRoaXMub3B0aW9ucy5sb2FkaW5nfSxtb3VudGVkOmZ1bmN0aW9uKCl7dGhpcy5lbD10aGlzLiRlbCx0LmFkZExhenlCb3godGhpcyksdC5sYXp5TG9hZEhhbmRsZXIoKX0sYmVmb3JlRGVzdHJveTpmdW5jdGlvbigpe3QucmVtb3ZlQ29tcG9uZW50KHRoaXMpfSxtZXRob2RzOntpbml0OmZ1bmN0aW9uKCl7dmFyIGU9dC5fdmFsdWVGb3JtYXR0ZXIodGhpcy5zcmMpLG49ZS5zcmMscj1lLmxvYWRpbmcsaT1lLmVycm9yO3RoaXMuc3RhdGUubG9hZGVkPSExLHRoaXMub3B0aW9ucy5zcmM9bix0aGlzLm9wdGlvbnMuZXJyb3I9aSx0aGlzLm9wdGlvbnMubG9hZGluZz1yLHRoaXMucmVuZGVyU3JjPXRoaXMub3B0aW9ucy5sb2FkaW5nfSxnZXRSZWN0OmZ1bmN0aW9uKCl7dGhpcy5yZWN0PXRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpfSxjaGVja0luVmlldzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFJlY3QoKSxFJiZ0aGlzLnJlY3QudG9wPHdpbmRvdy5pbm5lckhlaWdodCp0Lm9wdGlvbnMucHJlTG9hZCYmdGhpcy5yZWN0LmJvdHRvbT4wJiZ0aGlzLnJlY3QubGVmdDx3aW5kb3cuaW5uZXJXaWR0aCp0Lm9wdGlvbnMucHJlTG9hZCYmdGhpcy5yZWN0LnJpZ2h0PjB9LGxvYWQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLG49YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnY7aWYodGhpcy5zdGF0ZS5hdHRlbXB0PnRoaXMub3B0aW9ucy5hdHRlbXB0LTEmJnRoaXMuc3RhdGUuZXJyb3IpcmV0dXJuIHQub3B0aW9ucy5zaWxlbnR8fGNvbnNvbGUubG9nKFwiVnVlTGF6eWxvYWQgbG9nOiBcIit0aGlzLm9wdGlvbnMuc3JjK1wiIHRyaWVkIHRvbyBtb3JlIHRoYW4gXCIrdGhpcy5vcHRpb25zLmF0dGVtcHQrXCIgdGltZXNcIiksdm9pZCBuKCk7dmFyIHI9dGhpcy5vcHRpb25zLnNyYztJKHtzcmM6cn0sZnVuY3Rpb24odCl7dmFyIG49dC5zcmM7ZS5yZW5kZXJTcmM9bixlLnN0YXRlLmxvYWRlZD0hMH0sZnVuY3Rpb24odCl7ZS5zdGF0ZS5hdHRlbXB0KyssZS5yZW5kZXJTcmM9ZS5vcHRpb25zLmVycm9yLGUuc3RhdGUuZXJyb3I9ITB9KX19fX07cmV0dXJue2luc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LG49Qih0KSxyPW5ldyBuKGUpLGk9bmV3IFYoe2xhenk6cn0pLG89XCIyXCI9PT10LnZlcnNpb24uc3BsaXQoXCIuXCIpWzBdO3QucHJvdG90eXBlLiRMYXp5bG9hZD1yLGUubGF6eUNvbXBvbmVudCYmdC5jb21wb25lbnQoXCJsYXp5LWNvbXBvbmVudFwiLEQocikpLGUubGF6eUltYWdlJiZ0LmNvbXBvbmVudChcImxhenktaW1hZ2VcIixQKHIpKSxvPyh0LmRpcmVjdGl2ZShcImxhenlcIix7YmluZDpyLmFkZC5iaW5kKHIpLHVwZGF0ZTpyLnVwZGF0ZS5iaW5kKHIpLGNvbXBvbmVudFVwZGF0ZWQ6ci5sYXp5TG9hZEhhbmRsZXIuYmluZChyKSx1bmJpbmQ6ci5yZW1vdmUuYmluZChyKX0pLHQuZGlyZWN0aXZlKFwibGF6eS1jb250YWluZXJcIix7YmluZDppLmJpbmQuYmluZChpKSx1cGRhdGU6aS51cGRhdGUuYmluZChpKSx1bmJpbmQ6aS51bmJpbmQuYmluZChpKX0pKToodC5kaXJlY3RpdmUoXCJsYXp5XCIse2JpbmQ6ci5sYXp5TG9hZEhhbmRsZXIuYmluZChyKSx1cGRhdGU6ZnVuY3Rpb24odCxlKXtfKHRoaXMudm0uJHJlZnMsdGhpcy52bS4kZWxzKSxyLmFkZCh0aGlzLmVsLHttb2RpZmllcnM6dGhpcy5tb2RpZmllcnN8fHt9LGFyZzp0aGlzLmFyZyx2YWx1ZTp0LG9sZFZhbHVlOmV9LHtjb250ZXh0OnRoaXMudm19KX0sdW5iaW5kOmZ1bmN0aW9uKCl7ci5yZW1vdmUodGhpcy5lbCl9fSksdC5kaXJlY3RpdmUoXCJsYXp5LWNvbnRhaW5lclwiLHt1cGRhdGU6ZnVuY3Rpb24odCxlKXtpLnVwZGF0ZSh0aGlzLmVsLHttb2RpZmllcnM6dGhpcy5tb2RpZmllcnN8fHt9LGFyZzp0aGlzLmFyZyx2YWx1ZTp0LG9sZFZhbHVlOmV9LHtjb250ZXh0OnRoaXMudm19KX0sdW5iaW5kOmZ1bmN0aW9uKCl7aS51bmJpbmQodGhpcy5lbCl9fSkpfX19KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){eval('(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(0));\n\telse {}\n})(typeof self !== \'undefined\' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_vue__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== \'undefined\' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, \'__esModule\', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === \'object\' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, \'default\', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != \'string\') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, \'a\', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "/dist/";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = "./src/index.ts");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ "./src/components/VAlert/VAlert.ts":\n/*!*****************************************!*\\\n  !*** ./src/components/VAlert/VAlert.ts ***!\n  \\*****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_alerts_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_alerts.styl */ "./src/stylus/components/_alerts.styl");\n/* harmony import */ var _stylus_components_alerts_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_alerts_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\n/* harmony import */ var _mixins_transitionable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/transitionable */ "./src/mixins/transitionable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n// Styles\n\n// Components\n\n// Mixins\n\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_5__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_transitionable__WEBPACK_IMPORTED_MODULE_4__["default"]).extend({\n    name: \'v-alert\',\n    props: {\n        dismissible: Boolean,\n        icon: String,\n        outline: Boolean,\n        type: {\n            type: String,\n            validator: function validator(val) {\n                return [\'info\', \'error\', \'success\', \'warning\'].includes(val);\n            }\n        }\n    },\n    computed: {\n        computedColor: function computedColor() {\n            return this.type && !this.color ? this.type : this.color || \'error\';\n        },\n        computedIcon: function computedIcon() {\n            if (this.icon || !this.type) return this.icon;\n            switch (this.type) {\n                case \'info\':\n                    return \'$vuetify.icons.info\';\n                case \'error\':\n                    return \'$vuetify.icons.error\';\n                case \'success\':\n                    return \'$vuetify.icons.success\';\n                case \'warning\':\n                    return \'$vuetify.icons.warning\';\n            }\n        }\n    },\n    methods: {\n        genIcon: function genIcon() {\n            if (!this.computedIcon) return null;\n            return this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], {\n                \'class\': \'v-alert__icon\'\n            }, this.computedIcon);\n        },\n        genDismissible: function genDismissible() {\n            var _this = this;\n            if (!this.dismissible) return null;\n            return this.$createElement(\'a\', {\n                \'class\': \'v-alert__dismissible\',\n                on: { click: function click() {\n                        _this.isActive = false;\n                    } }\n            }, [this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], {\n                props: {\n                    right: true\n                }\n            }, \'$vuetify.icons.cancel\')]);\n        }\n    },\n    render: function render(h) {\n        var children = [this.genIcon(), h(\'div\', this.$slots.default), this.genDismissible()];\n        var setColor = this.outline ? this.setTextColor : this.setBackgroundColor;\n        var alert = h(\'div\', setColor(this.computedColor, {\n            staticClass: \'v-alert\',\n            \'class\': {\n                \'v-alert--outline\': this.outline\n            },\n            directives: [{\n                name: \'show\',\n                value: this.isActive\n            }],\n            on: this.$listeners\n        }), children);\n        if (!this.transition) return alert;\n        return h(\'transition\', {\n            props: {\n                name: this.transition,\n                origin: this.origin,\n                mode: this.mode\n            }\n        }, [alert]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VAlert/index.ts":\n/*!****************************************!*\\\n  !*** ./src/components/VAlert/index.ts ***!\n  \\****************************************/\n/*! exports provided: VAlert, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VAlert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VAlert */ "./src/components/VAlert/VAlert.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VAlert", function() { return _VAlert__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VAlert__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VApp/VApp.js":\n/*!*************************************!*\\\n  !*** ./src/components/VApp/VApp.js ***!\n  \\*************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_app_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_app.styl */ "./src/stylus/components/_app.styl");\n/* harmony import */ var _stylus_components_app_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_app_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_app_theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mixins/app-theme */ "./src/components/VApp/mixins/app-theme.js");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _directives_resize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../directives/resize */ "./src/directives/resize.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n// Component level mixins\n\n\n// Directives\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-app\',\n    directives: {\n        Resize: _directives_resize__WEBPACK_IMPORTED_MODULE_3__["default"]\n    },\n    mixins: [_mixins_app_theme__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        id: {\n            type: String,\n            default: \'app\'\n        },\n        dark: Boolean\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'application--is-rtl\': this.$vuetify.rtl }, this.themeClasses);\n        }\n    },\n    watch: {\n        dark: function dark() {\n            this.$vuetify.dark = this.dark;\n        }\n    },\n    mounted: function mounted() {\n        this.$vuetify.dark = this.dark;\n    },\n    render: function render(h) {\n        var data = {\n            staticClass: \'application\',\n            \'class\': this.classes,\n            attrs: { \'data-app\': true },\n            domProps: { id: this.id }\n        };\n        var wrapper = h(\'div\', { staticClass: \'application--wrap\' }, this.$slots.default);\n        return h(\'div\', data, [wrapper]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VApp/index.js":\n/*!**************************************!*\\\n  !*** ./src/components/VApp/index.js ***!\n  \\**************************************/\n/*! exports provided: VApp, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VApp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VApp */ "./src/components/VApp/VApp.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VApp", function() { return _VApp__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VApp__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VApp/mixins/app-theme.js":\n/*!*************************************************!*\\\n  !*** ./src/components/VApp/mixins/app-theme.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_theme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/theme */ "./src/util/theme.ts");\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    data: function data() {\n        return {\n            style: null\n        };\n    },\n    computed: {\n        parsedTheme: function parsedTheme() {\n            return _util_theme__WEBPACK_IMPORTED_MODULE_0__["parse"](this.$vuetify.theme);\n        },\n        /** @return string */\n        generatedStyles: function generatedStyles() {\n            var theme = this.parsedTheme;\n            var css;\n            if (this.$vuetify.options.themeCache != null) {\n                css = this.$vuetify.options.themeCache.get(theme);\n                if (css != null) return css;\n            }\n            css = _util_theme__WEBPACK_IMPORTED_MODULE_0__["genStyles"](theme, this.$vuetify.options.customProperties);\n            if (this.$vuetify.options.minifyTheme != null) {\n                css = this.$vuetify.options.minifyTheme(css);\n            }\n            if (this.$vuetify.options.themeCache != null) {\n                this.$vuetify.options.themeCache.set(theme, css);\n            }\n            return css;\n        },\n        vueMeta: function vueMeta() {\n            if (this.$vuetify.theme === false) return {};\n            var options = {\n                cssText: this.generatedStyles,\n                id: \'vuetify-theme-stylesheet\',\n                type: \'text/css\'\n            };\n            if (this.$vuetify.options.cspNonce) {\n                options.nonce = this.$vuetify.options.cspNonce;\n            }\n            return {\n                style: [options]\n            };\n        }\n    },\n    // Regular vue-meta\n    metaInfo: function metaInfo() {\n        return this.vueMeta;\n    },\n    // Nuxt\n    head: function head() {\n        return this.vueMeta;\n    },\n    watch: {\n        generatedStyles: function generatedStyles() {\n            !this.meta && this.applyTheme();\n        }\n    },\n    created: function created() {\n        if (this.$vuetify.theme === false) return;\n        if (this.$meta) {\n            // Vue-meta\n            // Handled by metaInfo()/nuxt()\n        } else if (typeof document === \'undefined\' && this.$ssrContext) {\n            // SSR\n            var nonce = this.$vuetify.options.cspNonce ? " nonce=\\"" + this.$vuetify.options.cspNonce + "\\"" : \'\';\n            this.$ssrContext.head = this.$ssrContext.head || \'\';\n            this.$ssrContext.head += "<style type=\\"text/css\\" id=\\"vuetify-theme-stylesheet\\"" + nonce + ">" + this.generatedStyles + "</style>";\n        } else if (typeof document !== \'undefined\') {\n            // Client-side\n            this.genStyle();\n            this.applyTheme();\n        }\n    },\n    methods: {\n        applyTheme: function applyTheme() {\n            if (this.style) this.style.innerHTML = this.generatedStyles;\n        },\n        genStyle: function genStyle() {\n            var style = document.getElementById(\'vuetify-theme-stylesheet\');\n            if (!style) {\n                style = document.createElement(\'style\');\n                style.type = \'text/css\';\n                style.id = \'vuetify-theme-stylesheet\';\n                if (this.$vuetify.options.cspNonce) {\n                    style.setAttribute(\'nonce\', this.$vuetify.options.cspNonce);\n                }\n                document.head.appendChild(style);\n            }\n            this.style = style;\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VAutocomplete/VAutocomplete.js":\n/*!*******************************************************!*\\\n  !*** ./src/components/VAutocomplete/VAutocomplete.js ***!\n  \\*******************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_autocompletes_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_autocompletes.styl */ "./src/stylus/components/_autocompletes.styl");\n/* harmony import */ var _stylus_components_autocompletes_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_autocompletes_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VSelect/VSelect */ "./src/components/VSelect/VSelect.js");\n/* harmony import */ var _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VTextField/VTextField */ "./src/components/VTextField/VTextField.js");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Extensions\n\n\n// Utils\n\nvar defaultMenuProps = __assign({}, _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["defaultMenuProps"], { offsetY: true, offsetOverflow: true, transition: false });\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-autocomplete\',\n    extends: _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"],\n    props: {\n        allowOverflow: {\n            type: Boolean,\n            default: true\n        },\n        browserAutocomplete: {\n            type: String,\n            default: \'off\'\n        },\n        filter: {\n            type: Function,\n            default: function _default(item, queryText, itemText) {\n                var hasValue = function hasValue(val) {\n                    return val != null ? val : \'\';\n                };\n                var text = hasValue(itemText);\n                var query = hasValue(queryText);\n                return text.toString().toLowerCase().indexOf(query.toString().toLowerCase()) > -1;\n            }\n        },\n        hideNoData: Boolean,\n        noFilter: Boolean,\n        searchInput: {\n            default: undefined\n        },\n        menuProps: {\n            type: _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].props.menuProps.type,\n            default: function _default() {\n                return defaultMenuProps;\n            }\n        }\n    },\n    data: function data(vm) {\n        return {\n            attrsInput: null,\n            lazySearch: vm.searchInput\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return Object.assign({}, _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].computed.classes.call(this), {\n                \'v-autocomplete\': true,\n                \'v-autocomplete--is-selecting-index\': this.selectedIndex > -1\n            });\n        },\n        computedItems: function computedItems() {\n            return this.filteredItems;\n        },\n        displayedItemsCount: function displayedItemsCount() {\n            return this.hideSelected ? this.filteredItems.length - this.selectedItems.length : this.filteredItems.length;\n        },\n        /**\n         * The range of the current input text\n         *\n         * @return {Number}\n         */\n        currentRange: function currentRange() {\n            if (this.selectedItem == null) return 0;\n            return this.getText(this.selectedItem).toString().length;\n        },\n        filteredItems: function filteredItems() {\n            var _this = this;\n            if (!this.isSearching || this.noFilter) return this.allItems;\n            return this.allItems.filter(function (i) {\n                return _this.filter(i, _this.internalSearch, _this.getText(i));\n            });\n        },\n        internalSearch: {\n            get: function get() {\n                return this.lazySearch;\n            },\n            set: function set(val) {\n                this.lazySearch = val;\n                this.$emit(\'update:searchInput\', val);\n            }\n        },\n        isAnyValueAllowed: function isAnyValueAllowed() {\n            return false;\n        },\n        isDirty: function isDirty() {\n            return this.searchIsDirty || this.selectedItems.length > 0;\n        },\n        isSearching: function isSearching() {\n            if (this.multiple) return this.searchIsDirty;\n            return this.searchIsDirty && this.internalSearch !== this.getText(this.selectedItem);\n        },\n        menuCanShow: function menuCanShow() {\n            if (!this.isFocused) return false;\n            return this.displayedItemsCount > 0 || !this.hideNoData;\n        },\n        $_menuProps: function $_menuProps() {\n            var props = _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].computed.$_menuProps.call(this);\n            props.contentClass = ("v-autocomplete__content " + (props.contentClass || \'\')).trim();\n            return __assign({}, defaultMenuProps, props);\n        },\n        searchIsDirty: function searchIsDirty() {\n            return this.internalSearch != null && this.internalSearch !== \'\';\n        },\n        selectedItem: function selectedItem() {\n            var _this = this;\n            if (this.multiple) return null;\n            return this.selectedItems.find(function (i) {\n                return _this.valueComparator(_this.getValue(i), _this.getValue(_this.internalValue));\n            });\n        },\n        listData: function listData() {\n            var data = _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].computed.listData.call(this);\n            Object.assign(data.props, {\n                items: this.virtualizedItems,\n                noFilter: this.noFilter || !this.isSearching || !this.filteredItems.length,\n                searchInput: this.internalSearch\n            });\n            return data;\n        }\n    },\n    watch: {\n        filteredItems: function filteredItems(val) {\n            this.onFilteredItemsChanged(val);\n        },\n        internalValue: function internalValue() {\n            this.setSearch();\n        },\n        isFocused: function isFocused(val) {\n            if (val) {\n                this.$refs.input && this.$refs.input.select();\n            } else {\n                this.updateSelf();\n            }\n        },\n        isMenuActive: function isMenuActive(val) {\n            if (val || !this.hasSlot) return;\n            this.lazySearch = null;\n        },\n        items: function items(val, oldVal) {\n            // If we are focused, the menu\n            // is not active, hide no data is enabled,\n            // and items change\n            // User is probably async loading\n            // items, try to activate the menu\n            if (!(oldVal && oldVal.length) && this.hideNoData && this.isFocused && !this.isMenuActive && val.length) this.activateMenu();\n        },\n        searchInput: function searchInput(val) {\n            this.lazySearch = val;\n        },\n        internalSearch: function internalSearch(val) {\n            this.onInternalSearchChanged(val);\n        }\n    },\n    created: function created() {\n        this.setSearch();\n    },\n    methods: {\n        onFilteredItemsChanged: function onFilteredItemsChanged(val) {\n            var _this = this;\n            this.setMenuIndex(-1);\n            this.$nextTick(function () {\n                _this.setMenuIndex(val.length === 1 ? 0 : -1);\n            });\n        },\n        onInternalSearchChanged: function onInternalSearchChanged(val) {\n            this.updateMenuDimensions();\n        },\n        updateMenuDimensions: function updateMenuDimensions() {\n            if (this.isMenuActive && this.$refs.menu) {\n                this.$refs.menu.updateDimensions();\n            }\n        },\n        changeSelectedIndex: function changeSelectedIndex(keyCode) {\n            // Do not allow changing of selectedIndex\n            // when search is dirty\n            if (this.searchIsDirty) return;\n            if (![_util_helpers__WEBPACK_IMPORTED_MODULE_3__["keyCodes"].backspace, _util_helpers__WEBPACK_IMPORTED_MODULE_3__["keyCodes"].left, _util_helpers__WEBPACK_IMPORTED_MODULE_3__["keyCodes"].right, _util_helpers__WEBPACK_IMPORTED_MODULE_3__["keyCodes"].delete].includes(keyCode)) return;\n            var indexes = this.selectedItems.length - 1;\n            if (keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_3__["keyCodes"].left) {\n                this.selectedIndex = this.selectedIndex === -1 ? indexes : this.selectedIndex - 1;\n            } else if (keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_3__["keyCodes"].right) {\n                this.selectedIndex = this.selectedIndex >= indexes ? -1 : this.selectedIndex + 1;\n            } else if (this.selectedIndex === -1) {\n                this.selectedIndex = indexes;\n                return;\n            }\n            var currentItem = this.selectedItems[this.selectedIndex];\n            if ([_util_helpers__WEBPACK_IMPORTED_MODULE_3__["keyCodes"].backspace, _util_helpers__WEBPACK_IMPORTED_MODULE_3__["keyCodes"].delete].includes(keyCode) && !this.getDisabled(currentItem)) {\n                var newIndex = this.selectedIndex === indexes ? this.selectedIndex - 1 : this.selectedItems[this.selectedIndex + 1] ? this.selectedIndex : -1;\n                if (newIndex === -1) {\n                    this.setValue(this.multiple ? [] : undefined);\n                } else {\n                    this.selectItem(currentItem);\n                }\n                this.selectedIndex = newIndex;\n            }\n        },\n        clearableCallback: function clearableCallback() {\n            this.internalSearch = undefined;\n            _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.clearableCallback.call(this);\n        },\n        genInput: function genInput() {\n            var input = _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_2__["default"].methods.genInput.call(this);\n            input.data.attrs.role = \'combobox\';\n            input.data.domProps.value = this.internalSearch;\n            return input;\n        },\n        genSelections: function genSelections() {\n            return this.hasSlot || this.multiple ? _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.genSelections.call(this) : [];\n        },\n        onClick: function onClick() {\n            if (this.isDisabled) return;\n            this.selectedIndex > -1 ? this.selectedIndex = -1 : this.onFocus();\n            this.activateMenu();\n        },\n        onEnterDown: function onEnterDown() {\n            // Avoid invoking this method\n            // will cause updateSelf to\n            // be called emptying search\n        },\n        onInput: function onInput(e) {\n            if (this.selectedIndex > -1) return;\n            // If typing and menu is not currently active\n            if (e.target.value) {\n                this.activateMenu();\n                if (!this.isAnyValueAllowed) this.setMenuIndex(0);\n            }\n            this.mask && this.resetSelections(e.target);\n            this.internalSearch = e.target.value;\n            this.badInput = e.target.validity && e.target.validity.badInput;\n        },\n        onKeyDown: function onKeyDown(e) {\n            var keyCode = e.keyCode;\n            _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.onKeyDown.call(this, e);\n            // The ordering is important here\n            // allows new value to be updated\n            // and then moves the index to the\n            // proper location\n            this.changeSelectedIndex(keyCode);\n        },\n        onTabDown: function onTabDown(e) {\n            _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.onTabDown.call(this, e);\n            this.updateSelf();\n        },\n        setSelectedItems: function setSelectedItems() {\n            _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.setSelectedItems.call(this);\n            // #4273 Don\'t replace if searching\n            // #4403 Don\'t replace if focused\n            if (!this.isFocused) this.setSearch();\n        },\n        setSearch: function setSearch() {\n            var _this = this;\n            // Wait for nextTick so selectedItem\n            // has had time to update\n            this.$nextTick(function () {\n                _this.internalSearch = !_this.selectedItems.length || _this.multiple || _this.hasSlot ? null : _this.getText(_this.selectedItem);\n            });\n        },\n        updateSelf: function updateSelf() {\n            this.updateAutocomplete();\n        },\n        updateAutocomplete: function updateAutocomplete() {\n            if (!this.searchIsDirty && !this.internalValue) return;\n            if (!this.valueComparator(this.internalSearch, this.getValue(this.internalValue))) {\n                this.setSearch();\n            }\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VAutocomplete/index.js":\n/*!***********************************************!*\\\n  !*** ./src/components/VAutocomplete/index.js ***!\n  \\***********************************************/\n/*! exports provided: VAutocomplete, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VAutocomplete__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VAutocomplete */ "./src/components/VAutocomplete/VAutocomplete.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VAutocomplete", function() { return _VAutocomplete__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VAutocomplete__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VAvatar/VAvatar.ts":\n/*!*******************************************!*\\\n  !*** ./src/components/VAvatar/VAvatar.ts ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_avatars_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_avatars.styl */ "./src/stylus/components/_avatars.styl");\n/* harmony import */ var _stylus_components_avatars_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_avatars_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n// Mixins\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_3__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"]).extend({\n    name: \'v-avatar\',\n    functional: true,\n    props: {\n        // TODO: inherit these\n        color: String,\n        size: {\n            type: [Number, String],\n            default: 48\n        },\n        tile: Boolean\n    },\n    render: function render(h, _a) {\n        var data = _a.data,\n            props = _a.props,\n            children = _a.children;\n        data.staticClass = ("v-avatar " + (data.staticClass || \'\')).trim();\n        if (props.tile) data.staticClass += \' v-avatar--tile\';\n        var size = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_2__["convertToUnit"])(props.size);\n        data.style = __assign({ height: size, width: size }, data.style);\n        return h(\'div\', _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"].options.methods.setBackgroundColor(props.color, data), children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VAvatar/index.ts":\n/*!*****************************************!*\\\n  !*** ./src/components/VAvatar/index.ts ***!\n  \\*****************************************/\n/*! exports provided: VAvatar, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VAvatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VAvatar */ "./src/components/VAvatar/VAvatar.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VAvatar", function() { return _VAvatar__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VAvatar__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VBadge/VBadge.ts":\n/*!*****************************************!*\\\n  !*** ./src/components/VBadge/VBadge.ts ***!\n  \\*****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_badges_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_badges.styl */ "./src/stylus/components/_badges.styl");\n/* harmony import */ var _stylus_components_badges_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_badges_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\n/* harmony import */ var _mixins_positionable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/positionable */ "./src/mixins/positionable.ts");\n/* harmony import */ var _mixins_transitionable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/transitionable */ "./src/mixins/transitionable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n// Styles\n\n// Mixins\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_5__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_2__["default"], Object(_mixins_positionable__WEBPACK_IMPORTED_MODULE_3__["factory"])([\'left\', \'bottom\']), _mixins_transitionable__WEBPACK_IMPORTED_MODULE_4__["default"]\n/* @vue/component */\n).extend({\n    name: \'v-badge\',\n    props: {\n        color: {\n            type: String,\n            default: \'primary\'\n        },\n        overlap: Boolean,\n        transition: {\n            type: String,\n            default: \'fab-transition\'\n        },\n        value: {\n            default: true\n        }\n    },\n    computed: {\n        classes: function classes() {\n            return {\n                \'v-badge--bottom\': this.bottom,\n                \'v-badge--left\': this.left,\n                \'v-badge--overlap\': this.overlap\n            };\n        }\n    },\n    render: function render(h) {\n        var badge = this.$slots.badge ? [h(\'span\', this.setBackgroundColor(this.color, {\n            staticClass: \'v-badge__badge\',\n            attrs: this.$attrs,\n            directives: [{\n                name: \'show\',\n                value: this.isActive\n            }]\n        }), this.$slots.badge)] : null;\n        return h(\'span\', {\n            staticClass: \'v-badge\',\n            \'class\': this.classes\n        }, [this.$slots.default, h(\'transition\', {\n            props: {\n                name: this.transition,\n                origin: this.origin,\n                mode: this.mode\n            }\n        }, badge)]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VBadge/index.ts":\n/*!****************************************!*\\\n  !*** ./src/components/VBadge/index.ts ***!\n  \\****************************************/\n/*! exports provided: VBadge, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VBadge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VBadge */ "./src/components/VBadge/VBadge.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBadge", function() { return _VBadge__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VBadge__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VBottomNav/VBottomNav.ts":\n/*!*************************************************!*\\\n  !*** ./src/components/VBottomNav/VBottomNav.ts ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_bottom_navs_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_bottom-navs.styl */ "./src/stylus/components/_bottom-navs.styl");\n/* harmony import */ var _stylus_components_bottom_navs_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_bottom_navs_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/applicationable */ "./src/mixins/applicationable.ts");\n/* harmony import */ var _mixins_button_group__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/button-group */ "./src/mixins/button-group.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n// Styles\n\n// Mixins\n\n\n\n// Util\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_4__["default"])(Object(_mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__["default"])(\'bottom\', [\'height\', \'value\']), _mixins_colorable__WEBPACK_IMPORTED_MODULE_3__["default"]\n/* @vue/component */\n).extend({\n    name: \'v-bottom-nav\',\n    props: {\n        active: [Number, String],\n        mandatory: Boolean,\n        height: {\n            default: 56,\n            type: [Number, String],\n            validator: function validator(v) {\n                return !isNaN(parseInt(v));\n            }\n        },\n        shift: Boolean,\n        value: null\n    },\n    computed: {\n        classes: function classes() {\n            return {\n                \'v-bottom-nav--absolute\': this.absolute,\n                \'v-bottom-nav--fixed\': !this.absolute && (this.app || this.fixed),\n                \'v-bottom-nav--shift\': this.shift,\n                \'v-bottom-nav--active\': this.value\n            };\n        },\n        computedHeight: function computedHeight() {\n            return parseInt(this.height);\n        }\n    },\n    methods: {\n        updateApplication: function updateApplication() {\n            return !this.value ? 0 : this.computedHeight;\n        },\n        updateValue: function updateValue(val) {\n            this.$emit(\'update:active\', val);\n        }\n    },\n    render: function render(h) {\n        return h(_mixins_button_group__WEBPACK_IMPORTED_MODULE_2__["default"], this.setBackgroundColor(this.color, {\n            staticClass: \'v-bottom-nav\',\n            class: this.classes,\n            style: {\n                height: parseInt(this.computedHeight) + "px"\n            },\n            props: {\n                mandatory: Boolean(this.mandatory || this.active !== undefined),\n                value: this.active\n            },\n            on: { change: this.updateValue }\n        }), this.$slots.default);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VBottomNav/index.ts":\n/*!********************************************!*\\\n  !*** ./src/components/VBottomNav/index.ts ***!\n  \\********************************************/\n/*! exports provided: VBottomNav, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VBottomNav__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VBottomNav */ "./src/components/VBottomNav/VBottomNav.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBottomNav", function() { return _VBottomNav__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VBottomNav__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VBottomSheet/VBottomSheet.js":\n/*!*****************************************************!*\\\n  !*** ./src/components/VBottomSheet/VBottomSheet.js ***!\n  \\*****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_bottom_sheets_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_bottom-sheets.styl */ "./src/stylus/components/_bottom-sheets.styl");\n/* harmony import */ var _stylus_components_bottom_sheets_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_bottom_sheets_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VDialog_VDialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VDialog/VDialog */ "./src/components/VDialog/VDialog.js");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-bottom-sheet\',\n    props: {\n        disabled: Boolean,\n        fullWidth: Boolean,\n        hideOverlay: Boolean,\n        inset: Boolean,\n        lazy: Boolean,\n        maxWidth: {\n            type: [String, Number],\n            default: \'auto\'\n        },\n        persistent: Boolean,\n        value: null\n    },\n    render: function render(h) {\n        var activator = h(\'template\', {\n            slot: \'activator\'\n        }, this.$slots.activator);\n        var contentClass = [\'v-bottom-sheet\', this.inset ? \'v-bottom-sheet--inset\' : \'\'].join(\' \');\n        return h(_VDialog_VDialog__WEBPACK_IMPORTED_MODULE_1__["default"], {\n            attrs: __assign({}, this.$props),\n            on: __assign({}, this.$listeners),\n            props: {\n                contentClass: contentClass,\n                noClickAnimation: true,\n                transition: \'bottom-sheet-transition\',\n                value: this.value\n            }\n        }, [activator, this.$slots.default]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VBottomSheet/index.js":\n/*!**********************************************!*\\\n  !*** ./src/components/VBottomSheet/index.js ***!\n  \\**********************************************/\n/*! exports provided: VBottomSheet, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VBottomSheet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VBottomSheet */ "./src/components/VBottomSheet/VBottomSheet.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBottomSheet", function() { return _VBottomSheet__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VBottomSheet__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VBreadcrumbs/VBreadcrumbs.ts":\n/*!*****************************************************!*\\\n  !*** ./src/components/VBreadcrumbs/VBreadcrumbs.ts ***!\n  \\*****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_breadcrumbs_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_breadcrumbs.styl */ "./src/stylus/components/_breadcrumbs.styl");\n/* harmony import */ var _stylus_components_breadcrumbs_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_breadcrumbs_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! . */ "./src/components/VBreadcrumbs/index.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Components\n\n// Mixins\n\n// Utils\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_4__["default"])(_mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]\n/* @vue/component */\n).extend({\n    name: \'v-breadcrumbs\',\n    props: {\n        divider: {\n            type: String,\n            default: \'/\'\n        },\n        items: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        },\n        large: Boolean,\n        justifyCenter: Boolean,\n        justifyEnd: Boolean\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-breadcrumbs--large\': this.large, \'justify-center\': this.justifyCenter, \'justify-end\': this.justifyEnd }, this.themeClasses);\n        }\n    },\n    mounted: function mounted() {\n        if (this.justifyCenter) Object(_util_console__WEBPACK_IMPORTED_MODULE_3__["deprecate"])(\'justify-center\', \'class="justify-center"\', this);\n        if (this.justifyEnd) Object(_util_console__WEBPACK_IMPORTED_MODULE_3__["deprecate"])(\'justify-end\', \'class="justify-end"\', this);\n        if (this.$slots.default) Object(_util_console__WEBPACK_IMPORTED_MODULE_3__["deprecate"])(\'default slot\', \':items and scoped slot "item"\', this);\n    },\n    methods: {\n        /* @deprecated */\n        genChildren /* istanbul ignore next */: function genChildren() {\n            if (!this.$slots.default) return undefined;\n            var children = [];\n            var createDividers = false;\n            for (var i = 0; i < this.$slots.default.length; i++) {\n                var elm = this.$slots.default[i];\n                if (!elm.componentOptions || elm.componentOptions.Ctor.options.name !== \'v-breadcrumbs-item\') {\n                    children.push(elm);\n                } else {\n                    if (createDividers) {\n                        children.push(this.genDivider());\n                    }\n                    children.push(elm);\n                    createDividers = true;\n                }\n            }\n            return children;\n        },\n        genDivider: function genDivider() {\n            return this.$createElement(___WEBPACK_IMPORTED_MODULE_1__["VBreadcrumbsDivider"], this.$slots.divider ? this.$slots.divider : this.divider);\n        },\n        genItems: function genItems() {\n            var items = [];\n            var hasSlot = !!this.$scopedSlots.item;\n            for (var i = 0; i < this.items.length; i++) {\n                var item = this.items[i];\n                if (hasSlot) items.push(this.$scopedSlots.item({ item: item }));else items.push(this.$createElement(___WEBPACK_IMPORTED_MODULE_1__["VBreadcrumbsItem"], { key: item.text, props: item }, [item.text]));\n                if (i < this.items.length - 1) items.push(this.genDivider());\n            }\n            return items;\n        }\n    },\n    render: function render(h) {\n        var children = this.$slots.default ? this.genChildren() : this.genItems();\n        return h(\'ul\', {\n            staticClass: \'v-breadcrumbs\',\n            \'class\': this.classes\n        }, children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VBreadcrumbs/VBreadcrumbsItem.ts":\n/*!*********************************************************!*\\\n  !*** ./src/components/VBreadcrumbs/VBreadcrumbsItem.ts ***!\n  \\*********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mixins_routable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/routable */ "./src/mixins/routable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_1__["default"])(_mixins_routable__WEBPACK_IMPORTED_MODULE_0__["default"]).extend({\n    name: \'v-breadcrumbs-item\',\n    props: {\n        // In a breadcrumb, the currently\n        // active item should be dimmed\n        activeClass: {\n            type: String,\n            default: \'v-breadcrumbs__item--disabled\'\n        }\n    },\n    computed: {\n        classes: function classes() {\n            var _a;\n            return _a = {\n                \'v-breadcrumbs__item\': true\n            }, _a[this.activeClass] = this.disabled, _a;\n        }\n    },\n    render: function render(h) {\n        var _a = this.generateRouteLink(this.classes),\n            tag = _a.tag,\n            data = _a.data;\n        return h(\'li\', [h(tag, data, this.$slots.default)]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VBreadcrumbs/index.ts":\n/*!**********************************************!*\\\n  !*** ./src/components/VBreadcrumbs/index.ts ***!\n  \\**********************************************/\n/*! exports provided: VBreadcrumbs, VBreadcrumbsItem, VBreadcrumbsDivider, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VBreadcrumbsDivider", function() { return VBreadcrumbsDivider; });\n/* harmony import */ var _VBreadcrumbs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VBreadcrumbs */ "./src/components/VBreadcrumbs/VBreadcrumbs.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBreadcrumbs", function() { return _VBreadcrumbs__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _VBreadcrumbsItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VBreadcrumbsItem */ "./src/components/VBreadcrumbs/VBreadcrumbsItem.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBreadcrumbsItem", function() { return _VBreadcrumbsItem__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n\n\n\nvar VBreadcrumbsDivider = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_2__["createSimpleFunctional"])(\'v-breadcrumbs__divider\', \'li\');\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VBreadcrumbs: _VBreadcrumbs__WEBPACK_IMPORTED_MODULE_0__["default"],\n        VBreadcrumbsItem: _VBreadcrumbsItem__WEBPACK_IMPORTED_MODULE_1__["default"],\n        VBreadcrumbsDivider: VBreadcrumbsDivider\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VBtn/VBtn.ts":\n/*!*************************************!*\\\n  !*** ./src/components/VBtn/VBtn.ts ***!\n  \\*************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_buttons_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_buttons.styl */ "./src/stylus/components/_buttons.styl");\n/* harmony import */ var _stylus_components_buttons_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_buttons_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _VProgressCircular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VProgressCircular */ "./src/components/VProgressCircular/index.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_groupable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/groupable */ "./src/mixins/groupable.ts");\n/* harmony import */ var _mixins_positionable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/positionable */ "./src/mixins/positionable.ts");\n/* harmony import */ var _mixins_routable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../mixins/routable */ "./src/mixins/routable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n\n// Components\n\n// Mixins\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_1__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_routable__WEBPACK_IMPORTED_MODULE_6__["default"], _mixins_positionable__WEBPACK_IMPORTED_MODULE_5__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_7__["default"], Object(_mixins_groupable__WEBPACK_IMPORTED_MODULE_4__["factory"])(\'btnToggle\'), Object(_mixins_toggleable__WEBPACK_IMPORTED_MODULE_8__["factory"])(\'inputValue\')\n/* @vue/component */\n).extend({\n    name: \'v-btn\',\n    props: {\n        activeClass: {\n            type: String,\n            default: \'v-btn--active\'\n        },\n        block: Boolean,\n        depressed: Boolean,\n        fab: Boolean,\n        flat: Boolean,\n        icon: Boolean,\n        large: Boolean,\n        loading: Boolean,\n        outline: Boolean,\n        ripple: {\n            type: [Boolean, Object],\n            default: null\n        },\n        round: Boolean,\n        small: Boolean,\n        tag: {\n            type: String,\n            default: \'button\'\n        },\n        type: {\n            type: String,\n            default: \'button\'\n        },\n        value: null\n    },\n    computed: {\n        classes: function classes() {\n            var _a;\n            return __assign((_a = { \'v-btn\': true }, _a[this.activeClass] = this.isActive, _a[\'v-btn--absolute\'] = this.absolute, _a[\'v-btn--block\'] = this.block, _a[\'v-btn--bottom\'] = this.bottom, _a[\'v-btn--disabled\'] = this.disabled, _a[\'v-btn--flat\'] = this.flat, _a[\'v-btn--floating\'] = this.fab, _a[\'v-btn--fixed\'] = this.fixed, _a[\'v-btn--icon\'] = this.icon, _a[\'v-btn--large\'] = this.large, _a[\'v-btn--left\'] = this.left, _a[\'v-btn--loader\'] = this.loading, _a[\'v-btn--outline\'] = this.outline, _a[\'v-btn--depressed\'] = this.depressed && !this.flat || this.outline, _a[\'v-btn--right\'] = this.right, _a[\'v-btn--round\'] = this.round, _a[\'v-btn--router\'] = this.to, _a[\'v-btn--small\'] = this.small, _a[\'v-btn--top\'] = this.top, _a), this.themeClasses);\n        },\n        computedRipple: function computedRipple() {\n            var defaultRipple = this.icon || this.fab ? { circle: true } : true;\n            if (this.disabled) return false;else return this.ripple !== null ? this.ripple : defaultRipple;\n        }\n    },\n    methods: {\n        // Prevent focus to match md spec\n        click: function click(e) {\n            !this.fab && e.detail && this.$el.blur();\n            this.$emit(\'click\', e);\n            this.btnToggle && this.toggle();\n        },\n        genContent: function genContent() {\n            return this.$createElement(\'div\', { \'class\': \'v-btn__content\' }, [this.$slots.default]);\n        },\n        genLoader: function genLoader() {\n            var children = [];\n            if (!this.$slots.loader) {\n                children.push(this.$createElement(_VProgressCircular__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                    props: {\n                        indeterminate: true,\n                        size: 23,\n                        width: 2\n                    }\n                }));\n            } else {\n                children.push(this.$slots.loader);\n            }\n            return this.$createElement(\'span\', { \'class\': \'v-btn__loading\' }, children);\n        }\n    },\n    render: function render(h) {\n        var setColor = !this.outline && !this.flat ? this.setBackgroundColor : this.setTextColor;\n        var _a = this.generateRouteLink(this.classes),\n            tag = _a.tag,\n            data = _a.data;\n        var children = [this.genContent()];\n        tag === \'button\' && (data.attrs.type = this.type);\n        this.loading && children.push(this.genLoader());\n        data.attrs.value = [\'string\', \'number\'].includes(_typeof(this.value)) ? this.value : JSON.stringify(this.value);\n        return h(tag, setColor(this.color, data), children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VBtn/index.ts":\n/*!**************************************!*\\\n  !*** ./src/components/VBtn/index.ts ***!\n  \\**************************************/\n/*! exports provided: VBtn, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VBtn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VBtn */ "./src/components/VBtn/VBtn.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBtn", function() { return _VBtn__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VBtn__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VBtnToggle/VBtnToggle.ts":\n/*!*************************************************!*\\\n  !*** ./src/components/VBtnToggle/VBtnToggle.ts ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_button_toggle_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_button-toggle.styl */ "./src/stylus/components/_button-toggle.styl");\n/* harmony import */ var _stylus_components_button_toggle_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_button_toggle_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_button_group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/button-group */ "./src/mixins/button-group.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Mixins\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (_mixins_button_group__WEBPACK_IMPORTED_MODULE_1__["default"].extend({\n    name: \'v-btn-toggle\',\n    props: {\n        activeClass: {\n            type: String,\n            default: \'v-btn--active\'\n        }\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({}, _mixins_button_group__WEBPACK_IMPORTED_MODULE_1__["default"].options.computed.classes.call(this), { \'v-btn-toggle\': true, \'v-btn-toggle--only-child\': this.selectedItems.length === 1, \'v-btn-toggle--selected\': this.selectedItems.length > 0 });\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VBtnToggle/index.ts":\n/*!********************************************!*\\\n  !*** ./src/components/VBtnToggle/index.ts ***!\n  \\********************************************/\n/*! exports provided: VBtnToggle, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VBtnToggle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VBtnToggle */ "./src/components/VBtnToggle/VBtnToggle.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBtnToggle", function() { return _VBtnToggle__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VBtnToggle__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VCard/VCard.ts":\n/*!***************************************!*\\\n  !*** ./src/components/VCard/VCard.ts ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_cards_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_cards.styl */ "./src/stylus/components/_cards.styl");\n/* harmony import */ var _stylus_components_cards_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_cards_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_measurable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/measurable */ "./src/mixins/measurable.ts");\n/* harmony import */ var _mixins_routable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/routable */ "./src/mixins/routable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Mixins\n\n\n\n\n// Helpers\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_6__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_measurable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_routable__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_4__["default"]).extend({\n    name: \'v-card\',\n    props: {\n        flat: Boolean,\n        hover: Boolean,\n        img: String,\n        raised: Boolean,\n        tag: {\n            type: String,\n            default: \'div\'\n        },\n        tile: Boolean\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-card\': true, \'v-card--flat\': this.flat, \'v-card--hover\': this.hover, \'v-card--raised\': this.raised, \'v-card--tile\': this.tile }, this.themeClasses);\n        },\n        styles: function styles() {\n            var style = {\n                height: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__["convertToUnit"])(this.height)\n            };\n            if (this.img) {\n                style.background = "url(\\"" + this.img + "\\") center center / cover no-repeat";\n            }\n            if (this.height) style.height = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__["convertToUnit"])(this.height);\n            if (this.maxHeight) style.maxHeight = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__["convertToUnit"])(this.maxHeight);\n            if (this.maxWidth) style.maxWidth = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__["convertToUnit"])(this.maxWidth);\n            if (this.width) style.width = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__["convertToUnit"])(this.width);\n            return style;\n        }\n    },\n    render: function render(h) {\n        var _a = this.generateRouteLink(this.classes),\n            tag = _a.tag,\n            data = _a.data;\n        data.style = this.styles;\n        return h(tag, this.setBackgroundColor(this.color, data), this.$slots.default);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VCard/VCardMedia.ts":\n/*!********************************************!*\\\n  !*** ./src/components/VCard/VCardMedia.ts ***!\n  \\********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VImg_VImg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VImg/VImg */ "./src/components/VImg/VImg.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n// Components\n\n// Utils\n\n/* istanbul ignore next */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (_VImg_VImg__WEBPACK_IMPORTED_MODULE_0__["default"].extend({\n    name: \'v-card-media\',\n    mounted: function mounted() {\n        Object(_util_console__WEBPACK_IMPORTED_MODULE_1__["deprecate"])(\'v-card-media\', this.src ? \'v-img\' : \'v-responsive\', this);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VCard/VCardTitle.ts":\n/*!********************************************!*\\\n  !*** ./src/components/VCard/VCardTitle.ts ***!\n  \\********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n// Types\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'v-card-title\',\n    functional: true,\n    props: {\n        primaryTitle: Boolean\n    },\n    render: function render(h, _a) {\n        var data = _a.data,\n            props = _a.props,\n            children = _a.children;\n        data.staticClass = ("v-card__title " + (data.staticClass || \'\')).trim();\n        if (props.primaryTitle) data.staticClass += \' v-card__title--primary\';\n        return h(\'div\', data, children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VCard/index.ts":\n/*!***************************************!*\\\n  !*** ./src/components/VCard/index.ts ***!\n  \\***************************************/\n/*! exports provided: VCard, VCardMedia, VCardTitle, VCardActions, VCardText, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VCardActions", function() { return VCardActions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VCardText", function() { return VCardText; });\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _VCard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VCard */ "./src/components/VCard/VCard.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCard", function() { return _VCard__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _VCardMedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VCardMedia */ "./src/components/VCard/VCardMedia.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCardMedia", function() { return _VCardMedia__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _VCardTitle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VCardTitle */ "./src/components/VCard/VCardTitle.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCardTitle", function() { return _VCardTitle__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\nvar VCardActions = vue__WEBPACK_IMPORTED_MODULE_4___default.a.extend(Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'v-card__actions\'));\nvar VCardText = vue__WEBPACK_IMPORTED_MODULE_4___default.a.extend(Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'v-card__text\'));\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VCard: _VCard__WEBPACK_IMPORTED_MODULE_1__["default"],\n        VCardMedia: _VCardMedia__WEBPACK_IMPORTED_MODULE_2__["default"],\n        VCardTitle: _VCardTitle__WEBPACK_IMPORTED_MODULE_3__["default"],\n        VCardActions: VCardActions,\n        VCardText: VCardText\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VCarousel/VCarousel.ts":\n/*!***********************************************!*\\\n  !*** ./src/components/VCarousel/VCarousel.ts ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_carousel_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_carousel.styl */ "./src/stylus/components/_carousel.styl");\n/* harmony import */ var _stylus_components_carousel_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_carousel_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VWindow_VWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VWindow/VWindow */ "./src/components/VWindow/VWindow.ts");\n/* harmony import */ var _VBtn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VBtn */ "./src/components/VBtn/index.ts");\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _mixins_button_group__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/button-group */ "./src/mixins/button-group.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n// Styles\n\n// Extensions\n\n// Components\n\n\n// Mixins\n// TODO: Move this into core components v2.0\n\n// Utilities\n\n/* harmony default export */ __webpack_exports__["default"] = (_VWindow_VWindow__WEBPACK_IMPORTED_MODULE_1__["default"].extend({\n    name: \'v-carousel\',\n    props: {\n        cycle: {\n            type: Boolean,\n            default: true\n        },\n        delimiterIcon: {\n            type: String,\n            default: \'$vuetify.icons.delimiter\'\n        },\n        height: {\n            type: [Number, String],\n            default: 500\n        },\n        hideControls: Boolean,\n        hideDelimiters: Boolean,\n        interval: {\n            type: [Number, String],\n            default: 6000,\n            validator: function validator(value) {\n                return value > 0;\n            }\n        },\n        mandatory: {\n            type: Boolean,\n            default: true\n        },\n        nextIcon: {\n            type: [Boolean, String],\n            default: \'$vuetify.icons.next\'\n        },\n        prevIcon: {\n            type: [Boolean, String],\n            default: \'$vuetify.icons.prev\'\n        }\n    },\n    data: function data() {\n        return {\n            changedByControls: false,\n            internalHeight: this.height,\n            slideTimeout: undefined\n        };\n    },\n    computed: {\n        isDark: function isDark() {\n            return this.dark || !this.light;\n        }\n    },\n    watch: {\n        internalValue: \'restartTimeout\',\n        interval: \'restartTimeout\',\n        cycle: function cycle(val) {\n            if (val) {\n                this.restartTimeout();\n            } else {\n                clearTimeout(this.slideTimeout);\n                this.slideTimeout = undefined;\n            }\n        }\n    },\n    mounted: function mounted() {\n        this.startTimeout();\n    },\n    methods: {\n        genDelimiters: function genDelimiters() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-carousel__controls\'\n            }, [this.genItems()]);\n        },\n        genIcon: function genIcon(direction, icon, fn) {\n            return this.$createElement(\'div\', {\n                staticClass: "v-carousel__" + direction\n            }, [this.$createElement(_VBtn__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                props: {\n                    icon: true\n                },\n                on: { click: fn }\n            }, [this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_3__["default"], {\n                props: { \'size\': \'46px\' }\n            }, icon)])]);\n        },\n        genIcons: function genIcons() {\n            var icons = [];\n            var prevIcon = this.$vuetify.rtl ? this.nextIcon : this.prevIcon;\n            if (prevIcon && typeof prevIcon === \'string\') {\n                icons.push(this.genIcon(\'prev\', prevIcon, this.prev));\n            }\n            var nextIcon = this.$vuetify.rtl ? this.prevIcon : this.nextIcon;\n            if (nextIcon && typeof nextIcon === \'string\') {\n                icons.push(this.genIcon(\'next\', nextIcon, this.next));\n            }\n            return icons;\n        },\n        genItems: function genItems() {\n            var _this = this;\n            var length = this.items.length;\n            var children = [];\n            for (var i = 0; i < length; i++) {\n                var child = this.$createElement(_VBtn__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                    class: {\n                        \'v-carousel__controls__item\': true\n                    },\n                    props: {\n                        icon: true,\n                        small: true\n                    }\n                }, [this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_3__["default"], {\n                    props: { size: 18 }\n                }, this.delimiterIcon)]);\n                children.push(child);\n            }\n            return this.$createElement(_mixins_button_group__WEBPACK_IMPORTED_MODULE_4__["default"], {\n                props: {\n                    value: this.internalValue\n                },\n                on: {\n                    change: function change(val) {\n                        _this.changedByControls = true;\n                        _this.internalValue = val;\n                    }\n                }\n            }, children);\n        },\n        restartTimeout: function restartTimeout() {\n            this.slideTimeout && clearTimeout(this.slideTimeout);\n            this.slideTimeout = undefined;\n            var raf = requestAnimationFrame || setTimeout;\n            raf(this.startTimeout);\n        },\n        startTimeout: function startTimeout() {\n            if (!this.cycle) return;\n            this.slideTimeout = window.setTimeout(this.next, +this.interval > 0 ? +this.interval : 6000);\n        },\n        updateReverse: function updateReverse(val, oldVal) {\n            if (this.changedByControls) {\n                this.changedByControls = false;\n                _VWindow_VWindow__WEBPACK_IMPORTED_MODULE_1__["default"].options.methods.updateReverse.call(this, val, oldVal);\n            }\n        }\n    },\n    render: function render(h) {\n        var children = [];\n        var data = {\n            staticClass: \'v-window v-carousel\',\n            style: {\n                height: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__["convertToUnit"])(this.height)\n            },\n            directives: []\n        };\n        if (!this.touchless) {\n            data.directives.push({\n                name: \'touch\',\n                value: {\n                    left: this.next,\n                    right: this.prev\n                }\n            });\n        }\n        if (!this.hideControls) {\n            children.push(this.genIcons());\n        }\n        if (!this.hideDelimiters) {\n            children.push(this.genDelimiters());\n        }\n        return h(\'div\', data, [children, this.genContainer()]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VCarousel/VCarouselItem.ts":\n/*!***************************************************!*\\\n  !*** ./src/components/VCarousel/VCarouselItem.ts ***!\n  \\***************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VWindow_VWindowItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VWindow/VWindowItem */ "./src/components/VWindow/VWindowItem.ts");\n/* harmony import */ var _VImg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VImg */ "./src/components/VImg/index.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Extensions\n\n// Components\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (_VWindow_VWindowItem__WEBPACK_IMPORTED_MODULE_0__["default"].extend({\n    name: \'v-carousel-item\',\n    inheritAttrs: false,\n    methods: {\n        genDefaultSlot: function genDefaultSlot() {\n            return [this.$createElement(_VImg__WEBPACK_IMPORTED_MODULE_1__["VImg"], {\n                staticClass: \'v-carousel__item\',\n                props: __assign({}, this.$attrs, { height: this.windowGroup.internalHeight }),\n                on: this.$listeners\n            }, this.$slots.default)];\n        },\n        onBeforeEnter: function onBeforeEnter() {},\n        onEnter: function onEnter() {},\n        onAfterEnter: function onAfterEnter() {},\n        onBeforeLeave: function onBeforeLeave() {},\n        onEnterCancelled: function onEnterCancelled() {}\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VCarousel/index.ts":\n/*!*******************************************!*\\\n  !*** ./src/components/VCarousel/index.ts ***!\n  \\*******************************************/\n/*! exports provided: VCarousel, VCarouselItem, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VCarousel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VCarousel */ "./src/components/VCarousel/VCarousel.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCarousel", function() { return _VCarousel__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _VCarouselItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VCarouselItem */ "./src/components/VCarousel/VCarouselItem.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCarouselItem", function() { return _VCarouselItem__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VCarousel: _VCarousel__WEBPACK_IMPORTED_MODULE_0__["default"],\n        VCarouselItem: _VCarouselItem__WEBPACK_IMPORTED_MODULE_1__["default"]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VCheckbox/VCheckbox.js":\n/*!***********************************************!*\\\n  !*** ./src/components/VCheckbox/VCheckbox.js ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_selection_controls_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_selection-controls.styl */ "./src/stylus/components/_selection-controls.styl");\n/* harmony import */ var _stylus_components_selection_controls_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_selection_controls_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _mixins_selectable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/selectable */ "./src/mixins/selectable.js");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Components\n\n// import { VFadeTransition } from \'../transitions\'\n// Mixins\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-checkbox\',\n    mixins: [_mixins_selectable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        indeterminate: Boolean,\n        indeterminateIcon: {\n            type: String,\n            default: \'$vuetify.icons.checkboxIndeterminate\'\n        },\n        onIcon: {\n            type: String,\n            default: \'$vuetify.icons.checkboxOn\'\n        },\n        offIcon: {\n            type: String,\n            default: \'$vuetify.icons.checkboxOff\'\n        }\n    },\n    data: function data(vm) {\n        return {\n            inputIndeterminate: vm.indeterminate\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return {\n                \'v-input--selection-controls\': true,\n                \'v-input--checkbox\': true\n            };\n        },\n        computedIcon: function computedIcon() {\n            if (this.inputIndeterminate) {\n                return this.indeterminateIcon;\n            } else if (this.isActive) {\n                return this.onIcon;\n            } else {\n                return this.offIcon;\n            }\n        }\n    },\n    watch: {\n        indeterminate: function indeterminate(val) {\n            this.inputIndeterminate = val;\n        }\n    },\n    methods: {\n        genCheckbox: function genCheckbox() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-input--selection-controls__input\'\n            }, [this.genInput(\'checkbox\', __assign({}, this.$attrs, { \'aria-checked\': this.inputIndeterminate ? \'mixed\' : this.isActive.toString() })), !this.disabled && this.genRipple(this.setTextColor(this.computedColor)), this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], this.setTextColor(this.computedColor, {\n                props: {\n                    dark: this.dark,\n                    light: this.light\n                }\n            }), this.computedIcon)]);\n        },\n        genDefaultSlot: function genDefaultSlot() {\n            return [this.genCheckbox(), this.genLabel()];\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VCheckbox/index.js":\n/*!*******************************************!*\\\n  !*** ./src/components/VCheckbox/index.js ***!\n  \\*******************************************/\n/*! exports provided: VCheckbox, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VCheckbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VCheckbox */ "./src/components/VCheckbox/VCheckbox.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCheckbox", function() { return _VCheckbox__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VCheckbox__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VChip/VChip.ts":\n/*!***************************************!*\\\n  !*** ./src/components/VChip/VChip.ts ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_chips_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_chips.styl */ "./src/stylus/components/_chips.styl");\n/* harmony import */ var _stylus_components_chips_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_chips_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n// Components\n\n// Mixins\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_1__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_5__["default"]).extend({\n    name: \'v-chip\',\n    props: {\n        close: Boolean,\n        disabled: Boolean,\n        label: Boolean,\n        outline: Boolean,\n        // Used for selects/tagging\n        selected: Boolean,\n        small: Boolean,\n        textColor: String,\n        value: {\n            type: Boolean,\n            default: true\n        }\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-chip--disabled\': this.disabled, \'v-chip--selected\': this.selected && !this.disabled, \'v-chip--label\': this.label, \'v-chip--outline\': this.outline, \'v-chip--small\': this.small, \'v-chip--removable\': this.close }, this.themeClasses);\n        }\n    },\n    methods: {\n        genClose: function genClose(h) {\n            var _this = this;\n            var data = {\n                staticClass: \'v-chip__close\',\n                on: {\n                    click: function click(e) {\n                        e.stopPropagation();\n                        _this.$emit(\'input\', false);\n                    }\n                }\n            };\n            return h(\'div\', data, [h(_VIcon__WEBPACK_IMPORTED_MODULE_2__["default"], \'$vuetify.icons.delete\')]);\n        },\n        genContent: function genContent(h) {\n            var children = [this.$slots.default];\n            this.close && children.push(this.genClose(h));\n            return h(\'span\', {\n                staticClass: \'v-chip__content\'\n            }, children);\n        }\n    },\n    render: function render(h) {\n        var data = this.setBackgroundColor(this.color, {\n            staticClass: \'v-chip\',\n            \'class\': this.classes,\n            attrs: { tabindex: this.disabled ? -1 : 0 },\n            directives: [{\n                name: \'show\',\n                value: this.isActive\n            }],\n            on: this.$listeners\n        });\n        var color = this.textColor || this.outline && this.color;\n        return h(\'span\', this.setTextColor(color, data), [this.genContent(h)]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VChip/index.ts":\n/*!***************************************!*\\\n  !*** ./src/components/VChip/index.ts ***!\n  \\***************************************/\n/*! exports provided: VChip, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VChip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VChip */ "./src/components/VChip/VChip.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VChip", function() { return _VChip__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VChip__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VCombobox/VCombobox.js":\n/*!***********************************************!*\\\n  !*** ./src/components/VCombobox/VCombobox.js ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_autocompletes_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_autocompletes.styl */ "./src/stylus/components/_autocompletes.styl");\n/* harmony import */ var _stylus_components_autocompletes_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_autocompletes_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VSelect/VSelect */ "./src/components/VSelect/VSelect.js");\n/* harmony import */ var _VAutocomplete_VAutocomplete__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VAutocomplete/VAutocomplete */ "./src/components/VAutocomplete/VAutocomplete.js");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n// Styles\n\n// Extensions\n\n\n// Utils\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-combobox\',\n    extends: _VAutocomplete_VAutocomplete__WEBPACK_IMPORTED_MODULE_2__["default"],\n    props: {\n        delimiters: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        },\n        returnObject: {\n            type: Boolean,\n            default: true\n        }\n    },\n    data: function data() {\n        return {\n            editingIndex: -1\n        };\n    },\n    computed: {\n        counterValue: function counterValue() {\n            return this.multiple ? this.selectedItems.length : (this.internalSearch || \'\').toString().length;\n        },\n        hasSlot: function hasSlot() {\n            return _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].computed.hasSlot.call(this) || this.multiple;\n        },\n        isAnyValueAllowed: function isAnyValueAllowed() {\n            return true;\n        },\n        menuCanShow: function menuCanShow() {\n            if (!this.isFocused) return false;\n            return this.displayedItemsCount > 0 || !!this.$slots[\'no-data\'] && !this.hideNoData;\n        }\n    },\n    methods: {\n        onFilteredItemsChanged: function onFilteredItemsChanged() {\n            // nop\n        },\n        onInternalSearchChanged: function onInternalSearchChanged(val) {\n            if (val && this.multiple && this.delimiters) {\n                var delimiter = this.delimiters.find(function (d) {\n                    return val.endsWith(d);\n                });\n                if (delimiter == null) return;\n                this.internalSearch = val.slice(0, val.length - delimiter.length);\n                this.updateTags();\n            }\n            this.updateMenuDimensions();\n        },\n        genChipSelection: function genChipSelection(item, index) {\n            var _this = this;\n            var chip = _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.genChipSelection.call(this, item, index);\n            // Allow user to update an existing value\n            if (this.multiple) {\n                chip.componentOptions.listeners.dblclick = function () {\n                    _this.editingIndex = index;\n                    _this.internalSearch = _this.getText(item);\n                    _this.selectedIndex = -1;\n                };\n            }\n            return chip;\n        },\n        onChipInput: function onChipInput(item) {\n            _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.onChipInput.call(this, item);\n            this.editingIndex = -1;\n        },\n        // Requires a manual definition\n        // to overwrite removal in v-autocomplete\n        onEnterDown: function onEnterDown(e) {\n            e.preventDefault();\n            _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.onEnterDown.call(this);\n            // If has menu index, let v-select-list handle\n            if (this.getMenuIndex() > -1) return;\n            this.updateSelf();\n        },\n        onKeyDown: function onKeyDown(e) {\n            var keyCode = e.keyCode;\n            _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.onKeyDown.call(this, e);\n            // If user is at selection index of 0\n            // create a new tag\n            if (this.multiple && keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_3__["keyCodes"].left && this.$refs.input.selectionStart === 0) {\n                this.updateSelf();\n            }\n            // The ordering is important here\n            // allows new value to be updated\n            // and then moves the index to the\n            // proper location\n            this.changeSelectedIndex(keyCode);\n        },\n        onTabDown: function onTabDown(e) {\n            // When adding tags, if searching and\n            // there is not a filtered options,\n            // add the value to the tags list\n            if (this.multiple && this.internalSearch && this.getMenuIndex() === -1) {\n                e.preventDefault();\n                e.stopPropagation();\n                return this.updateTags();\n            }\n            _VAutocomplete_VAutocomplete__WEBPACK_IMPORTED_MODULE_2__["default"].methods.onTabDown.call(this, e);\n        },\n        selectItem: function selectItem(item) {\n            // Currently only supports items:<string[]>\n            if (this.editingIndex > -1) {\n                this.updateEditing();\n            } else {\n                _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.selectItem.call(this, item);\n            }\n        },\n        setSelectedItems: function setSelectedItems() {\n            if (this.internalValue == null || this.internalValue === \'\') {\n                this.selectedItems = [];\n            } else {\n                this.selectedItems = this.multiple ? this.internalValue : [this.internalValue];\n            }\n        },\n        setValue: function setValue(value) {\n            if (value === void 0) {\n                value = this.internalSearch;\n            }\n            _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.setValue.call(this, value);\n        },\n        updateEditing: function updateEditing() {\n            var value = this.internalValue.slice();\n            value[this.editingIndex] = this.internalSearch;\n            this.setValue(value);\n            this.editingIndex = -1;\n        },\n        updateCombobox: function updateCombobox() {\n            var isUsingSlot = Boolean(this.$scopedSlots.selection) || this.hasChips;\n            // If search is not dirty and is\n            // using slot, do nothing\n            if (isUsingSlot && !this.searchIsDirty) return;\n            // The internal search is not matching\n            // the internal value, update the input\n            if (this.internalSearch !== this.getText(this.internalValue)) this.setValue();\n            // Reset search if using slot\n            // to avoid a double input\n            if (isUsingSlot) this.internalSearch = undefined;\n        },\n        updateSelf: function updateSelf() {\n            this.multiple ? this.updateTags() : this.updateCombobox();\n        },\n        updateTags: function updateTags() {\n            var menuIndex = this.getMenuIndex();\n            // If the user is not searching\n            // and no menu item is selected\n            // do nothing\n            if (menuIndex < 0 && !this.searchIsDirty) return;\n            if (this.editingIndex > -1) {\n                return this.updateEditing();\n            }\n            var index = this.selectedItems.indexOf(this.internalSearch);\n            // If it already exists, do nothing\n            // this might need to change to bring\n            // the duplicated item to the last entered\n            if (index > -1) {\n                var internalValue = this.internalValue.slice();\n                internalValue.splice(index, 1);\n                this.setValue(internalValue);\n            }\n            // If menu index is greater than 1\n            // the selection is handled elsewhere\n            // TODO: find out where\n            if (menuIndex > -1) return this.internalSearch = null;\n            this.selectItem(this.internalSearch);\n            this.internalSearch = null;\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VCombobox/index.js":\n/*!*******************************************!*\\\n  !*** ./src/components/VCombobox/index.js ***!\n  \\*******************************************/\n/*! exports provided: VCombobox, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VCombobox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VCombobox */ "./src/components/VCombobox/VCombobox.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCombobox", function() { return _VCombobox__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VCombobox__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VCounter/VCounter.js":\n/*!*********************************************!*\\\n  !*** ./src/components/VCounter/VCounter.js ***!\n  \\*********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_counters_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_counters.styl */ "./src/stylus/components/_counters.styl");\n/* harmony import */ var _stylus_components_counters_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_counters_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Mixins\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-counter\',\n    functional: true,\n    mixins: [_mixins_themeable__WEBPACK_IMPORTED_MODULE_1__["default"]],\n    props: {\n        value: {\n            type: [Number, String],\n            default: \'\'\n        },\n        max: [Number, String]\n    },\n    render: function render(h, ctx) {\n        var props = ctx.props;\n        var max = parseInt(props.max, 10);\n        var value = parseInt(props.value, 10);\n        var content = max ? value + " / " + max : props.value;\n        var isGreater = max && value > max;\n        return h(\'div\', {\n            staticClass: \'v-counter\',\n            class: __assign({ \'error--text\': isGreater }, Object(_mixins_themeable__WEBPACK_IMPORTED_MODULE_1__["functionalThemeClasses"])(ctx))\n        }, content);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VCounter/index.js":\n/*!******************************************!*\\\n  !*** ./src/components/VCounter/index.js ***!\n  \\******************************************/\n/*! exports provided: VCounter, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VCounter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VCounter */ "./src/components/VCounter/VCounter.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCounter", function() { return _VCounter__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VCounter__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VDataIterator/VDataIterator.js":\n/*!*******************************************************!*\\\n  !*** ./src/components/VDataIterator/VDataIterator.js ***!\n  \\*******************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_data_iterator_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_data-iterator.styl */ "./src/stylus/components/_data-iterator.styl");\n/* harmony import */ var _stylus_components_data_iterator_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_data_iterator_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_data_iterable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/data-iterable */ "./src/mixins/data-iterable.js");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-data-iterator\',\n    mixins: [_mixins_data_iterable__WEBPACK_IMPORTED_MODULE_1__["default"]],\n    inheritAttrs: false,\n    props: {\n        contentTag: {\n            type: String,\n            default: \'div\'\n        },\n        contentProps: {\n            type: Object,\n            required: false\n        },\n        contentClass: {\n            type: String,\n            required: false\n        }\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-data-iterator\': true, \'v-data-iterator--select-all\': this.selectAll !== false }, this.themeClasses);\n        }\n    },\n    created: function created() {\n        this.initPagination();\n    },\n    methods: {\n        genContent: function genContent() {\n            var children = this.genItems();\n            var data = {\n                \'class\': this.contentClass,\n                attrs: this.$attrs,\n                on: this.$listeners,\n                props: this.contentProps\n            };\n            return this.$createElement(this.contentTag, data, children);\n        },\n        genEmptyItems: function genEmptyItems(content) {\n            return [this.$createElement(\'div\', {\n                \'class\': \'text-xs-center\',\n                style: \'width: 100%\'\n            }, content)];\n        },\n        genFilteredItems: function genFilteredItems() {\n            if (!this.$scopedSlots.item) {\n                return null;\n            }\n            var items = [];\n            for (var index = 0, len = this.filteredItems.length; index < len; ++index) {\n                var item = this.filteredItems[index];\n                var props = this.createProps(item, index);\n                items.push(this.$scopedSlots.item(props));\n            }\n            return items;\n        },\n        genFooter: function genFooter() {\n            var children = [];\n            if (this.$slots.footer) {\n                children.push(this.$slots.footer);\n            }\n            if (!this.hideActions) {\n                children.push(this.genActions());\n            }\n            if (!children.length) return null;\n            return this.$createElement(\'div\', children);\n        },\n        genHeader: function genHeader() {\n            var children = [];\n            if (this.$slots.header) {\n                children.push(this.$slots.header);\n            }\n            if (!children.length) return null;\n            return this.$createElement(\'div\', children);\n        }\n    },\n    render: function render(h) {\n        return h(\'div\', {\n            \'class\': this.classes\n        }, [this.genHeader(), this.genContent(), this.genFooter()]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDataIterator/index.js":\n/*!***********************************************!*\\\n  !*** ./src/components/VDataIterator/index.js ***!\n  \\***********************************************/\n/*! exports provided: VDataIterator, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VDataIterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VDataIterator */ "./src/components/VDataIterator/VDataIterator.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDataIterator", function() { return _VDataIterator__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VDataIterator__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VDataTable/VDataTable.js":\n/*!*************************************************!*\\\n  !*** ./src/components/VDataTable/VDataTable.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_tables_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_tables.styl */ "./src/stylus/components/_tables.styl");\n/* harmony import */ var _stylus_components_tables_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_tables_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stylus_components_data_table_styl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stylus/components/_data-table.styl */ "./src/stylus/components/_data-table.styl");\n/* harmony import */ var _stylus_components_data_table_styl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_data_table_styl__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mixins_data_iterable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/data-iterable */ "./src/mixins/data-iterable.js");\n/* harmony import */ var _mixins_head__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mixins/head */ "./src/components/VDataTable/mixins/head.js");\n/* harmony import */ var _mixins_body__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mixins/body */ "./src/components/VDataTable/mixins/body.js");\n/* harmony import */ var _mixins_foot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mixins/foot */ "./src/components/VDataTable/mixins/foot.js");\n/* harmony import */ var _mixins_progress__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mixins/progress */ "./src/components/VDataTable/mixins/progress.js");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n\n\n\n\n\n\n// Importing does not work properly\nvar VTableOverflow = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["createSimpleFunctional"])(\'v-table__overflow\');\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-data-table\',\n    mixins: [_mixins_data_iterable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_head__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_body__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_foot__WEBPACK_IMPORTED_MODULE_5__["default"], _mixins_progress__WEBPACK_IMPORTED_MODULE_6__["default"]],\n    props: {\n        headers: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        },\n        headersLength: {\n            type: Number\n        },\n        headerText: {\n            type: String,\n            default: \'text\'\n        },\n        headerKey: {\n            type: String,\n            default: null\n        },\n        hideHeaders: Boolean,\n        rowsPerPageText: {\n            type: String,\n            default: \'$vuetify.dataTable.rowsPerPageText\'\n        },\n        customFilter: {\n            type: Function,\n            default: function _default(items, search, filter, headers) {\n                search = search.toString().toLowerCase();\n                if (search.trim() === \'\') return items;\n                var props = headers.map(function (h) {\n                    return h.value;\n                });\n                return items.filter(function (item) {\n                    return props.some(function (prop) {\n                        return filter(Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["getObjectValueByPath"])(item, prop, item[prop]), search);\n                    });\n                });\n            }\n        }\n    },\n    data: function data() {\n        return {\n            actionsClasses: \'v-datatable__actions\',\n            actionsRangeControlsClasses: \'v-datatable__actions__range-controls\',\n            actionsSelectClasses: \'v-datatable__actions__select\',\n            actionsPaginationClasses: \'v-datatable__actions__pagination\'\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-datatable v-table\': true, \'v-datatable--select-all\': this.selectAll !== false }, this.themeClasses);\n        },\n        filteredItems: function filteredItems() {\n            return this.filteredItemsImpl(this.headers);\n        },\n        headerColumns: function headerColumns() {\n            return this.headersLength || this.headers.length + (this.selectAll !== false);\n        }\n    },\n    created: function created() {\n        var firstSortable = this.headers.find(function (h) {\n            return !(\'sortable\' in h) || h.sortable;\n        });\n        this.defaultPagination.sortBy = !this.disableInitialSort && firstSortable ? firstSortable.value : null;\n        this.initPagination();\n    },\n    methods: {\n        hasTag: function hasTag(elements, tag) {\n            return Array.isArray(elements) && elements.find(function (e) {\n                return e.tag === tag;\n            });\n        },\n        genTR: function genTR(children, data) {\n            if (data === void 0) {\n                data = {};\n            }\n            return this.$createElement(\'tr\', data, children);\n        }\n    },\n    render: function render(h) {\n        var tableOverflow = h(VTableOverflow, {}, [h(\'table\', {\n            \'class\': this.classes\n        }, [this.genTHead(), this.genTBody(), this.genTFoot()])]);\n        return h(\'div\', [tableOverflow, this.genActionsFooter()]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDataTable/VEditDialog.js":\n/*!**************************************************!*\\\n  !*** ./src/components/VDataTable/VEditDialog.js ***!\n  \\**************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_small_dialog_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_small-dialog.styl */ "./src/stylus/components/_small-dialog.styl");\n/* harmony import */ var _stylus_components_small_dialog_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_small_dialog_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_returnable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/returnable */ "./src/mixins/returnable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _VBtn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VBtn */ "./src/components/VBtn/index.ts");\n/* harmony import */ var _VMenu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VMenu */ "./src/components/VMenu/index.js");\n\n// Mixins\n\n\n// Utils\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-edit-dialog\',\n    mixins: [_mixins_returnable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        cancelText: {\n            default: \'Cancel\'\n        },\n        large: Boolean,\n        lazy: Boolean,\n        persistent: Boolean,\n        saveText: {\n            default: \'Save\'\n        },\n        transition: {\n            type: String,\n            default: \'slide-x-reverse-transition\'\n        }\n    },\n    data: function data() {\n        return {\n            isActive: false\n        };\n    },\n    watch: {\n        isActive: function isActive(val) {\n            if (val) {\n                this.$emit(\'open\');\n                setTimeout(this.focus, 50); // Give DOM time to paint\n            } else {\n                this.$emit(\'close\');\n            }\n        }\n    },\n    methods: {\n        cancel: function cancel() {\n            this.isActive = false;\n            this.$emit(\'cancel\');\n        },\n        focus: function focus() {\n            var input = this.$refs.content.querySelector(\'input\');\n            input && input.focus();\n        },\n        genButton: function genButton(fn, text) {\n            return this.$createElement(_VBtn__WEBPACK_IMPORTED_MODULE_4__["default"], {\n                props: {\n                    flat: true,\n                    color: \'primary\',\n                    light: true\n                },\n                on: { click: fn }\n            }, text);\n        },\n        genActions: function genActions() {\n            var _this = this;\n            return this.$createElement(\'div\', {\n                \'class\': \'v-small-dialog__actions\'\n            }, [this.genButton(this.cancel, this.cancelText), this.genButton(function () {\n                _this.save(_this.returnValue);\n                _this.$emit(\'save\');\n            }, this.saveText)]);\n        },\n        genContent: function genContent() {\n            var _this = this;\n            return this.$createElement(\'div\', {\n                on: {\n                    keydown: function keydown(e) {\n                        var input = _this.$refs.content.querySelector(\'input\');\n                        e.keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_3__["keyCodes"].esc && _this.cancel();\n                        if (e.keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_3__["keyCodes"].enter && input) {\n                            _this.save(input.value);\n                            _this.$emit(\'save\');\n                        }\n                    }\n                },\n                ref: \'content\'\n            }, [this.$slots.input]);\n        }\n    },\n    render: function render(h) {\n        var _this = this;\n        return h(_VMenu__WEBPACK_IMPORTED_MODULE_5__["default"], {\n            staticClass: \'v-small-dialog\',\n            class: this.themeClasses,\n            props: {\n                contentClass: \'v-small-dialog__content\',\n                transition: this.transition,\n                origin: \'top right\',\n                right: true,\n                value: this.isActive,\n                closeOnClick: !this.persistent,\n                closeOnContentClick: false,\n                lazy: this.lazy,\n                light: this.light,\n                dark: this.dark\n            },\n            on: {\n                input: function input(val) {\n                    return _this.isActive = val;\n                }\n            }\n        }, [h(\'a\', {\n            slot: \'activator\'\n        }, this.$slots.default), this.genContent(), this.large ? this.genActions() : null]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDataTable/index.js":\n/*!********************************************!*\\\n  !*** ./src/components/VDataTable/index.js ***!\n  \\********************************************/\n/*! exports provided: VDataTable, VEditDialog, VTableOverflow, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VTableOverflow", function() { return VTableOverflow; });\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _VDataTable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VDataTable */ "./src/components/VDataTable/VDataTable.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDataTable", function() { return _VDataTable__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _VEditDialog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VEditDialog */ "./src/components/VDataTable/VEditDialog.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VEditDialog", function() { return _VEditDialog__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n\n\n\nvar VTableOverflow = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'v-table__overflow\');\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VDataTable: _VDataTable__WEBPACK_IMPORTED_MODULE_1__["default"],\n        VEditDialog: _VEditDialog__WEBPACK_IMPORTED_MODULE_2__["default"],\n        VTableOverflow: VTableOverflow\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDataTable/mixins/body.js":\n/*!**************************************************!*\\\n  !*** ./src/components/VDataTable/mixins/body.js ***!\n  \\**************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _transitions_expand_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../transitions/expand-transition */ "./src/components/transitions/expand-transition.js");\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    methods: {\n        genTBody: function genTBody() {\n            var children = this.genItems();\n            return this.$createElement(\'tbody\', children);\n        },\n        genExpandedRow: function genExpandedRow(props) {\n            var children = [];\n            if (this.isExpanded(props.item)) {\n                var expand = this.$createElement(\'div\', {\n                    class: \'v-datatable__expand-content\',\n                    key: props.item[this.itemKey]\n                }, [this.$scopedSlots.expand(props)]);\n                children.push(expand);\n            }\n            var transition = this.$createElement(\'transition-group\', {\n                class: \'v-datatable__expand-col\',\n                attrs: { colspan: this.headerColumns },\n                props: {\n                    tag: \'td\'\n                },\n                on: Object(_transitions_expand_transition__WEBPACK_IMPORTED_MODULE_0__["default"])(\'v-datatable__expand-col--expanded\')\n            }, children);\n            return this.genTR([transition], { class: \'v-datatable__expand-row\' });\n        },\n        genFilteredItems: function genFilteredItems() {\n            if (!this.$scopedSlots.items) {\n                return null;\n            }\n            var rows = [];\n            for (var index = 0, len = this.filteredItems.length; index < len; ++index) {\n                var item = this.filteredItems[index];\n                var props = this.createProps(item, index);\n                var row = this.$scopedSlots.items(props);\n                rows.push(this.hasTag(row, \'td\') ? this.genTR(row, {\n                    key: this.itemKey ? props.item[this.itemKey] : index,\n                    attrs: { active: this.isSelected(item) }\n                }) : row);\n                if (this.$scopedSlots.expand) {\n                    var expandRow = this.genExpandedRow(props);\n                    rows.push(expandRow);\n                }\n            }\n            return rows;\n        },\n        genEmptyItems: function genEmptyItems(content) {\n            if (this.hasTag(content, \'tr\')) {\n                return content;\n            } else if (this.hasTag(content, \'td\')) {\n                return this.genTR(content);\n            } else {\n                return this.genTR([this.$createElement(\'td\', {\n                    class: {\n                        \'text-xs-center\': typeof content === \'string\'\n                    },\n                    attrs: { colspan: this.headerColumns }\n                }, content)]);\n            }\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDataTable/mixins/foot.js":\n/*!**************************************************!*\\\n  !*** ./src/components/VDataTable/mixins/foot.js ***!\n  \\**************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    methods: {\n        genTFoot: function genTFoot() {\n            if (!this.$slots.footer) {\n                return null;\n            }\n            var footer = this.$slots.footer;\n            var row = this.hasTag(footer, \'td\') ? this.genTR(footer) : footer;\n            return this.$createElement(\'tfoot\', [row]);\n        },\n        genActionsFooter: function genActionsFooter() {\n            if (this.hideActions) {\n                return null;\n            }\n            return this.$createElement(\'div\', {\n                \'class\': this.classes\n            }, this.genActions());\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDataTable/mixins/head.js":\n/*!**************************************************!*\\\n  !*** ./src/components/VDataTable/mixins/head.js ***!\n  \\**************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/console */ "./src/util/console.ts");\n/* harmony import */ var _VCheckbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../VCheckbox */ "./src/components/VCheckbox/index.js");\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../VIcon */ "./src/components/VIcon/index.ts");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) {\n        ar = ar.concat(__read(arguments[i]));\n    }return ar;\n};\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    props: {\n        sortIcon: {\n            type: String,\n            default: \'$vuetify.icons.sort\'\n        }\n    },\n    methods: {\n        genTHead: function genTHead() {\n            var _this = this;\n            if (this.hideHeaders) return; // Exit Early since no headers are needed.\n            var children = [];\n            if (this.$scopedSlots.headers) {\n                var row = this.$scopedSlots.headers({\n                    headers: this.headers,\n                    indeterminate: this.indeterminate,\n                    all: this.everyItem\n                });\n                children = [this.hasTag(row, \'th\') ? this.genTR(row) : row, this.genTProgress()];\n            } else {\n                var row = this.headers.map(function (o, i) {\n                    return _this.genHeader(o, _this.headerKey ? o[_this.headerKey] : i);\n                });\n                var checkbox = this.$createElement(_VCheckbox__WEBPACK_IMPORTED_MODULE_1__["default"], {\n                    props: {\n                        dark: this.dark,\n                        light: this.light,\n                        color: this.selectAll === true ? \'\' : this.selectAll,\n                        hideDetails: true,\n                        inputValue: this.everyItem,\n                        indeterminate: this.indeterminate\n                    },\n                    on: { change: this.toggle }\n                });\n                this.hasSelectAll && row.unshift(this.$createElement(\'th\', [checkbox]));\n                children = [this.genTR(row), this.genTProgress()];\n            }\n            return this.$createElement(\'thead\', [children]);\n        },\n        genHeader: function genHeader(header, key) {\n            var array = [this.$scopedSlots.headerCell ? this.$scopedSlots.headerCell({ header: header }) : header[this.headerText]];\n            return this.$createElement.apply(this, __spread([\'th\'], this.genHeaderData(header, array, key)));\n        },\n        genHeaderData: function genHeaderData(header, children, key) {\n            var classes = [\'column\'];\n            var data = {\n                key: key,\n                attrs: {\n                    role: \'columnheader\',\n                    scope: \'col\',\n                    width: header.width || null,\n                    \'aria-label\': header[this.headerText] || \'\',\n                    \'aria-sort\': \'none\'\n                }\n            };\n            if (header.sortable == null || header.sortable) {\n                this.genHeaderSortingData(header, children, data, classes);\n            } else {\n                data.attrs[\'aria-label\'] += \': Not sorted.\'; // TODO: Localization\n            }\n            classes.push("text-xs-" + (header.align || \'left\'));\n            if (Array.isArray(header.class)) {\n                classes.push.apply(classes, __spread(header.class));\n            } else if (header.class) {\n                classes.push(header.class);\n            }\n            data.class = classes;\n            return [data, children];\n        },\n        genHeaderSortingData: function genHeaderSortingData(header, children, data, classes) {\n            var _this = this;\n            if (!(\'value\' in header)) {\n                Object(_util_console__WEBPACK_IMPORTED_MODULE_0__["consoleWarn"])(\'Headers must have a value property that corresponds to a value in the v-model array\', this);\n            }\n            data.attrs.tabIndex = 0;\n            data.on = {\n                click: function click() {\n                    _this.expanded = {};\n                    _this.sort(header.value);\n                },\n                keydown: function keydown(e) {\n                    // check for space\n                    if (e.keyCode === 32) {\n                        e.preventDefault();\n                        _this.sort(header.value);\n                    }\n                }\n            };\n            classes.push(\'sortable\');\n            var icon = this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                props: {\n                    small: true\n                }\n            }, this.sortIcon);\n            if (!header.align || header.align === \'left\') {\n                children.push(icon);\n            } else {\n                children.unshift(icon);\n            }\n            var pagination = this.computedPagination;\n            var beingSorted = pagination.sortBy === header.value;\n            if (beingSorted) {\n                classes.push(\'active\');\n                if (pagination.descending) {\n                    classes.push(\'desc\');\n                    data.attrs[\'aria-sort\'] = \'descending\';\n                    data.attrs[\'aria-label\'] += \': Sorted descending. Activate to remove sorting.\'; // TODO: Localization\n                } else {\n                    classes.push(\'asc\');\n                    data.attrs[\'aria-sort\'] = \'ascending\';\n                    data.attrs[\'aria-label\'] += \': Sorted ascending. Activate to sort descending.\'; // TODO: Localization\n                }\n            } else {\n                data.attrs[\'aria-label\'] += \': Not sorted. Activate to sort ascending.\'; // TODO: Localization\n            }\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDataTable/mixins/progress.js":\n/*!******************************************************!*\\\n  !*** ./src/components/VDataTable/mixins/progress.js ***!\n  \\******************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    methods: {\n        genTProgress: function genTProgress() {\n            var col = this.$createElement(\'th\', {\n                staticClass: \'column\',\n                attrs: {\n                    colspan: this.headerColumns\n                }\n            }, [this.genProgress()]);\n            return this.genTR([col], {\n                staticClass: \'v-datatable__progress\'\n            });\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/VDatePicker.js":\n/*!***************************************************!*\\\n  !*** ./src/components/VDatePicker/VDatePicker.js ***!\n  \\***************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VDatePickerTitle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VDatePickerTitle */ "./src/components/VDatePicker/VDatePickerTitle.js");\n/* harmony import */ var _VDatePickerHeader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VDatePickerHeader */ "./src/components/VDatePicker/VDatePickerHeader.js");\n/* harmony import */ var _VDatePickerDateTable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VDatePickerDateTable */ "./src/components/VDatePicker/VDatePickerDateTable.js");\n/* harmony import */ var _VDatePickerMonthTable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VDatePickerMonthTable */ "./src/components/VDatePicker/VDatePickerMonthTable.js");\n/* harmony import */ var _VDatePickerYears__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VDatePickerYears */ "./src/components/VDatePicker/VDatePickerYears.js");\n/* harmony import */ var _mixins_picker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/picker */ "./src/mixins/picker.js");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./src/components/VDatePicker/util/index.js");\n/* harmony import */ var _util_isDateAllowed__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/isDateAllowed */ "./src/components/VDatePicker/util/isDateAllowed.js");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\n// Components\n\n\n\n\n\n// Mixins\n\n// Utils\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-date-picker\',\n    mixins: [_mixins_picker__WEBPACK_IMPORTED_MODULE_5__["default"]],\n    props: {\n        allowedDates: Function,\n        // Function formatting the day in date picker table\n        dayFormat: {\n            type: Function,\n            default: null\n        },\n        events: {\n            type: [Array, Object, Function],\n            default: function _default() {\n                return null;\n            }\n        },\n        eventColor: {\n            type: [String, Function, Object],\n            default: \'warning\'\n        },\n        firstDayOfWeek: {\n            type: [String, Number],\n            default: 0\n        },\n        // Function formatting the tableDate in the day/month table header\n        headerDateFormat: {\n            type: Function,\n            default: null\n        },\n        locale: {\n            type: String,\n            default: \'en-us\'\n        },\n        max: String,\n        min: String,\n        // Function formatting month in the months table\n        monthFormat: {\n            type: Function,\n            default: null\n        },\n        multiple: Boolean,\n        nextIcon: {\n            type: String,\n            default: \'$vuetify.icons.next\'\n        },\n        pickerDate: String,\n        prevIcon: {\n            type: String,\n            default: \'$vuetify.icons.prev\'\n        },\n        reactive: Boolean,\n        readonly: Boolean,\n        scrollable: Boolean,\n        showCurrent: {\n            type: [Boolean, String],\n            default: true\n        },\n        // Function formatting currently selected date in the picker title\n        titleDateFormat: {\n            type: Function,\n            default: null\n        },\n        type: {\n            type: String,\n            default: \'date\',\n            validator: function validator(type) {\n                return [\'date\', \'month\'].includes(type);\n            } // TODO: year\n        },\n        value: [Array, String],\n        weekdayFormat: {\n            type: Function,\n            default: null\n        },\n        // Function formatting the year in table header and pickup title\n        yearFormat: {\n            type: Function,\n            default: null\n        },\n        yearIcon: String\n    },\n    data: function data() {\n        var _this = this;\n        var now = new Date();\n        return {\n            activePicker: this.type.toUpperCase(),\n            inputDay: null,\n            inputMonth: null,\n            inputYear: null,\n            isReversing: false,\n            now: now,\n            // tableDate is a string in \'YYYY\' / \'YYYY-M\' format (leading zero for month is not required)\n            tableDate: function () {\n                if (_this.pickerDate) {\n                    return _this.pickerDate;\n                }\n                var date = (_this.multiple ? _this.value[_this.value.length - 1] : _this.value) || now.getFullYear() + "-" + (now.getMonth() + 1);\n                var type = _this.type === \'date\' ? \'month\' : \'year\';\n                return _this.sanitizeDateString(date, type);\n            }()\n        };\n    },\n    computed: {\n        lastValue: function lastValue() {\n            return this.multiple ? this.value[this.value.length - 1] : this.value;\n        },\n        selectedMonths: function selectedMonths() {\n            if (!this.value || !this.value.length || this.type === \'month\') {\n                return this.value;\n            } else if (this.multiple) {\n                return this.value.map(function (val) {\n                    return val.substr(0, 7);\n                });\n            } else {\n                return this.value.substr(0, 7);\n            }\n        },\n        current: function current() {\n            if (this.showCurrent === true) {\n                return this.sanitizeDateString(this.now.getFullYear() + "-" + (this.now.getMonth() + 1) + "-" + this.now.getDate(), this.type);\n            }\n            return this.showCurrent || null;\n        },\n        inputDate: function inputDate() {\n            return this.type === \'date\' ? this.inputYear + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_6__["pad"])(this.inputMonth + 1) + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_6__["pad"])(this.inputDay) : this.inputYear + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_6__["pad"])(this.inputMonth + 1);\n        },\n        tableMonth: function tableMonth() {\n            return (this.pickerDate || this.tableDate).split(\'-\')[1] - 1;\n        },\n        tableYear: function tableYear() {\n            return (this.pickerDate || this.tableDate).split(\'-\')[0] * 1;\n        },\n        minMonth: function minMonth() {\n            return this.min ? this.sanitizeDateString(this.min, \'month\') : null;\n        },\n        maxMonth: function maxMonth() {\n            return this.max ? this.sanitizeDateString(this.max, \'month\') : null;\n        },\n        minYear: function minYear() {\n            return this.min ? this.sanitizeDateString(this.min, \'year\') : null;\n        },\n        maxYear: function maxYear() {\n            return this.max ? this.sanitizeDateString(this.max, \'year\') : null;\n        },\n        formatters: function formatters() {\n            return {\n                year: this.yearFormat || Object(_util__WEBPACK_IMPORTED_MODULE_6__["createNativeLocaleFormatter"])(this.locale, { year: \'numeric\', timeZone: \'UTC\' }, { length: 4 }),\n                titleDate: this.titleDateFormat || (this.multiple ? this.defaultTitleMultipleDateFormatter : this.defaultTitleDateFormatter)\n            };\n        },\n        defaultTitleMultipleDateFormatter: function defaultTitleMultipleDateFormatter() {\n            var _this = this;\n            if (this.value.length < 2) {\n                return function (dates) {\n                    return dates.length ? _this.defaultTitleDateFormatter(dates[0]) : \'0 selected\';\n                };\n            }\n            return function (dates) {\n                return dates.length + " selected";\n            };\n        },\n        defaultTitleDateFormatter: function defaultTitleDateFormatter() {\n            var titleFormats = {\n                year: { year: \'numeric\', timeZone: \'UTC\' },\n                month: { month: \'long\', timeZone: \'UTC\' },\n                date: { weekday: \'short\', month: \'short\', day: \'numeric\', timeZone: \'UTC\' }\n            };\n            var titleDateFormatter = Object(_util__WEBPACK_IMPORTED_MODULE_6__["createNativeLocaleFormatter"])(this.locale, titleFormats[this.type], {\n                start: 0,\n                length: { date: 10, month: 7, year: 4 }[this.type]\n            });\n            var landscapeFormatter = function landscapeFormatter(date) {\n                return titleDateFormatter(date).replace(/([^\\d\\s])([\\d])/g, function (match, nonDigit, digit) {\n                    return nonDigit + " " + digit;\n                }).replace(\', \', \',<br>\');\n            };\n            return this.landscape ? landscapeFormatter : titleDateFormatter;\n        }\n    },\n    watch: {\n        tableDate: function tableDate(val, prev) {\n            // Make a ISO 8601 strings from val and prev for comparision, otherwise it will incorrectly\n            // compare for example \'2000-9\' and \'2000-10\'\n            var sanitizeType = this.type === \'month\' ? \'year\' : \'month\';\n            this.isReversing = this.sanitizeDateString(val, sanitizeType) < this.sanitizeDateString(prev, sanitizeType);\n            this.$emit(\'update:pickerDate\', val);\n        },\n        pickerDate: function pickerDate(val) {\n            if (val) {\n                this.tableDate = val;\n            } else if (this.lastValue && this.type === \'date\') {\n                this.tableDate = this.sanitizeDateString(this.lastValue, \'month\');\n            } else if (this.lastValue && this.type === \'month\') {\n                this.tableDate = this.sanitizeDateString(this.lastValue, \'year\');\n            }\n        },\n        value: function value(newValue, oldValue) {\n            this.checkMultipleProp();\n            this.setInputDate();\n            if (!this.multiple && this.value && !this.pickerDate) {\n                this.tableDate = this.sanitizeDateString(this.inputDate, this.type === \'month\' ? \'year\' : \'month\');\n            } else if (this.multiple && this.value.length && !oldValue.length && !this.pickerDate) {\n                this.tableDate = this.sanitizeDateString(this.inputDate, this.type === \'month\' ? \'year\' : \'month\');\n            }\n        },\n        type: function type(_type) {\n            var _this = this;\n            this.activePicker = _type.toUpperCase();\n            if (this.value && this.value.length) {\n                var output = (this.multiple ? this.value : [this.value]).map(function (val) {\n                    return _this.sanitizeDateString(val, _type);\n                }).filter(this.isDateAllowed);\n                this.$emit(\'input\', this.multiple ? output : output[0]);\n            }\n        }\n    },\n    created: function created() {\n        this.checkMultipleProp();\n        if (this.pickerDate !== this.tableDate) {\n            this.$emit(\'update:pickerDate\', this.tableDate);\n        }\n        this.setInputDate();\n    },\n    methods: {\n        emitInput: function emitInput(newInput) {\n            var output = this.multiple ? this.value.indexOf(newInput) === -1 ? this.value.concat([newInput]) : this.value.filter(function (x) {\n                return x !== newInput;\n            }) : newInput;\n            this.$emit(\'input\', output);\n            this.multiple || this.$emit(\'change\', newInput);\n        },\n        checkMultipleProp: function checkMultipleProp() {\n            if (this.value == null) return;\n            var valueType = this.value.constructor.name;\n            var expected = this.multiple ? \'Array\' : \'String\';\n            if (valueType !== expected) {\n                Object(_util_console__WEBPACK_IMPORTED_MODULE_8__["consoleWarn"])("Value must be " + (this.multiple ? \'an\' : \'a\') + " " + expected + ", got " + valueType, this);\n            }\n        },\n        isDateAllowed: function isDateAllowed(value) {\n            return Object(_util_isDateAllowed__WEBPACK_IMPORTED_MODULE_7__["default"])(value, this.min, this.max, this.allowedDates);\n        },\n        yearClick: function yearClick(value) {\n            this.inputYear = value;\n            if (this.type === \'month\') {\n                this.tableDate = "" + value;\n            } else {\n                this.tableDate = value + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_6__["pad"])(this.tableMonth + 1);\n            }\n            this.activePicker = \'MONTH\';\n            this.reactive && !this.multiple && this.isDateAllowed(this.inputDate) && this.$emit(\'input\', this.inputDate);\n        },\n        monthClick: function monthClick(value) {\n            this.inputYear = parseInt(value.split(\'-\')[0], 10);\n            this.inputMonth = parseInt(value.split(\'-\')[1], 10) - 1;\n            if (this.type === \'date\') {\n                this.tableDate = value;\n                this.activePicker = \'DATE\';\n                this.reactive && !this.multiple && this.isDateAllowed(this.inputDate) && this.$emit(\'input\', this.inputDate);\n            } else {\n                this.emitInput(this.inputDate);\n            }\n        },\n        dateClick: function dateClick(value) {\n            this.inputYear = parseInt(value.split(\'-\')[0], 10);\n            this.inputMonth = parseInt(value.split(\'-\')[1], 10) - 1;\n            this.inputDay = parseInt(value.split(\'-\')[2], 10);\n            this.emitInput(this.inputDate);\n        },\n        genPickerTitle: function genPickerTitle() {\n            var _this = this;\n            return this.$createElement(_VDatePickerTitle__WEBPACK_IMPORTED_MODULE_0__["default"], {\n                props: {\n                    date: this.value ? this.formatters.titleDate(this.value) : \'\',\n                    selectingYear: this.activePicker === \'YEAR\',\n                    year: this.formatters.year("" + this.inputYear),\n                    yearIcon: this.yearIcon,\n                    value: this.multiple ? this.value[0] : this.value\n                },\n                slot: \'title\',\n                style: this.readonly ? {\n                    \'pointer-events\': \'none\'\n                } : undefined,\n                on: {\n                    \'update:selectingYear\': function updateSelectingYear(value) {\n                        return _this.activePicker = value ? \'YEAR\' : _this.type.toUpperCase();\n                    }\n                }\n            });\n        },\n        genTableHeader: function genTableHeader() {\n            var _this = this;\n            return this.$createElement(_VDatePickerHeader__WEBPACK_IMPORTED_MODULE_1__["default"], {\n                props: {\n                    nextIcon: this.nextIcon,\n                    color: this.color,\n                    dark: this.dark,\n                    disabled: this.readonly,\n                    format: this.headerDateFormat,\n                    light: this.light,\n                    locale: this.locale,\n                    min: this.activePicker === \'DATE\' ? this.minMonth : this.minYear,\n                    max: this.activePicker === \'DATE\' ? this.maxMonth : this.maxYear,\n                    prevIcon: this.prevIcon,\n                    value: this.activePicker === \'DATE\' ? this.tableYear + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_6__["pad"])(this.tableMonth + 1) : "" + this.tableYear\n                },\n                on: {\n                    toggle: function toggle() {\n                        return _this.activePicker = _this.activePicker === \'DATE\' ? \'MONTH\' : \'YEAR\';\n                    },\n                    input: function input(value) {\n                        return _this.tableDate = value;\n                    }\n                }\n            });\n        },\n        genDateTable: function genDateTable() {\n            var _this = this;\n            return this.$createElement(_VDatePickerDateTable__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                props: {\n                    allowedDates: this.allowedDates,\n                    color: this.color,\n                    current: this.current,\n                    dark: this.dark,\n                    disabled: this.readonly,\n                    events: this.events,\n                    eventColor: this.eventColor,\n                    firstDayOfWeek: this.firstDayOfWeek,\n                    format: this.dayFormat,\n                    light: this.light,\n                    locale: this.locale,\n                    min: this.min,\n                    max: this.max,\n                    tableDate: this.tableYear + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_6__["pad"])(this.tableMonth + 1),\n                    scrollable: this.scrollable,\n                    value: this.value,\n                    weekdayFormat: this.weekdayFormat\n                },\n                ref: \'table\',\n                on: {\n                    input: this.dateClick,\n                    tableDate: function tableDate(value) {\n                        return _this.tableDate = value;\n                    }\n                }\n            });\n        },\n        genMonthTable: function genMonthTable() {\n            var _this = this;\n            return this.$createElement(_VDatePickerMonthTable__WEBPACK_IMPORTED_MODULE_3__["default"], {\n                props: {\n                    allowedDates: this.type === \'month\' ? this.allowedDates : null,\n                    color: this.color,\n                    current: this.current ? this.sanitizeDateString(this.current, \'month\') : null,\n                    dark: this.dark,\n                    disabled: this.readonly,\n                    format: this.monthFormat,\n                    light: this.light,\n                    locale: this.locale,\n                    min: this.minMonth,\n                    max: this.maxMonth,\n                    scrollable: this.scrollable,\n                    value: this.selectedMonths,\n                    tableDate: "" + this.tableYear\n                },\n                ref: \'table\',\n                on: {\n                    input: this.monthClick,\n                    tableDate: function tableDate(value) {\n                        return _this.tableDate = value;\n                    }\n                }\n            });\n        },\n        genYears: function genYears() {\n            return this.$createElement(_VDatePickerYears__WEBPACK_IMPORTED_MODULE_4__["default"], {\n                props: {\n                    color: this.color,\n                    format: this.yearFormat,\n                    locale: this.locale,\n                    min: this.minYear,\n                    max: this.maxYear,\n                    value: "" + this.tableYear\n                },\n                on: {\n                    input: this.yearClick\n                }\n            });\n        },\n        genPickerBody: function genPickerBody() {\n            var children = this.activePicker === \'YEAR\' ? [this.genYears()] : [this.genTableHeader(), this.activePicker === \'DATE\' ? this.genDateTable() : this.genMonthTable()];\n            return this.$createElement(\'div\', {\n                key: this.activePicker,\n                style: this.readonly ? {\n                    \'pointer-events\': \'none\'\n                } : undefined\n            }, children);\n        },\n        // Adds leading zero to month/day if necessary, returns \'YYYY\' if type = \'year\',\n        // \'YYYY-MM\' if \'month\' and \'YYYY-MM-DD\' if \'date\'\n        sanitizeDateString: function sanitizeDateString(dateString, type) {\n            var _a = __read(dateString.split(\'-\'), 3),\n                year = _a[0],\n                _b = _a[1],\n                month = _b === void 0 ? 1 : _b,\n                _c = _a[2],\n                date = _c === void 0 ? 1 : _c;\n            return (year + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_6__["pad"])(month) + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_6__["pad"])(date)).substr(0, { date: 10, month: 7, year: 4 }[type]);\n        },\n        setInputDate: function setInputDate() {\n            if (this.lastValue) {\n                var array = this.lastValue.split(\'-\');\n                this.inputYear = parseInt(array[0], 10);\n                this.inputMonth = parseInt(array[1], 10) - 1;\n                if (this.type === \'date\') {\n                    this.inputDay = parseInt(array[2], 10);\n                }\n            } else {\n                this.inputYear = this.inputYear || this.now.getFullYear();\n                this.inputMonth = this.inputMonth == null ? this.inputMonth : this.now.getMonth();\n                this.inputDay = this.inputDay || this.now.getDate();\n            }\n        }\n    },\n    render: function render() {\n        return this.genPicker(\'v-picker--date\');\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/VDatePickerDateTable.js":\n/*!************************************************************!*\\\n  !*** ./src/components/VDatePicker/VDatePickerDateTable.js ***!\n  \\************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_date_picker_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mixins/date-picker-table */ "./src/components/VDatePicker/mixins/date-picker-table.js");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./src/components/VDatePicker/util/index.js");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n// Mixins\n\n\n\n// Utils\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-date-picker-date-table\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_0__["default"], _mixins_date_picker_table__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        events: {\n            type: [Array, Object, Function],\n            default: function _default() {\n                return null;\n            }\n        },\n        eventColor: {\n            type: [String, Function, Object],\n            default: \'warning\'\n        },\n        firstDayOfWeek: {\n            type: [String, Number],\n            default: 0\n        },\n        weekdayFormat: {\n            type: Function,\n            default: null\n        }\n    },\n    computed: {\n        formatter: function formatter() {\n            return this.format || Object(_util__WEBPACK_IMPORTED_MODULE_3__["createNativeLocaleFormatter"])(this.locale, { day: \'numeric\', timeZone: \'UTC\' }, { start: 8, length: 2 });\n        },\n        weekdayFormatter: function weekdayFormatter() {\n            return this.weekdayFormat || Object(_util__WEBPACK_IMPORTED_MODULE_3__["createNativeLocaleFormatter"])(this.locale, { weekday: \'narrow\', timeZone: \'UTC\' });\n        },\n        weekDays: function weekDays() {\n            var _this = this;\n            var first = parseInt(this.firstDayOfWeek, 10);\n            return this.weekdayFormatter ? Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["createRange"])(7).map(function (i) {\n                return _this.weekdayFormatter("2017-01-" + (first + i + 15));\n            }) // 2017-01-15 is Sunday\n            : Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["createRange"])(7).map(function (i) {\n                return [\'S\', \'M\', \'T\', \'W\', \'T\', \'F\', \'S\'][(i + first) % 7];\n            });\n        }\n    },\n    methods: {\n        calculateTableDate: function calculateTableDate(delta) {\n            return Object(_util__WEBPACK_IMPORTED_MODULE_3__["monthChange"])(this.tableDate, Math.sign(delta || 1));\n        },\n        genTHead: function genTHead() {\n            var _this = this;\n            var days = this.weekDays.map(function (day) {\n                return _this.$createElement(\'th\', day);\n            });\n            return this.$createElement(\'thead\', this.genTR(days));\n        },\n        genEvent: function genEvent(date) {\n            var eventColor;\n            if (typeof this.eventColor === \'string\') {\n                eventColor = this.eventColor;\n            } else if (typeof this.eventColor === \'function\') {\n                eventColor = this.eventColor(date);\n            } else {\n                eventColor = this.eventColor[date];\n            }\n            return this.$createElement(\'div\', this.setBackgroundColor(eventColor || this.color || \'accent\', {\n                staticClass: \'v-date-picker-table__event\'\n            }));\n        },\n        // Returns number of the days from the firstDayOfWeek to the first day of the current month\n        weekDaysBeforeFirstDayOfTheMonth: function weekDaysBeforeFirstDayOfTheMonth() {\n            var firstDayOfTheMonth = new Date(this.displayedYear + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_3__["pad"])(this.displayedMonth + 1) + "-01T00:00:00+00:00");\n            var weekDay = firstDayOfTheMonth.getUTCDay();\n            return (weekDay - parseInt(this.firstDayOfWeek) + 7) % 7;\n        },\n        isEvent: function isEvent(date) {\n            if (Array.isArray(this.events)) {\n                return this.events.indexOf(date) > -1;\n            } else if (this.events instanceof Function) {\n                return this.events(date);\n            } else {\n                return false;\n            }\n        },\n        genTBody: function genTBody() {\n            var children = [];\n            var daysInMonth = new Date(this.displayedYear, this.displayedMonth + 1, 0).getDate();\n            var rows = [];\n            var day = this.weekDaysBeforeFirstDayOfTheMonth();\n            while (day--) {\n                rows.push(this.$createElement(\'td\'));\n            }for (day = 1; day <= daysInMonth; day++) {\n                var date = this.displayedYear + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_3__["pad"])(this.displayedMonth + 1) + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_3__["pad"])(day);\n                rows.push(this.$createElement(\'td\', [this.genButton(date, true), this.isEvent(date) ? this.genEvent(date) : null]));\n                if (rows.length % 7 === 0) {\n                    children.push(this.genTR(rows));\n                    rows = [];\n                }\n            }\n            if (rows.length) {\n                children.push(this.genTR(rows));\n            }\n            return this.$createElement(\'tbody\', children);\n        },\n        genTR: function genTR(children) {\n            return [this.$createElement(\'tr\', children)];\n        }\n    },\n    render: function render() {\n        return this.genTable(\'v-date-picker-table v-date-picker-table--date\', [this.genTHead(), this.genTBody()]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/VDatePickerHeader.js":\n/*!*********************************************************!*\\\n  !*** ./src/components/VDatePicker/VDatePickerHeader.js ***!\n  \\*********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_date_picker_header_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_date-picker-header.styl */ "./src/stylus/components/_date-picker-header.styl");\n/* harmony import */ var _stylus_components_date_picker_header_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_date_picker_header_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VBtn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VBtn */ "./src/components/VBtn/index.ts");\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./src/components/VDatePicker/util/index.js");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\n\n// Components\n\n\n// Mixins\n\n\n// Utils\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-date-picker-header\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_4__["default"]],\n    props: {\n        disabled: Boolean,\n        format: {\n            type: Function,\n            default: null\n        },\n        locale: {\n            type: String,\n            default: \'en-us\'\n        },\n        min: String,\n        max: String,\n        nextIcon: {\n            type: String,\n            default: \'$vuetify.icons.next\'\n        },\n        prevIcon: {\n            type: String,\n            default: \'$vuetify.icons.prev\'\n        },\n        value: {\n            type: [Number, String],\n            required: true\n        }\n    },\n    data: function data() {\n        return {\n            isReversing: false\n        };\n    },\n    computed: {\n        formatter: function formatter() {\n            if (this.format) {\n                return this.format;\n            } else if (String(this.value).split(\'-\')[1]) {\n                return Object(_util__WEBPACK_IMPORTED_MODULE_5__["createNativeLocaleFormatter"])(this.locale, { month: \'long\', year: \'numeric\', timeZone: \'UTC\' }, { length: 7 });\n            } else {\n                return Object(_util__WEBPACK_IMPORTED_MODULE_5__["createNativeLocaleFormatter"])(this.locale, { year: \'numeric\', timeZone: \'UTC\' }, { length: 4 });\n            }\n        }\n    },\n    watch: {\n        value: function value(newVal, oldVal) {\n            this.isReversing = newVal < oldVal;\n        }\n    },\n    methods: {\n        genBtn: function genBtn(change) {\n            var _this = this;\n            var disabled = this.disabled || change < 0 && this.min && this.calculateChange(change) < this.min || change > 0 && this.max && this.calculateChange(change) > this.max;\n            return this.$createElement(_VBtn__WEBPACK_IMPORTED_MODULE_1__["default"], {\n                props: {\n                    dark: this.dark,\n                    disabled: disabled,\n                    icon: true,\n                    light: this.light\n                },\n                nativeOn: {\n                    click: function click(e) {\n                        e.stopPropagation();\n                        _this.$emit(\'input\', _this.calculateChange(change));\n                    }\n                }\n            }, [this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_2__["default"], change < 0 === !this.$vuetify.rtl ? this.prevIcon : this.nextIcon)]);\n        },\n        calculateChange: function calculateChange(sign) {\n            var _a = __read(String(this.value).split(\'-\').map(function (v) {\n                return 1 * v;\n            }), 2),\n                year = _a[0],\n                month = _a[1];\n            if (month == null) {\n                return "" + (year + sign);\n            } else {\n                return Object(_util__WEBPACK_IMPORTED_MODULE_5__["monthChange"])(String(this.value), sign);\n            }\n        },\n        genHeader: function genHeader() {\n            var _this = this;\n            var color = !this.disabled && (this.color || \'accent\');\n            var header = this.$createElement(\'strong\', this.setTextColor(color, {\n                key: String(this.value),\n                on: {\n                    click: function click() {\n                        return _this.$emit(\'toggle\');\n                    }\n                }\n            }), [this.$slots.default || this.formatter(String(this.value))]);\n            var transition = this.$createElement(\'transition\', {\n                props: {\n                    name: this.isReversing === !this.$vuetify.rtl ? \'tab-reverse-transition\' : \'tab-transition\'\n                }\n            }, [header]);\n            return this.$createElement(\'div\', {\n                staticClass: \'v-date-picker-header__value\',\n                class: {\n                    \'v-date-picker-header__value--disabled\': this.disabled\n                }\n            }, [transition]);\n        }\n    },\n    render: function render() {\n        return this.$createElement(\'div\', {\n            staticClass: \'v-date-picker-header\',\n            class: this.themeClasses\n        }, [this.genBtn(-1), this.genHeader(), this.genBtn(+1)]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/VDatePickerMonthTable.js":\n/*!*************************************************************!*\\\n  !*** ./src/components/VDatePicker/VDatePickerMonthTable.js ***!\n  \\*************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_date_picker_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mixins/date-picker-table */ "./src/components/VDatePicker/mixins/date-picker-table.js");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./src/components/VDatePicker/util/index.js");\n// Mixins\n\n\n\n// Utils\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-date-picker-month-table\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_0__["default"], _mixins_date_picker_table__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    computed: {\n        formatter: function formatter() {\n            return this.format || Object(_util__WEBPACK_IMPORTED_MODULE_3__["createNativeLocaleFormatter"])(this.locale, { month: \'short\', timeZone: \'UTC\' }, { start: 5, length: 2 });\n        }\n    },\n    methods: {\n        calculateTableDate: function calculateTableDate(delta) {\n            return "" + (parseInt(this.tableDate, 10) + Math.sign(delta || 1));\n        },\n        genTBody: function genTBody() {\n            var _this = this;\n            var children = [];\n            var cols = Array(3).fill(null);\n            var rows = 12 / cols.length;\n            var _loop_1 = function _loop_1(row) {\n                var tds = cols.map(function (_, col) {\n                    var month = row * cols.length + col;\n                    return _this.$createElement(\'td\', {\n                        key: month\n                    }, [_this.genButton(_this.displayedYear + "-" + Object(_util__WEBPACK_IMPORTED_MODULE_3__["pad"])(month + 1), false)]);\n                });\n                children.push(this_1.$createElement(\'tr\', {\n                    key: row\n                }, tds));\n            };\n            var this_1 = this;\n            for (var row = 0; row < rows; row++) {\n                _loop_1(row);\n            }\n            return this.$createElement(\'tbody\', children);\n        }\n    },\n    render: function render() {\n        return this.genTable(\'v-date-picker-table v-date-picker-table--month\', [this.genTBody()]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/VDatePickerTitle.js":\n/*!********************************************************!*\\\n  !*** ./src/components/VDatePicker/VDatePickerTitle.js ***!\n  \\********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_date_picker_title_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_date-picker-title.styl */ "./src/stylus/components/_date-picker-title.styl");\n/* harmony import */ var _stylus_components_date_picker_title_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_date_picker_title_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _mixins_picker_button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/picker-button */ "./src/mixins/picker-button.js");\n\n// Components\n\n// Mixins\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-date-picker-title\',\n    mixins: [_mixins_picker_button__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        date: {\n            type: String,\n            default: \'\'\n        },\n        selectingYear: Boolean,\n        year: {\n            type: [Number, String],\n            default: \'\'\n        },\n        yearIcon: {\n            type: String\n        },\n        value: {\n            type: String\n        }\n    },\n    data: function data() {\n        return {\n            isReversing: false\n        };\n    },\n    computed: {\n        computedTransition: function computedTransition() {\n            return this.isReversing ? \'picker-reverse-transition\' : \'picker-transition\';\n        }\n    },\n    watch: {\n        value: function value(val, prev) {\n            this.isReversing = val < prev;\n        }\n    },\n    methods: {\n        genYearIcon: function genYearIcon() {\n            return this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], {\n                props: {\n                    dark: true\n                }\n            }, this.yearIcon);\n        },\n        getYearBtn: function getYearBtn() {\n            return this.genPickerButton(\'selectingYear\', true, [this.year, this.yearIcon ? this.genYearIcon() : null], false, \'v-date-picker-title__year\');\n        },\n        genTitleText: function genTitleText() {\n            return this.$createElement(\'transition\', {\n                props: {\n                    name: this.computedTransition\n                }\n            }, [this.$createElement(\'div\', {\n                domProps: { innerHTML: this.date || \'&nbsp;\' },\n                key: this.value\n            })]);\n        },\n        genTitleDate: function genTitleDate(title) {\n            return this.genPickerButton(\'selectingYear\', false, this.genTitleText(title), false, \'v-date-picker-title__date\');\n        }\n    },\n    render: function render(h) {\n        return h(\'div\', {\n            staticClass: \'v-date-picker-title\'\n        }, [this.getYearBtn(), this.genTitleDate()]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/VDatePickerYears.js":\n/*!********************************************************!*\\\n  !*** ./src/components/VDatePicker/VDatePickerYears.js ***!\n  \\********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_date_picker_years_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_date-picker-years.styl */ "./src/stylus/components/_date-picker-years.styl");\n/* harmony import */ var _stylus_components_date_picker_years_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_date_picker_years_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./src/components/VDatePicker/util/index.js");\n\n// Mixins\n\n// Utils\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-date-picker-years\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"]],\n    props: {\n        format: {\n            type: Function,\n            default: null\n        },\n        locale: {\n            type: String,\n            default: \'en-us\'\n        },\n        min: [Number, String],\n        max: [Number, String],\n        value: [Number, String]\n    },\n    data: function data() {\n        return {\n            defaultColor: \'primary\'\n        };\n    },\n    computed: {\n        formatter: function formatter() {\n            return this.format || Object(_util__WEBPACK_IMPORTED_MODULE_2__["createNativeLocaleFormatter"])(this.locale, { year: \'numeric\', timeZone: \'UTC\' }, { length: 4 });\n        }\n    },\n    mounted: function mounted() {\n        var activeItem = this.$el.getElementsByClassName(\'active\')[0];\n        if (activeItem) {\n            this.$el.scrollTop = activeItem.offsetTop - this.$el.offsetHeight / 2 + activeItem.offsetHeight / 2;\n        } else {\n            this.$el.scrollTop = this.$el.scrollHeight / 2 - this.$el.offsetHeight / 2;\n        }\n    },\n    methods: {\n        genYearItem: function genYearItem(year) {\n            var _this = this;\n            var formatted = this.formatter("" + year);\n            var active = parseInt(this.value, 10) === year;\n            var color = active && (this.color || \'primary\');\n            return this.$createElement(\'li\', this.setTextColor(color, {\n                key: year,\n                \'class\': { active: active },\n                on: {\n                    click: function click() {\n                        return _this.$emit(\'input\', year);\n                    }\n                }\n            }), formatted);\n        },\n        genYearItems: function genYearItems() {\n            var children = [];\n            var selectedYear = this.value ? parseInt(this.value, 10) : new Date().getFullYear();\n            var maxYear = this.max ? parseInt(this.max, 10) : selectedYear + 100;\n            var minYear = Math.min(maxYear, this.min ? parseInt(this.min, 10) : selectedYear - 100);\n            for (var year = maxYear; year >= minYear; year--) {\n                children.push(this.genYearItem(year));\n            }\n            return children;\n        }\n    },\n    render: function render() {\n        return this.$createElement(\'ul\', {\n            staticClass: \'v-date-picker-years\',\n            ref: \'years\'\n        }, this.genYearItems());\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/index.js":\n/*!*********************************************!*\\\n  !*** ./src/components/VDatePicker/index.js ***!\n  \\*********************************************/\n/*! exports provided: VDatePicker, VDatePickerTitle, VDatePickerHeader, VDatePickerDateTable, VDatePickerMonthTable, VDatePickerYears, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VDatePicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VDatePicker */ "./src/components/VDatePicker/VDatePicker.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePicker", function() { return _VDatePicker__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _VDatePickerTitle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VDatePickerTitle */ "./src/components/VDatePicker/VDatePickerTitle.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePickerTitle", function() { return _VDatePickerTitle__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _VDatePickerHeader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VDatePickerHeader */ "./src/components/VDatePicker/VDatePickerHeader.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePickerHeader", function() { return _VDatePickerHeader__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _VDatePickerDateTable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VDatePickerDateTable */ "./src/components/VDatePicker/VDatePickerDateTable.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePickerDateTable", function() { return _VDatePickerDateTable__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n/* harmony import */ var _VDatePickerMonthTable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VDatePickerMonthTable */ "./src/components/VDatePicker/VDatePickerMonthTable.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePickerMonthTable", function() { return _VDatePickerMonthTable__WEBPACK_IMPORTED_MODULE_4__["default"]; });\n\n/* harmony import */ var _VDatePickerYears__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./VDatePickerYears */ "./src/components/VDatePicker/VDatePickerYears.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePickerYears", function() { return _VDatePickerYears__WEBPACK_IMPORTED_MODULE_5__["default"]; });\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VDatePicker: _VDatePicker__WEBPACK_IMPORTED_MODULE_0__["default"],\n        VDatePickerTitle: _VDatePickerTitle__WEBPACK_IMPORTED_MODULE_1__["default"],\n        VDatePickerHeader: _VDatePickerHeader__WEBPACK_IMPORTED_MODULE_2__["default"],\n        VDatePickerDateTable: _VDatePickerDateTable__WEBPACK_IMPORTED_MODULE_3__["default"],\n        VDatePickerMonthTable: _VDatePickerMonthTable__WEBPACK_IMPORTED_MODULE_4__["default"],\n        VDatePickerYears: _VDatePickerYears__WEBPACK_IMPORTED_MODULE_5__["default"]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/mixins/date-picker-table.js":\n/*!****************************************************************!*\\\n  !*** ./src/components/VDatePicker/mixins/date-picker-table.js ***!\n  \\****************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_date_picker_table_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../stylus/components/_date-picker-table.styl */ "./src/stylus/components/_date-picker-table.styl");\n/* harmony import */ var _stylus_components_date_picker_table_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_date_picker_table_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _directives_touch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../directives/touch */ "./src/directives/touch.ts");\n/* harmony import */ var _util_isDateAllowed__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! .././util/isDateAllowed */ "./src/components/VDatePicker/util/isDateAllowed.js");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n// Directives\n\n// Utils\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    directives: { Touch: _directives_touch__WEBPACK_IMPORTED_MODULE_1__["default"] },\n    props: {\n        allowedDates: Function,\n        current: String,\n        disabled: Boolean,\n        format: {\n            type: Function,\n            default: null\n        },\n        locale: {\n            type: String,\n            default: \'en-us\'\n        },\n        min: String,\n        max: String,\n        scrollable: Boolean,\n        tableDate: {\n            type: String,\n            required: true\n        },\n        value: [String, Array]\n    },\n    data: function data() {\n        return {\n            isReversing: false\n        };\n    },\n    computed: {\n        computedTransition: function computedTransition() {\n            return this.isReversing === !this.$vuetify.rtl ? \'tab-reverse-transition\' : \'tab-transition\';\n        },\n        displayedMonth: function displayedMonth() {\n            return this.tableDate.split(\'-\')[1] - 1;\n        },\n        displayedYear: function displayedYear() {\n            return this.tableDate.split(\'-\')[0] * 1;\n        }\n    },\n    watch: {\n        tableDate: function tableDate(newVal, oldVal) {\n            this.isReversing = newVal < oldVal;\n        }\n    },\n    methods: {\n        genButtonClasses: function genButtonClasses(isAllowed, isFloating, isSelected, isCurrent) {\n            return __assign({ \'v-btn--active\': isSelected, \'v-btn--flat\': !isSelected, \'v-btn--icon\': isSelected && isAllowed && isFloating, \'v-btn--floating\': isFloating, \'v-btn--depressed\': !isFloating && isSelected, \'v-btn--disabled\': !isAllowed || this.disabled && isSelected, \'v-btn--outline\': isCurrent && !isSelected }, this.themeClasses);\n        },\n        genButton: function genButton(value, isFloating) {\n            var _this = this;\n            var isAllowed = Object(_util_isDateAllowed__WEBPACK_IMPORTED_MODULE_2__["default"])(value, this.min, this.max, this.allowedDates);\n            var isSelected = value === this.value || Array.isArray(this.value) && this.value.indexOf(value) !== -1;\n            var isCurrent = value === this.current;\n            var setColor = isSelected ? this.setBackgroundColor : this.setTextColor;\n            var color = (isSelected || isCurrent) && (this.color || \'accent\');\n            return this.$createElement(\'button\', setColor(color, {\n                staticClass: \'v-btn\',\n                \'class\': this.genButtonClasses(isAllowed, isFloating, isSelected, isCurrent),\n                attrs: {\n                    type: \'button\'\n                },\n                domProps: {\n                    disabled: !isAllowed,\n                    innerHTML: "<div class=\\"v-btn__content\\">" + this.formatter(value) + "</div>"\n                },\n                on: this.disabled || !isAllowed ? {} : {\n                    click: function click() {\n                        return _this.$emit(\'input\', value);\n                    }\n                }\n            }));\n        },\n        wheel: function wheel(e) {\n            e.preventDefault();\n            this.$emit(\'tableDate\', this.calculateTableDate(e.deltaY));\n        },\n        touch: function touch(value) {\n            this.$emit(\'tableDate\', this.calculateTableDate(value));\n        },\n        genTable: function genTable(staticClass, children) {\n            var _this = this;\n            var transition = this.$createElement(\'transition\', {\n                props: { name: this.computedTransition }\n            }, [this.$createElement(\'table\', { key: this.tableDate }, children)]);\n            var touchDirective = {\n                name: \'touch\',\n                value: {\n                    left: function left(e) {\n                        return e.offsetX < -15 && _this.touch(1);\n                    },\n                    right: function right(e) {\n                        return e.offsetX > 15 && _this.touch(-1);\n                    }\n                }\n            };\n            return this.$createElement(\'div\', {\n                staticClass: staticClass,\n                class: this.themeClasses,\n                on: this.scrollable ? { wheel: this.wheel } : undefined,\n                directives: [touchDirective]\n            }, [transition]);\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/util/createNativeLocaleFormatter.js":\n/*!************************************************************************!*\\\n  !*** ./src/components/VDatePicker/util/createNativeLocaleFormatter.js ***!\n  \\************************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pad */ "./src/components/VDatePicker/util/pad.js");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (function (locale, options, _a) {\n    var _b = _a === void 0 ? { start: 0, length: 0 } : _a,\n        start = _b.start,\n        length = _b.length;\n    var makeIsoString = function makeIsoString(dateString) {\n        var _a = __read(dateString.trim().split(\' \')[0].split(\'-\'), 3),\n            year = _a[0],\n            month = _a[1],\n            date = _a[2];\n        return [year, Object(_pad__WEBPACK_IMPORTED_MODULE_0__["default"])(month || 1), Object(_pad__WEBPACK_IMPORTED_MODULE_0__["default"])(date || 1)].join(\'-\');\n    };\n    try {\n        var intlFormatter_1 = new Intl.DateTimeFormat(locale || undefined, options);\n        return function (dateString) {\n            return intlFormatter_1.format(new Date(makeIsoString(dateString) + "T00:00:00+00:00"));\n        };\n    } catch (e) {\n        return start || length ? function (dateString) {\n            return makeIsoString(dateString).substr(start, length);\n        } : null;\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/util/index.js":\n/*!**************************************************!*\\\n  !*** ./src/components/VDatePicker/util/index.js ***!\n  \\**************************************************/\n/*! exports provided: createNativeLocaleFormatter, monthChange, pad */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createNativeLocaleFormatter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createNativeLocaleFormatter */ "./src/components/VDatePicker/util/createNativeLocaleFormatter.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createNativeLocaleFormatter", function() { return _createNativeLocaleFormatter__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _monthChange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./monthChange */ "./src/components/VDatePicker/util/monthChange.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "monthChange", function() { return _monthChange__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _pad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pad */ "./src/components/VDatePicker/util/pad.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pad", function() { return _pad__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n\n\n\n\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/util/isDateAllowed.js":\n/*!**********************************************************!*\\\n  !*** ./src/components/VDatePicker/util/isDateAllowed.js ***!\n  \\**********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isDateAllowed; });\nfunction isDateAllowed(date, min, max, allowedFn) {\n    return (!allowedFn || allowedFn(date)) && (!min || date >= min) && (!max || date <= max);\n}\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/util/monthChange.js":\n/*!********************************************************!*\\\n  !*** ./src/components/VDatePicker/util/monthChange.js ***!\n  \\********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pad */ "./src/components/VDatePicker/util/pad.js");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\n\n/**\n * @param {String} value YYYY-MM format\n * @param {Number} sign -1 or +1\n */\n/* harmony default export */ __webpack_exports__["default"] = (function (value, sign) {\n    var _a = __read(value.split(\'-\').map(function (v) {\n        return 1 * v;\n    }), 2),\n        year = _a[0],\n        month = _a[1];\n    if (month + sign === 0) {\n        return year - 1 + "-12";\n    } else if (month + sign === 13) {\n        return year + 1 + "-01";\n    } else {\n        return year + "-" + Object(_pad__WEBPACK_IMPORTED_MODULE_0__["default"])(month + sign);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDatePicker/util/pad.js":\n/*!************************************************!*\\\n  !*** ./src/components/VDatePicker/util/pad.js ***!\n  \\************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\nvar padStart = function padStart(string, targetLength, padString) {\n    targetLength = targetLength >> 0;\n    string = String(string);\n    padString = String(padString);\n    if (string.length > targetLength) {\n        return String(string);\n    }\n    targetLength = targetLength - string.length;\n    if (targetLength > padString.length) {\n        padString += padString.repeat(targetLength / padString.length);\n    }\n    return padString.slice(0, targetLength) + String(string);\n};\n/* harmony default export */ __webpack_exports__["default"] = (function (n, length) {\n    if (length === void 0) {\n        length = 2;\n    }\n    return padStart(n, length, \'0\');\n});\n\n/***/ }),\n\n/***/ "./src/components/VDialog/VDialog.js":\n/*!*******************************************!*\\\n  !*** ./src/components/VDialog/VDialog.js ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_dialogs_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_dialogs.styl */ "./src/stylus/components/_dialogs.styl");\n/* harmony import */ var _stylus_components_dialogs_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_dialogs_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_dependent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/dependent */ "./src/mixins/dependent.ts");\n/* harmony import */ var _mixins_detachable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/detachable */ "./src/mixins/detachable.js");\n/* harmony import */ var _mixins_overlayable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/overlayable */ "./src/mixins/overlayable.js");\n/* harmony import */ var _mixins_returnable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/returnable */ "./src/mixins/returnable.ts");\n/* harmony import */ var _mixins_stackable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/stackable */ "./src/mixins/stackable.js");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\n/* harmony import */ var _directives_click_outside__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../directives/click-outside */ "./src/directives/click-outside.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_ThemeProvider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/ThemeProvider */ "./src/util/ThemeProvider.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n// Mixins\n\n\n\n\n\n\n// Directives\n\n// Helpers\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-dialog\',\n    directives: {\n        ClickOutside: _directives_click_outside__WEBPACK_IMPORTED_MODULE_7__["default"]\n    },\n    mixins: [_mixins_dependent__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_detachable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_overlayable__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_returnable__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_stackable__WEBPACK_IMPORTED_MODULE_5__["default"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_6__["default"]],\n    props: {\n        disabled: Boolean,\n        persistent: Boolean,\n        fullscreen: Boolean,\n        fullWidth: Boolean,\n        noClickAnimation: Boolean,\n        light: Boolean,\n        dark: Boolean,\n        maxWidth: {\n            type: [String, Number],\n            default: \'none\'\n        },\n        origin: {\n            type: String,\n            default: \'center center\'\n        },\n        width: {\n            type: [String, Number],\n            default: \'auto\'\n        },\n        scrollable: Boolean,\n        transition: {\n            type: [String, Boolean],\n            default: \'dialog-transition\'\n        }\n    },\n    data: function data() {\n        return {\n            animate: false,\n            animateTimeout: null,\n            stackClass: \'v-dialog__content--active\',\n            stackMinZIndex: 200\n        };\n    },\n    computed: {\n        classes: function classes() {\n            var _a;\n            return _a = {}, _a[("v-dialog " + this.contentClass).trim()] = true, _a[\'v-dialog--active\'] = this.isActive, _a[\'v-dialog--persistent\'] = this.persistent, _a[\'v-dialog--fullscreen\'] = this.fullscreen, _a[\'v-dialog--scrollable\'] = this.scrollable, _a[\'v-dialog--animated\'] = this.animate, _a;\n        },\n        contentClasses: function contentClasses() {\n            return {\n                \'v-dialog__content\': true,\n                \'v-dialog__content--active\': this.isActive\n            };\n        }\n    },\n    watch: {\n        isActive: function isActive(val) {\n            if (val) {\n                this.show();\n            } else {\n                this.removeOverlay();\n                this.unbind();\n            }\n        },\n        fullscreen: function fullscreen(val) {\n            if (val) this.hideScroll();else this.showScroll();\n        }\n    },\n    mounted: function mounted() {\n        this.isBooted = this.isActive;\n        this.isActive && this.show();\n    },\n    beforeDestroy: function beforeDestroy() {\n        if (typeof window !== \'undefined\') this.unbind();\n    },\n    methods: {\n        animateClick: function animateClick() {\n            var _this = this;\n            this.animate = false;\n            // Needed for when clicking very fast\n            // outside of the dialog\n            this.$nextTick(function () {\n                _this.animate = true;\n                clearTimeout(_this.animateTimeout);\n                _this.animateTimeout = setTimeout(function () {\n                    return _this.animate = false;\n                }, 150);\n            });\n        },\n        closeConditional: function closeConditional(e) {\n            // If the dialog content contains\n            // the click event, or if the\n            // dialog is not active\n            if (this.$refs.content.contains(e.target) || !this.isActive) return false;\n            // If we made it here, the click is outside\n            // and is active. If persistent, and the\n            // click is on the overlay, animate\n            if (this.persistent) {\n                if (!this.noClickAnimation && this.overlay === e.target) this.animateClick();\n                return false;\n            }\n            // close dialog if !persistent, clicked outside and we\'re the topmost dialog.\n            // Since this should only be called in a capture event (bottom up), we shouldn\'t need to stop propagation\n            return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_8__["getZIndex"])(this.$refs.content) >= this.getMaxZIndex();\n        },\n        hideScroll: function hideScroll() {\n            if (this.fullscreen) {\n                document.documentElement.classList.add(\'overflow-y-hidden\');\n            } else {\n                _mixins_overlayable__WEBPACK_IMPORTED_MODULE_3__["default"].methods.hideScroll.call(this);\n            }\n        },\n        show: function show() {\n            !this.fullscreen && !this.hideOverlay && this.genOverlay();\n            this.fullscreen && this.hideScroll();\n            this.$refs.content.focus();\n            this.$listeners.keydown && this.bind();\n        },\n        bind: function bind() {\n            window.addEventListener(\'keydown\', this.onKeydown);\n        },\n        unbind: function unbind() {\n            window.removeEventListener(\'keydown\', this.onKeydown);\n        },\n        onKeydown: function onKeydown(e) {\n            this.$emit(\'keydown\', e);\n        }\n    },\n    render: function render(h) {\n        var _this = this;\n        var children = [];\n        var data = {\n            \'class\': this.classes,\n            ref: \'dialog\',\n            directives: [{\n                name: \'click-outside\',\n                value: function value() {\n                    return _this.isActive = false;\n                },\n                args: {\n                    closeConditional: this.closeConditional,\n                    include: this.getOpenDependentElements\n                }\n            }, { name: \'show\', value: this.isActive }],\n            on: {\n                click: function click(e) {\n                    e.stopPropagation();\n                }\n            }\n        };\n        if (!this.fullscreen) {\n            data.style = {\n                maxWidth: this.maxWidth === \'none\' ? undefined : Object(_util_helpers__WEBPACK_IMPORTED_MODULE_8__["convertToUnit"])(this.maxWidth),\n                width: this.width === \'auto\' ? undefined : Object(_util_helpers__WEBPACK_IMPORTED_MODULE_8__["convertToUnit"])(this.width)\n            };\n        }\n        if (this.$slots.activator) {\n            children.push(h(\'div\', {\n                staticClass: \'v-dialog__activator\',\n                \'class\': {\n                    \'v-dialog__activator--disabled\': this.disabled\n                },\n                on: {\n                    click: function click(e) {\n                        e.stopPropagation();\n                        if (!_this.disabled) _this.isActive = !_this.isActive;\n                    }\n                }\n            }, [this.$slots.activator]));\n        }\n        var dialog = h(\'div\', data, this.showLazyContent(this.$slots.default));\n        if (this.transition) {\n            dialog = h(\'transition\', {\n                props: {\n                    name: this.transition,\n                    origin: this.origin\n                }\n            }, [dialog]);\n        }\n        children.push(h(\'div\', {\n            \'class\': this.contentClasses,\n            attrs: __assign({ tabIndex: \'-1\' }, this.getScopeIdAttrs()),\n            style: { zIndex: this.activeZIndex },\n            ref: \'content\'\n        }, [this.$createElement(_util_ThemeProvider__WEBPACK_IMPORTED_MODULE_9__["default"], {\n            props: {\n                root: true,\n                light: this.light,\n                dark: this.dark\n            }\n        }, [dialog])]));\n        return h(\'div\', {\n            staticClass: \'v-dialog__container\',\n            style: {\n                display: !this.$slots.activator || this.fullWidth ? \'block\' : \'inline-block\'\n            }\n        }, children);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VDialog/index.js":\n/*!*****************************************!*\\\n  !*** ./src/components/VDialog/index.js ***!\n  \\*****************************************/\n/*! exports provided: VDialog, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VDialog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VDialog */ "./src/components/VDialog/VDialog.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDialog", function() { return _VDialog__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VDialog__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VDivider/VDivider.ts":\n/*!*********************************************!*\\\n  !*** ./src/components/VDivider/VDivider.ts ***!\n  \\*********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_dividers_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_dividers.styl */ "./src/stylus/components/_dividers.styl");\n/* harmony import */ var _stylus_components_dividers_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_dividers_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Mixins\n\n/* harmony default export */ __webpack_exports__["default"] = (_mixins_themeable__WEBPACK_IMPORTED_MODULE_1__["default"].extend({\n    name: \'v-divider\',\n    props: {\n        inset: Boolean,\n        vertical: Boolean\n    },\n    render: function render(h) {\n        return h(\'hr\', {\n            class: __assign({ \'v-divider\': true, \'v-divider--inset\': this.inset, \'v-divider--vertical\': this.vertical }, this.themeClasses),\n            attrs: this.$attrs,\n            on: this.$listeners\n        });\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VDivider/index.ts":\n/*!******************************************!*\\\n  !*** ./src/components/VDivider/index.ts ***!\n  \\******************************************/\n/*! exports provided: VDivider, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VDivider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VDivider */ "./src/components/VDivider/VDivider.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDivider", function() { return _VDivider__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VDivider__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VExpansionPanel/VExpansionPanel.ts":\n/*!***********************************************************!*\\\n  !*** ./src/components/VExpansionPanel/VExpansionPanel.ts ***!\n  \\***********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_expansion_panel_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_expansion-panel.styl */ "./src/stylus/components/_expansion-panel.styl");\n/* harmony import */ var _stylus_components_expansion_panel_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_expansion_panel_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_3__["default"])(_mixins_themeable__WEBPACK_IMPORTED_MODULE_1__["default"], Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_2__["provide"])(\'expansionPanel\')).extend({\n    name: \'v-expansion-panel\',\n    provide: function provide() {\n        return {\n            expansionPanel: this\n        };\n    },\n    props: {\n        disabled: Boolean,\n        readonly: Boolean,\n        expand: Boolean,\n        focusable: Boolean,\n        inset: Boolean,\n        popout: Boolean,\n        value: {\n            type: [Number, Array],\n            default: function _default() {\n                return null;\n            }\n        }\n    },\n    data: function data() {\n        return {\n            items: [],\n            open: []\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-expansion-panel--focusable\': this.focusable, \'v-expansion-panel--popout\': this.popout, \'v-expansion-panel--inset\': this.inset }, this.themeClasses);\n        }\n    },\n    watch: {\n        expand: function expand(v) {\n            var openIndex = -1;\n            if (!v) {\n                // Close all panels unless only one is open\n                var openCount = this.open.reduce(function (acc, val) {\n                    return val ? acc + 1 : acc;\n                }, 0);\n                var open = Array(this.items.length).fill(false);\n                if (openCount === 1) {\n                    openIndex = this.open.indexOf(true);\n                }\n                if (openIndex > -1) {\n                    open[openIndex] = true;\n                }\n                this.open = open;\n            }\n            this.$emit(\'input\', v ? this.open : openIndex > -1 ? openIndex : null);\n        },\n        value: function value(v) {\n            this.updateFromValue(v);\n        }\n    },\n    mounted: function mounted() {\n        this.value !== null && this.updateFromValue(this.value);\n    },\n    methods: {\n        updateFromValue: function updateFromValue(v) {\n            if (Array.isArray(v) && !this.expand) return;\n            var open = Array(this.items.length).fill(false);\n            if (typeof v === \'number\') {\n                open[v] = true;\n            } else if (v !== null) {\n                open = v;\n            }\n            this.updatePanels(open);\n        },\n        updatePanels: function updatePanels(open) {\n            this.open = open;\n            for (var i = 0; i < this.items.length; i++) {\n                var active = open && open[i];\n                this.items[i].toggle(active);\n            }\n        },\n        panelClick: function panelClick(uid) {\n            var open = this.expand ? this.open.slice() : Array(this.items.length).fill(false);\n            for (var i = 0; i < this.items.length; i++) {\n                if (this.items[i]._uid === uid) {\n                    open[i] = !this.open[i];\n                    !this.expand && this.$emit(\'input\', open[i] ? i : null);\n                }\n            }\n            this.updatePanels(open);\n            if (this.expand) this.$emit(\'input\', open);\n        },\n        register: function register(content) {\n            this.items.push(content);\n            this.open.push(false);\n        },\n        unregister: function unregister(content) {\n            var index = this.items.findIndex(function (i) {\n                return i._uid === content._uid;\n            });\n            this.items.splice(index, 1);\n            this.open.splice(index, 1);\n        }\n    },\n    render: function render(h) {\n        return h(\'ul\', {\n            staticClass: \'v-expansion-panel\',\n            class: this.classes\n        }, this.$slots.default);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VExpansionPanel/VExpansionPanelContent.ts":\n/*!******************************************************************!*\\\n  !*** ./src/components/VExpansionPanel/VExpansionPanelContent.ts ***!\n  \\******************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transitions */ "./src/components/transitions/index.js");\n/* harmony import */ var _mixins_bootable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/bootable */ "./src/mixins/bootable.ts");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\n/* harmony import */ var _mixins_rippleable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/rippleable */ "./src/mixins/rippleable.ts");\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) {\n        ar = ar.concat(__read(arguments[i]));\n    }return ar;\n};\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_6__["default"])(_mixins_bootable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_rippleable__WEBPACK_IMPORTED_MODULE_3__["default"], Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_4__["inject"])(\'expansionPanel\', \'v-expansion-panel-content\', \'v-expansion-panel\')\n/* @vue/component */\n).extend({\n    name: \'v-expansion-panel-content\',\n    props: {\n        disabled: Boolean,\n        readonly: Boolean,\n        expandIcon: {\n            type: String,\n            default: \'$vuetify.icons.expand\'\n        },\n        hideActions: Boolean,\n        ripple: {\n            type: [Boolean, Object],\n            default: false\n        }\n    },\n    data: function data() {\n        return {\n            height: \'auto\'\n        };\n    },\n    computed: {\n        containerClasses: function containerClasses() {\n            return {\n                \'v-expansion-panel__container--active\': this.isActive,\n                \'v-expansion-panel__container--disabled\': this.isDisabled\n            };\n        },\n        isDisabled: function isDisabled() {\n            return this.expansionPanel.disabled || this.disabled;\n        },\n        isReadonly: function isReadonly() {\n            return this.expansionPanel.readonly || this.readonly;\n        }\n    },\n    mounted: function mounted() {\n        this.expansionPanel.register(this);\n        // Can be removed once fully deprecated\n        if (typeof this.value !== \'undefined\') Object(_util_console__WEBPACK_IMPORTED_MODULE_7__["consoleWarn"])(\'v-model has been deprecated\', this);\n    },\n    beforeDestroy: function beforeDestroy() {\n        this.expansionPanel.unregister(this);\n    },\n    methods: {\n        onKeydown: function onKeydown(e) {\n            // Ensure element is the activeElement\n            if (e.keyCode === 13 && this.$el === document.activeElement) this.expansionPanel.panelClick(this._uid);\n        },\n        onHeaderClick: function onHeaderClick() {\n            this.isReadonly || this.expansionPanel.panelClick(this._uid);\n        },\n        genBody: function genBody() {\n            return this.$createElement(\'div\', {\n                ref: \'body\',\n                class: \'v-expansion-panel__body\',\n                directives: [{\n                    name: \'show\',\n                    value: this.isActive\n                }]\n            }, this.showLazyContent(this.$slots.default));\n        },\n        genHeader: function genHeader() {\n            var children = __spread(this.$slots.header);\n            if (!this.hideActions) children.push(this.genIcon());\n            return this.$createElement(\'div\', {\n                staticClass: \'v-expansion-panel__header\',\n                directives: [{\n                    name: \'ripple\',\n                    value: this.ripple\n                }],\n                on: {\n                    click: this.onHeaderClick\n                }\n            }, children);\n        },\n        genIcon: function genIcon() {\n            var icon = this.$slots.actions || [this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_5__["default"], this.expandIcon)];\n            return this.$createElement(\'transition\', {\n                attrs: { name: \'fade-transition\' }\n            }, [this.$createElement(\'div\', {\n                staticClass: \'v-expansion-panel__header__icon\',\n                directives: [{\n                    name: \'show\',\n                    value: !this.isDisabled\n                }]\n            }, icon)]);\n        },\n        toggle: function toggle(active) {\n            var _this = this;\n            if (active) this.isBooted = true;\n            // We treat bootable differently\n            // Needs time to calc height\n            this.$nextTick(function () {\n                return _this.isActive = active;\n            });\n        }\n    },\n    render: function render(h) {\n        var children = [];\n        this.$slots.header && children.push(this.genHeader());\n        children.push(h(_transitions__WEBPACK_IMPORTED_MODULE_0__["VExpandTransition"], [this.genBody()]));\n        return h(\'li\', {\n            staticClass: \'v-expansion-panel__container\',\n            class: this.containerClasses,\n            attrs: {\n                tabindex: this.isReadonly || this.isDisabled ? null : 0\n            },\n            on: {\n                keydown: this.onKeydown\n            }\n        }, children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VExpansionPanel/index.ts":\n/*!*************************************************!*\\\n  !*** ./src/components/VExpansionPanel/index.ts ***!\n  \\*************************************************/\n/*! exports provided: VExpansionPanel, VExpansionPanelContent, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VExpansionPanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VExpansionPanel */ "./src/components/VExpansionPanel/VExpansionPanel.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VExpansionPanel", function() { return _VExpansionPanel__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _VExpansionPanelContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VExpansionPanelContent */ "./src/components/VExpansionPanel/VExpansionPanelContent.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VExpansionPanelContent", function() { return _VExpansionPanelContent__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VExpansionPanel: _VExpansionPanel__WEBPACK_IMPORTED_MODULE_0__["default"],\n        VExpansionPanelContent: _VExpansionPanelContent__WEBPACK_IMPORTED_MODULE_1__["default"]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VFooter/VFooter.js":\n/*!*******************************************!*\\\n  !*** ./src/components/VFooter/VFooter.js ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_footer_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_footer.styl */ "./src/stylus/components/_footer.styl");\n/* harmony import */ var _stylus_components_footer_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_footer_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/applicationable */ "./src/mixins/applicationable.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Mixins\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-footer\',\n    mixins: [Object(_mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__["default"])(null, [\'height\', \'inset\']), _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__["default"]],\n    props: {\n        height: {\n            default: 32,\n            type: [Number, String]\n        },\n        inset: Boolean\n    },\n    computed: {\n        applicationProperty: function applicationProperty() {\n            return this.inset ? \'insetFooter\' : \'footer\';\n        },\n        computedMarginBottom: function computedMarginBottom() {\n            if (!this.app) return;\n            return this.$vuetify.application.bottom;\n        },\n        computedPaddingLeft: function computedPaddingLeft() {\n            return !this.app || !this.inset ? 0 : this.$vuetify.application.left;\n        },\n        computedPaddingRight: function computedPaddingRight() {\n            return !this.app ? 0 : this.$vuetify.application.right;\n        },\n        styles: function styles() {\n            var styles = {\n                height: isNaN(this.height) ? this.height : this.height + "px"\n            };\n            if (this.computedPaddingLeft) {\n                styles.paddingLeft = this.computedPaddingLeft + "px";\n            }\n            if (this.computedPaddingRight) {\n                styles.paddingRight = this.computedPaddingRight + "px";\n            }\n            if (this.computedMarginBottom) {\n                styles.marginBottom = this.computedMarginBottom + "px";\n            }\n            return styles;\n        }\n    },\n    methods: {\n        /**\n         * Update the application layout\n         *\n         * @return {number}\n         */\n        updateApplication: function updateApplication() {\n            var height = parseInt(this.height);\n            return isNaN(height) ? this.$el ? this.$el.clientHeight : 0 : height;\n        }\n    },\n    render: function render(h) {\n        var data = this.setBackgroundColor(this.color, {\n            staticClass: \'v-footer\',\n            \'class\': __assign({ \'v-footer--absolute\': this.absolute, \'v-footer--fixed\': !this.absolute && (this.app || this.fixed), \'v-footer--inset\': this.inset }, this.themeClasses),\n            style: this.styles,\n            ref: \'content\'\n        });\n        return h(\'footer\', data, this.$slots.default);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VFooter/index.js":\n/*!*****************************************!*\\\n  !*** ./src/components/VFooter/index.js ***!\n  \\*****************************************/\n/*! exports provided: VFooter, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VFooter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VFooter */ "./src/components/VFooter/VFooter.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VFooter", function() { return _VFooter__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VFooter__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VForm/VForm.js":\n/*!***************************************!*\\\n  !*** ./src/components/VForm/VForm.js ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_forms_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_forms.styl */ "./src/stylus/components/_forms.styl");\n/* harmony import */ var _stylus_components_forms_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_forms_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\n// Styles\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-form\',\n    mixins: [Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_1__["provide"])(\'form\')],\n    inheritAttrs: false,\n    props: {\n        value: Boolean,\n        lazyValidation: Boolean\n    },\n    data: function data() {\n        return {\n            inputs: [],\n            watchers: [],\n            errorBag: {}\n        };\n    },\n    watch: {\n        errorBag: {\n            handler: function handler() {\n                var errors = Object.values(this.errorBag).includes(true);\n                this.$emit(\'input\', !errors);\n            },\n            deep: true,\n            immediate: true\n        }\n    },\n    methods: {\n        watchInput: function watchInput(input) {\n            var _this = this;\n            var watcher = function watcher(input) {\n                return input.$watch(\'hasError\', function (val) {\n                    _this.$set(_this.errorBag, input._uid, val);\n                }, { immediate: true });\n            };\n            var watchers = {\n                _uid: input._uid,\n                valid: undefined,\n                shouldValidate: undefined\n            };\n            if (this.lazyValidation) {\n                // Only start watching inputs if we need to\n                watchers.shouldValidate = input.$watch(\'shouldValidate\', function (val) {\n                    if (!val) return;\n                    // Only watch if we\'re not already doing it\n                    if (_this.errorBag.hasOwnProperty(input._uid)) return;\n                    watchers.valid = watcher(input);\n                });\n            } else {\n                watchers.valid = watcher(input);\n            }\n            return watchers;\n        },\n        /** @public */\n        validate: function validate() {\n            var errors = this.inputs.filter(function (input) {\n                return !input.validate(true);\n            }).length;\n            return !errors;\n        },\n        /** @public */\n        reset: function reset() {\n            var _this = this;\n            for (var i = this.inputs.length; i--;) {\n                this.inputs[i].reset();\n            }\n            if (this.lazyValidation) {\n                // Account for timeout in validatable\n                setTimeout(function () {\n                    _this.errorBag = {};\n                }, 0);\n            }\n        },\n        /** @public */\n        resetValidation: function resetValidation() {\n            var _this = this;\n            for (var i = this.inputs.length; i--;) {\n                this.inputs[i].resetValidation();\n            }\n            if (this.lazyValidation) {\n                // Account for timeout in validatable\n                setTimeout(function () {\n                    _this.errorBag = {};\n                }, 0);\n            }\n        },\n        register: function register(input) {\n            var unwatch = this.watchInput(input);\n            this.inputs.push(input);\n            this.watchers.push(unwatch);\n        },\n        unregister: function unregister(input) {\n            var found = this.inputs.find(function (i) {\n                return i._uid === input._uid;\n            });\n            if (!found) return;\n            var unwatch = this.watchers.find(function (i) {\n                return i._uid === found._uid;\n            });\n            unwatch.valid && unwatch.valid();\n            unwatch.shouldValidate && unwatch.shouldValidate();\n            this.watchers = this.watchers.filter(function (i) {\n                return i._uid !== found._uid;\n            });\n            this.inputs = this.inputs.filter(function (i) {\n                return i._uid !== found._uid;\n            });\n            this.$delete(this.errorBag, found._uid);\n        }\n    },\n    render: function render(h) {\n        var _this = this;\n        return h(\'form\', {\n            staticClass: \'v-form\',\n            attrs: Object.assign({\n                novalidate: true\n            }, this.$attrs),\n            on: {\n                submit: function submit(e) {\n                    return _this.$emit(\'submit\', e);\n                }\n            }\n        }, this.$slots.default);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VForm/index.js":\n/*!***************************************!*\\\n  !*** ./src/components/VForm/index.js ***!\n  \\***************************************/\n/*! exports provided: VForm, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VForm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VForm */ "./src/components/VForm/VForm.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VForm", function() { return _VForm__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VForm__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VGrid/VContainer.js":\n/*!********************************************!*\\\n  !*** ./src/components/VGrid/VContainer.js ***!\n  \\********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_grid_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_grid.styl */ "./src/stylus/components/_grid.styl");\n/* harmony import */ var _stylus_components_grid_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_grid_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grid */ "./src/components/VGrid/grid.js");\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_grid__WEBPACK_IMPORTED_MODULE_1__["default"])(\'container\'));\n\n/***/ }),\n\n/***/ "./src/components/VGrid/VContent.js":\n/*!******************************************!*\\\n  !*** ./src/components/VGrid/VContent.js ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_content_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_content.styl */ "./src/stylus/components/_content.styl");\n/* harmony import */ var _stylus_components_content_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_content_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_ssr_bootable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/ssr-bootable */ "./src/mixins/ssr-bootable.ts");\n// Styles\n\n// Mixins\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-content\',\n    mixins: [_mixins_ssr_bootable__WEBPACK_IMPORTED_MODULE_1__["default"]],\n    props: {\n        tag: {\n            type: String,\n            default: \'main\'\n        }\n    },\n    computed: {\n        styles: function styles() {\n            var _a = this.$vuetify.application,\n                bar = _a.bar,\n                top = _a.top,\n                right = _a.right,\n                footer = _a.footer,\n                insetFooter = _a.insetFooter,\n                bottom = _a.bottom,\n                left = _a.left;\n            return {\n                paddingTop: top + bar + "px",\n                paddingRight: right + "px",\n                paddingBottom: footer + insetFooter + bottom + "px",\n                paddingLeft: left + "px"\n            };\n        }\n    },\n    render: function render(h) {\n        var data = {\n            staticClass: \'v-content\',\n            style: this.styles,\n            ref: \'content\'\n        };\n        return h(this.tag, data, [h(\'div\', { staticClass: \'v-content__wrap\' }, this.$slots.default)]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VGrid/VFlex.js":\n/*!***************************************!*\\\n  !*** ./src/components/VGrid/VFlex.js ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_grid_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_grid.styl */ "./src/stylus/components/_grid.styl");\n/* harmony import */ var _stylus_components_grid_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_grid_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grid */ "./src/components/VGrid/grid.js");\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_grid__WEBPACK_IMPORTED_MODULE_1__["default"])(\'flex\'));\n\n/***/ }),\n\n/***/ "./src/components/VGrid/VLayout.js":\n/*!*****************************************!*\\\n  !*** ./src/components/VGrid/VLayout.js ***!\n  \\*****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_grid_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_grid.styl */ "./src/stylus/components/_grid.styl");\n/* harmony import */ var _stylus_components_grid_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_grid_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grid */ "./src/components/VGrid/grid.js");\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_grid__WEBPACK_IMPORTED_MODULE_1__["default"])(\'layout\'));\n\n/***/ }),\n\n/***/ "./src/components/VGrid/grid.js":\n/*!**************************************!*\\\n  !*** ./src/components/VGrid/grid.js ***!\n  \\**************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Grid; });\nfunction Grid(name) {\n    /* @vue/component */\n    return {\n        name: "v-" + name,\n        functional: true,\n        props: {\n            id: String,\n            tag: {\n                type: String,\n                default: \'div\'\n            }\n        },\n        render: function render(h, _a) {\n            var props = _a.props,\n                data = _a.data,\n                children = _a.children;\n            data.staticClass = (name + " " + (data.staticClass || \'\')).trim();\n            if (data.attrs) {\n                var classes = Object.keys(data.attrs).filter(function (key) {\n                    // TODO: Remove once resolved\n                    // https://github.com/vuejs/vue/issues/7841\n                    if (key === \'slot\') return false;\n                    var value = data.attrs[key];\n                    return value || typeof value === \'string\';\n                });\n                if (classes.length) data.staticClass += " " + classes.join(\' \');\n                delete data.attrs;\n            }\n            if (props.id) {\n                data.domProps = data.domProps || {};\n                data.domProps.id = props.id;\n            }\n            return h(props.tag, data, children);\n        }\n    };\n}\n\n/***/ }),\n\n/***/ "./src/components/VGrid/index.js":\n/*!***************************************!*\\\n  !*** ./src/components/VGrid/index.js ***!\n  \\***************************************/\n/*! exports provided: VContainer, VContent, VFlex, VLayout, VSpacer, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSpacer", function() { return VSpacer; });\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _VContainer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VContainer */ "./src/components/VGrid/VContainer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VContainer", function() { return _VContainer__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _VContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VContent */ "./src/components/VGrid/VContent.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VContent", function() { return _VContent__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _VFlex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VFlex */ "./src/components/VGrid/VFlex.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VFlex", function() { return _VFlex__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n/* harmony import */ var _VLayout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VLayout */ "./src/components/VGrid/VLayout.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VLayout", function() { return _VLayout__WEBPACK_IMPORTED_MODULE_4__["default"]; });\n\n\n\n\n\n\nvar VSpacer = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'spacer\', \'div\', \'v-spacer\');\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VContainer: _VContainer__WEBPACK_IMPORTED_MODULE_1__["default"],\n        VContent: _VContent__WEBPACK_IMPORTED_MODULE_2__["default"],\n        VFlex: _VFlex__WEBPACK_IMPORTED_MODULE_3__["default"],\n        VLayout: _VLayout__WEBPACK_IMPORTED_MODULE_4__["default"],\n        VSpacer: VSpacer\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VHover/VHover.ts":\n/*!*****************************************!*\\\n  !*** ./src/components/VHover/VHover.ts ***!\n  \\*****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mixins_delayable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/delayable */ "./src/mixins/delayable.ts");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n// Mixins\n\n\n// Utilities\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_2__["default"])(_mixins_delayable__WEBPACK_IMPORTED_MODULE_0__["default"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_1__["default"]\n/* @vue/component */\n).extend({\n    name: \'v-hover\',\n    props: {\n        disabled: {\n            type: Boolean,\n            default: false\n        },\n        value: {\n            type: Boolean,\n            default: undefined\n        }\n    },\n    methods: {\n        onMouseEnter: function onMouseEnter() {\n            var _this = this;\n            this.runDelay(\'open\', function () {\n                _this.isActive = true;\n            });\n        },\n        onMouseLeave: function onMouseLeave() {\n            var _this = this;\n            this.runDelay(\'close\', function () {\n                _this.isActive = false;\n            });\n        }\n    },\n    render: function render() {\n        if (!this.$scopedSlots.default && this.value === undefined) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_3__["consoleWarn"])(\'v-hover is missing a default scopedSlot or bound value\', this);\n            return null;\n        }\n        var element;\n        if (this.$scopedSlots.default) {\n            element = this.$scopedSlots.default({ hover: this.isActive });\n        } else if (this.$slots.default.length === 1) {\n            element = this.$slots.default[0];\n        }\n        if (!element || typeof element === \'string\' || Array.isArray(element)) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_3__["consoleWarn"])(\'v-hover should only contain a single element\', this);\n            return element;\n        }\n        if (!this.disabled) {\n            this._g(element.data, {\n                mouseenter: this.onMouseEnter,\n                mouseleave: this.onMouseLeave\n            });\n        }\n        return element;\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VHover/index.ts":\n/*!****************************************!*\\\n  !*** ./src/components/VHover/index.ts ***!\n  \\****************************************/\n/*! exports provided: VHover, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VHover__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VHover */ "./src/components/VHover/VHover.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VHover", function() { return _VHover__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VHover__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VIcon/VIcon.ts":\n/*!***************************************!*\\\n  !*** ./src/components/VIcon/VIcon.ts ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_icons_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_icons.styl */ "./src/stylus/components/_icons.styl");\n/* harmony import */ var _stylus_components_icons_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_icons_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_sizeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/sizeable */ "./src/mixins/sizeable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n// Mixins\n\n\n\n// Util\n\n// Types\n\n\nvar SIZE_MAP;\n(function (SIZE_MAP) {\n    SIZE_MAP["small"] = "16px";\n    SIZE_MAP["default"] = "24px";\n    SIZE_MAP["medium"] = "28px";\n    SIZE_MAP["large"] = "36px";\n    SIZE_MAP["xLarge"] = "40px";\n})(SIZE_MAP || (SIZE_MAP = {}));\nfunction isFontAwesome5(iconType) {\n    return [\'fas\', \'far\', \'fal\', \'fab\'].some(function (val) {\n        return iconType.includes(val);\n    });\n}\nvar VIcon = Object(_util_mixins__WEBPACK_IMPORTED_MODULE_6__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_sizeable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__["default"]\n/* @vue/component */\n).extend({\n    name: \'v-icon\',\n    props: {\n        disabled: Boolean,\n        left: Boolean,\n        right: Boolean\n    },\n    render: function render(h) {\n        var _a;\n        var sizes = {\n            small: this.small,\n            medium: this.medium,\n            large: this.large,\n            xLarge: this.xLarge\n        };\n        var explicitSize = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["keys"])(sizes).find(function (key) {\n            return sizes[key] && !!key;\n        });\n        var fontSize = explicitSize && SIZE_MAP[explicitSize] || Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["convertToUnit"])(this.size);\n        var newChildren = [];\n        var data = {\n            staticClass: \'v-icon\',\n            attrs: __assign({ \'aria-hidden\': true }, this.$attrs),\n            on: this.$listeners\n        };\n        if (fontSize) data.style = { fontSize: fontSize };\n        var iconName = \'\';\n        if (this.$slots.default) iconName = this.$slots.default[0].text;\n        // Remap internal names like \'$vuetify.icons.cancel\' to the current name for that icon\n        iconName = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["remapInternalIcon"])(this, iconName);\n        var iconType = \'material-icons\';\n        // Material Icon delimiter is _\n        // https://material.io/icons/\n        var delimiterIndex = iconName.indexOf(\'-\');\n        var isCustomIcon = delimiterIndex > -1;\n        if (isCustomIcon) {\n            iconType = iconName.slice(0, delimiterIndex);\n            if (isFontAwesome5(iconType)) iconType = \'\';\n            // Assume if not a custom icon\n            // is Material Icon font\n        } else newChildren.push(iconName);\n        data.class = __assign((_a = { \'v-icon--disabled\': this.disabled, \'v-icon--left\': this.left, \'v-icon--link\': this.$listeners.click || this.$listeners[\'!click\'], \'v-icon--right\': this.right }, _a[iconType] = true, _a[iconName] = isCustomIcon, _a), this.themeClasses);\n        return h(\'i\', this.setTextColor(this.color, data), newChildren);\n    }\n});\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_5___default.a.extend({\n    name: \'v-icon\',\n    $_wrapperFor: VIcon,\n    functional: true,\n    render: function render(h, _a) {\n        var data = _a.data,\n            children = _a.children;\n        var iconName = \'\';\n        // Support usage of v-text and v-html\n        if (data.domProps) {\n            iconName = data.domProps.textContent || data.domProps.innerHTML || iconName;\n            // Remove nodes so it doesn\'t\n            // overwrite our changes\n            delete data.domProps.textContent;\n            delete data.domProps.innerHTML;\n        }\n        return h(VIcon, data, iconName ? [iconName] : children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VIcon/index.ts":\n/*!***************************************!*\\\n  !*** ./src/components/VIcon/index.ts ***!\n  \\***************************************/\n/*! exports provided: VIcon, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VIcon */ "./src/components/VIcon/VIcon.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VIcon", function() { return _VIcon__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VIcon__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VImg/VImg.ts":\n/*!*************************************!*\\\n  !*** ./src/components/VImg/VImg.ts ***!\n  \\*************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_images_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_images.styl */ "./src/stylus/components/_images.styl");\n/* harmony import */ var _stylus_components_images_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_images_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VResponsive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VResponsive */ "./src/components/VResponsive/index.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n\n// Components\n\n// Utils\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (_VResponsive__WEBPACK_IMPORTED_MODULE_1__["default"].extend({\n    name: \'v-img\',\n    props: {\n        alt: String,\n        contain: Boolean,\n        src: {\n            type: [String, Object],\n            default: \'\'\n        },\n        gradient: String,\n        lazySrc: String,\n        srcset: String,\n        sizes: String,\n        position: {\n            type: String,\n            default: \'center center\'\n        },\n        transition: {\n            type: [Boolean, String],\n            default: \'fade-transition\'\n        }\n    },\n    data: function data() {\n        return {\n            currentSrc: \'\',\n            image: null,\n            isLoading: true,\n            calculatedAspectRatio: undefined\n        };\n    },\n    computed: {\n        computedAspectRatio: function computedAspectRatio() {\n            return this.normalisedSrc.aspect;\n        },\n        normalisedSrc: function normalisedSrc() {\n            return typeof this.src === \'string\' ? {\n                src: this.src,\n                srcset: this.srcset,\n                lazySrc: this.lazySrc,\n                aspect: Number(this.aspectRatio || this.calculatedAspectRatio)\n            } : {\n                src: this.src.src,\n                srcset: this.srcset || this.src.srcset,\n                lazySrc: this.lazySrc || this.src.lazySrc,\n                aspect: Number(this.aspectRatio || this.src.aspect || this.calculatedAspectRatio)\n            };\n        },\n        __cachedImage: function __cachedImage() {\n            if (!(this.normalisedSrc.src || this.normalisedSrc.lazySrc)) return [];\n            var backgroundImage = [];\n            var src = this.isLoading ? this.normalisedSrc.lazySrc : this.currentSrc;\n            if (this.gradient) backgroundImage.push("linear-gradient(" + this.gradient + ")");\n            if (src) backgroundImage.push("url(\\"" + src + "\\")");\n            var image = this.$createElement(\'div\', {\n                staticClass: \'v-image__image\',\n                class: {\n                    \'v-image__image--preload\': this.isLoading,\n                    \'v-image__image--contain\': this.contain,\n                    \'v-image__image--cover\': !this.contain\n                },\n                style: {\n                    backgroundImage: backgroundImage.join(\', \'),\n                    backgroundPosition: this.position\n                },\n                key: +this.isLoading\n            });\n            if (!this.transition) return image;\n            return this.$createElement(\'transition\', {\n                attrs: {\n                    name: this.transition,\n                    mode: \'in-out\'\n                }\n            }, [image]);\n        }\n    },\n    watch: {\n        src: function src() {\n            if (!this.isLoading) this.init();else this.loadImage();\n        },\n        \'$vuetify.breakpoint.width\': \'getSrc\'\n    },\n    mounted: function mounted() {\n        this.init();\n    },\n    methods: {\n        init: function init() {\n            if (this.normalisedSrc.lazySrc) {\n                var lazyImg = new Image();\n                lazyImg.src = this.normalisedSrc.lazySrc;\n                this.pollForSize(lazyImg, null);\n            }\n            /* istanbul ignore else */\n            if (this.normalisedSrc.src) this.loadImage();\n        },\n        onLoad: function onLoad() {\n            this.getSrc();\n            this.isLoading = false;\n            this.$emit(\'load\', this.src);\n        },\n        onError: function onError() {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_2__["consoleError"])("Image load failed\\n\\n" + ("src: " + this.normalisedSrc.src), this);\n            this.$emit(\'error\', this.src);\n        },\n        getSrc: function getSrc() {\n            /* istanbul ignore else */\n            if (this.image) this.currentSrc = this.image.currentSrc || this.image.src;\n        },\n        loadImage: function loadImage() {\n            var _this = this;\n            var image = new Image();\n            this.image = image;\n            image.onload = function () {\n                /* istanbul ignore if */\n                if (image.decode) {\n                    image.decode().catch(function (err) {\n                        Object(_util_console__WEBPACK_IMPORTED_MODULE_2__["consoleWarn"])("Failed to decode image, trying to render anyway\\n\\n" + ("src: " + _this.normalisedSrc.src) + (err.message ? "\\nOriginal error: " + err.message : \'\'), _this);\n                    }).then(_this.onLoad);\n                } else {\n                    _this.onLoad();\n                }\n            };\n            image.onerror = this.onError;\n            image.src = this.normalisedSrc.src;\n            this.sizes && (image.sizes = this.sizes);\n            this.normalisedSrc.srcset && (image.srcset = this.normalisedSrc.srcset);\n            this.aspectRatio || this.pollForSize(image);\n            this.getSrc();\n        },\n        pollForSize: function pollForSize(img, timeout) {\n            var _this = this;\n            if (timeout === void 0) {\n                timeout = 100;\n            }\n            var poll = function poll() {\n                var naturalHeight = img.naturalHeight,\n                    naturalWidth = img.naturalWidth;\n                if (naturalHeight || naturalWidth) {\n                    _this.calculatedAspectRatio = naturalWidth / naturalHeight;\n                } else {\n                    timeout != null && setTimeout(poll, timeout);\n                }\n            };\n            poll();\n        },\n        __genPlaceholder: function __genPlaceholder() {\n            if (this.$slots.placeholder) {\n                var placeholder = this.isLoading ? [this.$createElement(\'div\', {\n                    staticClass: \'v-image__placeholder\'\n                }, this.$slots.placeholder)] : [];\n                if (!this.transition) return placeholder[0];\n                return this.$createElement(\'transition\', {\n                    attrs: { name: this.transition }\n                }, placeholder);\n            }\n        }\n    },\n    render: function render(h) {\n        var node = _VResponsive__WEBPACK_IMPORTED_MODULE_1__["default"].options.render.call(this, h);\n        node.data.staticClass += \' v-image\';\n        node.data.attrs = {\n            role: this.alt ? \'img\' : undefined,\n            \'aria-label\': this.alt\n        };\n        node.children = [this.__cachedSizer, this.__cachedImage, this.__genPlaceholder(), this.genContent()];\n        return h(node.tag, node.data, node.children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VImg/index.ts":\n/*!**************************************!*\\\n  !*** ./src/components/VImg/index.ts ***!\n  \\**************************************/\n/*! exports provided: VImg, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VImg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VImg */ "./src/components/VImg/VImg.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VImg", function() { return _VImg__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VImg__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VInput/VInput.js":\n/*!*****************************************!*\\\n  !*** ./src/components/VInput/VInput.js ***!\n  \\*****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_inputs_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_inputs.styl */ "./src/stylus/components/_inputs.styl");\n/* harmony import */ var _stylus_components_inputs_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_inputs_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _VLabel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VLabel */ "./src/components/VLabel/index.js");\n/* harmony import */ var _VMessages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VMessages */ "./src/components/VMessages/index.js");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _mixins_validatable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../mixins/validatable */ "./src/mixins/validatable.js");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Components\n\n\n\n// Mixins\n\n\n\n// Utilities\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-input\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_5__["default"], _mixins_validatable__WEBPACK_IMPORTED_MODULE_6__["default"]],\n    props: {\n        appendIcon: String,\n        /** @deprecated */\n        appendIconCb: Function,\n        backgroundColor: {\n            type: String,\n            default: \'\'\n        },\n        height: [Number, String],\n        hideDetails: Boolean,\n        hint: String,\n        label: String,\n        persistentHint: Boolean,\n        prependIcon: String,\n        /** @deprecated */\n        prependIconCb: Function,\n        value: { required: false }\n    },\n    data: function data(vm) {\n        return {\n            lazyValue: vm.value,\n            hasMouseDown: false\n        };\n    },\n    computed: {\n        classesInput: function classesInput() {\n            return __assign({}, this.classes, { \'v-input--has-state\': this.hasState, \'v-input--hide-details\': this.hideDetails, \'v-input--is-label-active\': this.isLabelActive, \'v-input--is-dirty\': this.isDirty, \'v-input--is-disabled\': this.disabled, \'v-input--is-focused\': this.isFocused, \'v-input--is-loading\': this.loading !== false && this.loading !== undefined, \'v-input--is-readonly\': this.readonly }, this.themeClasses);\n        },\n        directivesInput: function directivesInput() {\n            return [];\n        },\n        hasHint: function hasHint() {\n            return !this.hasMessages && this.hint && (this.persistentHint || this.isFocused);\n        },\n        hasLabel: function hasLabel() {\n            return Boolean(this.$slots.label || this.label);\n        },\n        // Proxy for `lazyValue`\n        // This allows an input\n        // to function without\n        // a provided model\n        internalValue: {\n            get: function get() {\n                return this.lazyValue;\n            },\n            set: function set(val) {\n                this.lazyValue = val;\n                this.$emit(this.$_modelEvent, val);\n            }\n        },\n        isDirty: function isDirty() {\n            return !!this.lazyValue;\n        },\n        isDisabled: function isDisabled() {\n            return Boolean(this.disabled || this.readonly);\n        },\n        isLabelActive: function isLabelActive() {\n            return this.isDirty;\n        }\n    },\n    watch: {\n        value: function value(val) {\n            this.lazyValue = val;\n        }\n    },\n    beforeCreate: function beforeCreate() {\n        // v-radio-group needs to emit a different event\n        // https://github.com/vuetifyjs/vuetify/issues/4752\n        this.$_modelEvent = this.$options.model && this.$options.model.event || \'input\';\n    },\n    methods: {\n        genContent: function genContent() {\n            return [this.genPrependSlot(), this.genControl(), this.genAppendSlot()];\n        },\n        genControl: function genControl() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-input__control\'\n            }, [this.genInputSlot(), this.genMessages()]);\n        },\n        genDefaultSlot: function genDefaultSlot() {\n            return [this.genLabel(), this.$slots.default];\n        },\n        // TODO: remove shouldDeprecate (2.0), used for clearIcon\n        genIcon: function genIcon(type, cb, shouldDeprecate) {\n            var _this = this;\n            if (shouldDeprecate === void 0) {\n                shouldDeprecate = true;\n            }\n            var icon = this[type + "Icon"];\n            var eventName = "click:" + Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["kebabCase"])(type);\n            cb = cb || this[type + "IconCb"];\n            if (shouldDeprecate && type && cb) {\n                Object(_util_console__WEBPACK_IMPORTED_MODULE_8__["deprecate"])(":" + type + "-icon-cb", "@" + eventName, this);\n            }\n            var data = {\n                props: {\n                    color: this.validationState,\n                    dark: this.dark,\n                    disabled: this.disabled,\n                    light: this.light\n                },\n                on: !(this.$listeners[eventName] || cb) ? null : {\n                    click: function click(e) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                        _this.$emit(eventName, e);\n                        cb && cb(e);\n                    },\n                    // Container has mouseup event that will\n                    // trigger menu open if enclosed\n                    mouseup: function mouseup(e) {\n                        e.preventDefault();\n                        e.stopPropagation();\n                    }\n                }\n            };\n            return this.$createElement(\'div\', {\n                staticClass: "v-input__icon v-input__icon--" + Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["kebabCase"])(type),\n                key: "" + type + icon\n            }, [this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], data, icon)]);\n        },\n        genInputSlot: function genInputSlot() {\n            return this.$createElement(\'div\', this.setBackgroundColor(this.backgroundColor, {\n                staticClass: \'v-input__slot\',\n                style: { height: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["convertToUnit"])(this.height) },\n                directives: this.directivesInput,\n                on: {\n                    click: this.onClick,\n                    mousedown: this.onMouseDown,\n                    mouseup: this.onMouseUp\n                },\n                ref: \'input-slot\'\n            }), [this.genDefaultSlot()]);\n        },\n        genLabel: function genLabel() {\n            if (!this.hasLabel) return null;\n            return this.$createElement(_VLabel__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                props: {\n                    color: this.validationState,\n                    dark: this.dark,\n                    focused: this.hasState,\n                    for: this.$attrs.id,\n                    light: this.light\n                }\n            }, this.$slots.label || this.label);\n        },\n        genMessages: function genMessages() {\n            if (this.hideDetails) return null;\n            var messages = this.hasHint ? [this.hint] : this.validations;\n            return this.$createElement(_VMessages__WEBPACK_IMPORTED_MODULE_3__["default"], {\n                props: {\n                    color: this.hasHint ? \'\' : this.validationState,\n                    dark: this.dark,\n                    light: this.light,\n                    value: this.hasMessages || this.hasHint ? messages : []\n                }\n            });\n        },\n        genSlot: function genSlot(type, location, slot) {\n            if (!slot.length) return null;\n            var ref = type + "-" + location;\n            return this.$createElement(\'div\', {\n                staticClass: "v-input__" + ref,\n                ref: ref\n            }, slot);\n        },\n        genPrependSlot: function genPrependSlot() {\n            var slot = [];\n            if (this.$slots[\'prepend\']) {\n                slot.push(this.$slots[\'prepend\']);\n            } else if (this.prependIcon) {\n                slot.push(this.genIcon(\'prepend\'));\n            }\n            return this.genSlot(\'prepend\', \'outer\', slot);\n        },\n        genAppendSlot: function genAppendSlot() {\n            var slot = [];\n            // Append icon for text field was really\n            // an appended inner icon, v-text-field\n            // will overwrite this method in order to obtain\n            // backwards compat\n            if (this.$slots[\'append\']) {\n                slot.push(this.$slots[\'append\']);\n            } else if (this.appendIcon) {\n                slot.push(this.genIcon(\'append\'));\n            }\n            return this.genSlot(\'append\', \'outer\', slot);\n        },\n        onClick: function onClick(e) {\n            this.$emit(\'click\', e);\n        },\n        onMouseDown: function onMouseDown(e) {\n            this.hasMouseDown = true;\n            this.$emit(\'mousedown\', e);\n        },\n        onMouseUp: function onMouseUp(e) {\n            this.hasMouseDown = false;\n            this.$emit(\'mouseup\', e);\n        }\n    },\n    render: function render(h) {\n        return h(\'div\', this.setTextColor(this.validationState, {\n            staticClass: \'v-input\',\n            attrs: this.attrsInput,\n            \'class\': this.classesInput\n        }), this.genContent());\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VInput/index.js":\n/*!****************************************!*\\\n  !*** ./src/components/VInput/index.js ***!\n  \\****************************************/\n/*! exports provided: VInput, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VInput__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VInput */ "./src/components/VInput/VInput.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VInput", function() { return _VInput__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VInput__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VItemGroup/VItem.ts":\n/*!********************************************!*\\\n  !*** ./src/components/VItemGroup/VItem.ts ***!\n  \\********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mixins_groupable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/groupable */ "./src/mixins/groupable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n// Mixins\n\n// Utilities\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_mixins_groupable__WEBPACK_IMPORTED_MODULE_0__["factory"])(\'itemGroup\', \'v-item\', \'v-item-group\')\n/* @vue/component */\n).extend({\n    name: \'v-item\',\n    props: {\n        value: {\n            required: false\n        }\n    },\n    render: function render() {\n        var _a;\n        if (!this.$scopedSlots.default) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_2__["consoleWarn"])(\'v-item is missing a default scopedSlot\', this);\n            return null;\n        }\n        var element;\n        /* istanbul ignore else */\n        if (this.$scopedSlots.default) {\n            element = this.$scopedSlots.default({\n                active: this.isActive,\n                toggle: this.toggle\n            });\n        }\n        if (!element || typeof element === \'string\' || Array.isArray(element)) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_2__["consoleWarn"])(\'v-item should only contain a single element\', this);\n            return element;\n        }\n        element.data = element.data || {};\n        element.data.class = [element.data.class, (_a = {}, _a[this.activeClass] = this.isActive, _a)];\n        return element;\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VItemGroup/VItemGroup.ts":\n/*!*************************************************!*\\\n  !*** ./src/components/VItemGroup/VItemGroup.ts ***!\n  \\*************************************************/\n/*! exports provided: BaseItemGroup, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseItemGroup", function() { return BaseItemGroup; });\n/* harmony import */ var _stylus_components_item_group_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_item-group.styl */ "./src/stylus/components/_item-group.styl");\n/* harmony import */ var _stylus_components_item_group_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_item_group_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_proxyable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/proxyable */ "./src/mixins/proxyable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n\n\n// Utilities\n\n\nvar BaseItemGroup = Object(_util_mixins__WEBPACK_IMPORTED_MODULE_3__["default"])(_mixins_proxyable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]).extend({\n    name: \'base-item-group\',\n    props: {\n        activeClass: {\n            type: String,\n            default: \'v-item--active\'\n        },\n        mandatory: Boolean,\n        max: {\n            type: [Number, String],\n            default: null\n        },\n        multiple: Boolean\n    },\n    data: function data() {\n        return {\n            // As long as a value is defined, show it\n            // Otherwise, check if multiple\n            // to determine which default to provide\n            internalLazyValue: this.value !== undefined ? this.value : this.multiple ? [] : undefined,\n            items: []\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({}, this.themeClasses);\n        },\n        selectedItems: function selectedItems() {\n            var _this = this;\n            return this.items.filter(function (item, index) {\n                return _this.toggleMethod(_this.getValue(item, index));\n            });\n        },\n        selectedValues: function selectedValues() {\n            return Array.isArray(this.internalValue) ? this.internalValue : [this.internalValue];\n        },\n        toggleMethod: function toggleMethod() {\n            var _this = this;\n            if (!this.multiple) {\n                return function (v) {\n                    return _this.internalValue === v;\n                };\n            }\n            var internalValue = this.internalValue;\n            if (Array.isArray(internalValue)) {\n                return function (v) {\n                    return internalValue.includes(v);\n                };\n            }\n            return function () {\n                return false;\n            };\n        }\n    },\n    watch: {\n        internalValue: function internalValue() {\n            // https://github.com/vuetifyjs/vuetify/issues/5352\n            this.$nextTick(this.updateItemsState);\n        }\n    },\n    created: function created() {\n        if (this.multiple && !Array.isArray(this.internalValue)) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_4__["consoleWarn"])(\'Model must be bound to an array if the multiple property is true.\', this);\n        }\n    },\n    methods: {\n        getValue: function getValue(item, i) {\n            return item.value == null || item.value === \'\' ? i : item.value;\n        },\n        onClick: function onClick(item, index) {\n            this.updateInternalValue(this.getValue(item, index));\n        },\n        register: function register(item) {\n            var _this = this;\n            var index = this.items.push(item) - 1;\n            item.$on(\'change\', function () {\n                return _this.onClick(item, index);\n            });\n            // If no value provided and mandatory,\n            // assign first registered item\n            if (this.mandatory && this.internalLazyValue == null) {\n                this.updateMandatory();\n            }\n            this.updateItem(item, index);\n        },\n        unregister: function unregister(item) {\n            if (this._isDestroyed) return;\n            var index = this.items.indexOf(item);\n            var value = this.getValue(item, index);\n            this.items.splice(index, 1);\n            var valueIndex = this.selectedValues.indexOf(value);\n            // Items is not selected, do nothing\n            if (valueIndex < 0) return;\n            // If not mandatory, use regular update process\n            if (!this.mandatory) {\n                return this.updateInternalValue(value);\n            }\n            // Remove the value\n            if (this.multiple && Array.isArray(this.internalValue)) {\n                this.internalValue = this.internalValue.filter(function (v) {\n                    return v !== value;\n                });\n            } else {\n                this.internalValue = undefined;\n            }\n            // If mandatory and we have no selection\n            // add the last item as value\n            /* istanbul ignore else */\n            if (!this.selectedItems.length) {\n                this.updateMandatory(true);\n            }\n        },\n        updateItem: function updateItem(item, index) {\n            var value = this.getValue(item, index);\n            item.isActive = this.toggleMethod(value);\n        },\n        updateItemsState: function updateItemsState() {\n            if (this.mandatory && !this.selectedItems.length) {\n                return this.updateMandatory();\n            }\n            // TODO: Make this smarter so it\n            // doesn\'t have to iterate every\n            // child in an update\n            this.items.forEach(this.updateItem);\n        },\n        updateInternalValue: function updateInternalValue(value) {\n            this.multiple ? this.updateMultiple(value) : this.updateSingle(value);\n        },\n        updateMandatory: function updateMandatory(last) {\n            if (!this.items.length) return;\n            var index = last ? this.items.length - 1 : 0;\n            this.updateInternalValue(this.getValue(this.items[index], index));\n        },\n        updateMultiple: function updateMultiple(value) {\n            var defaultValue = Array.isArray(this.internalValue) ? this.internalValue : [];\n            var internalValue = defaultValue.slice();\n            var index = internalValue.findIndex(function (val) {\n                return val === value;\n            });\n            if (this.mandatory &&\n            // Item already exists\n            index > -1 &&\n            // value would be reduced below min\n            internalValue.length - 1 < 1) return;\n            if (\n            // Max is set\n            this.max != null &&\n            // Item doesn\'t exist\n            index < 0 &&\n            // value woudl be increased above max\n            internalValue.length + 1 > this.max) return;\n            index > -1 ? internalValue.splice(index, 1) : internalValue.push(value);\n            this.internalValue = internalValue;\n        },\n        updateSingle: function updateSingle(value) {\n            var isSame = value === this.internalValue;\n            if (this.mandatory && isSame) return;\n            this.internalValue = isSame ? undefined : value;\n        }\n    },\n    render: function render(h) {\n        return h(\'div\', {\n            staticClass: \'v-item-group\',\n            class: this.classes\n        }, this.$slots.default);\n    }\n});\n/* harmony default export */ __webpack_exports__["default"] = (BaseItemGroup.extend({\n    name: \'v-item-group\',\n    provide: function provide() {\n        return {\n            itemGroup: this\n        };\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VItemGroup/index.ts":\n/*!********************************************!*\\\n  !*** ./src/components/VItemGroup/index.ts ***!\n  \\********************************************/\n/*! exports provided: VItem, VItemGroup, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VItem */ "./src/components/VItemGroup/VItem.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VItem", function() { return _VItem__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _VItemGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VItemGroup */ "./src/components/VItemGroup/VItemGroup.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VItemGroup", function() { return _VItemGroup__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VItem: _VItem__WEBPACK_IMPORTED_MODULE_0__["default"],\n        VItemGroup: _VItemGroup__WEBPACK_IMPORTED_MODULE_1__["default"]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VJumbotron/VJumbotron.js":\n/*!*************************************************!*\\\n  !*** ./src/components/VJumbotron/VJumbotron.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_jumbotrons_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_jumbotrons.styl */ "./src/stylus/components/_jumbotrons.styl");\n/* harmony import */ var _stylus_components_jumbotrons_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_jumbotrons_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_routable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/routable */ "./src/mixins/routable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n\n// Mixins\n\n\n\n// Utils\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-jumbotron\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_routable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__["default"]],\n    props: {\n        gradient: String,\n        height: {\n            type: [Number, String],\n            default: \'400px\'\n        },\n        src: String,\n        tag: {\n            type: String,\n            default: \'div\'\n        }\n    },\n    computed: {\n        backgroundStyles: function backgroundStyles() {\n            var styles = {};\n            if (this.gradient) {\n                styles.background = "linear-gradient(" + this.gradient + ")";\n            }\n            return styles;\n        },\n        classes: function classes() {\n            return this.themeClasses;\n        },\n        styles: function styles() {\n            return {\n                height: this.height\n            };\n        }\n    },\n    mounted: function mounted() {\n        Object(_util_console__WEBPACK_IMPORTED_MODULE_4__["deprecate"])(\'v-jumbotron\', this.src ? \'v-img\' : \'v-responsive\', this);\n    },\n    methods: {\n        genBackground: function genBackground() {\n            return this.$createElement(\'div\', this.setBackgroundColor(this.color, {\n                staticClass: \'v-jumbotron__background\',\n                style: this.backgroundStyles\n            }));\n        },\n        genContent: function genContent() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-jumbotron__content\'\n            }, this.$slots.default);\n        },\n        genImage: function genImage() {\n            if (!this.src) return null;\n            if (this.$slots.img) return this.$slots.img({ src: this.src });\n            return this.$createElement(\'img\', {\n                staticClass: \'v-jumbotron__image\',\n                attrs: { src: this.src }\n            });\n        },\n        genWrapper: function genWrapper() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-jumbotron__wrapper\'\n            }, [this.genImage(), this.genBackground(), this.genContent()]);\n        }\n    },\n    render: function render(h) {\n        var _a = this.generateRouteLink(this.classes),\n            tag = _a.tag,\n            data = _a.data;\n        data.staticClass = \'v-jumbotron\';\n        data.style = this.styles;\n        return h(tag, data, [this.genWrapper()]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VJumbotron/index.js":\n/*!********************************************!*\\\n  !*** ./src/components/VJumbotron/index.js ***!\n  \\********************************************/\n/*! exports provided: VJumbotron, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VJumbotron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VJumbotron */ "./src/components/VJumbotron/VJumbotron.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VJumbotron", function() { return _VJumbotron__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VJumbotron__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VLabel/VLabel.js":\n/*!*****************************************!*\\\n  !*** ./src/components/VLabel/VLabel.js ***!\n  \\*****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_labels_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_labels.styl */ "./src/stylus/components/_labels.styl");\n/* harmony import */ var _stylus_components_labels_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_labels_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Mixins\n\n\n// Helpers\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-label\',\n    functional: true,\n    mixins: [_mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        absolute: Boolean,\n        color: {\n            type: [Boolean, String],\n            default: \'primary\'\n        },\n        disabled: Boolean,\n        focused: Boolean,\n        for: String,\n        left: {\n            type: [Number, String],\n            default: 0\n        },\n        right: {\n            type: [Number, String],\n            default: \'auto\'\n        },\n        value: Boolean\n    },\n    render: function render(h, ctx) {\n        var children = ctx.children,\n            listeners = ctx.listeners,\n            props = ctx.props;\n        var data = {\n            staticClass: \'v-label\',\n            \'class\': __assign({ \'v-label--active\': props.value, \'v-label--is-disabled\': props.disabled }, Object(_mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["functionalThemeClasses"])(ctx)),\n            attrs: {\n                for: props.for,\n                \'aria-hidden\': !props.for\n            },\n            on: listeners,\n            style: {\n                left: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["convertToUnit"])(props.left),\n                right: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["convertToUnit"])(props.right),\n                position: props.absolute ? \'absolute\' : \'relative\'\n            }\n        };\n        return h(\'label\', _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"].options.methods.setTextColor(props.focused && props.color, data), children);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VLabel/index.js":\n/*!****************************************!*\\\n  !*** ./src/components/VLabel/index.js ***!\n  \\****************************************/\n/*! exports provided: VLabel, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VLabel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VLabel */ "./src/components/VLabel/VLabel.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VLabel", function() { return _VLabel__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VLabel__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VList/VList.js":\n/*!***************************************!*\\\n  !*** ./src/components/VList/VList.js ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_lists_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_lists.styl */ "./src/stylus/components/_lists.styl");\n/* harmony import */ var _stylus_components_lists_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_lists_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Mixins\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-list\',\n    mixins: [Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_2__["provide"])(\'list\'), _mixins_themeable__WEBPACK_IMPORTED_MODULE_1__["default"]],\n    provide: function provide() {\n        return {\n            \'listClick\': this.listClick\n        };\n    },\n    props: {\n        dense: Boolean,\n        expand: Boolean,\n        subheader: Boolean,\n        threeLine: Boolean,\n        twoLine: Boolean\n    },\n    data: function data() {\n        return {\n            groups: []\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-list--dense\': this.dense, \'v-list--subheader\': this.subheader, \'v-list--two-line\': this.twoLine, \'v-list--three-line\': this.threeLine }, this.themeClasses);\n        }\n    },\n    methods: {\n        register: function register(uid, cb) {\n            this.groups.push({ uid: uid, cb: cb });\n        },\n        unregister: function unregister(uid) {\n            var index = this.groups.findIndex(function (g) {\n                return g.uid === uid;\n            });\n            if (index > -1) {\n                this.groups.splice(index, 1);\n            }\n        },\n        listClick: function listClick(uid) {\n            if (this.expand) return;\n            for (var i = this.groups.length; i--;) {\n                this.groups[i].cb(uid);\n            }\n        }\n    },\n    render: function render(h) {\n        var data = {\n            staticClass: \'v-list\',\n            \'class\': this.classes\n        };\n        return h(\'div\', data, [this.$slots.default]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VList/VListGroup.js":\n/*!********************************************!*\\\n  !*** ./src/components/VList/VListGroup.js ***!\n  \\********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_VIcon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _mixins_bootable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/bootable */ "./src/mixins/bootable.ts");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\n/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transitions */ "./src/components/transitions/index.js");\n// Components\n\n// Mixins\n\n\n\n// Transitions\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-list-group\',\n    mixins: [_mixins_bootable__WEBPACK_IMPORTED_MODULE_1__["default"], Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_3__["inject"])(\'list\', \'v-list-group\', \'v-list\'), _mixins_toggleable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    inject: [\'listClick\'],\n    props: {\n        activeClass: {\n            type: String,\n            default: \'primary--text\'\n        },\n        appendIcon: {\n            type: String,\n            default: \'$vuetify.icons.expand\'\n        },\n        disabled: Boolean,\n        group: String,\n        noAction: Boolean,\n        prependIcon: String,\n        subGroup: Boolean\n    },\n    data: function data() {\n        return {\n            groups: []\n        };\n    },\n    computed: {\n        groupClasses: function groupClasses() {\n            return {\n                \'v-list__group--active\': this.isActive,\n                \'v-list__group--disabled\': this.disabled\n            };\n        },\n        headerClasses: function headerClasses() {\n            return {\n                \'v-list__group__header--active\': this.isActive,\n                \'v-list__group__header--sub-group\': this.subGroup\n            };\n        },\n        itemsClasses: function itemsClasses() {\n            return {\n                \'v-list__group__items--no-action\': this.noAction\n            };\n        }\n    },\n    watch: {\n        isActive: function isActive(val) {\n            if (!this.subGroup && val) {\n                this.listClick(this._uid);\n            }\n        },\n        $route: function $route(to) {\n            var isActive = this.matchRoute(to.path);\n            if (this.group) {\n                if (isActive && this.isActive !== isActive) {\n                    this.listClick(this._uid);\n                }\n                this.isActive = isActive;\n            }\n        }\n    },\n    mounted: function mounted() {\n        this.list.register(this._uid, this.toggle);\n        if (this.group && this.$route && this.value == null) {\n            this.isActive = this.matchRoute(this.$route.path);\n        }\n    },\n    beforeDestroy: function beforeDestroy() {\n        this.list.unregister(this._uid);\n    },\n    methods: {\n        click: function click() {\n            if (this.disabled) return;\n            this.isActive = !this.isActive;\n        },\n        genIcon: function genIcon(icon) {\n            return this.$createElement(_components_VIcon__WEBPACK_IMPORTED_MODULE_0__["default"], icon);\n        },\n        genAppendIcon: function genAppendIcon() {\n            var icon = !this.subGroup ? this.appendIcon : false;\n            if (!icon && !this.$slots.appendIcon) return null;\n            return this.$createElement(\'div\', {\n                staticClass: \'v-list__group__header__append-icon\'\n            }, [this.$slots.appendIcon || this.genIcon(icon)]);\n        },\n        genGroup: function genGroup() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-list__group__header\',\n                \'class\': this.headerClasses,\n                on: Object.assign({}, {\n                    click: this.click\n                }, this.$listeners),\n                ref: \'item\'\n            }, [this.genPrependIcon(), this.$slots.activator, this.genAppendIcon()]);\n        },\n        genItems: function genItems() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-list__group__items\',\n                \'class\': this.itemsClasses,\n                directives: [{\n                    name: \'show\',\n                    value: this.isActive\n                }],\n                ref: \'group\'\n            }, this.showLazyContent(this.$slots.default));\n        },\n        genPrependIcon: function genPrependIcon() {\n            var _a;\n            var icon = this.prependIcon ? this.prependIcon : this.subGroup ? \'$vuetify.icons.subgroup\' : false;\n            if (!icon && !this.$slots.prependIcon) return null;\n            return this.$createElement(\'div\', {\n                staticClass: \'v-list__group__header__prepend-icon\',\n                \'class\': (_a = {}, _a[this.activeClass] = this.isActive, _a)\n            }, [this.$slots.prependIcon || this.genIcon(icon)]);\n        },\n        toggle: function toggle(uid) {\n            this.isActive = this._uid === uid;\n        },\n        matchRoute: function matchRoute(to) {\n            if (!this.group) return false;\n            return to.match(this.group) !== null;\n        }\n    },\n    render: function render(h) {\n        return h(\'div\', {\n            staticClass: \'v-list__group\',\n            \'class\': this.groupClasses\n        }, [this.genGroup(), h(_transitions__WEBPACK_IMPORTED_MODULE_4__["VExpandTransition"], [this.genItems()])]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VList/VListTile.js":\n/*!*******************************************!*\\\n  !*** ./src/components/VList/VListTile.js ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_routable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/routable */ "./src/mixins/routable.ts");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _directives_ripple__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../directives/ripple */ "./src/directives/ripple.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Mixins\n\n\n\n\n// Directives\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-list-tile\',\n    directives: {\n        Ripple: _directives_ripple__WEBPACK_IMPORTED_MODULE_4__["default"]\n    },\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_0__["default"], _mixins_routable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__["default"]],\n    inheritAttrs: false,\n    props: {\n        activeClass: {\n            type: String,\n            default: \'primary--text\'\n        },\n        avatar: Boolean,\n        inactive: Boolean,\n        tag: String\n    },\n    data: function data() {\n        return {\n            proxyClass: \'v-list__tile--active\'\n        };\n    },\n    computed: {\n        listClasses: function listClasses() {\n            return this.disabled ? { \'v-list--disabled\': true } : undefined;\n        },\n        classes: function classes() {\n            var _a;\n            return __assign({ \'v-list__tile\': true, \'v-list__tile--link\': this.isLink && !this.inactive, \'v-list__tile--avatar\': this.avatar, \'v-list__tile--disabled\': this.disabled, \'v-list__tile--active\': !this.to && this.isActive }, this.themeClasses, (_a = {}, _a[this.activeClass] = this.isActive, _a));\n        },\n        isLink: function isLink() {\n            return this.href || this.to || this.$listeners && (this.$listeners.click || this.$listeners[\'!click\']);\n        }\n    },\n    render: function render(h) {\n        var isRouteLink = !this.inactive && this.isLink;\n        var _a = isRouteLink ? this.generateRouteLink(this.classes) : {\n            tag: this.tag || \'div\',\n            data: {\n                class: this.classes\n            }\n        },\n            tag = _a.tag,\n            data = _a.data;\n        data.attrs = Object.assign({}, data.attrs, this.$attrs);\n        return h(\'div\', this.setTextColor(!this.disabled && this.color, {\n            class: this.listClasses,\n            attrs: {\n                disabled: this.disabled\n            },\n            on: __assign({}, this.$listeners)\n        }), [h(tag, data, this.$slots.default)]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VList/VListTileAction.js":\n/*!*************************************************!*\\\n  !*** ./src/components/VList/VListTileAction.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-list-tile-action\',\n    functional: true,\n    render: function render(h, _a) {\n        var data = _a.data,\n            _b = _a.children,\n            children = _b === void 0 ? [] : _b;\n        data.staticClass = data.staticClass ? "v-list__tile__action " + data.staticClass : \'v-list__tile__action\';\n        var filteredChild = children.filter(function (VNode) {\n            return VNode.isComment === false && VNode.text !== \' \';\n        });\n        if (filteredChild.length > 1) data.staticClass += \' v-list__tile__action--stack\';\n        return h(\'div\', data, children);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VList/VListTileAvatar.js":\n/*!*************************************************!*\\\n  !*** ./src/components/VList/VListTileAvatar.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VAvatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VAvatar */ "./src/components/VAvatar/index.ts");\n// Components\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-list-tile-avatar\',\n    functional: true,\n    props: {\n        color: String,\n        size: {\n            type: [Number, String],\n            default: 40\n        },\n        tile: Boolean\n    },\n    render: function render(h, _a) {\n        var data = _a.data,\n            children = _a.children,\n            props = _a.props;\n        data.staticClass = ("v-list__tile__avatar " + (data.staticClass || \'\')).trim();\n        var avatar = h(_VAvatar__WEBPACK_IMPORTED_MODULE_0__["default"], {\n            props: {\n                color: props.color,\n                size: props.size,\n                tile: props.tile\n            }\n        }, [children]);\n        return h(\'div\', data, [avatar]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VList/index.js":\n/*!***************************************!*\\\n  !*** ./src/components/VList/index.js ***!\n  \\***************************************/\n/*! exports provided: VList, VListGroup, VListTile, VListTileAction, VListTileAvatar, VListTileActionText, VListTileContent, VListTileTitle, VListTileSubTitle, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VListTileActionText", function() { return VListTileActionText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VListTileContent", function() { return VListTileContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VListTileTitle", function() { return VListTileTitle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VListTileSubTitle", function() { return VListTileSubTitle; });\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _VList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VList */ "./src/components/VList/VList.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VList", function() { return _VList__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _VListGroup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VListGroup */ "./src/components/VList/VListGroup.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListGroup", function() { return _VListGroup__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _VListTile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VListTile */ "./src/components/VList/VListTile.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListTile", function() { return _VListTile__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n/* harmony import */ var _VListTileAction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VListTileAction */ "./src/components/VList/VListTileAction.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListTileAction", function() { return _VListTileAction__WEBPACK_IMPORTED_MODULE_4__["default"]; });\n\n/* harmony import */ var _VListTileAvatar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./VListTileAvatar */ "./src/components/VList/VListTileAvatar.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListTileAvatar", function() { return _VListTileAvatar__WEBPACK_IMPORTED_MODULE_5__["default"]; });\n\n\n\n\n\n\n\n\nvar VListTileActionText = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'v-list__tile__action-text\', \'span\');\nvar VListTileContent = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'v-list__tile__content\', \'div\');\nvar VListTileTitle = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'v-list__tile__title\', \'div\');\nvar VListTileSubTitle = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'v-list__tile__sub-title\', \'div\');\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VList: _VList__WEBPACK_IMPORTED_MODULE_1__["default"],\n        VListGroup: _VListGroup__WEBPACK_IMPORTED_MODULE_2__["default"],\n        VListTile: _VListTile__WEBPACK_IMPORTED_MODULE_3__["default"],\n        VListTileAction: _VListTileAction__WEBPACK_IMPORTED_MODULE_4__["default"],\n        VListTileActionText: VListTileActionText,\n        VListTileAvatar: _VListTileAvatar__WEBPACK_IMPORTED_MODULE_5__["default"],\n        VListTileContent: VListTileContent,\n        VListTileSubTitle: VListTileSubTitle,\n        VListTileTitle: VListTileTitle\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VMenu/VMenu.js":\n/*!***************************************!*\\\n  !*** ./src/components/VMenu/VMenu.js ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_menus_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_menus.styl */ "./src/stylus/components/_menus.styl");\n/* harmony import */ var _stylus_components_menus_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_menus_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mixins_delayable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/delayable */ "./src/mixins/delayable.ts");\n/* harmony import */ var _mixins_dependent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/dependent */ "./src/mixins/dependent.ts");\n/* harmony import */ var _mixins_detachable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/detachable */ "./src/mixins/detachable.js");\n/* harmony import */ var _mixins_menuable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/menuable.js */ "./src/mixins/menuable.js");\n/* harmony import */ var _mixins_returnable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../mixins/returnable */ "./src/mixins/returnable.ts");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _mixins_menu_activator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./mixins/menu-activator */ "./src/components/VMenu/mixins/menu-activator.js");\n/* harmony import */ var _mixins_menu_generators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./mixins/menu-generators */ "./src/components/VMenu/mixins/menu-generators.js");\n/* harmony import */ var _mixins_menu_keyable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./mixins/menu-keyable */ "./src/components/VMenu/mixins/menu-keyable.js");\n/* harmony import */ var _mixins_menu_position__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mixins/menu-position */ "./src/components/VMenu/mixins/menu-position.js");\n/* harmony import */ var _directives_click_outside__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../directives/click-outside */ "./src/directives/click-outside.ts");\n/* harmony import */ var _directives_resize__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../directives/resize */ "./src/directives/resize.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_ThemeProvider__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../util/ThemeProvider */ "./src/util/ThemeProvider.ts");\n\n\n// Mixins\n\n\n\n\n\n\n\n// Component level mixins\n\n\n\n\n// Directives\n\n\n// Helpers\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_1___default.a.extend({\n    name: \'v-menu\',\n    provide: function provide() {\n        return {\n            // Pass theme through to default slot\n            theme: this.theme\n        };\n    },\n    directives: {\n        ClickOutside: _directives_click_outside__WEBPACK_IMPORTED_MODULE_13__["default"],\n        Resize: _directives_resize__WEBPACK_IMPORTED_MODULE_14__["default"]\n    },\n    mixins: [_mixins_menu_activator__WEBPACK_IMPORTED_MODULE_9__["default"], _mixins_dependent__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_delayable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_detachable__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_menu_generators__WEBPACK_IMPORTED_MODULE_10__["default"], _mixins_menu_keyable__WEBPACK_IMPORTED_MODULE_11__["default"], _mixins_menuable_js__WEBPACK_IMPORTED_MODULE_5__["default"], _mixins_menu_position__WEBPACK_IMPORTED_MODULE_12__["default"], _mixins_returnable__WEBPACK_IMPORTED_MODULE_6__["default"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_7__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_8__["default"]],\n    props: {\n        auto: Boolean,\n        closeOnClick: {\n            type: Boolean,\n            default: true\n        },\n        closeOnContentClick: {\n            type: Boolean,\n            default: true\n        },\n        disabled: Boolean,\n        fullWidth: Boolean,\n        maxHeight: { default: \'auto\' },\n        offsetX: Boolean,\n        offsetY: Boolean,\n        openOnClick: {\n            type: Boolean,\n            default: true\n        },\n        openOnHover: Boolean,\n        origin: {\n            type: String,\n            default: \'top left\'\n        },\n        transition: {\n            type: [Boolean, String],\n            default: \'v-menu-transition\'\n        }\n    },\n    data: function data() {\n        return {\n            defaultOffset: 8,\n            maxHeightAutoDefault: \'200px\',\n            startIndex: 3,\n            stopIndex: 0,\n            hasJustFocused: false,\n            resizeTimeout: null\n        };\n    },\n    computed: {\n        calculatedLeft: function calculatedLeft() {\n            if (!this.auto) return this.calcLeft();\n            return this.calcXOverflow(this.calcLeftAuto()) + "px";\n        },\n        calculatedMaxHeight: function calculatedMaxHeight() {\n            return this.auto ? \'200px\' : Object(_util_helpers__WEBPACK_IMPORTED_MODULE_15__["convertToUnit"])(this.maxHeight);\n        },\n        calculatedMaxWidth: function calculatedMaxWidth() {\n            return isNaN(this.maxWidth) ? this.maxWidth : this.maxWidth + "px";\n        },\n        calculatedMinWidth: function calculatedMinWidth() {\n            if (this.minWidth) {\n                return isNaN(this.minWidth) ? this.minWidth : this.minWidth + "px";\n            }\n            var minWidth = this.dimensions.activator.width + this.nudgeWidth + (this.auto ? 16 : 0);\n            var calculatedMaxWidth = isNaN(parseInt(this.calculatedMaxWidth)) ? minWidth : parseInt(this.calculatedMaxWidth);\n            return Math.min(calculatedMaxWidth, minWidth) + "px";\n        },\n        calculatedTop: function calculatedTop() {\n            if (!this.auto || this.isAttached) return this.calcTop();\n            return this.calcYOverflow(this.calcTopAuto()) + "px";\n        },\n        styles: function styles() {\n            return {\n                maxHeight: this.calculatedMaxHeight,\n                minWidth: this.calculatedMinWidth,\n                maxWidth: this.calculatedMaxWidth,\n                top: this.calculatedTop,\n                left: this.calculatedLeft,\n                transformOrigin: this.origin,\n                zIndex: this.zIndex || this.activeZIndex\n            };\n        },\n        tileHeight: function tileHeight() {\n            return this.dense ? 36 : 48;\n        }\n    },\n    watch: {\n        activator: function activator(newActivator, oldActivator) {\n            this.removeActivatorEvents(oldActivator);\n            this.addActivatorEvents(newActivator);\n        },\n        isContentActive: function isContentActive(val) {\n            this.hasJustFocused = val;\n        }\n    },\n    methods: {\n        activate: function activate() {\n            // This exists primarily for v-select\n            // helps determine which tiles to activate\n            this.getTiles();\n            // Update coordinates and dimensions of menu\n            // and its activator\n            this.updateDimensions();\n            // Start the transition\n            requestAnimationFrame(this.startTransition);\n            // Once transitioning, calculate scroll position\n            setTimeout(this.calculateScroll, 50);\n        },\n        closeConditional: function closeConditional() {\n            return this.isActive && this.closeOnClick;\n        },\n        onResize: function onResize() {\n            if (!this.isActive) return;\n            // Account for screen resize\n            // and orientation change\n            // eslint-disable-next-line no-unused-expressions\n            this.$refs.content.offsetWidth;\n            this.updateDimensions();\n            // When resizing to a smaller width\n            // content width is evaluated before\n            // the new activator width has been\n            // set, causing it to not size properly\n            // hacky but will revisit in the future\n            clearTimeout(this.resizeTimeout);\n            this.resizeTimeout = setTimeout(this.updateDimensions, 100);\n        }\n    },\n    render: function render(h) {\n        var data = {\n            staticClass: \'v-menu\',\n            class: { \'v-menu--inline\': !this.fullWidth && this.$slots.activator },\n            directives: [{\n                arg: 500,\n                name: \'resize\',\n                value: this.onResize\n            }],\n            on: {\n                keydown: this.onKeyDown\n            }\n        };\n        return h(\'div\', data, [this.genActivator(), this.$createElement(_util_ThemeProvider__WEBPACK_IMPORTED_MODULE_16__["default"], {\n            props: {\n                root: true,\n                light: this.light,\n                dark: this.dark\n            }\n        }, [this.genTransition()])]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VMenu/index.js":\n/*!***************************************!*\\\n  !*** ./src/components/VMenu/index.js ***!\n  \\***************************************/\n/*! exports provided: VMenu, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VMenu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VMenu */ "./src/components/VMenu/VMenu.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VMenu", function() { return _VMenu__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VMenu__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VMenu/mixins/menu-activator.js":\n/*!*******************************************************!*\\\n  !*** ./src/components/VMenu/mixins/menu-activator.js ***!\n  \\*******************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/**\n * Menu activator\n *\n * @mixin\n *\n * Handles the click and hover activation\n * Supports slotted and detached activators\n */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    methods: {\n        activatorClickHandler: function activatorClickHandler(e) {\n            if (this.disabled) return;\n            if (this.openOnClick && !this.isActive) {\n                this.getActivator().focus();\n                this.isActive = true;\n                this.absoluteX = e.clientX;\n                this.absoluteY = e.clientY;\n            } else if (this.closeOnClick && this.isActive) {\n                this.getActivator().blur();\n                this.isActive = false;\n            }\n        },\n        mouseEnterHandler: function mouseEnterHandler() {\n            var _this = this;\n            this.runDelay(\'open\', function () {\n                if (_this.hasJustFocused) return;\n                _this.hasJustFocused = true;\n                _this.isActive = true;\n            });\n        },\n        mouseLeaveHandler: function mouseLeaveHandler(e) {\n            var _this = this;\n            // Prevent accidental re-activation\n            this.runDelay(\'close\', function () {\n                if (_this.$refs.content.contains(e.relatedTarget)) return;\n                requestAnimationFrame(function () {\n                    _this.isActive = false;\n                    _this.callDeactivate();\n                });\n            });\n        },\n        addActivatorEvents: function addActivatorEvents(activator) {\n            if (activator === void 0) {\n                activator = null;\n            }\n            if (!activator) return;\n            activator.addEventListener(\'click\', this.activatorClickHandler);\n        },\n        removeActivatorEvents: function removeActivatorEvents(activator) {\n            if (activator === void 0) {\n                activator = null;\n            }\n            if (!activator) return;\n            activator.removeEventListener(\'click\', this.activatorClickHandler);\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VMenu/mixins/menu-generators.js":\n/*!********************************************************!*\\\n  !*** ./src/components/VMenu/mixins/menu-generators.js ***!\n  \\********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) {\n        ar = ar.concat(__read(arguments[i]));\n    }return ar;\n};\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    methods: {\n        genActivator: function genActivator() {\n            if (!this.$slots.activator) return null;\n            var options = {\n                staticClass: \'v-menu__activator\',\n                \'class\': {\n                    \'v-menu__activator--active\': this.hasJustFocused || this.isActive,\n                    \'v-menu__activator--disabled\': this.disabled\n                },\n                ref: \'activator\',\n                on: {}\n            };\n            if (this.openOnHover) {\n                options.on[\'mouseenter\'] = this.mouseEnterHandler;\n                options.on[\'mouseleave\'] = this.mouseLeaveHandler;\n            } else if (this.openOnClick) {\n                options.on[\'click\'] = this.activatorClickHandler;\n            }\n            return this.$createElement(\'div\', options, this.$slots.activator);\n        },\n        genTransition: function genTransition() {\n            if (!this.transition) return this.genContent();\n            return this.$createElement(\'transition\', {\n                props: {\n                    name: this.transition\n                }\n            }, [this.genContent()]);\n        },\n        genDirectives: function genDirectives() {\n            var _this = this;\n            // Do not add click outside for hover menu\n            var directives = !this.openOnHover && this.closeOnClick ? [{\n                name: \'click-outside\',\n                value: function value() {\n                    return _this.isActive = false;\n                },\n                args: {\n                    closeConditional: this.closeConditional,\n                    include: function include() {\n                        return __spread([_this.$el], _this.getOpenDependentElements());\n                    }\n                }\n            }] : [];\n            directives.push({\n                name: \'show\',\n                value: this.isContentActive\n            });\n            return directives;\n        },\n        genContent: function genContent() {\n            var _this = this;\n            var _a;\n            var options = {\n                attrs: this.getScopeIdAttrs(),\n                staticClass: \'v-menu__content\',\n                \'class\': __assign({}, this.rootThemeClasses, (_a = { \'v-menu__content--auto\': this.auto, \'menuable__content__active\': this.isActive }, _a[this.contentClass.trim()] = true, _a)),\n                style: this.styles,\n                directives: this.genDirectives(),\n                ref: \'content\',\n                on: {\n                    click: function click(e) {\n                        e.stopPropagation();\n                        if (e.target.getAttribute(\'disabled\')) return;\n                        if (_this.closeOnContentClick) _this.isActive = false;\n                    }\n                }\n            };\n            !this.disabled && this.openOnHover && (options.on.mouseenter = this.mouseEnterHandler);\n            this.openOnHover && (options.on.mouseleave = this.mouseLeaveHandler);\n            return this.$createElement(\'div\', options, this.showLazyContent(this.$slots.default));\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VMenu/mixins/menu-keyable.js":\n/*!*****************************************************!*\\\n  !*** ./src/components/VMenu/mixins/menu-keyable.js ***!\n  \\*****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/helpers */ "./src/util/helpers.ts");\n/**\n * Menu keyable\n *\n * @mixin\n *\n * Primarily used to support VSelect\n * Handles opening and closing of VMenu from keystrokes\n * Will conditionally highlight VListTiles for VSelect\n */\n// Utils\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    data: function data() {\n        return {\n            listIndex: -1,\n            tiles: []\n        };\n    },\n    watch: {\n        isActive: function isActive(val) {\n            if (!val) this.listIndex = -1;\n        },\n        listIndex: function listIndex(next, prev) {\n            if (next in this.tiles) {\n                var tile = this.tiles[next];\n                tile.classList.add(\'v-list__tile--highlighted\');\n                this.$refs.content.scrollTop = tile.offsetTop - tile.clientHeight;\n            }\n            prev in this.tiles && this.tiles[prev].classList.remove(\'v-list__tile--highlighted\');\n        }\n    },\n    methods: {\n        onKeyDown: function onKeyDown(e) {\n            if ([_util_helpers__WEBPACK_IMPORTED_MODULE_0__["keyCodes"].down, _util_helpers__WEBPACK_IMPORTED_MODULE_0__["keyCodes"].up, _util_helpers__WEBPACK_IMPORTED_MODULE_0__["keyCodes"].enter].includes(e.keyCode)) e.preventDefault();\n            if ([_util_helpers__WEBPACK_IMPORTED_MODULE_0__["keyCodes"].esc, _util_helpers__WEBPACK_IMPORTED_MODULE_0__["keyCodes"].tab].includes(e.keyCode)) {\n                return this.isActive = false;\n            }\n            this.changeListIndex(e);\n        },\n        changeListIndex: function changeListIndex(e) {\n            // For infinite scroll and autocomplete, re-evaluate children\n            this.getTiles();\n            if (e.keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_0__["keyCodes"].down && this.listIndex < this.tiles.length - 1) {\n                this.listIndex++;\n                // Allow user to set listIndex to -1 so\n                // that the list can be un-highlighted\n            } else if (e.keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_0__["keyCodes"].up && this.listIndex > -1) {\n                this.listIndex--;\n            } else if (e.keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_0__["keyCodes"].enter && this.listIndex !== -1) {\n                this.tiles[this.listIndex].click();\n            }\n        },\n        getTiles: function getTiles() {\n            this.tiles = this.$refs.content.querySelectorAll(\'.v-list__tile\');\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VMenu/mixins/menu-position.js":\n/*!******************************************************!*\\\n  !*** ./src/components/VMenu/mixins/menu-position.js ***!\n  \\******************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/**\n * Menu position\n *\n * @mixin\n *\n * Used for calculating an automatic position (used for VSelect)\n * Will position the VMenu content properly over the VSelect\n */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    methods: {\n        // Revisit this\n        calculateScroll: function calculateScroll() {\n            if (this.selectedIndex === null) return;\n            var scrollTop = 0;\n            if (this.selectedIndex >= this.stopIndex) {\n                scrollTop = this.$refs.content.scrollHeight;\n            } else if (this.selectedIndex > this.startIndex) {\n                scrollTop =\n                // Top position of selected item\n                this.selectedIndex * this.tileHeight +\n                // Remove half of a tile\'s height\n                this.tileHeight / 2 +\n                // Account for padding offset on lists\n                this.defaultOffset / 2 -\n                // Half of the auto content\'s height\n                100;\n            }\n            if (this.$refs.content) {\n                this.$refs.content.scrollTop = scrollTop;\n            }\n        },\n        calcLeftAuto: function calcLeftAuto() {\n            if (this.isAttached) return 0;\n            return parseInt(this.dimensions.activator.left - this.defaultOffset * 2);\n        },\n        calcTopAuto: function calcTopAuto() {\n            var selectedIndex = Array.from(this.tiles).findIndex(function (n) {\n                return n.classList.contains(\'v-list__tile--active\');\n            });\n            if (selectedIndex === -1) {\n                this.selectedIndex = null;\n                return this.computedTop;\n            }\n            this.selectedIndex = selectedIndex;\n            this.stopIndex = this.tiles.length > 4 ? this.tiles.length - 4 : this.tiles.length;\n            var additionalOffset = this.defaultOffset;\n            var offsetPadding;\n            // Menu should be centered\n            if (selectedIndex > this.startIndex && selectedIndex < this.stopIndex) {\n                offsetPadding = 1.5 * this.tileHeight;\n                // Menu should be offset top\n            } else if (selectedIndex >= this.stopIndex) {\n                // Being offset top means\n                // we have to account for top\n                // and bottom list padding\n                additionalOffset *= 2;\n                offsetPadding = (selectedIndex - this.stopIndex) * this.tileHeight;\n                // Menu should be offset bottom\n            } else {\n                offsetPadding = selectedIndex * this.tileHeight;\n            }\n            return this.computedTop + additionalOffset - offsetPadding - this.tileHeight / 2;\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VMessages/VMessages.js":\n/*!***********************************************!*\\\n  !*** ./src/components/VMessages/VMessages.js ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_messages_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_messages.styl */ "./src/stylus/components/_messages.styl");\n/* harmony import */ var _stylus_components_messages_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_messages_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n// Styles\n\n// Mixins\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-messages\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        value: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        }\n    },\n    methods: {\n        genChildren: function genChildren() {\n            return this.$createElement(\'transition-group\', {\n                staticClass: \'v-messages__wrapper\',\n                attrs: {\n                    name: \'message-transition\',\n                    tag: \'div\'\n                }\n            }, this.value.map(this.genMessage));\n        },\n        genMessage: function genMessage(message, key) {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-messages__message\',\n                key: key,\n                domProps: {\n                    innerHTML: message\n                }\n            });\n        }\n    },\n    render: function render(h) {\n        return h(\'div\', this.setTextColor(this.color, {\n            staticClass: \'v-messages\',\n            class: this.themeClasses\n        }), [this.genChildren()]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VMessages/index.js":\n/*!*******************************************!*\\\n  !*** ./src/components/VMessages/index.js ***!\n  \\*******************************************/\n/*! exports provided: VMessages, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VMessages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VMessages */ "./src/components/VMessages/VMessages.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VMessages", function() { return _VMessages__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VMessages__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VNavigationDrawer/VNavigationDrawer.js":\n/*!***************************************************************!*\\\n  !*** ./src/components/VNavigationDrawer/VNavigationDrawer.js ***!\n  \\***************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_navigation_drawer_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_navigation-drawer.styl */ "./src/stylus/components/_navigation-drawer.styl");\n/* harmony import */ var _stylus_components_navigation_drawer_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_navigation_drawer_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/applicationable */ "./src/mixins/applicationable.ts");\n/* harmony import */ var _mixins_dependent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/dependent */ "./src/mixins/dependent.ts");\n/* harmony import */ var _mixins_overlayable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/overlayable */ "./src/mixins/overlayable.js");\n/* harmony import */ var _mixins_ssr_bootable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/ssr-bootable */ "./src/mixins/ssr-bootable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _directives_click_outside__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../directives/click-outside */ "./src/directives/click-outside.ts");\n/* harmony import */ var _directives_resize__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../directives/resize */ "./src/directives/resize.ts");\n/* harmony import */ var _directives_touch__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../directives/touch */ "./src/directives/touch.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n// Mixins\n\n\n\n\n\n// Directives\n\n\n\n// Helpers\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-navigation-drawer\',\n    directives: {\n        ClickOutside: _directives_click_outside__WEBPACK_IMPORTED_MODULE_6__["default"],\n        Resize: _directives_resize__WEBPACK_IMPORTED_MODULE_7__["default"],\n        Touch: _directives_touch__WEBPACK_IMPORTED_MODULE_8__["default"]\n    },\n    mixins: [Object(_mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__["default"])(null, [\'miniVariant\', \'right\', \'width\']), _mixins_dependent__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_overlayable__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_ssr_bootable__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_5__["default"]],\n    props: {\n        clipped: Boolean,\n        disableRouteWatcher: Boolean,\n        disableResizeWatcher: Boolean,\n        height: {\n            type: [Number, String],\n            default: \'100%\'\n        },\n        floating: Boolean,\n        miniVariant: Boolean,\n        miniVariantWidth: {\n            type: [Number, String],\n            default: 80\n        },\n        mobileBreakPoint: {\n            type: [Number, String],\n            default: 1264\n        },\n        permanent: Boolean,\n        right: Boolean,\n        stateless: Boolean,\n        temporary: Boolean,\n        touchless: Boolean,\n        width: {\n            type: [Number, String],\n            default: 300\n        },\n        value: { required: false }\n    },\n    data: function data() {\n        return {\n            isActive: false,\n            touchArea: {\n                left: 0,\n                right: 0\n            }\n        };\n    },\n    computed: {\n        /**\n         * Used for setting an app\n         * value from a dynamic\n         * property. Called from\n         * applicationable.js\n         *\n         * @return {string}\n         */\n        applicationProperty: function applicationProperty() {\n            return this.right ? \'right\' : \'left\';\n        },\n        calculatedTransform: function calculatedTransform() {\n            if (this.isActive) return 0;\n            return this.right ? this.calculatedWidth : -this.calculatedWidth;\n        },\n        calculatedWidth: function calculatedWidth() {\n            return this.miniVariant ? this.miniVariantWidth : this.width;\n        },\n        classes: function classes() {\n            return __assign({ \'v-navigation-drawer\': true, \'v-navigation-drawer--absolute\': this.absolute, \'v-navigation-drawer--clipped\': this.clipped, \'v-navigation-drawer--close\': !this.isActive, \'v-navigation-drawer--fixed\': !this.absolute && (this.app || this.fixed), \'v-navigation-drawer--floating\': this.floating, \'v-navigation-drawer--is-mobile\': this.isMobile, \'v-navigation-drawer--mini-variant\': this.miniVariant, \'v-navigation-drawer--open\': this.isActive, \'v-navigation-drawer--right\': this.right, \'v-navigation-drawer--temporary\': this.temporary }, this.themeClasses);\n        },\n        hasApp: function hasApp() {\n            return this.app && !this.isMobile && !this.temporary;\n        },\n        isMobile: function isMobile() {\n            return !this.stateless && !this.permanent && !this.temporary && this.$vuetify.breakpoint.width < parseInt(this.mobileBreakPoint, 10);\n        },\n        marginTop: function marginTop() {\n            if (!this.hasApp) return 0;\n            var marginTop = this.$vuetify.application.bar;\n            marginTop += this.clipped ? this.$vuetify.application.top : 0;\n            return marginTop;\n        },\n        maxHeight: function maxHeight() {\n            if (!this.hasApp) return null;\n            var maxHeight = this.$vuetify.application.bottom + this.$vuetify.application.footer + this.$vuetify.application.bar;\n            if (!this.clipped) return maxHeight;\n            return maxHeight + this.$vuetify.application.top;\n        },\n        reactsToClick: function reactsToClick() {\n            return !this.stateless && !this.permanent && (this.isMobile || this.temporary);\n        },\n        reactsToMobile: function reactsToMobile() {\n            return !this.disableResizeWatcher && !this.stateless && !this.permanent && !this.temporary;\n        },\n        reactsToRoute: function reactsToRoute() {\n            return !this.disableRouteWatcher && !this.stateless && (this.temporary || this.isMobile);\n        },\n        resizeIsDisabled: function resizeIsDisabled() {\n            return this.disableResizeWatcher || this.stateless;\n        },\n        showOverlay: function showOverlay() {\n            return this.isActive && (this.isMobile || this.temporary);\n        },\n        styles: function styles() {\n            var styles = {\n                height: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_9__["convertToUnit"])(this.height),\n                marginTop: this.marginTop + "px",\n                maxHeight: "calc(100% - " + +this.maxHeight + "px)",\n                transform: "translateX(" + this.calculatedTransform + "px)",\n                width: this.calculatedWidth + "px"\n            };\n            return styles;\n        }\n    },\n    watch: {\n        $route: function $route() {\n            if (this.reactsToRoute && this.closeConditional()) {\n                this.isActive = false;\n            }\n        },\n        isActive: function isActive(val) {\n            this.$emit(\'input\', val);\n            this.callUpdate();\n        },\n        /**\n         * When mobile changes, adjust\n         * the active state only when\n         * there has been a previous\n         * value\n         */\n        isMobile: function isMobile(val, prev) {\n            !val && this.isActive && !this.temporary && this.removeOverlay();\n            if (prev == null || this.resizeIsDisabled || !this.reactsToMobile) return;\n            this.isActive = !val;\n            this.callUpdate();\n        },\n        permanent: function permanent(val) {\n            // If enabling prop\n            // enable the drawer\n            if (val) {\n                this.isActive = true;\n            }\n            this.callUpdate();\n        },\n        showOverlay: function showOverlay(val) {\n            if (val) this.genOverlay();else this.removeOverlay();\n        },\n        temporary: function temporary() {\n            this.callUpdate();\n        },\n        value: function value(val) {\n            if (this.permanent) return;\n            if (val == null) return this.init();\n            if (val !== this.isActive) this.isActive = val;\n        }\n    },\n    beforeMount: function beforeMount() {\n        this.init();\n    },\n    methods: {\n        calculateTouchArea: function calculateTouchArea() {\n            if (!this.$el.parentNode) return;\n            var parentRect = this.$el.parentNode.getBoundingClientRect();\n            this.touchArea = {\n                left: parentRect.left + 50,\n                right: parentRect.right - 50\n            };\n        },\n        closeConditional: function closeConditional() {\n            return this.isActive && this.reactsToClick;\n        },\n        genDirectives: function genDirectives() {\n            var _this = this;\n            var directives = [{\n                name: \'click-outside\',\n                value: function value() {\n                    return _this.isActive = false;\n                },\n                args: {\n                    closeConditional: this.closeConditional,\n                    include: this.getOpenDependentElements\n                }\n            }];\n            !this.touchless && directives.push({\n                name: \'touch\',\n                value: {\n                    parent: true,\n                    left: this.swipeLeft,\n                    right: this.swipeRight\n                }\n            });\n            return directives;\n        },\n        /**\n         * Sets state before mount to avoid\n         * entry transitions in SSR\n         *\n         * @return {void}\n         */\n        init: function init() {\n            if (this.permanent) {\n                this.isActive = true;\n            } else if (this.stateless || this.value != null) {\n                this.isActive = this.value;\n            } else if (!this.temporary) {\n                this.isActive = !this.isMobile;\n            }\n        },\n        swipeRight: function swipeRight(e) {\n            if (this.isActive && !this.right) return;\n            this.calculateTouchArea();\n            if (Math.abs(e.touchendX - e.touchstartX) < 100) return;\n            if (!this.right && e.touchstartX <= this.touchArea.left) this.isActive = true;else if (this.right && this.isActive) this.isActive = false;\n        },\n        swipeLeft: function swipeLeft(e) {\n            if (this.isActive && this.right) return;\n            this.calculateTouchArea();\n            if (Math.abs(e.touchendX - e.touchstartX) < 100) return;\n            if (this.right && e.touchstartX >= this.touchArea.right) this.isActive = true;else if (!this.right && this.isActive) this.isActive = false;\n        },\n        /**\n         * Update the application layout\n         *\n         * @return {number}\n         */\n        updateApplication: function updateApplication() {\n            return !this.isActive || this.temporary || this.isMobile ? 0 : this.calculatedWidth;\n        }\n    },\n    render: function render(h) {\n        var _this = this;\n        var data = {\n            \'class\': this.classes,\n            style: this.styles,\n            directives: this.genDirectives(),\n            on: {\n                click: function click() {\n                    if (!_this.miniVariant) return;\n                    _this.$emit(\'update:miniVariant\', false);\n                },\n                transitionend: function transitionend(e) {\n                    if (e.target !== e.currentTarget) return;\n                    _this.$emit(\'transitionend\', e);\n                    // IE11 does not support new Event(\'resize\')\n                    var resizeEvent = document.createEvent(\'UIEvents\');\n                    resizeEvent.initUIEvent(\'resize\', true, false, window, 0);\n                    window.dispatchEvent(resizeEvent);\n                }\n            }\n        };\n        return h(\'aside\', data, [this.$slots.default, h(\'div\', { \'class\': \'v-navigation-drawer__border\' })]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VNavigationDrawer/index.js":\n/*!***************************************************!*\\\n  !*** ./src/components/VNavigationDrawer/index.js ***!\n  \\***************************************************/\n/*! exports provided: VNavigationDrawer, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VNavigationDrawer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VNavigationDrawer */ "./src/components/VNavigationDrawer/VNavigationDrawer.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VNavigationDrawer", function() { return _VNavigationDrawer__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VNavigationDrawer__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VOverflowBtn/VOverflowBtn.js":\n/*!*****************************************************!*\\\n  !*** ./src/components/VOverflowBtn/VOverflowBtn.js ***!\n  \\*****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_overflow_buttons_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_overflow-buttons.styl */ "./src/stylus/components/_overflow-buttons.styl");\n/* harmony import */ var _stylus_components_overflow_buttons_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_overflow_buttons_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VSelect/VSelect */ "./src/components/VSelect/VSelect.js");\n/* harmony import */ var _VAutocomplete__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VAutocomplete */ "./src/components/VAutocomplete/index.js");\n/* harmony import */ var _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VTextField/VTextField */ "./src/components/VTextField/VTextField.js");\n/* harmony import */ var _VBtn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VBtn */ "./src/components/VBtn/index.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n// Styles\n\n// Extensions\n\n\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-overflow-btn\',\n    extends: _VAutocomplete__WEBPACK_IMPORTED_MODULE_2__["default"],\n    props: {\n        segmented: Boolean,\n        editable: Boolean,\n        transition: _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].props.transition\n    },\n    computed: {\n        classes: function classes() {\n            return Object.assign(_VAutocomplete__WEBPACK_IMPORTED_MODULE_2__["default"].computed.classes.call(this), {\n                \'v-overflow-btn\': true,\n                \'v-overflow-btn--segmented\': this.segmented,\n                \'v-overflow-btn--editable\': this.editable\n            });\n        },\n        isAnyValueAllowed: function isAnyValueAllowed() {\n            return this.editable || _VAutocomplete__WEBPACK_IMPORTED_MODULE_2__["default"].computed.isAnyValueAllowed.call(this);\n        },\n        isSingle: function isSingle() {\n            return true;\n        },\n        computedItems: function computedItems() {\n            return this.segmented ? this.allItems : this.filteredItems;\n        },\n        $_menuProps: function $_menuProps() {\n            var props = _VAutocomplete__WEBPACK_IMPORTED_MODULE_2__["default"].computed.$_menuProps.call(this);\n            props.transition = props.transition || \'v-menu-transition\';\n            return props;\n        }\n    },\n    methods: {\n        genSelections: function genSelections() {\n            return this.editable ? _VAutocomplete__WEBPACK_IMPORTED_MODULE_2__["default"].methods.genSelections.call(this) : _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.genSelections.call(this); // Override v-autocomplete\'s override\n        },\n        genCommaSelection: function genCommaSelection(item, index, last) {\n            return this.segmented ? this.genSegmentedBtn(item) : _VSelect_VSelect__WEBPACK_IMPORTED_MODULE_1__["default"].methods.genCommaSelection.call(this, item, index, last);\n        },\n        genInput: function genInput() {\n            var input = _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_3__["default"].methods.genInput.call(this);\n            input.data.domProps.value = this.editable ? this.internalSearch : \'\';\n            input.data.attrs.readonly = !this.isAnyValueAllowed;\n            return input;\n        },\n        genLabel: function genLabel() {\n            if (this.editable && this.isFocused) return null;\n            var label = _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_3__["default"].methods.genLabel.call(this);\n            if (!label) return label;\n            // Reset previously set styles from parent\n            label.data.style = {};\n            return label;\n        },\n        genSegmentedBtn: function genSegmentedBtn(item) {\n            var _this = this;\n            var itemValue = this.getValue(item);\n            var itemObj = this.computedItems.find(function (i) {\n                return _this.getValue(i) === itemValue;\n            }) || item;\n            if (!itemObj.text || !itemObj.callback) {\n                Object(_util_console__WEBPACK_IMPORTED_MODULE_5__["consoleWarn"])(\'When using \\\'segmented\\\' prop without a selection slot, items must contain both a text and callback property\', this);\n                return null;\n            }\n            return this.$createElement(_VBtn__WEBPACK_IMPORTED_MODULE_4__["default"], {\n                props: { flat: true },\n                on: {\n                    click: function click(e) {\n                        e.stopPropagation();\n                        itemObj.callback(e);\n                    }\n                }\n            }, [itemObj.text]);\n        },\n        setSelectedItems: function setSelectedItems() {\n            if (this.internalValue == null) {\n                this.selectedItems = [];\n            } else {\n                this.selectedItems = [this.internalValue];\n            }\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VOverflowBtn/index.js":\n/*!**********************************************!*\\\n  !*** ./src/components/VOverflowBtn/index.js ***!\n  \\**********************************************/\n/*! exports provided: VOverflowBtn, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VOverflowBtn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VOverflowBtn */ "./src/components/VOverflowBtn/VOverflowBtn.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VOverflowBtn", function() { return _VOverflowBtn__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VOverflowBtn__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VPagination/VPagination.ts":\n/*!***************************************************!*\\\n  !*** ./src/components/VPagination/VPagination.ts ***!\n  \\***************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_pagination_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_pagination.styl */ "./src/stylus/components/_pagination.styl");\n/* harmony import */ var _stylus_components_pagination_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_pagination_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _directives_resize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../directives/resize */ "./src/directives/resize.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) {\n        ar = ar.concat(__read(arguments[i]));\n    }return ar;\n};\n\n\n// Directives\n\n// Mixins\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_3__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_5__["default"]).extend({\n    name: \'v-pagination\',\n    directives: { Resize: _directives_resize__WEBPACK_IMPORTED_MODULE_2__["default"] },\n    props: {\n        circle: Boolean,\n        disabled: Boolean,\n        length: {\n            type: Number,\n            default: 0,\n            validator: function validator(val) {\n                return val % 1 === 0;\n            }\n        },\n        totalVisible: [Number, String],\n        nextIcon: {\n            type: String,\n            default: \'$vuetify.icons.next\'\n        },\n        prevIcon: {\n            type: String,\n            default: \'$vuetify.icons.prev\'\n        },\n        value: {\n            type: Number,\n            default: 0\n        }\n    },\n    data: function data() {\n        return {\n            maxButtons: 0,\n            selected: null\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-pagination\': true, \'v-pagination--circle\': this.circle, \'v-pagination--disabled\': this.disabled }, this.themeClasses);\n        },\n        items: function items() {\n            var maxLength = parseInt(this.totalVisible, 10) || this.maxButtons;\n            if (this.length <= maxLength) {\n                return this.range(1, this.length);\n            }\n            var even = maxLength % 2 === 0 ? 1 : 0;\n            var left = Math.floor(maxLength / 2);\n            var right = this.length - left + 1 + even;\n            if (this.value > left && this.value < right) {\n                var start = this.value - left + 2;\n                var end = this.value + left - 2 - even;\n                return __spread([1, \'...\'], this.range(start, end), [\'...\', this.length]);\n            } else if (this.value === left) {\n                var end = this.value + left - 1 - even;\n                return __spread(this.range(1, end), [\'...\', this.length]);\n            } else if (this.value === right) {\n                var start = this.value - left + 1;\n                return __spread([1, \'...\'], this.range(start, this.length));\n            } else {\n                return __spread(this.range(1, left), [\'...\'], this.range(right, this.length));\n            }\n        }\n    },\n    watch: {\n        value: function value() {\n            this.init();\n        }\n    },\n    mounted: function mounted() {\n        this.init();\n    },\n    methods: {\n        init: function init() {\n            var _this = this;\n            this.selected = null;\n            this.$nextTick(this.onResize);\n            // TODO: Change this (f75dee3a, cbdf7caa)\n            setTimeout(function () {\n                return _this.selected = _this.value;\n            }, 100);\n        },\n        onResize: function onResize() {\n            var width = this.$el && this.$el.parentElement ? this.$el.parentElement.clientWidth : window.innerWidth;\n            this.maxButtons = Math.floor((width - 96) / 42);\n        },\n        next: function next(e) {\n            e.preventDefault();\n            this.$emit(\'input\', this.value + 1);\n            this.$emit(\'next\');\n        },\n        previous: function previous(e) {\n            e.preventDefault();\n            this.$emit(\'input\', this.value - 1);\n            this.$emit(\'previous\');\n        },\n        range: function range(from, to) {\n            var range = [];\n            from = from > 0 ? from : 1;\n            for (var i = from; i <= to; i++) {\n                range.push(i);\n            }\n            return range;\n        },\n        genIcon: function genIcon(h, icon, disabled, fn) {\n            return h(\'li\', [h(\'button\', {\n                staticClass: \'v-pagination__navigation\',\n                class: {\n                    \'v-pagination__navigation--disabled\': disabled\n                },\n                attrs: {\n                    type: \'button\'\n                },\n                on: disabled ? {} : { click: fn }\n            }, [h(_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], [icon])])]);\n        },\n        genItem: function genItem(h, i) {\n            var _this = this;\n            var color = i === this.value && (this.color || \'primary\');\n            return h(\'button\', this.setBackgroundColor(color, {\n                staticClass: \'v-pagination__item\',\n                class: {\n                    \'v-pagination__item--active\': i === this.value\n                },\n                attrs: {\n                    type: \'button\'\n                },\n                on: {\n                    click: function click() {\n                        return _this.$emit(\'input\', i);\n                    }\n                }\n            }), [i.toString()]);\n        },\n        genItems: function genItems(h) {\n            var _this = this;\n            return this.items.map(function (i, index) {\n                return h(\'li\', { key: index }, [isNaN(Number(i)) ? h(\'span\', { class: \'v-pagination__more\' }, [i.toString()]) : _this.genItem(h, i)]);\n            });\n        }\n    },\n    render: function render(h) {\n        var children = [this.genIcon(h, this.$vuetify.rtl ? this.nextIcon : this.prevIcon, this.value <= 1, this.previous), this.genItems(h), this.genIcon(h, this.$vuetify.rtl ? this.prevIcon : this.nextIcon, this.value >= this.length, this.next)];\n        return h(\'ul\', {\n            directives: [{\n                modifiers: { quiet: true },\n                name: \'resize\',\n                value: this.onResize\n            }],\n            class: this.classes\n        }, children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VPagination/index.ts":\n/*!*********************************************!*\\\n  !*** ./src/components/VPagination/index.ts ***!\n  \\*********************************************/\n/*! exports provided: VPagination, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VPagination__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VPagination */ "./src/components/VPagination/VPagination.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VPagination", function() { return _VPagination__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VPagination__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VParallax/VParallax.ts":\n/*!***********************************************!*\\\n  !*** ./src/components/VParallax/VParallax.ts ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_parallax_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_parallax.styl */ "./src/stylus/components/_parallax.styl");\n/* harmony import */ var _stylus_components_parallax_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_parallax_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_translatable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/translatable */ "./src/mixins/translatable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n// Style\n\n// Mixins\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_2__["default"])(_mixins_translatable__WEBPACK_IMPORTED_MODULE_1__["default"]).extend({\n    name: \'v-parallax\',\n    props: {\n        alt: String,\n        height: {\n            type: [String, Number],\n            default: 500\n        },\n        src: String\n    },\n    data: function data() {\n        return {\n            isBooted: false\n        };\n    },\n    computed: {\n        styles: function styles() {\n            return {\n                display: \'block\',\n                opacity: this.isBooted ? 1 : 0,\n                transform: "translate(-50%, " + this.parallax + "px)"\n            };\n        }\n    },\n    watch: {\n        parallax: function parallax() {\n            this.isBooted = true;\n        }\n    },\n    mounted: function mounted() {\n        this.init();\n    },\n    methods: {\n        init: function init() {\n            var _this = this;\n            var img = this.$refs.img;\n            if (!img) return;\n            if (img.complete) {\n                this.translate();\n                this.listeners();\n            } else {\n                img.addEventListener(\'load\', function () {\n                    _this.translate();\n                    _this.listeners();\n                }, false);\n            }\n        },\n        objHeight: function objHeight() {\n            return this.$refs.img.naturalHeight;\n        }\n    },\n    render: function render(h) {\n        var imgData = {\n            staticClass: \'v-parallax__image\',\n            style: this.styles,\n            attrs: {\n                src: this.src\n            },\n            ref: \'img\'\n        };\n        if (this.alt) imgData.attrs.alt = this.alt;\n        var container = h(\'div\', {\n            staticClass: \'v-parallax__image-container\'\n        }, [h(\'img\', imgData)]);\n        var content = h(\'div\', {\n            staticClass: \'v-parallax__content\'\n        }, this.$slots.default);\n        return h(\'div\', {\n            staticClass: \'v-parallax\',\n            style: {\n                height: this.height + "px"\n            },\n            on: this.$listeners\n        }, [container, content]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VParallax/index.ts":\n/*!*******************************************!*\\\n  !*** ./src/components/VParallax/index.ts ***!\n  \\*******************************************/\n/*! exports provided: VParallax, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VParallax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VParallax */ "./src/components/VParallax/VParallax.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VParallax", function() { return _VParallax__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VParallax__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VPicker/VPicker.js":\n/*!*******************************************!*\\\n  !*** ./src/components/VPicker/VPicker.js ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_pickers_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_pickers.styl */ "./src/stylus/components/_pickers.styl");\n/* harmony import */ var _stylus_components_pickers_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_pickers_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stylus_components_cards_styl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stylus/components/_cards.styl */ "./src/stylus/components/_cards.styl");\n/* harmony import */ var _stylus_components_cards_styl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_cards_styl__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n// Mixins\n\n\n// Helpers\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-picker\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__["default"]],\n    props: {\n        fullWidth: Boolean,\n        landscape: Boolean,\n        transition: {\n            type: String,\n            default: \'fade-transition\'\n        },\n        width: {\n            type: [Number, String],\n            default: 290\n        }\n    },\n    computed: {\n        computedTitleColor: function computedTitleColor() {\n            var defaultTitleColor = this.isDark ? null : this.color || \'primary\';\n            return this.color || defaultTitleColor;\n        }\n    },\n    methods: {\n        genTitle: function genTitle() {\n            return this.$createElement(\'div\', this.setBackgroundColor(this.computedTitleColor, {\n                staticClass: \'v-picker__title\',\n                \'class\': {\n                    \'v-picker__title--landscape\': this.landscape\n                }\n            }), this.$slots.title);\n        },\n        genBodyTransition: function genBodyTransition() {\n            return this.$createElement(\'transition\', {\n                props: {\n                    name: this.transition\n                }\n            }, this.$slots.default);\n        },\n        genBody: function genBody() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-picker__body\',\n                \'class\': this.themeClasses,\n                style: this.fullWidth ? undefined : {\n                    width: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["convertToUnit"])(this.width)\n                }\n            }, [this.genBodyTransition()]);\n        },\n        genActions: function genActions() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-picker__actions v-card__actions\'\n            }, this.$slots.actions);\n        }\n    },\n    render: function render(h) {\n        return h(\'div\', {\n            staticClass: \'v-picker v-card\',\n            \'class\': __assign({ \'v-picker--landscape\': this.landscape, \'v-picker--full-width\': this.fullWidth }, this.themeClasses)\n        }, [this.$slots.title ? this.genTitle() : null, this.genBody(), this.$slots.actions ? this.genActions() : null]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VPicker/index.js":\n/*!*****************************************!*\\\n  !*** ./src/components/VPicker/index.js ***!\n  \\*****************************************/\n/*! exports provided: VPicker, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VPicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VPicker */ "./src/components/VPicker/VPicker.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VPicker", function() { return _VPicker__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VPicker__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VProgressCircular/VProgressCircular.ts":\n/*!***************************************************************!*\\\n  !*** ./src/components/VProgressCircular/VProgressCircular.ts ***!\n  \\***************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_progress_circular_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_progress-circular.styl */ "./src/stylus/components/_progress-circular.styl");\n/* harmony import */ var _stylus_components_progress_circular_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_progress_circular_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n\n// Mixins\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_2__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"]).extend({\n    name: \'v-progress-circular\',\n    props: {\n        button: Boolean,\n        indeterminate: Boolean,\n        rotate: {\n            type: Number,\n            default: 0\n        },\n        size: {\n            type: [Number, String],\n            default: 32\n        },\n        width: {\n            type: Number,\n            default: 4\n        },\n        value: {\n            type: [Number, String],\n            default: 0\n        }\n    },\n    computed: {\n        calculatedSize: function calculatedSize() {\n            return Number(this.size) + (this.button ? 8 : 0);\n        },\n        circumference: function circumference() {\n            return 2 * Math.PI * this.radius;\n        },\n        classes: function classes() {\n            return {\n                \'v-progress-circular--indeterminate\': this.indeterminate,\n                \'v-progress-circular--button\': this.button\n            };\n        },\n        normalizedValue: function normalizedValue() {\n            if (this.value < 0) {\n                return 0;\n            }\n            if (this.value > 100) {\n                return 100;\n            }\n            return parseInt(this.value, 10);\n        },\n        radius: function radius() {\n            return 20;\n        },\n        strokeDashArray: function strokeDashArray() {\n            return Math.round(this.circumference * 1000) / 1000;\n        },\n        strokeDashOffset: function strokeDashOffset() {\n            return (100 - this.normalizedValue) / 100 * this.circumference + \'px\';\n        },\n        strokeWidth: function strokeWidth() {\n            return this.width / +this.size * this.viewBoxSize * 2;\n        },\n        styles: function styles() {\n            return {\n                height: this.calculatedSize + "px",\n                width: this.calculatedSize + "px"\n            };\n        },\n        svgStyles: function svgStyles() {\n            return {\n                transform: "rotate(" + this.rotate + "deg)"\n            };\n        },\n        viewBoxSize: function viewBoxSize() {\n            return this.radius / (1 - this.width / +this.size);\n        }\n    },\n    methods: {\n        genCircle: function genCircle(h, name, offset) {\n            return h(\'circle\', {\n                class: "v-progress-circular__" + name,\n                attrs: {\n                    fill: \'transparent\',\n                    cx: 2 * this.viewBoxSize,\n                    cy: 2 * this.viewBoxSize,\n                    r: this.radius,\n                    \'stroke-width\': this.strokeWidth,\n                    \'stroke-dasharray\': this.strokeDashArray,\n                    \'stroke-dashoffset\': offset\n                }\n            });\n        },\n        genSvg: function genSvg(h) {\n            var children = [this.indeterminate || this.genCircle(h, \'underlay\', 0), this.genCircle(h, \'overlay\', this.strokeDashOffset)];\n            return h(\'svg\', {\n                style: this.svgStyles,\n                attrs: {\n                    xmlns: \'http://www.w3.org/2000/svg\',\n                    viewBox: this.viewBoxSize + " " + this.viewBoxSize + " " + 2 * this.viewBoxSize + " " + 2 * this.viewBoxSize\n                }\n            }, children);\n        }\n    },\n    render: function render(h) {\n        var info = h(\'div\', { staticClass: \'v-progress-circular__info\' }, [this.$slots.default]);\n        var svg = this.genSvg(h);\n        return h(\'div\', this.setTextColor(this.color, {\n            staticClass: \'v-progress-circular\',\n            attrs: {\n                \'role\': \'progressbar\',\n                \'aria-valuemin\': 0,\n                \'aria-valuemax\': 100,\n                \'aria-valuenow\': this.indeterminate ? undefined : this.normalizedValue\n            },\n            class: this.classes,\n            style: this.styles,\n            on: this.$listeners\n        }), [svg, info]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VProgressCircular/index.ts":\n/*!***************************************************!*\\\n  !*** ./src/components/VProgressCircular/index.ts ***!\n  \\***************************************************/\n/*! exports provided: VProgressCircular, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VProgressCircular__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VProgressCircular */ "./src/components/VProgressCircular/VProgressCircular.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VProgressCircular", function() { return _VProgressCircular__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VProgressCircular__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VProgressLinear/VProgressLinear.ts":\n/*!***********************************************************!*\\\n  !*** ./src/components/VProgressLinear/VProgressLinear.ts ***!\n  \\***********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_progress_linear_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_progress-linear.styl */ "./src/stylus/components/_progress-linear.styl");\n/* harmony import */ var _stylus_components_progress_linear_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_progress_linear_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transitions */ "./src/components/transitions/index.js");\n\n// Mixins\n\n// Helpers\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_3__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"]).extend({\n    name: \'v-progress-linear\',\n    props: {\n        active: {\n            type: Boolean,\n            default: true\n        },\n        backgroundColor: {\n            type: String,\n            default: null\n        },\n        backgroundOpacity: {\n            type: [Number, String],\n            default: null\n        },\n        bufferValue: {\n            type: [Number, String],\n            default: 100\n        },\n        color: {\n            type: String,\n            default: \'primary\'\n        },\n        height: {\n            type: [Number, String],\n            default: 7\n        },\n        indeterminate: Boolean,\n        query: Boolean,\n        value: {\n            type: [Number, String],\n            default: 0\n        }\n    },\n    computed: {\n        backgroundStyle: function backgroundStyle() {\n            var backgroundOpacity = this.backgroundOpacity == null ? this.backgroundColor ? 1 : 0.3 : parseFloat(this.backgroundOpacity);\n            return {\n                height: this.active ? Object(_util_helpers__WEBPACK_IMPORTED_MODULE_2__["convertToUnit"])(this.height) : 0,\n                opacity: backgroundOpacity,\n                width: this.normalizedBufer + "%"\n            };\n        },\n        effectiveWidth: function effectiveWidth() {\n            if (!this.normalizedBufer) {\n                return 0;\n            }\n            return +this.normalizedValue * 100 / +this.normalizedBufer;\n        },\n        normalizedBufer: function normalizedBufer() {\n            if (this.bufferValue < 0) {\n                return 0;\n            }\n            if (this.bufferValue > 100) {\n                return 100;\n            }\n            return parseInt(this.bufferValue, 10);\n        },\n        normalizedValue: function normalizedValue() {\n            if (this.value < 0) {\n                return 0;\n            }\n            if (this.value > 100) {\n                return 100;\n            }\n            return parseInt(this.value, 10);\n        },\n        styles: function styles() {\n            var styles = {};\n            if (!this.active) {\n                styles.height = 0;\n            }\n            if (!this.indeterminate && parseInt(this.normalizedBufer, 10) !== 100) {\n                styles.width = this.normalizedBufer + "%";\n            }\n            return styles;\n        }\n    },\n    methods: {\n        genDeterminate: function genDeterminate(h) {\n            return h(\'div\', this.setBackgroundColor(this.color, {\n                ref: \'front\',\n                staticClass: "v-progress-linear__bar__determinate",\n                style: {\n                    width: this.effectiveWidth + "%"\n                }\n            }));\n        },\n        genBar: function genBar(h, name) {\n            var _a;\n            return h(\'div\', this.setBackgroundColor(this.color, {\n                staticClass: \'v-progress-linear__bar__indeterminate\',\n                class: (_a = {}, _a[name] = true, _a)\n            }));\n        },\n        genIndeterminate: function genIndeterminate(h) {\n            return h(\'div\', {\n                ref: \'front\',\n                staticClass: \'v-progress-linear__bar__indeterminate\',\n                class: {\n                    \'v-progress-linear__bar__indeterminate--active\': this.active\n                }\n            }, [this.genBar(h, \'long\'), this.genBar(h, \'short\')]);\n        }\n    },\n    render: function render(h) {\n        var fade = h(_transitions__WEBPACK_IMPORTED_MODULE_4__["VFadeTransition"], this.indeterminate ? [this.genIndeterminate(h)] : []);\n        var slide = h(_transitions__WEBPACK_IMPORTED_MODULE_4__["VSlideXTransition"], this.indeterminate ? [] : [this.genDeterminate(h)]);\n        var bar = h(\'div\', {\n            staticClass: \'v-progress-linear__bar\',\n            style: this.styles\n        }, [fade, slide]);\n        var background = h(\'div\', this.setBackgroundColor(this.backgroundColor || this.color, {\n            staticClass: \'v-progress-linear__background\',\n            style: this.backgroundStyle\n        }));\n        return h(\'div\', {\n            staticClass: \'v-progress-linear\',\n            attrs: {\n                \'role\': \'progressbar\',\n                \'aria-valuemin\': 0,\n                \'aria-valuemax\': this.normalizedBufer,\n                \'aria-valuenow\': this.indeterminate ? undefined : this.normalizedValue\n            },\n            class: {\n                \'v-progress-linear--query\': this.query\n            },\n            style: {\n                height: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_2__["convertToUnit"])(this.height)\n            },\n            on: this.$listeners\n        }, [background, bar]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VProgressLinear/index.ts":\n/*!*************************************************!*\\\n  !*** ./src/components/VProgressLinear/index.ts ***!\n  \\*************************************************/\n/*! exports provided: VProgressLinear, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VProgressLinear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VProgressLinear */ "./src/components/VProgressLinear/VProgressLinear.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VProgressLinear", function() { return _VProgressLinear__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VProgressLinear__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VRadioGroup/VRadio.js":\n/*!**********************************************!*\\\n  !*** ./src/components/VRadioGroup/VRadio.js ***!\n  \\**********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_radios_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_radios.styl */ "./src/stylus/components/_radios.styl");\n/* harmony import */ var _stylus_components_radios_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_radios_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _VLabel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VLabel */ "./src/components/VLabel/index.js");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_rippleable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/rippleable */ "./src/mixins/rippleable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _mixins_selectable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../mixins/selectable */ "./src/mixins/selectable.js");\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) {\n        ar = ar.concat(__read(arguments[i]));\n    }return ar;\n};\n// Styles\n\n// Components\n\n\n// Mixins\n\n\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-radio\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_rippleable__WEBPACK_IMPORTED_MODULE_4__["default"], Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_7__["inject"])(\'radio\', \'v-radio\', \'v-radio-group\'), _mixins_themeable__WEBPACK_IMPORTED_MODULE_5__["default"]],\n    inheritAttrs: false,\n    props: {\n        color: {\n            type: String,\n            default: \'accent\'\n        },\n        disabled: Boolean,\n        label: String,\n        onIcon: {\n            type: String,\n            default: \'$vuetify.icons.radioOn\'\n        },\n        offIcon: {\n            type: String,\n            default: \'$vuetify.icons.radioOff\'\n        },\n        readonly: Boolean,\n        value: null\n    },\n    data: function data() {\n        return {\n            isActive: false,\n            isFocused: false,\n            parentError: false\n        };\n    },\n    computed: {\n        computedData: function computedData() {\n            return this.setTextColor(!this.parentError && this.isActive && this.color, {\n                staticClass: \'v-radio\',\n                \'class\': __assign({ \'v-radio--is-disabled\': this.isDisabled, \'v-radio--is-focused\': this.isFocused }, this.themeClasses)\n            });\n        },\n        computedColor: function computedColor() {\n            return this.isActive ? this.color : this.radio.validationState || false;\n        },\n        computedIcon: function computedIcon() {\n            return this.isActive ? this.onIcon : this.offIcon;\n        },\n        hasState: function hasState() {\n            return this.isActive || !!this.radio.validationState;\n        },\n        isDisabled: function isDisabled() {\n            return this.disabled || !!this.radio.disabled;\n        },\n        isReadonly: function isReadonly() {\n            return this.readonly || !!this.radio.readonly;\n        }\n    },\n    mounted: function mounted() {\n        this.radio.register(this);\n    },\n    beforeDestroy: function beforeDestroy() {\n        this.radio.unregister(this);\n    },\n    methods: {\n        genInput: function genInput() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var _a;\n            // We can\'t actually use the mixin directly because\n            // it\'s made for standalone components, but its\n            // genInput method is exactly what we need\n            return (_a = _mixins_selectable__WEBPACK_IMPORTED_MODULE_6__["default"].methods.genInput).call.apply(_a, __spread([this], args));\n        },\n        genLabel: function genLabel() {\n            return this.$createElement(_VLabel__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                on: { click: this.onChange },\n                attrs: {\n                    for: this.id\n                },\n                props: {\n                    color: this.radio.validationState || false,\n                    dark: this.dark,\n                    focused: this.hasState,\n                    light: this.light\n                }\n            }, this.$slots.label || this.label);\n        },\n        genRadio: function genRadio() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-input--selection-controls__input\'\n            }, [this.genInput(\'radio\', __assign({ name: this.radio.name || (this.radio._uid ? \'v-radio-\' + this.radio._uid : false), value: this.value }, this.$attrs)), !this.isDisabled && this.genRipple(this.setTextColor(this.computedColor)), this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], this.setTextColor(this.computedColor, {\n                props: {\n                    dark: this.dark,\n                    light: this.light\n                }\n            }), this.computedIcon)]);\n        },\n        onFocus: function onFocus() {\n            this.isFocused = true;\n        },\n        onBlur: function onBlur(e) {\n            this.isFocused = false;\n            this.$emit(\'blur\', e);\n        },\n        onChange: function onChange() {\n            if (this.isDisabled || this.isReadonly) return;\n            if (!this.isDisabled && (!this.isActive || !this.radio.mandatory)) {\n                this.$emit(\'change\', this.value);\n            }\n        },\n        onKeydown: function onKeydown() {}\n    },\n    render: function render(h) {\n        return h(\'div\', this.computedData, [this.genRadio(), this.genLabel()]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VRadioGroup/VRadioGroup.js":\n/*!***************************************************!*\\\n  !*** ./src/components/VRadioGroup/VRadioGroup.js ***!\n  \\***************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_selection_controls_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_selection-controls.styl */ "./src/stylus/components/_selection-controls.styl");\n/* harmony import */ var _stylus_components_selection_controls_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_selection_controls_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stylus_components_radio_group_styl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stylus/components/_radio-group.styl */ "./src/stylus/components/_radio-group.styl");\n/* harmony import */ var _stylus_components_radio_group_styl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_radio_group_styl__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _VInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VInput */ "./src/components/VInput/index.js");\n/* harmony import */ var _mixins_comparable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/comparable */ "./src/mixins/comparable.ts");\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\n// Styles\n\n\n// Components\n\n// Mixins\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-radio-group\',\n    extends: _VInput__WEBPACK_IMPORTED_MODULE_2__["default"],\n    mixins: [_mixins_comparable__WEBPACK_IMPORTED_MODULE_3__["default"], Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_4__["provide"])(\'radio\')],\n    model: {\n        prop: \'value\',\n        event: \'change\'\n    },\n    provide: function provide() {\n        return {\n            radio: this\n        };\n    },\n    props: {\n        column: {\n            type: Boolean,\n            default: true\n        },\n        height: {\n            type: [Number, String],\n            default: \'auto\'\n        },\n        mandatory: {\n            type: Boolean,\n            default: true\n        },\n        name: String,\n        row: Boolean,\n        // If no value set on VRadio\n        // will match valueComparator\n        // force default to null\n        value: {\n            default: null\n        }\n    },\n    data: function data() {\n        return {\n            internalTabIndex: -1,\n            radios: []\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return {\n                \'v-input--selection-controls v-input--radio-group\': true,\n                \'v-input--radio-group--column\': this.column && !this.row,\n                \'v-input--radio-group--row\': this.row\n            };\n        }\n    },\n    watch: {\n        hasError: \'setErrorState\',\n        internalValue: \'setActiveRadio\'\n    },\n    mounted: function mounted() {\n        this.setErrorState(this.hasError);\n        this.setActiveRadio();\n    },\n    methods: {\n        genDefaultSlot: function genDefaultSlot() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-input--radio-group__input\',\n                attrs: {\n                    role: \'radiogroup\'\n                }\n            }, _VInput__WEBPACK_IMPORTED_MODULE_2__["default"].methods.genDefaultSlot.call(this));\n        },\n        onRadioChange: function onRadioChange(value) {\n            if (this.disabled) return;\n            this.hasInput = true;\n            this.internalValue = value;\n            this.setActiveRadio();\n            this.$nextTick(this.validate);\n        },\n        onRadioBlur: function onRadioBlur(e) {\n            if (!e.relatedTarget || !e.relatedTarget.classList.contains(\'v-radio\')) {\n                this.hasInput = true;\n                this.$emit(\'blur\', e);\n            }\n        },\n        register: function register(radio) {\n            radio.isActive = this.valueComparator(this.internalValue, radio.value);\n            radio.$on(\'change\', this.onRadioChange);\n            radio.$on(\'blur\', this.onRadioBlur);\n            this.radios.push(radio);\n        },\n        setErrorState: function setErrorState(val) {\n            for (var index = this.radios.length; --index >= 0;) {\n                this.radios[index].parentError = val;\n            }\n        },\n        setActiveRadio: function setActiveRadio() {\n            for (var index = this.radios.length; --index >= 0;) {\n                var radio = this.radios[index];\n                radio.isActive = this.valueComparator(this.internalValue, radio.value);\n            }\n        },\n        unregister: function unregister(radio) {\n            radio.$off(\'change\', this.onRadioChange);\n            radio.$off(\'blur\', this.onRadioBlur);\n            var index = this.radios.findIndex(function (r) {\n                return r === radio;\n            });\n            /* istanbul ignore else */\n            if (index > -1) this.radios.splice(index, 1);\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VRadioGroup/index.js":\n/*!*********************************************!*\\\n  !*** ./src/components/VRadioGroup/index.js ***!\n  \\*********************************************/\n/*! exports provided: VRadioGroup, VRadio, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VRadioGroup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VRadioGroup */ "./src/components/VRadioGroup/VRadioGroup.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VRadioGroup", function() { return _VRadioGroup__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _VRadio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VRadio */ "./src/components/VRadioGroup/VRadio.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VRadio", function() { return _VRadio__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VRadioGroup: _VRadioGroup__WEBPACK_IMPORTED_MODULE_0__["default"],\n        VRadio: _VRadio__WEBPACK_IMPORTED_MODULE_1__["default"]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VRangeSlider/VRangeSlider.js":\n/*!*****************************************************!*\\\n  !*** ./src/components/VRangeSlider/VRangeSlider.js ***!\n  \\*****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_range_sliders_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_range-sliders.styl */ "./src/stylus/components/_range-sliders.styl");\n/* harmony import */ var _stylus_components_range_sliders_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_range_sliders_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VSlider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VSlider */ "./src/components/VSlider/index.js");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n// Styles\n\n// Extensions\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-range-slider\',\n    extends: _VSlider__WEBPACK_IMPORTED_MODULE_1__["default"],\n    props: {\n        value: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        }\n    },\n    data: function data(vm) {\n        return {\n            activeThumb: null,\n            lazyValue: !vm.value.length ? [0, 0] : vm.value\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return Object.assign({}, {\n                \'v-input--range-slider\': true\n            }, _VSlider__WEBPACK_IMPORTED_MODULE_1__["default"].computed.classes.call(this));\n        },\n        internalValue: {\n            get: function get() {\n                return this.lazyValue;\n            },\n            set: function set(val) {\n                var _this = this;\n                var _a = this,\n                    min = _a.min,\n                    max = _a.max;\n                // Round value to ensure the\n                // entire slider range can\n                // be selected with step\n                var value = val.map(function (v) {\n                    return _this.roundValue(Math.min(Math.max(v, min), max));\n                });\n                // Switch values if range and wrong order\n                if (value[0] > value[1] || value[1] < value[0]) {\n                    if (this.activeThumb !== null) this.activeThumb = this.activeThumb === 1 ? 0 : 1;\n                    value = [value[1], value[0]];\n                }\n                this.lazyValue = value;\n                if (!Object(_util_helpers__WEBPACK_IMPORTED_MODULE_2__["deepEqual"])(value, this.value)) this.$emit(\'input\', value);\n                this.validate();\n            }\n        },\n        inputWidth: function inputWidth() {\n            var _this = this;\n            return this.internalValue.map(function (v) {\n                return (_this.roundValue(v) - _this.min) / (_this.max - _this.min) * 100;\n            });\n        },\n        isDirty: function isDirty() {\n            var _this = this;\n            return this.internalValue.some(function (v) {\n                return v !== _this.min;\n            }) || this.alwaysDirty;\n        },\n        trackFillStyles: function trackFillStyles() {\n            var styles = _VSlider__WEBPACK_IMPORTED_MODULE_1__["default"].computed.trackFillStyles.call(this);\n            var fillPercent = Math.abs(this.inputWidth[0] - this.inputWidth[1]);\n            styles.width = "calc(" + fillPercent + "% - " + this.trackPadding + "px)";\n            styles[this.$vuetify.rtl ? \'right\' : \'left\'] = this.inputWidth[0] + "%";\n            return styles;\n        },\n        trackPadding: function trackPadding() {\n            if (this.isDirty || this.internalValue[0]) return 0;\n            return _VSlider__WEBPACK_IMPORTED_MODULE_1__["default"].computed.trackPadding.call(this);\n        }\n    },\n    methods: {\n        getIndexOfClosestValue: function getIndexOfClosestValue(arr, v) {\n            if (Math.abs(arr[0] - v) < Math.abs(arr[1] - v)) return 0;else return 1;\n        },\n        genInput: function genInput() {\n            var _this = this;\n            return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_2__["createRange"])(2).map(function (i) {\n                var input = _VSlider__WEBPACK_IMPORTED_MODULE_1__["default"].methods.genInput.call(_this);\n                input.data.attrs.value = _this.internalValue[i];\n                input.data.on.focus = function (e) {\n                    _this.activeThumb = i;\n                    _VSlider__WEBPACK_IMPORTED_MODULE_1__["default"].methods.onFocus.call(_this, e);\n                };\n                return input;\n            });\n        },\n        genChildren: function genChildren() {\n            var _this = this;\n            return [this.genInput(), this.genTrackContainer(), this.genSteps(), Object(_util_helpers__WEBPACK_IMPORTED_MODULE_2__["createRange"])(2).map(function (i) {\n                var value = _this.internalValue[i];\n                var onDrag = function onDrag(e) {\n                    _this.isActive = true;\n                    _this.activeThumb = i;\n                    _this.onThumbMouseDown(e);\n                };\n                var valueWidth = _this.inputWidth[i];\n                var isActive = (_this.isFocused || _this.isActive) && _this.activeThumb === i;\n                return _this.genThumbContainer(value, valueWidth, isActive, onDrag);\n            })];\n        },\n        onSliderClick: function onSliderClick(e) {\n            if (!this.isActive) {\n                this.isFocused = true;\n                this.onMouseMove(e, true);\n                this.$emit(\'change\', this.internalValue);\n            }\n        },\n        onMouseMove: function onMouseMove(e, trackClick) {\n            if (trackClick === void 0) {\n                trackClick = false;\n            }\n            var _a = this.parseMouseMove(e),\n                value = _a.value,\n                isInsideTrack = _a.isInsideTrack;\n            if (isInsideTrack) {\n                if (trackClick) this.activeThumb = this.getIndexOfClosestValue(this.internalValue, value);\n                this.setInternalValue(value);\n            }\n        },\n        onKeyDown: function onKeyDown(e) {\n            var value = this.parseKeyDown(e, this.internalValue[this.activeThumb]);\n            if (value == null) return;\n            this.setInternalValue(value);\n        },\n        setInternalValue: function setInternalValue(value) {\n            var _this = this;\n            this.internalValue = this.internalValue.map(function (v, i) {\n                if (i === _this.activeThumb) return value;else return Number(v);\n            });\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VRangeSlider/index.js":\n/*!**********************************************!*\\\n  !*** ./src/components/VRangeSlider/index.js ***!\n  \\**********************************************/\n/*! exports provided: VRangeSlider, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VRangeSlider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VRangeSlider */ "./src/components/VRangeSlider/VRangeSlider.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VRangeSlider", function() { return _VRangeSlider__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VRangeSlider__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VRating/VRating.ts":\n/*!*******************************************!*\\\n  !*** ./src/components/VRating/VRating.ts ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_rating_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_rating.styl */ "./src/stylus/components/_rating.styl");\n/* harmony import */ var _stylus_components_rating_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_rating_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_delayable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/delayable */ "./src/mixins/delayable.ts");\n/* harmony import */ var _mixins_sizeable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/sizeable */ "./src/mixins/sizeable.ts");\n/* harmony import */ var _mixins_rippleable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/rippleable */ "./src/mixins/rippleable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n// Styles\n\n// Components\n\n// Mixins\n\n\n\n\n\n// Utilities\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_8__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_delayable__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_rippleable__WEBPACK_IMPORTED_MODULE_5__["default"], _mixins_sizeable__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_6__["default"]).extend({\n    name: \'v-rating\',\n    props: {\n        backgroundColor: {\n            type: String,\n            default: \'accent\'\n        },\n        color: {\n            type: String,\n            default: \'primary\'\n        },\n        dense: Boolean,\n        emptyIcon: {\n            type: String,\n            default: \'$vuetify.icons.ratingEmpty\'\n        },\n        fullIcon: {\n            type: String,\n            default: \'$vuetify.icons.ratingFull\'\n        },\n        halfIcon: {\n            type: String,\n            default: \'$vuetify.icons.ratingHalf\'\n        },\n        halfIncrements: Boolean,\n        length: {\n            type: [Number, String],\n            default: 5\n        },\n        clearable: Boolean,\n        readonly: Boolean,\n        hover: Boolean,\n        value: {\n            type: Number,\n            default: 0\n        }\n    },\n    data: function data() {\n        return {\n            hoverIndex: -1,\n            internalValue: this.value\n        };\n    },\n    computed: {\n        directives: function directives() {\n            if (this.readonly || !this.ripple) return [];\n            return [{\n                name: \'ripple\',\n                value: { circle: true }\n            }];\n        },\n        iconProps: function iconProps() {\n            var _a = this.$props,\n                dark = _a.dark,\n                medium = _a.medium,\n                large = _a.large,\n                light = _a.light,\n                small = _a.small,\n                size = _a.size,\n                xLarge = _a.xLarge;\n            return {\n                dark: dark,\n                medium: medium,\n                large: large,\n                light: light,\n                size: size,\n                small: small,\n                xLarge: xLarge\n            };\n        },\n        isHovering: function isHovering() {\n            return this.hover && this.hoverIndex >= 0;\n        }\n    },\n    watch: {\n        internalValue: function internalValue(val) {\n            val !== this.value && this.$emit(\'input\', val);\n        },\n        value: function value(val) {\n            this.internalValue = val;\n        }\n    },\n    methods: {\n        createClickFn: function createClickFn(i) {\n            var _this = this;\n            return function (e) {\n                if (_this.readonly) return;\n                var newValue = _this.genHoverIndex(e, i);\n                if (_this.clearable && _this.internalValue === newValue) {\n                    _this.internalValue = 0;\n                } else {\n                    _this.internalValue = newValue;\n                }\n            };\n        },\n        createProps: function createProps(i) {\n            var props = {\n                index: i,\n                value: this.internalValue,\n                click: this.createClickFn(i),\n                isFilled: Math.floor(this.internalValue) > i,\n                isHovered: Math.floor(this.hoverIndex) > i\n            };\n            if (this.halfIncrements) {\n                props.isHalfHovered = !props.isHovered && (this.hoverIndex - i) % 1 > 0;\n                props.isHalfFilled = !props.isFilled && (this.internalValue - i) % 1 > 0;\n            }\n            return props;\n        },\n        genHoverIndex: function genHoverIndex(e, i) {\n            return i + (this.isHalfEvent(e) ? 0.5 : 1);\n        },\n        getIconName: function getIconName(props) {\n            var isFull = this.isHovering ? props.isHovered : props.isFilled;\n            var isHalf = this.isHovering ? props.isHalfHovered : props.isHalfFilled;\n            return isFull ? this.fullIcon : isHalf ? this.halfIcon : this.emptyIcon;\n        },\n        getColor: function getColor(props) {\n            if (this.isHovering) {\n                if (props.isHovered || props.isHalfHovered) return this.color;\n            } else {\n                if (props.isFilled || props.isHalfFilled) return this.color;\n            }\n            return this.backgroundColor;\n        },\n        isHalfEvent: function isHalfEvent(e) {\n            if (this.halfIncrements) {\n                var rect = e.target && e.target.getBoundingClientRect();\n                if (rect && e.pageX - rect.left < rect.width / 2) return true;\n            }\n            return false;\n        },\n        onMouseEnter: function onMouseEnter(e, i) {\n            var _this = this;\n            this.runDelay(\'open\', function () {\n                _this.hoverIndex = _this.genHoverIndex(e, i);\n            });\n        },\n        onMouseLeave: function onMouseLeave() {\n            var _this = this;\n            this.runDelay(\'close\', function () {\n                return _this.hoverIndex = -1;\n            });\n        },\n        genItem: function genItem(i) {\n            var _this = this;\n            var props = this.createProps(i);\n            if (this.$scopedSlots.item) return this.$scopedSlots.item(props);\n            var listeners = {\n                click: props.click\n            };\n            if (this.hover) {\n                listeners.mouseenter = function (e) {\n                    return _this.onMouseEnter(e, i);\n                };\n                listeners.mouseleave = this.onMouseLeave;\n                if (this.halfIncrements) {\n                    listeners.mousemove = function (e) {\n                        return _this.onMouseEnter(e, i);\n                    };\n                }\n            }\n            return this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], this.setTextColor(this.getColor(props), {\n                directives: this.directives,\n                props: this.iconProps,\n                on: listeners\n            }), [this.getIconName(props)]);\n        }\n    },\n    render: function render(h) {\n        var _this = this;\n        var children = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["createRange"])(Number(this.length)).map(function (i) {\n            return _this.genItem(i);\n        });\n        return h(\'div\', {\n            staticClass: \'v-rating\',\n            class: {\n                \'v-rating--readonly\': this.readonly,\n                \'v-rating--dense\': this.dense\n            }\n        }, children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VRating/index.ts":\n/*!*****************************************!*\\\n  !*** ./src/components/VRating/index.ts ***!\n  \\*****************************************/\n/*! exports provided: VRating, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VRating__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VRating */ "./src/components/VRating/VRating.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VRating", function() { return _VRating__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VRating__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VResponsive/VResponsive.ts":\n/*!***************************************************!*\\\n  !*** ./src/components/VResponsive/VResponsive.ts ***!\n  \\***************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_responsive_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_responsive.styl */ "./src/stylus/components/_responsive.styl");\n/* harmony import */ var _stylus_components_responsive_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_responsive_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_measurable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/measurable */ "./src/mixins/measurable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n\n// Mixins\n\n// Utils\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_2__["default"])(_mixins_measurable__WEBPACK_IMPORTED_MODULE_1__["default"]).extend({\n    name: \'v-responsive\',\n    props: {\n        aspectRatio: [String, Number]\n    },\n    computed: {\n        computedAspectRatio: function computedAspectRatio() {\n            return Number(this.aspectRatio);\n        },\n        aspectStyle: function aspectStyle() {\n            return this.computedAspectRatio ? { paddingBottom: 1 / this.computedAspectRatio * 100 + \'%\' } : undefined;\n        },\n        __cachedSizer: function __cachedSizer() {\n            if (!this.aspectStyle) return [];\n            return this.$createElement(\'div\', {\n                style: this.aspectStyle,\n                staticClass: \'v-responsive__sizer\'\n            });\n        }\n    },\n    methods: {\n        genContent: function genContent() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-responsive__content\'\n            }, this.$slots.default);\n        }\n    },\n    render: function render(h) {\n        return h(\'div\', {\n            staticClass: \'v-responsive\',\n            style: {\n                height: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["convertToUnit"])(this.height),\n                maxHeight: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["convertToUnit"])(this.maxHeight),\n                maxWidth: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["convertToUnit"])(this.maxWidth),\n                width: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["convertToUnit"])(this.width)\n            },\n            on: this.$listeners\n        }, [this.__cachedSizer, this.genContent()]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VResponsive/index.ts":\n/*!*********************************************!*\\\n  !*** ./src/components/VResponsive/index.ts ***!\n  \\*********************************************/\n/*! exports provided: VResponsive, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VResponsive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VResponsive */ "./src/components/VResponsive/VResponsive.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VResponsive", function() { return _VResponsive__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VResponsive__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VSelect/VSelect.js":\n/*!*******************************************!*\\\n  !*** ./src/components/VSelect/VSelect.js ***!\n  \\*******************************************/\n/*! exports provided: defaultMenuProps, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultMenuProps", function() { return defaultMenuProps; });\n/* harmony import */ var _stylus_components_text_fields_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_text-fields.styl */ "./src/stylus/components/_text-fields.styl");\n/* harmony import */ var _stylus_components_text_fields_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_text_fields_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stylus_components_select_styl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stylus/components/_select.styl */ "./src/stylus/components/_select.styl");\n/* harmony import */ var _stylus_components_select_styl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_select_styl__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _VChip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VChip */ "./src/components/VChip/index.ts");\n/* harmony import */ var _VMenu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VMenu */ "./src/components/VMenu/index.js");\n/* harmony import */ var _VSelectList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VSelectList */ "./src/components/VSelect/VSelectList.js");\n/* harmony import */ var _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VTextField/VTextField */ "./src/components/VTextField/VTextField.js");\n/* harmony import */ var _mixins_comparable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../mixins/comparable */ "./src/mixins/comparable.ts");\n/* harmony import */ var _mixins_filterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../mixins/filterable */ "./src/mixins/filterable.ts");\n/* harmony import */ var _directives_click_outside__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../directives/click-outside */ "./src/directives/click-outside.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = undefined && undefined.__values || function (o) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator],\n        i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function next() {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\n// Styles\n\n\n// Components\n\n\n\n// Extensions\n\n// Mixins\n\n\n// Directives\n\n// Helpers\n\n\nvar defaultMenuProps = {\n    closeOnClick: false,\n    closeOnContentClick: false,\n    openOnClick: false,\n    maxHeight: 300\n};\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-select\',\n    directives: {\n        ClickOutside: _directives_click_outside__WEBPACK_IMPORTED_MODULE_8__["default"]\n    },\n    extends: _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_5__["default"],\n    mixins: [_mixins_comparable__WEBPACK_IMPORTED_MODULE_6__["default"], _mixins_filterable__WEBPACK_IMPORTED_MODULE_7__["default"]],\n    props: {\n        appendIcon: {\n            type: String,\n            default: \'$vuetify.icons.dropdown\'\n        },\n        appendIconCb: Function,\n        attach: {\n            type: null,\n            default: false\n        },\n        browserAutocomplete: {\n            type: String,\n            default: \'on\'\n        },\n        cacheItems: Boolean,\n        chips: Boolean,\n        clearable: Boolean,\n        deletableChips: Boolean,\n        dense: Boolean,\n        hideSelected: Boolean,\n        items: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        },\n        itemAvatar: {\n            type: [String, Array, Function],\n            default: \'avatar\'\n        },\n        itemDisabled: {\n            type: [String, Array, Function],\n            default: \'disabled\'\n        },\n        itemText: {\n            type: [String, Array, Function],\n            default: \'text\'\n        },\n        itemValue: {\n            type: [String, Array, Function],\n            default: \'value\'\n        },\n        menuProps: {\n            type: [String, Array, Object],\n            default: function _default() {\n                return defaultMenuProps;\n            }\n        },\n        multiple: Boolean,\n        openOnClear: Boolean,\n        returnObject: Boolean,\n        searchInput: {\n            default: null\n        },\n        smallChips: Boolean\n    },\n    data: function data(vm) {\n        return {\n            attrsInput: { role: \'combobox\' },\n            cachedItems: vm.cacheItems ? vm.items : [],\n            content: null,\n            isBooted: false,\n            isMenuActive: false,\n            lastItem: 20,\n            // As long as a value is defined, show it\n            // Otherwise, check if multiple\n            // to determine which default to provide\n            lazyValue: vm.value !== undefined ? vm.value : vm.multiple ? [] : undefined,\n            selectedIndex: -1,\n            selectedItems: []\n        };\n    },\n    computed: {\n        /* All items that the select has */\n        allItems: function allItems() {\n            return this.filterDuplicates(this.cachedItems.concat(this.items));\n        },\n        classes: function classes() {\n            return Object.assign({}, _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_5__["default"].computed.classes.call(this), {\n                \'v-select\': true,\n                \'v-select--chips\': this.hasChips,\n                \'v-select--chips--small\': this.smallChips,\n                \'v-select--is-menu-active\': this.isMenuActive\n            });\n        },\n        /* Used by other components to overwrite */\n        computedItems: function computedItems() {\n            return this.allItems;\n        },\n        counterValue: function counterValue() {\n            return this.multiple ? this.selectedItems.length : (this.getText(this.selectedItems[0]) || \'\').toString().length;\n        },\n        directives: function directives() {\n            return this.isFocused ? [{\n                name: \'click-outside\',\n                value: this.blur,\n                args: {\n                    closeConditional: this.closeConditional\n                }\n            }] : undefined;\n        },\n        dynamicHeight: function dynamicHeight() {\n            return \'auto\';\n        },\n        hasChips: function hasChips() {\n            return this.chips || this.smallChips;\n        },\n        hasSlot: function hasSlot() {\n            return Boolean(this.hasChips || this.$scopedSlots.selection);\n        },\n        isDirty: function isDirty() {\n            return this.selectedItems.length > 0;\n        },\n        listData: function listData() {\n            return {\n                props: {\n                    action: this.multiple && !this.isHidingSelected,\n                    color: this.color,\n                    dense: this.dense,\n                    hideSelected: this.hideSelected,\n                    items: this.virtualizedItems,\n                    noDataText: this.$vuetify.t(this.noDataText),\n                    selectedItems: this.selectedItems,\n                    itemAvatar: this.itemAvatar,\n                    itemDisabled: this.itemDisabled,\n                    itemValue: this.itemValue,\n                    itemText: this.itemText\n                },\n                on: {\n                    select: this.selectItem\n                },\n                scopedSlots: {\n                    item: this.$scopedSlots.item\n                }\n            };\n        },\n        staticList: function staticList() {\n            if (this.$slots[\'no-data\'] || this.$slots[\'prepend-item\'] || this.$slots[\'append-item\']) {\n                Object(_util_console__WEBPACK_IMPORTED_MODULE_10__["consoleError"])(\'assert: staticList should not be called if slots are used\');\n            }\n            return this.$createElement(_VSelectList__WEBPACK_IMPORTED_MODULE_4__["default"], this.listData);\n        },\n        virtualizedItems: function virtualizedItems() {\n            return this.$_menuProps.auto ? this.computedItems : this.computedItems.slice(0, this.lastItem);\n        },\n        menuCanShow: function menuCanShow() {\n            return true;\n        },\n        $_menuProps: function $_menuProps() {\n            var normalisedProps;\n            normalisedProps = typeof this.menuProps === \'string\' ? this.menuProps.split(\',\') : this.menuProps;\n            if (Array.isArray(normalisedProps)) {\n                normalisedProps = normalisedProps.reduce(function (acc, p) {\n                    acc[p.trim()] = true;\n                    return acc;\n                }, {});\n            }\n            return __assign({}, defaultMenuProps, { value: this.menuCanShow && this.isMenuActive, nudgeBottom: this.nudgeBottom ? this.nudgeBottom : normalisedProps.offsetY ? 1 : 0 }, normalisedProps);\n        }\n    },\n    watch: {\n        internalValue: function internalValue(val) {\n            this.initialValue = val;\n            this.setSelectedItems();\n        },\n        isBooted: function isBooted() {\n            var _this = this;\n            this.$nextTick(function () {\n                if (_this.content && _this.content.addEventListener) {\n                    _this.content.addEventListener(\'scroll\', _this.onScroll, false);\n                }\n            });\n        },\n        isMenuActive: function isMenuActive(val) {\n            if (!val) return;\n            this.isBooted = true;\n        },\n        items: {\n            immediate: true,\n            handler: function handler(val) {\n                if (this.cacheItems) {\n                    this.cachedItems = this.filterDuplicates(this.cachedItems.concat(val));\n                }\n                this.setSelectedItems();\n            }\n        }\n    },\n    mounted: function mounted() {\n        this.content = this.$refs.menu && this.$refs.menu.$refs.content;\n    },\n    methods: {\n        /** @public */\n        blur: function blur() {\n            this.isMenuActive = false;\n            this.isFocused = false;\n            this.$refs.input && this.$refs.input.blur();\n            this.selectedIndex = -1;\n        },\n        /** @public */\n        activateMenu: function activateMenu() {\n            this.isMenuActive = true;\n        },\n        clearableCallback: function clearableCallback() {\n            var _this = this;\n            this.setValue(this.multiple ? [] : undefined);\n            this.$nextTick(function () {\n                return _this.$refs.input.focus();\n            });\n            if (this.openOnClear) this.isMenuActive = true;\n        },\n        closeConditional: function closeConditional(e) {\n            return (\n                // Click originates from outside the menu content\n                !!this.content && !this.content.contains(e.target) &&\n                // Click originates from outside the element\n                !!this.$el && !this.$el.contains(e.target) && e.target !== this.$el\n            );\n        },\n        filterDuplicates: function filterDuplicates(arr) {\n            var uniqueValues = new Map();\n            for (var index = 0; index < arr.length; ++index) {\n                var item = arr[index];\n                var val = this.getValue(item);\n                // TODO: comparator\n                !uniqueValues.has(val) && uniqueValues.set(val, item);\n            }\n            return Array.from(uniqueValues.values());\n        },\n        findExistingIndex: function findExistingIndex(item) {\n            var _this = this;\n            var itemValue = this.getValue(item);\n            return (this.internalValue || []).findIndex(function (i) {\n                return _this.valueComparator(_this.getValue(i), itemValue);\n            });\n        },\n        genChipSelection: function genChipSelection(item, index) {\n            var _this = this;\n            var isDisabled = this.disabled || this.readonly || this.getDisabled(item);\n            var focus = function focus(e, cb) {\n                if (isDisabled) return;\n                e.stopPropagation();\n                _this.onFocus();\n                cb && cb();\n            };\n            return this.$createElement(_VChip__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                staticClass: \'v-chip--select-multi\',\n                props: {\n                    close: this.deletableChips && !isDisabled,\n                    disabled: isDisabled,\n                    selected: index === this.selectedIndex,\n                    small: this.smallChips\n                },\n                on: {\n                    click: function click(e) {\n                        focus(e, function () {\n                            _this.selectedIndex = index;\n                        });\n                    },\n                    focus: focus,\n                    input: function input() {\n                        return _this.onChipInput(item);\n                    }\n                },\n                key: this.getValue(item)\n            }, this.getText(item));\n        },\n        genCommaSelection: function genCommaSelection(item, index, last) {\n            // Item may be an object\n            // TODO: Remove JSON.stringify\n            var key = JSON.stringify(this.getValue(item));\n            var color = index === this.selectedIndex && this.color;\n            var isDisabled = this.disabled || this.getDisabled(item);\n            return this.$createElement(\'div\', this.setTextColor(color, {\n                staticClass: \'v-select__selection v-select__selection--comma\',\n                \'class\': {\n                    \'v-select__selection--disabled\': isDisabled\n                },\n                key: key\n            }), "" + this.getText(item) + (last ? \'\' : \', \'));\n        },\n        genDefaultSlot: function genDefaultSlot() {\n            var selections = this.genSelections();\n            var input = this.genInput();\n            // If the return is an empty array\n            // push the input\n            if (Array.isArray(selections)) {\n                selections.push(input);\n                // Otherwise push it into children\n            } else {\n                selections.children = selections.children || [];\n                selections.children.push(input);\n            }\n            return [this.$createElement(\'div\', {\n                staticClass: \'v-select__slot\',\n                directives: this.directives\n            }, [this.genLabel(), this.prefix ? this.genAffix(\'prefix\') : null, selections, this.suffix ? this.genAffix(\'suffix\') : null, this.genClearIcon(), this.genIconSlot()]), this.genMenu(), this.genProgress()];\n        },\n        genInput: function genInput() {\n            var input = _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_5__["default"].methods.genInput.call(this);\n            input.data.domProps.value = null;\n            input.data.attrs.readonly = true;\n            input.data.attrs[\'aria-readonly\'] = String(this.readonly);\n            return input;\n        },\n        genList: function genList() {\n            // If there\'s no slots, we can use a cached VNode to improve performance\n            if (this.$slots[\'no-data\'] || this.$slots[\'prepend-item\'] || this.$slots[\'append-item\']) {\n                return this.genListWithSlot();\n            } else {\n                return this.staticList;\n            }\n        },\n        genListWithSlot: function genListWithSlot() {\n            var _this = this;\n            var slots = [\'prepend-item\', \'no-data\', \'append-item\'].filter(function (slotName) {\n                return _this.$slots[slotName];\n            }).map(function (slotName) {\n                return _this.$createElement(\'template\', {\n                    slot: slotName\n                }, _this.$slots[slotName]);\n            });\n            // Requires destructuring due to Vue\n            // modifying the `on` property when passed\n            // as a referenced object\n            return this.$createElement(_VSelectList__WEBPACK_IMPORTED_MODULE_4__["default"], __assign({}, this.listData), slots);\n        },\n        genMenu: function genMenu() {\n            var _this = this;\n            var e_1, _a;\n            var props = this.$_menuProps;\n            props.activator = this.$refs[\'input-slot\'];\n            // Deprecate using menu props directly\n            // TODO: remove (2.0)\n            var inheritedProps = Object.keys(_VMenu__WEBPACK_IMPORTED_MODULE_3__["default"].options.props);\n            var deprecatedProps = Object.keys(this.$attrs).reduce(function (acc, attr) {\n                if (inheritedProps.includes(Object(_util_helpers__WEBPACK_IMPORTED_MODULE_9__["camelize"])(attr))) acc.push(attr);\n                return acc;\n            }, []);\n            try {\n                for (var deprecatedProps_1 = __values(deprecatedProps), deprecatedProps_1_1 = deprecatedProps_1.next(); !deprecatedProps_1_1.done; deprecatedProps_1_1 = deprecatedProps_1.next()) {\n                    var prop = deprecatedProps_1_1.value;\n                    props[Object(_util_helpers__WEBPACK_IMPORTED_MODULE_9__["camelize"])(prop)] = this.$attrs[prop];\n                }\n            } catch (e_1_1) {\n                e_1 = { error: e_1_1 };\n            } finally {\n                try {\n                    if (deprecatedProps_1_1 && !deprecatedProps_1_1.done && (_a = deprecatedProps_1.return)) _a.call(deprecatedProps_1);\n                } finally {\n                    if (e_1) throw e_1.error;\n                }\n            }\n            if (true) {\n                if (deprecatedProps.length) {\n                    var multiple = deprecatedProps.length > 1;\n                    var replacement_1 = deprecatedProps.reduce(function (acc, p) {\n                        acc[Object(_util_helpers__WEBPACK_IMPORTED_MODULE_9__["camelize"])(p)] = _this.$attrs[p];\n                        return acc;\n                    }, {});\n                    var props_1 = deprecatedProps.map(function (p) {\n                        return "\'" + p + "\'";\n                    }).join(\', \');\n                    var separator = multiple ? \'\\n\' : \'\\\'\';\n                    var onlyBools = Object.keys(replacement_1).every(function (prop) {\n                        var propType = _VMenu__WEBPACK_IMPORTED_MODULE_3__["default"].options.props[prop];\n                        var value = replacement_1[prop];\n                        return value === true || (propType.type || propType) === Boolean && value === \'\';\n                    });\n                    if (onlyBools) {\n                        replacement_1 = Object.keys(replacement_1).join(\', \');\n                    } else {\n                        replacement_1 = JSON.stringify(replacement_1, null, multiple ? 2 : 0).replace(/"([^(")"]+)":/g, \'$1:\').replace(/"/g, \'\\\'\');\n                    }\n                    Object(_util_console__WEBPACK_IMPORTED_MODULE_10__["consoleWarn"])(props_1 + " " + (multiple ? \'are\' : \'is\') + " deprecated, use " + separator + ":menu-props=\\"" + replacement_1 + "\\"" + separator + " instead", this);\n                }\n            }\n            // Attach to root el so that\n            // menu covers prepend/append icons\n            if (\n            // TODO: make this a computed property or helper or something\n            this.attach === \'\' || // If used as a boolean prop (<v-menu attach>)\n            this.attach === true || // If bound to a boolean (<v-menu :attach="true">)\n            this.attach === \'attach\' // If bound as boolean prop in pug (v-menu(attach))\n            ) {\n                    props.attach = this.$el;\n                } else {\n                props.attach = this.attach;\n            }\n            return this.$createElement(_VMenu__WEBPACK_IMPORTED_MODULE_3__["default"], {\n                props: props,\n                on: {\n                    input: function input(val) {\n                        _this.isMenuActive = val;\n                        _this.isFocused = val;\n                    }\n                },\n                ref: \'menu\'\n            }, [this.genList()]);\n        },\n        genSelections: function genSelections() {\n            var length = this.selectedItems.length;\n            var children = new Array(length);\n            var genSelection;\n            if (this.$scopedSlots.selection) {\n                genSelection = this.genSlotSelection;\n            } else if (this.hasChips) {\n                genSelection = this.genChipSelection;\n            } else {\n                genSelection = this.genCommaSelection;\n            }\n            while (length--) {\n                children[length] = genSelection(this.selectedItems[length], length, length === children.length - 1);\n            }\n            return this.$createElement(\'div\', {\n                staticClass: \'v-select__selections\'\n            }, children);\n        },\n        genSlotSelection: function genSlotSelection(item, index) {\n            return this.$scopedSlots.selection({\n                parent: this,\n                item: item,\n                index: index,\n                selected: index === this.selectedIndex,\n                disabled: this.disabled || this.readonly\n            });\n        },\n        getMenuIndex: function getMenuIndex() {\n            return this.$refs.menu ? this.$refs.menu.listIndex : -1;\n        },\n        getDisabled: function getDisabled(item) {\n            return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_9__["getPropertyFromItem"])(item, this.itemDisabled, false);\n        },\n        getText: function getText(item) {\n            return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_9__["getPropertyFromItem"])(item, this.itemText, item);\n        },\n        getValue: function getValue(item) {\n            return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_9__["getPropertyFromItem"])(item, this.itemValue, this.getText(item));\n        },\n        onBlur: function onBlur(e) {\n            this.$emit(\'blur\', e);\n        },\n        onChipInput: function onChipInput(item) {\n            if (this.multiple) this.selectItem(item);else this.setValue(null);\n            // If all items have been deleted,\n            // open `v-menu`\n            if (this.selectedItems.length === 0) {\n                this.isMenuActive = true;\n            }\n            this.selectedIndex = -1;\n        },\n        onClick: function onClick() {\n            if (this.isDisabled) return;\n            this.isMenuActive = true;\n            if (!this.isFocused) {\n                this.isFocused = true;\n                this.$emit(\'focus\');\n            }\n        },\n        onEnterDown: function onEnterDown() {\n            this.onBlur();\n        },\n        onEscDown: function onEscDown(e) {\n            e.preventDefault();\n            this.isMenuActive = false;\n        },\n        onKeyDown: function onKeyDown(e) {\n            var keyCode = e.keyCode;\n            // If enter, space, up, or down is pressed, open menu\n            if (!this.readonly && !this.isMenuActive && [_util_helpers__WEBPACK_IMPORTED_MODULE_9__["keyCodes"].enter, _util_helpers__WEBPACK_IMPORTED_MODULE_9__["keyCodes"].space, _util_helpers__WEBPACK_IMPORTED_MODULE_9__["keyCodes"].up, _util_helpers__WEBPACK_IMPORTED_MODULE_9__["keyCodes"].down].includes(keyCode)) this.activateMenu();\n            if (this.isMenuActive && this.$refs.menu) this.$refs.menu.changeListIndex(e);\n            // This should do something different\n            if (keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_9__["keyCodes"].enter) return this.onEnterDown(e);\n            // If escape deactivate the menu\n            if (keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_9__["keyCodes"].esc) return this.onEscDown(e);\n            // If tab - select item or close menu\n            if (keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_9__["keyCodes"].tab) return this.onTabDown(e);\n        },\n        onMouseUp: function onMouseUp(e) {\n            var _this = this;\n            var appendInner = this.$refs[\'append-inner\'];\n            // If append inner is present\n            // and the target is itself\n            // or inside, toggle menu\n            if (this.isMenuActive && appendInner && (appendInner === e.target || appendInner.contains(e.target))) {\n                this.$nextTick(function () {\n                    return _this.isMenuActive = !_this.isMenuActive;\n                });\n                // If user is clicking in the container\n                // and field is enclosed, activate it\n            } else if (this.isEnclosed && !this.isDisabled) {\n                this.isMenuActive = true;\n            }\n            _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_5__["default"].methods.onMouseUp.call(this, e);\n        },\n        onScroll: function onScroll() {\n            var _this = this;\n            if (!this.isMenuActive) {\n                requestAnimationFrame(function () {\n                    return _this.content.scrollTop = 0;\n                });\n            } else {\n                if (this.lastItem >= this.computedItems.length) return;\n                var showMoreItems = this.content.scrollHeight - (this.content.scrollTop + this.content.clientHeight) < 200;\n                if (showMoreItems) {\n                    this.lastItem += 20;\n                }\n            }\n        },\n        onTabDown: function onTabDown(e) {\n            var menuIndex = this.getMenuIndex();\n            var listTile = this.$refs.menu.tiles[menuIndex];\n            // An item that is selected by\n            // menu-index should toggled\n            if (listTile && listTile.className.indexOf(\'v-list__tile--highlighted\') > -1 && this.isMenuActive && menuIndex > -1) {\n                e.preventDefault();\n                e.stopPropagation();\n                listTile.click();\n            } else {\n                // If we make it here,\n                // the user has no selected indexes\n                // and is probably tabbing out\n                _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_5__["default"].methods.onBlur.call(this, e);\n            }\n        },\n        selectItem: function selectItem(item) {\n            var _this = this;\n            if (!this.multiple) {\n                this.setValue(this.returnObject ? item : this.getValue(item));\n                this.isMenuActive = false;\n            } else {\n                var internalValue = (this.internalValue || []).slice();\n                var i = this.findExistingIndex(item);\n                i !== -1 ? internalValue.splice(i, 1) : internalValue.push(item);\n                this.setValue(internalValue.map(function (i) {\n                    return _this.returnObject ? i : _this.getValue(i);\n                }));\n                // When selecting multiple\n                // adjust menu after each\n                // selection\n                this.$nextTick(function () {\n                    _this.$refs.menu && _this.$refs.menu.updateDimensions();\n                });\n            }\n        },\n        setMenuIndex: function setMenuIndex(index) {\n            this.$refs.menu && (this.$refs.menu.listIndex = index);\n        },\n        setSelectedItems: function setSelectedItems() {\n            var _this = this;\n            var e_2, _a;\n            var selectedItems = [];\n            var values = !this.multiple || !Array.isArray(this.internalValue) ? [this.internalValue] : this.internalValue;\n            var _loop_1 = function _loop_1(value) {\n                var index = this_1.allItems.findIndex(function (v) {\n                    return _this.valueComparator(_this.getValue(v), _this.getValue(value));\n                });\n                if (index > -1) {\n                    selectedItems.push(this_1.allItems[index]);\n                }\n            };\n            var this_1 = this;\n            try {\n                for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {\n                    var value = values_1_1.value;\n                    _loop_1(value);\n                }\n            } catch (e_2_1) {\n                e_2 = { error: e_2_1 };\n            } finally {\n                try {\n                    if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);\n                } finally {\n                    if (e_2) throw e_2.error;\n                }\n            }\n            this.selectedItems = selectedItems;\n        },\n        setValue: function setValue(value) {\n            this.internalValue = value;\n            this.$emit(\'change\', value);\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VSelect/VSelectList.js":\n/*!***********************************************!*\\\n  !*** ./src/components/VSelect/VSelectList.js ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_cards_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_cards.styl */ "./src/stylus/components/_cards.styl");\n/* harmony import */ var _stylus_components_cards_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_cards_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VCheckbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VCheckbox */ "./src/components/VCheckbox/index.js");\n/* harmony import */ var _VDivider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VDivider */ "./src/components/VDivider/index.ts");\n/* harmony import */ var _VSubheader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VSubheader */ "./src/components/VSubheader/index.js");\n/* harmony import */ var _VList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VList */ "./src/components/VList/index.js");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\nvar __values = undefined && undefined.__values || function (o) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator],\n        i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function next() {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\n\n// Components\n\n\n\n\n// Mixins\n\n\n// Helpers\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-select-list\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_5__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_6__["default"]],\n    props: {\n        action: Boolean,\n        dense: Boolean,\n        hideSelected: Boolean,\n        items: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        },\n        itemAvatar: {\n            type: [String, Array, Function],\n            default: \'avatar\'\n        },\n        itemDisabled: {\n            type: [String, Array, Function],\n            default: \'disabled\'\n        },\n        itemText: {\n            type: [String, Array, Function],\n            default: \'text\'\n        },\n        itemValue: {\n            type: [String, Array, Function],\n            default: \'value\'\n        },\n        noDataText: String,\n        noFilter: Boolean,\n        searchInput: {\n            default: null\n        },\n        selectedItems: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        }\n    },\n    computed: {\n        parsedItems: function parsedItems() {\n            var _this = this;\n            return this.selectedItems.map(function (item) {\n                return _this.getValue(item);\n            });\n        },\n        tileActiveClass: function tileActiveClass() {\n            return Object.keys(this.setTextColor(this.color).class || {}).join(\' \');\n        },\n        staticNoDataTile: function staticNoDataTile() {\n            var tile = {\n                on: {\n                    mousedown: function mousedown(e) {\n                        return e.preventDefault();\n                    } // Prevent onBlur from being called\n                }\n            };\n            return this.$createElement(_VList__WEBPACK_IMPORTED_MODULE_4__["VListTile"], tile, [this.genTileContent(this.noDataText)]);\n        }\n    },\n    methods: {\n        genAction: function genAction(item, inputValue) {\n            var _this = this;\n            var data = {\n                on: {\n                    click: function click(e) {\n                        e.stopPropagation();\n                        _this.$emit(\'select\', item);\n                    }\n                }\n            };\n            return this.$createElement(_VList__WEBPACK_IMPORTED_MODULE_4__["VListTileAction"], data, [this.$createElement(_VCheckbox__WEBPACK_IMPORTED_MODULE_1__["default"], {\n                props: {\n                    color: this.color,\n                    inputValue: inputValue\n                }\n            })]);\n        },\n        genDivider: function genDivider(props) {\n            return this.$createElement(_VDivider__WEBPACK_IMPORTED_MODULE_2__["default"], { props: props });\n        },\n        genFilteredText: function genFilteredText(text) {\n            text = (text || \'\').toString();\n            if (!this.searchInput || this.noFilter) return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["escapeHTML"])(text);\n            var _a = this.getMaskedCharacters(text),\n                start = _a.start,\n                middle = _a.middle,\n                end = _a.end;\n            return "" + Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["escapeHTML"])(start) + this.genHighlight(middle) + Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["escapeHTML"])(end);\n        },\n        genHeader: function genHeader(props) {\n            return this.$createElement(_VSubheader__WEBPACK_IMPORTED_MODULE_3__["default"], { props: props }, props.header);\n        },\n        genHighlight: function genHighlight(text) {\n            return "<span class=\\"v-list__tile__mask\\">" + Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["escapeHTML"])(text) + "</span>";\n        },\n        getMaskedCharacters: function getMaskedCharacters(text) {\n            var searchInput = (this.searchInput || \'\').toString().toLowerCase();\n            var index = text.toLowerCase().indexOf(searchInput);\n            if (index < 0) return { start: \'\', middle: text, end: \'\' };\n            var start = text.slice(0, index);\n            var middle = text.slice(index, index + searchInput.length);\n            var end = text.slice(index + searchInput.length);\n            return { start: start, middle: middle, end: end };\n        },\n        genTile: function genTile(item, disabled, avatar, value) {\n            var _this = this;\n            if (disabled === void 0) {\n                disabled = null;\n            }\n            if (avatar === void 0) {\n                avatar = false;\n            }\n            if (value === void 0) {\n                value = this.hasItem(item);\n            }\n            if (item === Object(item)) {\n                avatar = this.getAvatar(item);\n                disabled = disabled !== null ? disabled : this.getDisabled(item);\n            }\n            var tile = {\n                on: {\n                    mousedown: function mousedown(e) {\n                        // Prevent onBlur from being called\n                        e.preventDefault();\n                    },\n                    click: function click() {\n                        return disabled || _this.$emit(\'select\', item);\n                    }\n                },\n                props: {\n                    activeClass: this.tileActiveClass,\n                    avatar: avatar,\n                    disabled: disabled,\n                    ripple: true,\n                    value: value\n                }\n            };\n            if (!this.$scopedSlots.item) {\n                return this.$createElement(_VList__WEBPACK_IMPORTED_MODULE_4__["VListTile"], tile, [this.action && !this.hideSelected && this.items.length > 0 ? this.genAction(item, value) : null, this.genTileContent(item)]);\n            }\n            var parent = this;\n            var scopedSlot = this.$scopedSlots.item({ parent: parent, item: item, tile: tile });\n            return this.needsTile(scopedSlot) ? this.$createElement(_VList__WEBPACK_IMPORTED_MODULE_4__["VListTile"], tile, [scopedSlot]) : scopedSlot;\n        },\n        genTileContent: function genTileContent(item) {\n            var innerHTML = this.genFilteredText(this.getText(item));\n            return this.$createElement(_VList__WEBPACK_IMPORTED_MODULE_4__["VListTileContent"], [this.$createElement(_VList__WEBPACK_IMPORTED_MODULE_4__["VListTileTitle"], {\n                domProps: { innerHTML: innerHTML }\n            })]);\n        },\n        hasItem: function hasItem(item) {\n            return this.parsedItems.indexOf(this.getValue(item)) > -1;\n        },\n        needsTile: function needsTile(tile) {\n            return tile.componentOptions == null || tile.componentOptions.Ctor.options.name !== \'v-list-tile\';\n        },\n        getAvatar: function getAvatar(item) {\n            return Boolean(Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["getPropertyFromItem"])(item, this.itemAvatar, false));\n        },\n        getDisabled: function getDisabled(item) {\n            return Boolean(Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["getPropertyFromItem"])(item, this.itemDisabled, false));\n        },\n        getText: function getText(item) {\n            return String(Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["getPropertyFromItem"])(item, this.itemText, item));\n        },\n        getValue: function getValue(item) {\n            return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["getPropertyFromItem"])(item, this.itemValue, this.getText(item));\n        }\n    },\n    render: function render() {\n        var e_1, _a;\n        var children = [];\n        try {\n            for (var _b = __values(this.items), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var item = _c.value;\n                if (this.hideSelected && this.hasItem(item)) continue;\n                if (item == null) children.push(this.genTile(item));else if (item.header) children.push(this.genHeader(item));else if (item.divider) children.push(this.genDivider(item));else children.push(this.genTile(item));\n            }\n        } catch (e_1_1) {\n            e_1 = { error: e_1_1 };\n        } finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n                if (e_1) throw e_1.error;\n            }\n        }\n        children.length || children.push(this.$slots[\'no-data\'] || this.staticNoDataTile);\n        this.$slots[\'prepend-item\'] && children.unshift(this.$slots[\'prepend-item\']);\n        this.$slots[\'append-item\'] && children.push(this.$slots[\'append-item\']);\n        return this.$createElement(\'div\', {\n            staticClass: \'v-select-list v-card\',\n            \'class\': this.themeClasses\n        }, [this.$createElement(_VList__WEBPACK_IMPORTED_MODULE_4__["VList"], {\n            props: {\n                dense: this.dense\n            }\n        }, children)]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VSelect/index.js":\n/*!*****************************************!*\\\n  !*** ./src/components/VSelect/index.js ***!\n  \\*****************************************/\n/*! exports provided: VSelect, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSelect", function() { return wrapper; });\n/* harmony import */ var _VSelect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VSelect */ "./src/components/VSelect/VSelect.js");\n/* harmony import */ var _VOverflowBtn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VOverflowBtn */ "./src/components/VOverflowBtn/index.js");\n/* harmony import */ var _VAutocomplete__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VAutocomplete */ "./src/components/VAutocomplete/index.js");\n/* harmony import */ var _VCombobox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VCombobox */ "./src/components/VCombobox/index.js");\n/* harmony import */ var _util_rebuildFunctionalSlots__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/rebuildFunctionalSlots */ "./src/util/rebuildFunctionalSlots.js");\n/* harmony import */ var _util_dedupeModelListeners__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/dedupeModelListeners */ "./src/util/dedupeModelListeners.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n\n\n\n\n\n\n\n/* @vue/component */\nvar wrapper = {\n    functional: true,\n    $_wrapperFor: _VSelect__WEBPACK_IMPORTED_MODULE_0__["default"],\n    props: {\n        // VAutoComplete\n        /** @deprecated */\n        autocomplete: Boolean,\n        /** @deprecated */\n        combobox: Boolean,\n        multiple: Boolean,\n        /** @deprecated */\n        tags: Boolean,\n        // VOverflowBtn\n        /** @deprecated */\n        editable: Boolean,\n        /** @deprecated */\n        overflow: Boolean,\n        /** @deprecated */\n        segmented: Boolean\n    },\n    render: function render(h, _a) {\n        var props = _a.props,\n            data = _a.data,\n            slots = _a.slots,\n            parent = _a.parent;\n        Object(_util_dedupeModelListeners__WEBPACK_IMPORTED_MODULE_5__["default"])(data);\n        var children = Object(_util_rebuildFunctionalSlots__WEBPACK_IMPORTED_MODULE_4__["default"])(slots(), h);\n        if (props.autocomplete) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_6__["deprecate"])(\'<v-select autocomplete>\', \'<v-autocomplete>\', wrapper, parent);\n        }\n        if (props.combobox) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_6__["deprecate"])(\'<v-select combobox>\', \'<v-combobox>\', wrapper, parent);\n        }\n        if (props.tags) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_6__["deprecate"])(\'<v-select tags>\', \'<v-combobox multiple>\', wrapper, parent);\n        }\n        if (props.overflow) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_6__["deprecate"])(\'<v-select overflow>\', \'<v-overflow-btn>\', wrapper, parent);\n        }\n        if (props.segmented) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_6__["deprecate"])(\'<v-select segmented>\', \'<v-overflow-btn segmented>\', wrapper, parent);\n        }\n        if (props.editable) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_6__["deprecate"])(\'<v-select editable>\', \'<v-overflow-btn editable>\', wrapper, parent);\n        }\n        if (props.combobox || props.tags) {\n            data.attrs.multiple = props.tags;\n            return h(_VCombobox__WEBPACK_IMPORTED_MODULE_3__["default"], data, children);\n        } else if (props.autocomplete) {\n            data.attrs.multiple = props.multiple;\n            return h(_VAutocomplete__WEBPACK_IMPORTED_MODULE_2__["default"], data, children);\n        } else if (props.overflow || props.segmented || props.editable) {\n            data.attrs.segmented = props.segmented;\n            data.attrs.editable = props.editable;\n            return h(_VOverflowBtn__WEBPACK_IMPORTED_MODULE_1__["default"], data, children);\n        } else {\n            data.attrs.multiple = props.multiple;\n            return h(_VSelect__WEBPACK_IMPORTED_MODULE_0__["default"], data, children);\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (wrapper);\n\n/***/ }),\n\n/***/ "./src/components/VSlider/VSlider.js":\n/*!*******************************************!*\\\n  !*** ./src/components/VSlider/VSlider.js ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_sliders_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_sliders.styl */ "./src/stylus/components/_sliders.styl");\n/* harmony import */ var _stylus_components_sliders_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_sliders_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transitions */ "./src/components/transitions/index.js");\n/* harmony import */ var _VInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VInput */ "./src/components/VInput/index.js");\n/* harmony import */ var _directives_click_outside__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../directives/click-outside */ "./src/directives/click-outside.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n/* harmony import */ var _mixins_loadable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../mixins/loadable */ "./src/mixins/loadable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Components\n\n// Extensions\n\n// Directives\n\n// Utilities\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-slider\',\n    directives: { ClickOutside: _directives_click_outside__WEBPACK_IMPORTED_MODULE_3__["default"] },\n    extends: _VInput__WEBPACK_IMPORTED_MODULE_2__["default"],\n    mixins: [_mixins_loadable__WEBPACK_IMPORTED_MODULE_6__["default"]],\n    props: {\n        alwaysDirty: Boolean,\n        inverseLabel: Boolean,\n        label: String,\n        min: {\n            type: [Number, String],\n            default: 0\n        },\n        max: {\n            type: [Number, String],\n            default: 100\n        },\n        range: Boolean,\n        step: {\n            type: [Number, String],\n            default: 1\n        },\n        ticks: {\n            type: [Boolean, String],\n            default: false,\n            validator: function validator(v) {\n                return typeof v === \'boolean\' || v === \'always\';\n            }\n        },\n        tickLabels: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        },\n        tickSize: {\n            type: [Number, String],\n            default: 1\n        },\n        thumbColor: {\n            type: String,\n            default: null\n        },\n        thumbLabel: {\n            type: [Boolean, String],\n            default: null,\n            validator: function validator(v) {\n                return typeof v === \'boolean\' || v === \'always\';\n            }\n        },\n        thumbSize: {\n            type: [Number, String],\n            default: 32\n        },\n        trackColor: {\n            type: String,\n            default: null\n        },\n        value: [Number, String]\n    },\n    data: function data(vm) {\n        return {\n            app: {},\n            isActive: false,\n            keyPressed: 0,\n            lazyValue: typeof vm.value !== \'undefined\' ? vm.value : Number(vm.min),\n            oldValue: null\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return {\n                \'v-input--slider\': true,\n                \'v-input--slider--ticks\': this.showTicks,\n                \'v-input--slider--inverse-label\': this.inverseLabel,\n                \'v-input--slider--ticks-labels\': this.tickLabels.length > 0,\n                \'v-input--slider--thumb-label\': this.thumbLabel || this.$scopedSlots.thumbLabel\n            };\n        },\n        showTicks: function showTicks() {\n            return this.tickLabels.length > 0 || !this.disabled && this.stepNumeric && !!this.ticks;\n        },\n        showThumbLabel: function showThumbLabel() {\n            return !this.disabled && (!!this.thumbLabel || this.thumbLabel === \'\' || this.$scopedSlots[\'thumb-label\']);\n        },\n        computedColor: function computedColor() {\n            if (this.disabled) return null;\n            return this.validationState || this.color || \'primary\';\n        },\n        computedTrackColor: function computedTrackColor() {\n            return this.disabled ? null : this.trackColor || null;\n        },\n        computedThumbColor: function computedThumbColor() {\n            if (this.disabled || !this.isDirty) return null;\n            return this.validationState || this.thumbColor || this.color || \'primary\';\n        },\n        internalValue: {\n            get: function get() {\n                return this.lazyValue;\n            },\n            set: function set(val) {\n                var _a = this,\n                    min = _a.min,\n                    max = _a.max;\n                // Round value to ensure the\n                // entire slider range can\n                // be selected with step\n                var value = this.roundValue(Math.min(Math.max(val, min), max));\n                if (value === this.lazyValue) return;\n                this.lazyValue = value;\n                this.$emit(\'input\', value);\n                this.validate();\n            }\n        },\n        stepNumeric: function stepNumeric() {\n            return this.step > 0 ? parseFloat(this.step) : 0;\n        },\n        trackFillStyles: function trackFillStyles() {\n            var left = this.$vuetify.rtl ? \'auto\' : 0;\n            var right = this.$vuetify.rtl ? 0 : \'auto\';\n            var width = this.inputWidth + "%";\n            if (this.disabled) width = "calc(" + this.inputWidth + "% - 8px)";\n            return {\n                transition: this.trackTransition,\n                left: left,\n                right: right,\n                width: width\n            };\n        },\n        trackPadding: function trackPadding() {\n            return this.isActive || this.inputWidth > 0 || this.disabled ? 0 : 7;\n        },\n        trackStyles: function trackStyles() {\n            var trackPadding = this.disabled ? "calc(" + this.inputWidth + "% + 8px)" : this.trackPadding + "px";\n            var left = this.$vuetify.rtl ? \'auto\' : trackPadding;\n            var right = this.$vuetify.rtl ? trackPadding : \'auto\';\n            var width = this.disabled ? "calc(" + (100 - this.inputWidth) + "% - 8px)" : \'100%\';\n            return {\n                transition: this.trackTransition,\n                left: left,\n                right: right,\n                width: width\n            };\n        },\n        tickStyles: function tickStyles() {\n            var size = Number(this.tickSize);\n            return {\n                \'border-width\': size + "px",\n                \'border-radius\': size > 1 ? \'50%\' : null,\n                transform: size > 1 ? "translateX(-" + size + "px) translateY(-" + (size - 1) + "px)" : null\n            };\n        },\n        trackTransition: function trackTransition() {\n            return this.keyPressed >= 2 ? \'none\' : \'\';\n        },\n        numTicks: function numTicks() {\n            return Math.ceil((this.max - this.min) / this.stepNumeric);\n        },\n        inputWidth: function inputWidth() {\n            return (this.roundValue(this.internalValue) - this.min) / (this.max - this.min) * 100;\n        },\n        isDirty: function isDirty() {\n            return this.internalValue > this.min || this.alwaysDirty;\n        }\n    },\n    watch: {\n        min: function min(val) {\n            val > this.internalValue && this.$emit(\'input\', parseFloat(val));\n        },\n        max: function max(val) {\n            val < this.internalValue && this.$emit(\'input\', parseFloat(val));\n        },\n        value: function value(val) {\n            this.internalValue = val;\n        }\n    },\n    mounted: function mounted() {\n        // Without a v-app, iOS does not work with body selectors\n        this.app = document.querySelector(\'[data-app]\') || Object(_util_console__WEBPACK_IMPORTED_MODULE_5__["consoleWarn"])(\'Missing v-app or a non-body wrapping element with the [data-app] attribute\', this);\n    },\n    methods: {\n        genDefaultSlot: function genDefaultSlot() {\n            var children = [this.genLabel()];\n            var slider = this.genSlider();\n            this.inverseLabel ? children.unshift(slider) : children.push(slider);\n            children.push(this.genProgress());\n            return children;\n        },\n        genListeners: function genListeners() {\n            return {\n                blur: this.onBlur,\n                click: this.onSliderClick,\n                focus: this.onFocus,\n                keydown: this.onKeyDown,\n                keyup: this.onKeyUp\n            };\n        },\n        genInput: function genInput() {\n            return this.$createElement(\'input\', {\n                attrs: __assign({ \'aria-label\': this.label, name: this.name, role: \'slider\', tabindex: this.disabled ? -1 : this.$attrs.tabindex, value: this.internalValue, readonly: true, \'aria-readonly\': String(this.readonly), \'aria-valuemin\': this.min, \'aria-valuemax\': this.max, \'aria-valuenow\': this.internalValue }, this.$attrs),\n                on: this.genListeners(),\n                ref: \'input\'\n            });\n        },\n        genSlider: function genSlider() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-slider\',\n                \'class\': {\n                    \'v-slider--is-active\': this.isActive\n                },\n                directives: [{\n                    name: \'click-outside\',\n                    value: this.onBlur\n                }]\n            }, this.genChildren());\n        },\n        genChildren: function genChildren() {\n            return [this.genInput(), this.genTrackContainer(), this.genSteps(), this.genThumbContainer(this.internalValue, this.inputWidth, this.isFocused || this.isActive, this.onThumbMouseDown)];\n        },\n        genSteps: function genSteps() {\n            var _this = this;\n            if (!this.step || !this.showTicks) return null;\n            var ticks = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["createRange"])(this.numTicks + 1).map(function (i) {\n                var children = [];\n                if (_this.tickLabels[i]) {\n                    children.push(_this.$createElement(\'span\', _this.tickLabels[i]));\n                }\n                return _this.$createElement(\'span\', {\n                    key: i,\n                    staticClass: \'v-slider__ticks\',\n                    class: {\n                        \'v-slider__ticks--always-show\': _this.ticks === \'always\' || _this.tickLabels.length > 0\n                    },\n                    style: __assign({}, _this.tickStyles, { left: i * (100 / _this.numTicks) + "%" })\n                }, children);\n            });\n            return this.$createElement(\'div\', {\n                staticClass: \'v-slider__ticks-container\'\n            }, ticks);\n        },\n        genThumb: function genThumb() {\n            return this.$createElement(\'div\', this.setBackgroundColor(this.computedThumbColor, {\n                staticClass: \'v-slider__thumb\'\n            }));\n        },\n        genThumbContainer: function genThumbContainer(value, valueWidth, isActive, onDrag) {\n            var children = [this.genThumb()];\n            var thumbLabelContent = this.getLabel(value);\n            this.showThumbLabel && children.push(this.genThumbLabel(thumbLabelContent));\n            return this.$createElement(\'div\', this.setTextColor(this.computedThumbColor, {\n                staticClass: \'v-slider__thumb-container\',\n                \'class\': {\n                    \'v-slider__thumb-container--is-active\': isActive,\n                    \'v-slider__thumb-container--show-label\': this.showThumbLabel\n                },\n                style: {\n                    transition: this.trackTransition,\n                    left: (this.$vuetify.rtl ? 100 - valueWidth : valueWidth) + "%"\n                },\n                on: {\n                    touchstart: onDrag,\n                    mousedown: onDrag\n                }\n            }), children);\n        },\n        genThumbLabel: function genThumbLabel(content) {\n            var size = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["convertToUnit"])(this.thumbSize);\n            return this.$createElement(_transitions__WEBPACK_IMPORTED_MODULE_1__["VScaleTransition"], {\n                props: { origin: \'bottom center\' }\n            }, [this.$createElement(\'div\', {\n                staticClass: \'v-slider__thumb-label__container\',\n                directives: [{\n                    name: \'show\',\n                    value: this.isFocused || this.isActive || this.thumbLabel === \'always\'\n                }]\n            }, [this.$createElement(\'div\', this.setBackgroundColor(this.computedThumbColor, {\n                staticClass: \'v-slider__thumb-label\',\n                style: {\n                    height: size,\n                    width: size\n                }\n            }), [content])])]);\n        },\n        genTrackContainer: function genTrackContainer() {\n            var children = [this.$createElement(\'div\', this.setBackgroundColor(this.computedTrackColor, {\n                staticClass: \'v-slider__track\',\n                style: this.trackStyles\n            })), this.$createElement(\'div\', this.setBackgroundColor(this.computedColor, {\n                staticClass: \'v-slider__track-fill\',\n                style: this.trackFillStyles\n            }))];\n            return this.$createElement(\'div\', {\n                staticClass: \'v-slider__track__container\',\n                ref: \'track\'\n            }, children);\n        },\n        getLabel: function getLabel(value) {\n            return this.$scopedSlots[\'thumb-label\'] ? this.$scopedSlots[\'thumb-label\']({ value: value }) : this.$createElement(\'span\', value);\n        },\n        onBlur: function onBlur(e) {\n            if (this.keyPressed === 2) return;\n            this.isActive = false;\n            this.isFocused = false;\n            this.$emit(\'blur\', e);\n        },\n        onFocus: function onFocus(e) {\n            this.isFocused = true;\n            this.$emit(\'focus\', e);\n        },\n        onThumbMouseDown: function onThumbMouseDown(e) {\n            this.oldValue = this.internalValue;\n            this.keyPressed = 2;\n            var options = { passive: true };\n            this.isActive = true;\n            this.isFocused = false;\n            if (\'touches\' in e) {\n                this.app.addEventListener(\'touchmove\', this.onMouseMove, options);\n                Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["addOnceEventListener"])(this.app, \'touchend\', this.onSliderMouseUp);\n            } else {\n                this.app.addEventListener(\'mousemove\', this.onMouseMove, options);\n                Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["addOnceEventListener"])(this.app, \'mouseup\', this.onSliderMouseUp);\n            }\n            this.$emit(\'start\', this.internalValue);\n        },\n        onSliderMouseUp: function onSliderMouseUp() {\n            this.keyPressed = 0;\n            var options = { passive: true };\n            this.isActive = false;\n            this.isFocused = false;\n            this.app.removeEventListener(\'touchmove\', this.onMouseMove, options);\n            this.app.removeEventListener(\'mousemove\', this.onMouseMove, options);\n            this.$emit(\'end\', this.internalValue);\n            if (!Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["deepEqual"])(this.oldValue, this.internalValue)) {\n                this.$emit(\'change\', this.internalValue);\n            }\n        },\n        onMouseMove: function onMouseMove(e) {\n            var _a = this.parseMouseMove(e),\n                value = _a.value,\n                isInsideTrack = _a.isInsideTrack;\n            if (isInsideTrack) {\n                this.setInternalValue(value);\n            }\n        },\n        onKeyDown: function onKeyDown(e) {\n            if (this.disabled || this.readonly) return;\n            var value = this.parseKeyDown(e);\n            if (value == null) return;\n            this.setInternalValue(value);\n            this.$emit(\'change\', value);\n        },\n        onKeyUp: function onKeyUp() {\n            this.keyPressed = 0;\n        },\n        onSliderClick: function onSliderClick(e) {\n            this.isFocused = true;\n            this.onMouseMove(e);\n            this.$emit(\'change\', this.internalValue);\n        },\n        parseMouseMove: function parseMouseMove(e) {\n            var _a = this.$refs.track.getBoundingClientRect(),\n                offsetLeft = _a.left,\n                trackWidth = _a.width;\n            var clientX = \'touches\' in e ? e.touches[0].clientX : e.clientX;\n            // It is possible for left to be NaN, force to number\n            var left = Math.min(Math.max((clientX - offsetLeft) / trackWidth, 0), 1) || 0;\n            if (this.$vuetify.rtl) left = 1 - left;\n            var isInsideTrack = clientX >= offsetLeft - 8 && clientX <= offsetLeft + trackWidth + 8;\n            var value = parseFloat(this.min) + left * (this.max - this.min);\n            return { value: value, isInsideTrack: isInsideTrack };\n        },\n        parseKeyDown: function parseKeyDown(e, value) {\n            if (value === void 0) {\n                value = this.internalValue;\n            }\n            if (this.disabled) return;\n            var pageup = _util_helpers__WEBPACK_IMPORTED_MODULE_4__["keyCodes"].pageup,\n                pagedown = _util_helpers__WEBPACK_IMPORTED_MODULE_4__["keyCodes"].pagedown,\n                end = _util_helpers__WEBPACK_IMPORTED_MODULE_4__["keyCodes"].end,\n                home = _util_helpers__WEBPACK_IMPORTED_MODULE_4__["keyCodes"].home,\n                left = _util_helpers__WEBPACK_IMPORTED_MODULE_4__["keyCodes"].left,\n                right = _util_helpers__WEBPACK_IMPORTED_MODULE_4__["keyCodes"].right,\n                down = _util_helpers__WEBPACK_IMPORTED_MODULE_4__["keyCodes"].down,\n                up = _util_helpers__WEBPACK_IMPORTED_MODULE_4__["keyCodes"].up;\n            if (![pageup, pagedown, end, home, left, right, down, up].includes(e.keyCode)) return;\n            e.preventDefault();\n            var step = this.stepNumeric || 1;\n            var steps = (this.max - this.min) / step;\n            if ([left, right, down, up].includes(e.keyCode)) {\n                this.keyPressed += 1;\n                var increase = this.$vuetify.rtl ? [left, up] : [right, up];\n                var direction = increase.includes(e.keyCode) ? 1 : -1;\n                var multiplier = e.shiftKey ? 3 : e.ctrlKey ? 2 : 1;\n                value = value + direction * step * multiplier;\n            } else if (e.keyCode === home) {\n                value = parseFloat(this.min);\n            } else if (e.keyCode === end) {\n                value = parseFloat(this.max);\n            } else /* if (e.keyCode === keyCodes.pageup || e.keyCode === pagedown) */{\n                    // Page up/down\n                    var direction = e.keyCode === pagedown ? 1 : -1;\n                    value = value - direction * step * (steps > 100 ? steps / 10 : 10);\n                }\n            return value;\n        },\n        roundValue: function roundValue(value) {\n            if (!this.stepNumeric) return value;\n            // Format input value using the same number\n            // of decimals places as in the step prop\n            var trimmedStep = this.step.toString().trim();\n            var decimals = trimmedStep.indexOf(\'.\') > -1 ? trimmedStep.length - trimmedStep.indexOf(\'.\') - 1 : 0;\n            var offset = this.min % this.stepNumeric;\n            var newValue = Math.round((value - offset) / this.stepNumeric) * this.stepNumeric + offset;\n            return parseFloat(Math.min(newValue, this.max).toFixed(decimals));\n        },\n        setInternalValue: function setInternalValue(value) {\n            this.internalValue = value;\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VSlider/index.js":\n/*!*****************************************!*\\\n  !*** ./src/components/VSlider/index.js ***!\n  \\*****************************************/\n/*! exports provided: VSlider, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VSlider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VSlider */ "./src/components/VSlider/VSlider.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSlider", function() { return _VSlider__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VSlider__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VSnackbar/VSnackbar.ts":\n/*!***********************************************!*\\\n  !*** ./src/components/VSnackbar/VSnackbar.ts ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_snackbars_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_snackbars.styl */ "./src/stylus/components/_snackbars.styl");\n/* harmony import */ var _stylus_components_snackbars_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_snackbars_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\n/* harmony import */ var _mixins_positionable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/positionable */ "./src/mixins/positionable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_4__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_2__["default"], Object(_mixins_positionable__WEBPACK_IMPORTED_MODULE_3__["factory"])([\'absolute\', \'top\', \'bottom\', \'left\', \'right\'])\n/* @vue/component */\n).extend({\n    name: \'v-snackbar\',\n    props: {\n        autoHeight: Boolean,\n        multiLine: Boolean,\n        // TODO: change this to closeDelay to match other API in delayable.js\n        timeout: {\n            type: Number,\n            default: 6000\n        },\n        vertical: Boolean\n    },\n    data: function data() {\n        return {\n            activeTimeout: -1\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return {\n                \'v-snack--active\': this.isActive,\n                \'v-snack--absolute\': this.absolute,\n                \'v-snack--auto-height\': this.autoHeight,\n                \'v-snack--bottom\': this.bottom || !this.top,\n                \'v-snack--left\': this.left,\n                \'v-snack--multi-line\': this.multiLine && !this.vertical,\n                \'v-snack--right\': this.right,\n                \'v-snack--top\': this.top,\n                \'v-snack--vertical\': this.vertical\n            };\n        }\n    },\n    watch: {\n        isActive: function isActive() {\n            this.setTimeout();\n        }\n    },\n    mounted: function mounted() {\n        this.setTimeout();\n    },\n    methods: {\n        setTimeout: function setTimeout() {\n            var _this = this;\n            window.clearTimeout(this.activeTimeout);\n            if (this.isActive && this.timeout) {\n                this.activeTimeout = window.setTimeout(function () {\n                    _this.isActive = false;\n                }, this.timeout);\n            }\n        }\n    },\n    render: function render(h) {\n        var children = [];\n        if (this.isActive) {\n            children.push(h(\'div\', {\n                staticClass: \'v-snack\',\n                class: this.classes,\n                on: this.$listeners\n            }, [h(\'div\', this.setBackgroundColor(this.color, {\n                staticClass: \'v-snack__wrapper\'\n            }), [h(\'div\', {\n                staticClass: \'v-snack__content\'\n            }, this.$slots.default)])]));\n        }\n        return h(\'transition\', {\n            attrs: { name: \'v-snack-transition\' }\n        }, children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VSnackbar/index.ts":\n/*!*******************************************!*\\\n  !*** ./src/components/VSnackbar/index.ts ***!\n  \\*******************************************/\n/*! exports provided: VSnackbar, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VSnackbar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VSnackbar */ "./src/components/VSnackbar/VSnackbar.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSnackbar", function() { return _VSnackbar__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VSnackbar__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VSpeedDial/VSpeedDial.js":\n/*!*************************************************!*\\\n  !*** ./src/components/VSpeedDial/VSpeedDial.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_speed_dial_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_speed-dial.styl */ "./src/stylus/components/_speed-dial.styl");\n/* harmony import */ var _stylus_components_speed_dial_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_speed_dial_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\n/* harmony import */ var _mixins_positionable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/positionable */ "./src/mixins/positionable.ts");\n/* harmony import */ var _mixins_transitionable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/transitionable */ "./src/mixins/transitionable.ts");\n/* harmony import */ var _directives_click_outside__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../directives/click-outside */ "./src/directives/click-outside.ts");\n\n\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-speed-dial\',\n    directives: { ClickOutside: _directives_click_outside__WEBPACK_IMPORTED_MODULE_4__["default"] },\n    mixins: [_mixins_positionable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_transitionable__WEBPACK_IMPORTED_MODULE_3__["default"]],\n    props: {\n        direction: {\n            type: String,\n            default: \'top\',\n            validator: function validator(val) {\n                return [\'top\', \'right\', \'bottom\', \'left\'].includes(val);\n            }\n        },\n        openOnHover: Boolean,\n        transition: {\n            type: String,\n            default: \'scale-transition\'\n        }\n    },\n    computed: {\n        classes: function classes() {\n            var _a;\n            return _a = {\n                \'v-speed-dial\': true,\n                \'v-speed-dial--top\': this.top,\n                \'v-speed-dial--right\': this.right,\n                \'v-speed-dial--bottom\': this.bottom,\n                \'v-speed-dial--left\': this.left,\n                \'v-speed-dial--absolute\': this.absolute,\n                \'v-speed-dial--fixed\': this.fixed\n            }, _a["v-speed-dial--direction-" + this.direction] = true, _a;\n        }\n    },\n    render: function render(h) {\n        var _this = this;\n        var children = [];\n        var data = {\n            \'class\': this.classes,\n            directives: [{\n                name: \'click-outside\',\n                value: function value() {\n                    return _this.isActive = false;\n                }\n            }],\n            on: {\n                click: function click() {\n                    return _this.isActive = !_this.isActive;\n                }\n            }\n        };\n        if (this.openOnHover) {\n            data.on.mouseenter = function () {\n                return _this.isActive = true;\n            };\n            data.on.mouseleave = function () {\n                return _this.isActive = false;\n            };\n        }\n        if (this.isActive) {\n            children = (this.$slots.default || []).map(function (b, i) {\n                b.key = i;\n                return b;\n            });\n        }\n        var list = h(\'transition-group\', {\n            \'class\': \'v-speed-dial__list\',\n            props: {\n                name: this.transition,\n                mode: this.mode,\n                origin: this.origin,\n                tag: \'div\'\n            }\n        }, children);\n        return h(\'div\', data, [this.$slots.activator, list]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VSpeedDial/index.js":\n/*!********************************************!*\\\n  !*** ./src/components/VSpeedDial/index.js ***!\n  \\********************************************/\n/*! exports provided: VSpeedDial, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VSpeedDial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VSpeedDial */ "./src/components/VSpeedDial/VSpeedDial.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSpeedDial", function() { return _VSpeedDial__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VSpeedDial__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VStepper/VStepper.js":\n/*!*********************************************!*\\\n  !*** ./src/components/VStepper/VStepper.js ***!\n  \\*********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_steppers_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_steppers.styl */ "./src/stylus/components/_steppers.styl");\n/* harmony import */ var _stylus_components_steppers_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_steppers_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Mixins\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-stepper\',\n    mixins: [Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_1__["provide"])(\'stepper\'), _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    provide: function provide() {\n        return {\n            stepClick: this.stepClick,\n            isVertical: this.vertical\n        };\n    },\n    props: {\n        nonLinear: Boolean,\n        altLabels: Boolean,\n        vertical: Boolean,\n        value: [Number, String]\n    },\n    data: function data() {\n        return {\n            inputValue: null,\n            isBooted: false,\n            steps: [],\n            content: [],\n            isReverse: false\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-stepper\': true, \'v-stepper--is-booted\': this.isBooted, \'v-stepper--vertical\': this.vertical, \'v-stepper--alt-labels\': this.altLabels, \'v-stepper--non-linear\': this.nonLinear }, this.themeClasses);\n        }\n    },\n    watch: {\n        inputValue: function inputValue(val, prev) {\n            this.isReverse = Number(val) < Number(prev);\n            for (var index = this.steps.length; --index >= 0;) {\n                this.steps[index].toggle(this.inputValue);\n            }\n            for (var index = this.content.length; --index >= 0;) {\n                this.content[index].toggle(this.inputValue, this.isReverse);\n            }\n            this.$emit(\'input\', this.inputValue);\n            prev && (this.isBooted = true);\n        },\n        value: function value() {\n            var _this = this;\n            this.$nextTick(function () {\n                return _this.inputValue = _this.value;\n            });\n        }\n    },\n    mounted: function mounted() {\n        this.inputValue = this.value || this.steps[0].step || 1;\n    },\n    methods: {\n        register: function register(item) {\n            if (item.$options.name === \'v-stepper-step\') {\n                this.steps.push(item);\n            } else if (item.$options.name === \'v-stepper-content\') {\n                item.isVertical = this.vertical;\n                this.content.push(item);\n            }\n        },\n        unregister: function unregister(item) {\n            if (item.$options.name === \'v-stepper-step\') {\n                this.steps = this.steps.filter(function (i) {\n                    return i !== item;\n                });\n            } else if (item.$options.name === \'v-stepper-content\') {\n                item.isVertical = this.vertical;\n                this.content = this.content.filter(function (i) {\n                    return i !== item;\n                });\n            }\n        },\n        stepClick: function stepClick(step) {\n            var _this = this;\n            this.$nextTick(function () {\n                return _this.inputValue = step;\n            });\n        }\n    },\n    render: function render(h) {\n        return h(\'div\', {\n            \'class\': this.classes\n        }, this.$slots.default);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VStepper/VStepperContent.js":\n/*!****************************************************!*\\\n  !*** ./src/components/VStepper/VStepperContent.js ***!\n  \\****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transitions */ "./src/components/transitions/index.js");\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n// Components\n\n// Mixins\n\n// Helpers\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-stepper-content\',\n    mixins: [Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_1__["inject"])(\'stepper\', \'v-stepper-content\', \'v-stepper\')],\n    inject: {\n        isVerticalProvided: {\n            from: \'isVertical\'\n        }\n    },\n    props: {\n        step: {\n            type: [Number, String],\n            required: true\n        }\n    },\n    data: function data() {\n        return {\n            height: 0,\n            // Must be null to allow\n            // previous comparison\n            isActive: null,\n            isReverse: false,\n            isVertical: this.isVerticalProvided\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return {\n                \'v-stepper__content\': true\n            };\n        },\n        computedTransition: function computedTransition() {\n            return this.isReverse ? _transitions__WEBPACK_IMPORTED_MODULE_0__["VTabReverseTransition"] : _transitions__WEBPACK_IMPORTED_MODULE_0__["VTabTransition"];\n        },\n        styles: function styles() {\n            if (!this.isVertical) return {};\n            return {\n                height: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_2__["convertToUnit"])(this.height)\n            };\n        },\n        wrapperClasses: function wrapperClasses() {\n            return {\n                \'v-stepper__wrapper\': true\n            };\n        }\n    },\n    watch: {\n        isActive: function isActive(current, previous) {\n            // If active and the previous state\n            // was null, is just booting up\n            if (current && previous == null) {\n                return this.height = \'auto\';\n            }\n            if (!this.isVertical) return;\n            if (this.isActive) this.enter();else this.leave();\n        }\n    },\n    mounted: function mounted() {\n        this.$refs.wrapper.addEventListener(\'transitionend\', this.onTransition, false);\n        this.stepper && this.stepper.register(this);\n    },\n    beforeDestroy: function beforeDestroy() {\n        this.$refs.wrapper.removeEventListener(\'transitionend\', this.onTransition, false);\n        this.stepper && this.stepper.unregister(this);\n    },\n    methods: {\n        onTransition: function onTransition(e) {\n            if (!this.isActive || e.propertyName !== \'height\') return;\n            this.height = \'auto\';\n        },\n        enter: function enter() {\n            var _this = this;\n            var scrollHeight = 0;\n            // Render bug with height\n            requestAnimationFrame(function () {\n                scrollHeight = _this.$refs.wrapper.scrollHeight;\n            });\n            this.height = 0;\n            // Give the collapsing element time to collapse\n            setTimeout(function () {\n                return _this.isActive && (_this.height = scrollHeight || \'auto\');\n            }, 450);\n        },\n        leave: function leave() {\n            var _this = this;\n            this.height = this.$refs.wrapper.clientHeight;\n            setTimeout(function () {\n                return _this.height = 0;\n            }, 10);\n        },\n        toggle: function toggle(step, reverse) {\n            this.isActive = step.toString() === this.step.toString();\n            this.isReverse = reverse;\n        }\n    },\n    render: function render(h) {\n        var contentData = {\n            \'class\': this.classes\n        };\n        var wrapperData = {\n            \'class\': this.wrapperClasses,\n            style: this.styles,\n            ref: \'wrapper\'\n        };\n        if (!this.isVertical) {\n            contentData.directives = [{\n                name: \'show\',\n                value: this.isActive\n            }];\n        }\n        var wrapper = h(\'div\', wrapperData, [this.$slots.default]);\n        var content = h(\'div\', contentData, [wrapper]);\n        return h(this.computedTransition, {\n            on: this.$listeners\n        }, [content]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VStepper/VStepperStep.js":\n/*!*************************************************!*\\\n  !*** ./src/components/VStepper/VStepperStep.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\n/* harmony import */ var _directives_ripple__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../directives/ripple */ "./src/directives/ripple.ts");\n// Components\n\n// Mixins\n\n\n// Directives\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-stepper-step\',\n    directives: { Ripple: _directives_ripple__WEBPACK_IMPORTED_MODULE_3__["default"] },\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"], Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_2__["inject"])(\'stepper\', \'v-stepper-step\', \'v-stepper\')],\n    inject: [\'stepClick\'],\n    props: {\n        color: {\n            type: String,\n            default: \'primary\'\n        },\n        complete: Boolean,\n        completeIcon: {\n            type: String,\n            default: \'$vuetify.icons.complete\'\n        },\n        editIcon: {\n            type: String,\n            default: \'$vuetify.icons.edit\'\n        },\n        errorIcon: {\n            type: String,\n            default: \'$vuetify.icons.error\'\n        },\n        editable: Boolean,\n        rules: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        },\n        step: [Number, String]\n    },\n    data: function data() {\n        return {\n            isActive: false,\n            isInactive: true\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return {\n                \'v-stepper__step\': true,\n                \'v-stepper__step--active\': this.isActive,\n                \'v-stepper__step--editable\': this.editable,\n                \'v-stepper__step--inactive\': this.isInactive,\n                \'v-stepper__step--error\': this.hasError,\n                \'v-stepper__step--complete\': this.complete,\n                \'error--text\': this.hasError\n            };\n        },\n        hasError: function hasError() {\n            return this.rules.some(function (i) {\n                return i() !== true;\n            });\n        }\n    },\n    mounted: function mounted() {\n        this.stepper && this.stepper.register(this);\n    },\n    beforeDestroy: function beforeDestroy() {\n        this.stepper && this.stepper.unregister(this);\n    },\n    methods: {\n        click: function click(e) {\n            e.stopPropagation();\n            if (this.editable) {\n                this.stepClick(this.step);\n            }\n        },\n        toggle: function toggle(step) {\n            this.isActive = step.toString() === this.step.toString();\n            this.isInactive = Number(step) < Number(this.step);\n        }\n    },\n    render: function render(h) {\n        var data = {\n            \'class\': this.classes,\n            directives: [{\n                name: \'ripple\',\n                value: this.editable\n            }],\n            on: { click: this.click }\n        };\n        var stepContent;\n        if (this.hasError) {\n            stepContent = [h(_VIcon__WEBPACK_IMPORTED_MODULE_0__["default"], {}, this.errorIcon)];\n        } else if (this.complete) {\n            if (this.editable) {\n                stepContent = [h(_VIcon__WEBPACK_IMPORTED_MODULE_0__["default"], {}, this.editIcon)];\n            } else {\n                stepContent = [h(_VIcon__WEBPACK_IMPORTED_MODULE_0__["default"], {}, this.completeIcon)];\n            }\n        } else {\n            stepContent = this.step;\n        }\n        var color = !this.hasError && (this.complete || this.isActive) ? this.color : false;\n        var step = h(\'span\', this.setBackgroundColor(color, {\n            staticClass: \'v-stepper__step__step\'\n        }), stepContent);\n        var label = h(\'div\', {\n            staticClass: \'v-stepper__label\'\n        }, this.$slots.default);\n        return h(\'div\', data, [step, label]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VStepper/index.js":\n/*!******************************************!*\\\n  !*** ./src/components/VStepper/index.js ***!\n  \\******************************************/\n/*! exports provided: VStepper, VStepperContent, VStepperStep, VStepperHeader, VStepperItems, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VStepperHeader", function() { return VStepperHeader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VStepperItems", function() { return VStepperItems; });\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _VStepper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VStepper */ "./src/components/VStepper/VStepper.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VStepper", function() { return _VStepper__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _VStepperStep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VStepperStep */ "./src/components/VStepper/VStepperStep.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VStepperStep", function() { return _VStepperStep__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _VStepperContent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VStepperContent */ "./src/components/VStepper/VStepperContent.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VStepperContent", function() { return _VStepperContent__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n\n\n\n\nvar VStepperHeader = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'v-stepper__header\');\nvar VStepperItems = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'v-stepper__items\');\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VStepper: _VStepper__WEBPACK_IMPORTED_MODULE_1__["default"],\n        VStepperContent: _VStepperContent__WEBPACK_IMPORTED_MODULE_3__["default"],\n        VStepperStep: _VStepperStep__WEBPACK_IMPORTED_MODULE_2__["default"],\n        VStepperHeader: VStepperHeader,\n        VStepperItems: VStepperItems\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VSubheader/VSubheader.js":\n/*!*************************************************!*\\\n  !*** ./src/components/VSubheader/VSubheader.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_subheaders_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_subheaders.styl */ "./src/stylus/components/_subheaders.styl");\n/* harmony import */ var _stylus_components_subheaders_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_subheaders_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-subheader\',\n    mixins: [_mixins_themeable__WEBPACK_IMPORTED_MODULE_1__["default"]],\n    props: {\n        inset: Boolean\n    },\n    render: function render(h) {\n        return h(\'div\', {\n            staticClass: \'v-subheader\',\n            class: __assign({ \'v-subheader--inset\': this.inset }, this.themeClasses),\n            attrs: this.$attrs,\n            on: this.$listeners\n        }, this.$slots.default);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VSubheader/index.js":\n/*!********************************************!*\\\n  !*** ./src/components/VSubheader/index.js ***!\n  \\********************************************/\n/*! exports provided: VSubheader, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VSubheader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VSubheader */ "./src/components/VSubheader/VSubheader.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSubheader", function() { return _VSubheader__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VSubheader__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VSwitch/VSwitch.js":\n/*!*******************************************!*\\\n  !*** ./src/components/VSwitch/VSwitch.js ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_selection_controls_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_selection-controls.styl */ "./src/stylus/components/_selection-controls.styl");\n/* harmony import */ var _stylus_components_selection_controls_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_selection_controls_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stylus_components_switch_styl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stylus/components/_switch.styl */ "./src/stylus/components/_switch.styl");\n/* harmony import */ var _stylus_components_switch_styl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_switch_styl__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mixins_selectable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/selectable */ "./src/mixins/selectable.js");\n/* harmony import */ var _directives_touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../directives/touch */ "./src/directives/touch.ts");\n/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transitions */ "./src/components/transitions/index.js");\n/* harmony import */ var _VProgressCircular_VProgressCircular__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VProgressCircular/VProgressCircular */ "./src/components/VProgressCircular/VProgressCircular.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n// Mixins\n\n// Directives\n\n// Components\n\n\n// Helpers\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-switch\',\n    directives: { Touch: _directives_touch__WEBPACK_IMPORTED_MODULE_3__["default"] },\n    mixins: [_mixins_selectable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        loading: {\n            type: [Boolean, String],\n            default: false\n        }\n    },\n    computed: {\n        classes: function classes() {\n            return {\n                \'v-input--selection-controls v-input--switch\': true\n            };\n        },\n        switchData: function switchData() {\n            return this.setTextColor(this.loading ? undefined : this.computedColor, {\n                class: this.themeClasses\n            });\n        }\n    },\n    methods: {\n        genDefaultSlot: function genDefaultSlot() {\n            return [this.genSwitch(), this.genLabel()];\n        },\n        genSwitch: function genSwitch() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-input--selection-controls__input\'\n            }, [this.genInput(\'checkbox\', this.$attrs), !this.disabled && this.genRipple(this.setTextColor(this.computedColor, {\n                directives: [{\n                    name: \'touch\',\n                    value: {\n                        left: this.onSwipeLeft,\n                        right: this.onSwipeRight\n                    }\n                }]\n            })), this.$createElement(\'div\', __assign({ staticClass: \'v-input--switch__track\' }, this.switchData)), this.$createElement(\'div\', __assign({ staticClass: \'v-input--switch__thumb\' }, this.switchData), [this.genProgress()])]);\n        },\n        genProgress: function genProgress() {\n            return this.$createElement(_transitions__WEBPACK_IMPORTED_MODULE_4__["VFabTransition"], {}, [this.loading === false ? null : this.$slots.progress || this.$createElement(_VProgressCircular_VProgressCircular__WEBPACK_IMPORTED_MODULE_5__["default"], {\n                props: {\n                    color: this.loading === true || this.loading === \'\' ? this.color || \'primary\' : this.loading,\n                    size: 16,\n                    width: 2,\n                    indeterminate: true\n                }\n            })]);\n        },\n        onSwipeLeft: function onSwipeLeft() {\n            if (this.isActive) this.onChange();\n        },\n        onSwipeRight: function onSwipeRight() {\n            if (!this.isActive) this.onChange();\n        },\n        onKeydown: function onKeydown(e) {\n            if (e.keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_6__["keyCodes"].left && this.isActive || e.keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_6__["keyCodes"].right && !this.isActive) this.onChange();\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VSwitch/index.js":\n/*!*****************************************!*\\\n  !*** ./src/components/VSwitch/index.js ***!\n  \\*****************************************/\n/*! exports provided: VSwitch, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VSwitch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VSwitch */ "./src/components/VSwitch/VSwitch.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSwitch", function() { return _VSwitch__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VSwitch__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VSystemBar/VSystemBar.js":\n/*!*************************************************!*\\\n  !*** ./src/components/VSystemBar/VSystemBar.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_system_bars_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_system-bars.styl */ "./src/stylus/components/_system-bars.styl");\n/* harmony import */ var _stylus_components_system_bars_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_system_bars_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/applicationable */ "./src/mixins/applicationable.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-system-bar\',\n    mixins: [Object(_mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__["default"])(\'bar\', [\'height\', \'window\']), _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__["default"]],\n    props: {\n        height: {\n            type: [Number, String],\n            validator: function validator(v) {\n                return !isNaN(parseInt(v));\n            }\n        },\n        lightsOut: Boolean,\n        status: Boolean,\n        window: Boolean\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-system-bar--lights-out\': this.lightsOut, \'v-system-bar--absolute\': this.absolute, \'v-system-bar--fixed\': !this.absolute && (this.app || this.fixed), \'v-system-bar--status\': this.status, \'v-system-bar--window\': this.window }, this.themeClasses);\n        },\n        computedHeight: function computedHeight() {\n            if (this.height) return parseInt(this.height);\n            return this.window ? 32 : 24;\n        }\n    },\n    methods: {\n        /**\n         * Update the application layout\n         *\n         * @return {number}\n         */\n        updateApplication: function updateApplication() {\n            return this.computedHeight;\n        }\n    },\n    render: function render(h) {\n        var data = {\n            staticClass: \'v-system-bar\',\n            \'class\': this.classes,\n            style: {\n                height: this.computedHeight + "px"\n            }\n        };\n        return h(\'div\', this.setBackgroundColor(this.color, data), this.$slots.default);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VSystemBar/index.js":\n/*!********************************************!*\\\n  !*** ./src/components/VSystemBar/index.js ***!\n  \\********************************************/\n/*! exports provided: VSystemBar, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VSystemBar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VSystemBar */ "./src/components/VSystemBar/VSystemBar.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSystemBar", function() { return _VSystemBar__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VSystemBar__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VTabs/VTab.js":\n/*!**************************************!*\\\n  !*** ./src/components/VTabs/VTab.js ***!\n  \\**************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mixins_groupable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/groupable */ "./src/mixins/groupable.ts");\n/* harmony import */ var _mixins_routable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/routable */ "./src/mixins/routable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Mixins\n\n\n\n// Utilities\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-tab\',\n    mixins: [_mixins_routable__WEBPACK_IMPORTED_MODULE_1__["default"],\n    // Must be after routable\n    // to overwrite activeClass\n    Object(_mixins_groupable__WEBPACK_IMPORTED_MODULE_0__["factory"])(\'tabGroup\'), _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        ripple: {\n            type: [Boolean, Object],\n            default: true\n        }\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-tabs__item\': true, \'v-tabs__item--disabled\': this.disabled }, this.groupClasses);\n        },\n        value: function value() {\n            var to = this.to || this.href || \'\';\n            if (this.$router && this.to === Object(this.to)) {\n                var resolve = this.$router.resolve(this.to, this.$route, this.append);\n                to = resolve.href;\n            }\n            return to.replace(\'#\', \'\');\n        }\n    },\n    watch: {\n        $route: \'onRouteChange\'\n    },\n    mounted: function mounted() {\n        this.onRouteChange();\n    },\n    methods: {\n        click: function click(e) {\n            // If user provides an\n            // actual link, do not\n            // prevent default\n            if (this.href && this.href.indexOf(\'#\') > -1) e.preventDefault();\n            this.$emit(\'click\', e);\n            this.to || this.toggle();\n        },\n        onRouteChange: function onRouteChange() {\n            var _this = this;\n            if (!this.to || !this.$refs.link) return;\n            var path = "_vnode.data.class." + this.activeClass;\n            this.$nextTick(function () {\n                if (Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["getObjectValueByPath"])(_this.$refs.link, path)) {\n                    _this.toggle();\n                }\n            });\n        }\n    },\n    render: function render(h) {\n        var link = this.generateRouteLink(this.classes);\n        var data = link.data;\n        // If disabled, use div as anchor tags do not support\n        // being disabled\n        var tag = this.disabled ? \'div\' : link.tag;\n        data.ref = \'link\';\n        return h(\'div\', {\n            staticClass: \'v-tabs__div\'\n        }, [h(tag, data, this.$slots.default)]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTabs/VTabItem.js":\n/*!******************************************!*\\\n  !*** ./src/components/VTabs/VTabItem.js ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VWindow_VWindowItem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VWindow/VWindowItem */ "./src/components/VWindow/VWindowItem.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n// Extensions\n\n// Mixins\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (_VWindow_VWindowItem__WEBPACK_IMPORTED_MODULE_0__["default"].extend({\n    name: \'v-tab-item\',\n    props: {\n        id: String\n    },\n    render: function render(h) {\n        var render = _VWindow_VWindowItem__WEBPACK_IMPORTED_MODULE_0__["default"].options.render.call(this, h);\n        // For backwards compatibility with v1.2\n        /* istanbul ignore next */\n        if (this.id) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_1__["deprecate"])(\'id\', \'value\', this);\n            render.data.domProps = render.data.domProps || {};\n            render.data.domProps.id = this.id;\n        }\n        return render;\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VTabs/VTabs.js":\n/*!***************************************!*\\\n  !*** ./src/components/VTabs/VTabs.js ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_tabs_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_tabs.styl */ "./src/stylus/components/_tabs.styl");\n/* harmony import */ var _stylus_components_tabs_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_tabs_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VItemGroup/VItemGroup */ "./src/components/VItemGroup/VItemGroup.ts");\n/* harmony import */ var _mixins_tabs_computed__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mixins/tabs-computed */ "./src/components/VTabs/mixins/tabs-computed.js");\n/* harmony import */ var _mixins_tabs_generators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mixins/tabs-generators */ "./src/components/VTabs/mixins/tabs-generators.js");\n/* harmony import */ var _mixins_tabs_props__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mixins/tabs-props */ "./src/components/VTabs/mixins/tabs-props.js");\n/* harmony import */ var _mixins_tabs_touch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mixins/tabs-touch */ "./src/components/VTabs/mixins/tabs-touch.js");\n/* harmony import */ var _mixins_tabs_watchers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mixins/tabs-watchers */ "./src/components/VTabs/mixins/tabs-watchers.js");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_ssr_bootable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../mixins/ssr-bootable */ "./src/mixins/ssr-bootable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _directives_resize__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../directives/resize */ "./src/directives/resize.ts");\n/* harmony import */ var _directives_touch__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../directives/touch */ "./src/directives/touch.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n/* harmony import */ var _util_ThemeProvider__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../util/ThemeProvider */ "./src/util/ThemeProvider.ts");\n// Styles\n\n// Extensions\n\n// Component level mixins\n\n\n\n\n\n// Mixins\n\n\n\n// Directives\n\n\n\n// Utils\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (_VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_1__["BaseItemGroup"].extend({\n    name: \'v-tabs\',\n    directives: {\n        Resize: _directives_resize__WEBPACK_IMPORTED_MODULE_10__["default"],\n        Touch: _directives_touch__WEBPACK_IMPORTED_MODULE_11__["default"]\n    },\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_7__["default"], _mixins_ssr_bootable__WEBPACK_IMPORTED_MODULE_8__["default"], _mixins_tabs_computed__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_tabs_props__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_tabs_generators__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_tabs_touch__WEBPACK_IMPORTED_MODULE_5__["default"], _mixins_tabs_watchers__WEBPACK_IMPORTED_MODULE_6__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_9__["default"]],\n    provide: function provide() {\n        return {\n            tabGroup: this,\n            tabProxy: this.tabProxy,\n            registerItems: this.registerItems,\n            unregisterItems: this.unregisterItems\n        };\n    },\n    data: function data() {\n        return {\n            bar: [],\n            content: [],\n            isOverflowing: false,\n            nextIconVisible: false,\n            prevIconVisible: false,\n            resizeTimeout: null,\n            scrollOffset: 0,\n            sliderWidth: null,\n            sliderLeft: null,\n            startX: 0,\n            tabItems: null,\n            transitionTime: 300,\n            widths: {\n                bar: 0,\n                container: 0,\n                wrapper: 0\n            }\n        };\n    },\n    watch: {\n        items: \'onResize\',\n        tabs: \'onResize\'\n    },\n    mounted: function mounted() {\n        this.init();\n    },\n    methods: {\n        checkIcons: function checkIcons() {\n            this.prevIconVisible = this.checkPrevIcon();\n            this.nextIconVisible = this.checkNextIcon();\n        },\n        checkPrevIcon: function checkPrevIcon() {\n            return this.scrollOffset > 0;\n        },\n        checkNextIcon: function checkNextIcon() {\n            // Check one scroll ahead to know the width of right-most item\n            return this.widths.container > this.scrollOffset + this.widths.wrapper;\n        },\n        callSlider: function callSlider() {\n            var _this = this;\n            if (this.hideSlider || !this.activeTab) return false;\n            // Give screen time to paint\n            var activeTab = this.activeTab;\n            this.$nextTick(function () {\n                /* istanbul ignore if */\n                if (!activeTab || !activeTab.$el) return;\n                _this.sliderWidth = activeTab.$el.scrollWidth;\n                _this.sliderLeft = activeTab.$el.offsetLeft;\n            });\n        },\n        // Do not process\n        // until DOM is\n        // painted\n        init: function init() {\n            /* istanbul ignore next */\n            if (this.$listeners[\'input\']) {\n                Object(_util_console__WEBPACK_IMPORTED_MODULE_12__["deprecate"])(\'@input\', \'@change\', this);\n            }\n        },\n        /**\n         * When v-navigation-drawer changes the\n         * width of the container, call resize\n         * after the transition is complete\n         */\n        onResize: function onResize() {\n            if (this._isDestroyed) return;\n            this.setWidths();\n            var delay = this.isBooted ? this.transitionTime : 0;\n            clearTimeout(this.resizeTimeout);\n            this.resizeTimeout = setTimeout(this.updateTabsView, delay);\n        },\n        overflowCheck: function overflowCheck(e, fn) {\n            this.isOverflowing && fn(e);\n        },\n        scrollTo: function scrollTo(direction) {\n            this.scrollOffset = this.newOffset(direction);\n        },\n        setOverflow: function setOverflow() {\n            this.isOverflowing = this.widths.bar < this.widths.container;\n        },\n        setWidths: function setWidths() {\n            var bar = this.$refs.bar ? this.$refs.bar.clientWidth : 0;\n            var container = this.$refs.container ? this.$refs.container.clientWidth : 0;\n            var wrapper = this.$refs.wrapper ? this.$refs.wrapper.clientWidth : 0;\n            this.widths = { bar: bar, container: container, wrapper: wrapper };\n            this.setOverflow();\n        },\n        parseNodes: function parseNodes() {\n            var item = [];\n            var items = [];\n            var slider = [];\n            var tab = [];\n            var length = (this.$slots.default || []).length;\n            for (var i = 0; i < length; i++) {\n                var vnode = this.$slots.default[i];\n                if (vnode.componentOptions) {\n                    switch (vnode.componentOptions.Ctor.options.name) {\n                        case \'v-tabs-slider\':\n                            slider.push(vnode);\n                            break;\n                        case \'v-tabs-items\':\n                            items.push(vnode);\n                            break;\n                        case \'v-tab-item\':\n                            item.push(vnode);\n                            break;\n                        // case \'v-tab\' - intentionally omitted\n                        default:\n                            tab.push(vnode);\n                    }\n                } else {\n                    tab.push(vnode);\n                }\n            }\n            return { tab: tab, slider: slider, items: items, item: item };\n        },\n        registerItems: function registerItems(fn) {\n            this.tabItems = fn;\n            fn(this.internalValue);\n        },\n        unregisterItems: function unregisterItems() {\n            this.tabItems = null;\n        },\n        updateTabsView: function updateTabsView() {\n            this.callSlider();\n            this.scrollIntoView();\n            this.checkIcons();\n        },\n        scrollIntoView: function scrollIntoView() {\n            /* istanbul ignore next */\n            if (!this.activeTab) return;\n            if (!this.isOverflowing) return this.scrollOffset = 0;\n            var totalWidth = this.widths.wrapper + this.scrollOffset;\n            var _a = this.activeTab.$el,\n                clientWidth = _a.clientWidth,\n                offsetLeft = _a.offsetLeft;\n            var itemOffset = clientWidth + offsetLeft;\n            var additionalOffset = clientWidth * 0.3;\n            if (this.activeTab === this.items[this.items.length - 1]) {\n                additionalOffset = 0; // don\'t add an offset if selecting the last tab\n            }\n            /* istanbul ignore else */\n            if (offsetLeft < this.scrollOffset) {\n                this.scrollOffset = Math.max(offsetLeft - additionalOffset, 0);\n            } else if (totalWidth < itemOffset) {\n                this.scrollOffset -= totalWidth - itemOffset - additionalOffset;\n            }\n        },\n        tabProxy: function tabProxy(val) {\n            this.internalValue = val;\n        }\n    },\n    render: function render(h) {\n        var _a = this.parseNodes(),\n            tab = _a.tab,\n            slider = _a.slider,\n            items = _a.items,\n            item = _a.item;\n        return h(\'div\', {\n            staticClass: \'v-tabs\',\n            directives: [{\n                name: \'resize\',\n                modifiers: { quiet: true },\n                value: this.onResize\n            }]\n        }, [this.genBar([this.hideSlider ? null : this.genSlider(slider), tab]), h(_util_ThemeProvider__WEBPACK_IMPORTED_MODULE_13__["default"], {\n            props: { dark: this.theme.isDark, light: !this.theme.isDark }\n        }, [this.genItems(items, item)])]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VTabs/VTabsItems.js":\n/*!********************************************!*\\\n  !*** ./src/components/VTabs/VTabsItems.js ***!\n  \\********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VWindow_VWindow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VWindow/VWindow */ "./src/components/VWindow/VWindow.ts");\n// Extensions\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (_VWindow_VWindow__WEBPACK_IMPORTED_MODULE_0__["default"].extend({\n    name: \'v-tabs-items\',\n    inject: {\n        registerItems: {\n            default: null\n        },\n        tabProxy: {\n            default: null\n        },\n        unregisterItems: {\n            default: null\n        }\n    },\n    props: {\n        cycle: Boolean\n    },\n    watch: {\n        internalValue: function internalValue(val) {\n            /* istanbul ignore else */\n            if (this.tabProxy) this.tabProxy(val);\n        }\n    },\n    created: function created() {\n        this.registerItems && this.registerItems(this.changeModel);\n    },\n    beforeDestroy: function beforeDestroy() {\n        this.unregisterItems && this.unregisterItems();\n    },\n    methods: {\n        changeModel: function changeModel(val) {\n            this.internalValue = val;\n        },\n        // For backwards compatability with v1.2\n        getValue: function getValue(item, i) {\n            /* istanbul ignore if */\n            if (item.id) return item.id;\n            return _VWindow_VWindow__WEBPACK_IMPORTED_MODULE_0__["default"].options.methods.getValue.call(this, item, i);\n        },\n        next: function next() {\n            if (!this.cycle && this.internalIndex === this.items.length - 1) {\n                return;\n            }\n            _VWindow_VWindow__WEBPACK_IMPORTED_MODULE_0__["default"].options.methods.next.call(this);\n        },\n        prev: function prev() {\n            if (!this.cycle && this.internalIndex === 0) {\n                return;\n            }\n            _VWindow_VWindow__WEBPACK_IMPORTED_MODULE_0__["default"].options.methods.prev.call(this);\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VTabs/VTabsSlider.js":\n/*!*********************************************!*\\\n  !*** ./src/components/VTabs/VTabsSlider.js ***!\n  \\*********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-tabs-slider\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_0__["default"]],\n    render: function render(h) {\n        return h(\'div\', this.setBackgroundColor(this.color || \'accent\', {\n            staticClass: \'v-tabs__slider\'\n        }));\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTabs/index.js":\n/*!***************************************!*\\\n  !*** ./src/components/VTabs/index.js ***!\n  \\***************************************/\n/*! exports provided: VTabs, VTab, VTabItem, VTabsItems, VTabsSlider, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTabs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTabs */ "./src/components/VTabs/VTabs.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTabs", function() { return _VTabs__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _VTab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VTab */ "./src/components/VTabs/VTab.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTab", function() { return _VTab__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _VTabsItems__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VTabsItems */ "./src/components/VTabs/VTabsItems.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTabsItems", function() { return _VTabsItems__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _VTabItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VTabItem */ "./src/components/VTabs/VTabItem.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTabItem", function() { return _VTabItem__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n/* harmony import */ var _VTabsSlider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VTabsSlider */ "./src/components/VTabs/VTabsSlider.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTabsSlider", function() { return _VTabsSlider__WEBPACK_IMPORTED_MODULE_4__["default"]; });\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VTabs: _VTabs__WEBPACK_IMPORTED_MODULE_0__["default"],\n        VTab: _VTab__WEBPACK_IMPORTED_MODULE_1__["default"],\n        VTabsItems: _VTabsItems__WEBPACK_IMPORTED_MODULE_2__["default"],\n        VTabItem: _VTabItem__WEBPACK_IMPORTED_MODULE_3__["default"],\n        VTabsSlider: _VTabsSlider__WEBPACK_IMPORTED_MODULE_4__["default"]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTabs/mixins/tabs-computed.js":\n/*!******************************************************!*\\\n  !*** ./src/components/VTabs/mixins/tabs-computed.js ***!\n  \\******************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/**\n * Tabs computed\n *\n * @mixin\n */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    computed: {\n        activeTab: function activeTab() {\n            if (!this.selectedItems.length) return undefined;\n            return this.selectedItems[0];\n        },\n        containerStyles: function containerStyles() {\n            return this.height ? {\n                height: parseInt(this.height, 10) + "px"\n            } : null;\n        },\n        hasArrows: function hasArrows() {\n            return (this.showArrows || !this.isMobile) && this.isOverflowing;\n        },\n        isMobile: function isMobile() {\n            return this.$vuetify.breakpoint.width < this.mobileBreakPoint;\n        },\n        sliderStyles: function sliderStyles() {\n            return {\n                left: this.sliderLeft + "px",\n                transition: this.sliderLeft != null ? null : \'none\',\n                width: this.sliderWidth + "px"\n            };\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTabs/mixins/tabs-generators.js":\n/*!********************************************************!*\\\n  !*** ./src/components/VTabs/mixins/tabs-generators.js ***!\n  \\********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTabsItems__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../VTabsItems */ "./src/components/VTabs/VTabsItems.js");\n/* harmony import */ var _VTabsSlider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VTabsSlider */ "./src/components/VTabs/VTabsSlider.js");\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../VIcon */ "./src/components/VIcon/index.ts");\n\n\n\n/**\n * Tabs generators\n *\n * @mixin\n */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    methods: {\n        genBar: function genBar(items) {\n            return this.$createElement(\'div\', this.setBackgroundColor(this.color, {\n                staticClass: \'v-tabs__bar\',\n                \'class\': this.themeClasses,\n                ref: \'bar\'\n            }), [this.genTransition(\'prev\'), this.genWrapper(this.genContainer(items)), this.genTransition(\'next\')]);\n        },\n        genContainer: function genContainer(items) {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-tabs__container\',\n                class: {\n                    \'v-tabs__container--align-with-title\': this.alignWithTitle,\n                    \'v-tabs__container--centered\': this.centered,\n                    \'v-tabs__container--fixed-tabs\': this.fixedTabs,\n                    \'v-tabs__container--grow\': this.grow,\n                    \'v-tabs__container--icons-and-text\': this.iconsAndText,\n                    \'v-tabs__container--overflow\': this.isOverflowing,\n                    \'v-tabs__container--right\': this.right\n                },\n                style: this.containerStyles,\n                ref: \'container\'\n            }, items);\n        },\n        genIcon: function genIcon(direction) {\n            var _this = this;\n            if (!this.hasArrows || !this[direction + "IconVisible"]) return null;\n            return this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                staticClass: "v-tabs__icon v-tabs__icon--" + direction,\n                props: {\n                    disabled: !this[direction + "IconVisible"]\n                },\n                on: {\n                    click: function click() {\n                        return _this.scrollTo(direction);\n                    }\n                }\n            }, this[direction + "Icon"]);\n        },\n        genItems: function genItems(items, item) {\n            if (items.length > 0) return items;\n            if (!item.length) return null;\n            return this.$createElement(_VTabsItems__WEBPACK_IMPORTED_MODULE_0__["default"], item);\n        },\n        genTransition: function genTransition(direction) {\n            return this.$createElement(\'transition\', {\n                props: { name: \'fade-transition\' }\n            }, [this.genIcon(direction)]);\n        },\n        genWrapper: function genWrapper(items) {\n            var _this = this;\n            return this.$createElement(\'div\', {\n                staticClass: \'v-tabs__wrapper\',\n                class: {\n                    \'v-tabs__wrapper--show-arrows\': this.hasArrows\n                },\n                ref: \'wrapper\',\n                directives: [{\n                    name: \'touch\',\n                    value: {\n                        start: function start(e) {\n                            return _this.overflowCheck(e, _this.onTouchStart);\n                        },\n                        move: function move(e) {\n                            return _this.overflowCheck(e, _this.onTouchMove);\n                        },\n                        end: function end(e) {\n                            return _this.overflowCheck(e, _this.onTouchEnd);\n                        }\n                    }\n                }]\n            }, [items]);\n        },\n        genSlider: function genSlider(items) {\n            if (!items.length) {\n                items = [this.$createElement(_VTabsSlider__WEBPACK_IMPORTED_MODULE_1__["default"], {\n                    props: { color: this.sliderColor }\n                })];\n            }\n            return this.$createElement(\'div\', {\n                staticClass: \'v-tabs__slider-wrapper\',\n                style: this.sliderStyles\n            }, items);\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTabs/mixins/tabs-props.js":\n/*!***************************************************!*\\\n  !*** ./src/components/VTabs/mixins/tabs-props.js ***!\n  \\***************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/**\n * Tabs props\n *\n * @mixin\n */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    props: {\n        activeClass: {\n            type: String,\n            default: \'v-tabs__item--active\'\n        },\n        alignWithTitle: Boolean,\n        centered: Boolean,\n        fixedTabs: Boolean,\n        grow: Boolean,\n        height: {\n            type: [Number, String],\n            default: undefined,\n            validator: function validator(v) {\n                return !isNaN(parseInt(v));\n            }\n        },\n        hideSlider: Boolean,\n        iconsAndText: Boolean,\n        mandatory: {\n            type: Boolean,\n            default: true\n        },\n        mobileBreakPoint: {\n            type: [Number, String],\n            default: 1264,\n            validator: function validator(v) {\n                return !isNaN(parseInt(v));\n            }\n        },\n        nextIcon: {\n            type: String,\n            default: \'$vuetify.icons.next\'\n        },\n        prevIcon: {\n            type: String,\n            default: \'$vuetify.icons.prev\'\n        },\n        right: Boolean,\n        showArrows: Boolean,\n        sliderColor: {\n            type: String,\n            default: \'accent\'\n        },\n        value: [Number, String]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTabs/mixins/tabs-touch.js":\n/*!***************************************************!*\\\n  !*** ./src/components/VTabs/mixins/tabs-touch.js ***!\n  \\***************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/**\n * Tabs touch\n *\n * @mixin\n */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    methods: {\n        newOffset: function newOffset(direction) {\n            var clientWidth = this.$refs.wrapper.clientWidth;\n            if (direction === \'prev\') {\n                return Math.max(this.scrollOffset - clientWidth, 0);\n            } else {\n                return Math.min(this.scrollOffset + clientWidth, this.$refs.container.clientWidth - clientWidth);\n            }\n        },\n        onTouchStart: function onTouchStart(e) {\n            this.startX = this.scrollOffset + e.touchstartX;\n            this.$refs.container.style.transition = \'none\';\n            this.$refs.container.style.willChange = \'transform\';\n        },\n        onTouchMove: function onTouchMove(e) {\n            this.scrollOffset = this.startX - e.touchmoveX;\n        },\n        onTouchEnd: function onTouchEnd() {\n            var container = this.$refs.container;\n            var wrapper = this.$refs.wrapper;\n            var maxScrollOffset = container.clientWidth - wrapper.clientWidth;\n            container.style.transition = null;\n            container.style.willChange = null;\n            /* istanbul ignore else */\n            if (this.scrollOffset < 0 || !this.isOverflowing) {\n                this.scrollOffset = 0;\n            } else if (this.scrollOffset >= maxScrollOffset) {\n                this.scrollOffset = maxScrollOffset;\n            }\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTabs/mixins/tabs-watchers.js":\n/*!******************************************************!*\\\n  !*** ./src/components/VTabs/mixins/tabs-watchers.js ***!\n  \\******************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/**\n * Tabs watchers\n *\n * @mixin\n */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    watch: {\n        activeTab: function activeTab(val, oldVal) {\n            this.setOverflow();\n            if (!val) return;\n            this.tabItems && this.tabItems(this.getValue(val, this.items.indexOf(val)));\n            // Do nothing for first tab\n            // is handled from isBooted\n            // watcher\n            if (oldVal == null) return;\n            this.updateTabsView();\n        },\n        alignWithTitle: \'callSlider\',\n        centered: \'callSlider\',\n        fixedTabs: \'callSlider\',\n        hasArrows: function hasArrows(val) {\n            if (!val) this.scrollOffset = 0;\n        },\n        /* @deprecate */\n        internalValue: function internalValue(val) {\n            /* istanbul ignore else */\n            if (!this.$listeners[\'input\']) return;\n            this.$emit(\'input\', val);\n        },\n        lazyValue: \'updateTabs\',\n        right: \'callSlider\',\n        \'$vuetify.application.left\': \'onResize\',\n        \'$vuetify.application.right\': \'onResize\',\n        scrollOffset: function scrollOffset(val) {\n            this.$refs.container.style.transform = "translateX(" + -val + "px)";\n            if (this.hasArrows) {\n                this.prevIconVisible = this.checkPrevIcon();\n                this.nextIconVisible = this.checkNextIcon();\n            }\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTextField/VTextField.js":\n/*!*************************************************!*\\\n  !*** ./src/components/VTextField/VTextField.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_text_fields_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_text-fields.styl */ "./src/stylus/components/_text-fields.styl");\n/* harmony import */ var _stylus_components_text_fields_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_text_fields_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VInput */ "./src/components/VInput/index.js");\n/* harmony import */ var _VCounter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VCounter */ "./src/components/VCounter/index.js");\n/* harmony import */ var _VLabel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../VLabel */ "./src/components/VLabel/index.js");\n/* harmony import */ var _mixins_maskable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/maskable */ "./src/mixins/maskable.js");\n/* harmony import */ var _mixins_loadable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/loadable */ "./src/mixins/loadable.ts");\n/* harmony import */ var _directives_ripple__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../directives/ripple */ "./src/directives/ripple.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Extensions\n\n// Components\n\n\n// Mixins\n\n\n// Directives\n\n// Utilities\n\n\nvar dirtyTypes = [\'color\', \'file\', \'time\', \'date\', \'datetime-local\', \'week\', \'month\'];\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-text-field\',\n    directives: { Ripple: _directives_ripple__WEBPACK_IMPORTED_MODULE_6__["default"] },\n    extends: _VInput__WEBPACK_IMPORTED_MODULE_1__["default"],\n    mixins: [_mixins_maskable__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_loadable__WEBPACK_IMPORTED_MODULE_5__["default"]],\n    inheritAttrs: false,\n    props: {\n        appendOuterIcon: String,\n        /** @deprecated */\n        appendOuterIconCb: Function,\n        autofocus: Boolean,\n        box: Boolean,\n        browserAutocomplete: String,\n        clearable: Boolean,\n        clearIcon: {\n            type: String,\n            default: \'$vuetify.icons.clear\'\n        },\n        clearIconCb: Function,\n        color: {\n            type: String,\n            default: \'primary\'\n        },\n        counter: [Boolean, Number, String],\n        flat: Boolean,\n        fullWidth: Boolean,\n        label: String,\n        outline: Boolean,\n        placeholder: String,\n        prefix: String,\n        prependInnerIcon: String,\n        /** @deprecated */\n        prependInnerIconCb: Function,\n        reverse: Boolean,\n        singleLine: Boolean,\n        solo: Boolean,\n        soloInverted: Boolean,\n        suffix: String,\n        textarea: Boolean,\n        type: {\n            type: String,\n            default: \'text\'\n        }\n    },\n    data: function data() {\n        return {\n            badInput: false,\n            initialValue: null,\n            internalChange: false,\n            isClearing: false\n        };\n    },\n    computed: {\n        classes: function classes() {\n            return {\n                \'v-text-field\': true,\n                \'v-text-field--full-width\': this.fullWidth,\n                \'v-text-field--prefix\': this.prefix,\n                \'v-text-field--single-line\': this.isSingle,\n                \'v-text-field--solo\': this.isSolo,\n                \'v-text-field--solo-inverted\': this.soloInverted,\n                \'v-text-field--solo-flat\': this.flat,\n                \'v-text-field--box\': this.box,\n                \'v-text-field--enclosed\': this.isEnclosed,\n                \'v-text-field--reverse\': this.reverse,\n                \'v-text-field--outline\': this.hasOutline,\n                \'v-text-field--placeholder\': this.placeholder\n            };\n        },\n        counterValue: function counterValue() {\n            return (this.internalValue || \'\').toString().length;\n        },\n        directivesInput: function directivesInput() {\n            return [];\n        },\n        // TODO: Deprecate\n        hasOutline: function hasOutline() {\n            return this.outline || this.textarea;\n        },\n        internalValue: {\n            get: function get() {\n                return this.lazyValue;\n            },\n            set: function set(val) {\n                if (this.mask) {\n                    this.lazyValue = this.unmaskText(this.maskText(this.unmaskText(val)));\n                    this.setSelectionRange();\n                } else {\n                    this.lazyValue = val;\n                    this.$emit(\'input\', this.lazyValue);\n                }\n            }\n        },\n        isDirty: function isDirty() {\n            return this.lazyValue != null && this.lazyValue.toString().length > 0 || this.badInput;\n        },\n        isEnclosed: function isEnclosed() {\n            return this.box || this.isSolo || this.hasOutline || this.fullWidth;\n        },\n        isLabelActive: function isLabelActive() {\n            return this.isDirty || dirtyTypes.includes(this.type);\n        },\n        isSingle: function isSingle() {\n            return this.isSolo || this.singleLine;\n        },\n        isSolo: function isSolo() {\n            return this.solo || this.soloInverted;\n        },\n        labelPosition: function labelPosition() {\n            var offset = this.prefix && !this.labelValue ? this.prefixWidth : 0;\n            return !this.$vuetify.rtl !== !this.reverse ? {\n                left: \'auto\',\n                right: offset\n            } : {\n                left: offset,\n                right: \'auto\'\n            };\n        },\n        showLabel: function showLabel() {\n            return this.hasLabel && (!this.isSingle || !this.isLabelActive && !this.placeholder && !this.prefixLabel);\n        },\n        labelValue: function labelValue() {\n            return !this.isSingle && Boolean(this.isFocused || this.isLabelActive || this.placeholder || this.prefixLabel);\n        },\n        prefixWidth: function prefixWidth() {\n            if (!this.prefix && !this.$refs.prefix) return;\n            return this.$refs.prefix.offsetWidth;\n        },\n        prefixLabel: function prefixLabel() {\n            return this.prefix && !this.value;\n        }\n    },\n    watch: {\n        isFocused: function isFocused(val) {\n            // Sets validationState from validatable\n            this.hasColor = val;\n            if (val) {\n                this.initialValue = this.lazyValue;\n            } else if (this.initialValue !== this.lazyValue) {\n                this.$emit(\'change\', this.lazyValue);\n            }\n        },\n        value: function value(val) {\n            var _this = this;\n            if (this.mask && !this.internalChange) {\n                var masked_1 = this.maskText(this.unmaskText(val));\n                this.lazyValue = this.unmaskText(masked_1);\n                // Emit when the externally set value was modified internally\n                String(val) !== this.lazyValue && this.$nextTick(function () {\n                    _this.$refs.input.value = masked_1;\n                    _this.$emit(\'input\', _this.lazyValue);\n                });\n            } else this.lazyValue = val;\n        }\n    },\n    mounted: function mounted() {\n        this.autofocus && this.onFocus();\n    },\n    methods: {\n        /** @public */\n        focus: function focus() {\n            this.onFocus();\n        },\n        /** @public */\n        blur: function blur() {\n            this.$refs.input ? this.$refs.input.blur() : this.onBlur();\n        },\n        clearableCallback: function clearableCallback() {\n            var _this = this;\n            this.internalValue = null;\n            this.$nextTick(function () {\n                return _this.$refs.input.focus();\n            });\n        },\n        genAppendSlot: function genAppendSlot() {\n            var slot = [];\n            if (this.$slots[\'append-outer\']) {\n                slot.push(this.$slots[\'append-outer\']);\n            } else if (this.appendOuterIcon) {\n                slot.push(this.genIcon(\'appendOuter\'));\n            }\n            return this.genSlot(\'append\', \'outer\', slot);\n        },\n        genPrependInnerSlot: function genPrependInnerSlot() {\n            var slot = [];\n            if (this.$slots[\'prepend-inner\']) {\n                slot.push(this.$slots[\'prepend-inner\']);\n            } else if (this.prependInnerIcon) {\n                slot.push(this.genIcon(\'prependInner\'));\n            }\n            return this.genSlot(\'prepend\', \'inner\', slot);\n        },\n        genIconSlot: function genIconSlot() {\n            var slot = [];\n            if (this.$slots[\'append\']) {\n                slot.push(this.$slots[\'append\']);\n            } else if (this.appendIcon) {\n                slot.push(this.genIcon(\'append\'));\n            }\n            return this.genSlot(\'append\', \'inner\', slot);\n        },\n        genInputSlot: function genInputSlot() {\n            var input = _VInput__WEBPACK_IMPORTED_MODULE_1__["default"].methods.genInputSlot.call(this);\n            var prepend = this.genPrependInnerSlot();\n            prepend && input.children.unshift(prepend);\n            return input;\n        },\n        genClearIcon: function genClearIcon() {\n            if (!this.clearable) return null;\n            var icon = !this.isDirty ? false : \'clear\';\n            if (this.clearIconCb) Object(_util_console__WEBPACK_IMPORTED_MODULE_8__["deprecate"])(\':clear-icon-cb\', \'@click:clear\', this);\n            return this.genSlot(\'append\', \'inner\', [this.genIcon(icon, !this.$listeners[\'click:clear\'] && this.clearIconCb || this.clearableCallback, false)]);\n        },\n        genCounter: function genCounter() {\n            if (this.counter === false || this.counter == null) return null;\n            var max = this.counter === true ? this.$attrs.maxlength : this.counter;\n            return this.$createElement(_VCounter__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                props: {\n                    dark: this.dark,\n                    light: this.light,\n                    max: max,\n                    value: this.counterValue\n                }\n            });\n        },\n        genDefaultSlot: function genDefaultSlot() {\n            return [this.genTextFieldSlot(), this.genClearIcon(), this.genIconSlot(), this.genProgress()];\n        },\n        genLabel: function genLabel() {\n            if (!this.showLabel) return null;\n            var data = {\n                props: {\n                    absolute: true,\n                    color: this.validationState,\n                    dark: this.dark,\n                    disabled: this.disabled,\n                    focused: !this.isSingle && (this.isFocused || !!this.validationState),\n                    left: this.labelPosition.left,\n                    light: this.light,\n                    right: this.labelPosition.right,\n                    value: this.labelValue\n                }\n            };\n            if (this.$attrs.id) data.props.for = this.$attrs.id;\n            return this.$createElement(_VLabel__WEBPACK_IMPORTED_MODULE_3__["default"], data, this.$slots.label || this.label);\n        },\n        genInput: function genInput() {\n            var listeners = Object.assign({}, this.$listeners);\n            delete listeners[\'change\']; // Change should not be bound externally\n            var data = {\n                style: {},\n                domProps: {\n                    value: this.maskText(this.lazyValue)\n                },\n                attrs: __assign({ \'aria-label\': (!this.$attrs || !this.$attrs.id) && this.label }, this.$attrs, { autofocus: this.autofocus, disabled: this.disabled, readonly: this.readonly, type: this.type }),\n                on: Object.assign(listeners, {\n                    blur: this.onBlur,\n                    input: this.onInput,\n                    focus: this.onFocus,\n                    keydown: this.onKeyDown\n                }),\n                ref: \'input\'\n            };\n            if (this.placeholder) data.attrs.placeholder = this.placeholder;\n            if (this.mask) data.attrs.maxlength = this.masked.length;\n            if (this.browserAutocomplete) data.attrs.autocomplete = this.browserAutocomplete;\n            return this.$createElement(\'input\', data);\n        },\n        genMessages: function genMessages() {\n            if (this.hideDetails) return null;\n            return this.$createElement(\'div\', {\n                staticClass: \'v-text-field__details\'\n            }, [_VInput__WEBPACK_IMPORTED_MODULE_1__["default"].methods.genMessages.call(this), this.genCounter()]);\n        },\n        genTextFieldSlot: function genTextFieldSlot() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-text-field__slot\'\n            }, [this.genLabel(), this.prefix ? this.genAffix(\'prefix\') : null, this.genInput(), this.suffix ? this.genAffix(\'suffix\') : null]);\n        },\n        genAffix: function genAffix(type) {\n            return this.$createElement(\'div\', {\n                \'class\': "v-text-field__" + type,\n                ref: type\n            }, this[type]);\n        },\n        onBlur: function onBlur(e) {\n            this.isFocused = false;\n            // Reset internalChange state\n            // to allow external change\n            // to persist\n            this.internalChange = false;\n            this.$emit(\'blur\', e);\n        },\n        onClick: function onClick() {\n            if (this.isFocused || this.disabled) return;\n            this.$refs.input.focus();\n        },\n        onFocus: function onFocus(e) {\n            if (!this.$refs.input) return;\n            if (document.activeElement !== this.$refs.input) {\n                return this.$refs.input.focus();\n            }\n            if (!this.isFocused) {\n                this.isFocused = true;\n                this.$emit(\'focus\', e);\n            }\n        },\n        onInput: function onInput(e) {\n            this.internalChange = true;\n            this.mask && this.resetSelections(e.target);\n            this.internalValue = e.target.value;\n            this.badInput = e.target.validity && e.target.validity.badInput;\n        },\n        onKeyDown: function onKeyDown(e) {\n            this.internalChange = true;\n            if (e.keyCode === _util_helpers__WEBPACK_IMPORTED_MODULE_7__["keyCodes"].enter) this.$emit(\'change\', this.internalValue);\n            this.$emit(\'keydown\', e);\n        },\n        onMouseDown: function onMouseDown(e) {\n            // Prevent input from being blurred\n            if (e.target !== this.$refs.input) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n            _VInput__WEBPACK_IMPORTED_MODULE_1__["default"].methods.onMouseDown.call(this, e);\n        },\n        onMouseUp: function onMouseUp(e) {\n            if (this.hasMouseDown) this.focus();\n            _VInput__WEBPACK_IMPORTED_MODULE_1__["default"].methods.onMouseUp.call(this, e);\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTextField/index.js":\n/*!********************************************!*\\\n  !*** ./src/components/VTextField/index.js ***!\n  \\********************************************/\n/*! exports provided: VTextField, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VTextField", function() { return wrapper; });\n/* harmony import */ var _VTextField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTextField */ "./src/components/VTextField/VTextField.js");\n/* harmony import */ var _VTextarea_VTextarea__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VTextarea/VTextarea */ "./src/components/VTextarea/VTextarea.js");\n/* harmony import */ var _util_rebuildFunctionalSlots__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/rebuildFunctionalSlots */ "./src/util/rebuildFunctionalSlots.js");\n/* harmony import */ var _util_dedupeModelListeners__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/dedupeModelListeners */ "./src/util/dedupeModelListeners.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n\n\n\n\n\n// TODO: remove this in v2.0\n/* @vue/component */\nvar wrapper = {\n    functional: true,\n    $_wrapperFor: _VTextField__WEBPACK_IMPORTED_MODULE_0__["default"],\n    props: {\n        textarea: Boolean,\n        multiLine: Boolean\n    },\n    render: function render(h, _a) {\n        var props = _a.props,\n            data = _a.data,\n            slots = _a.slots,\n            parent = _a.parent;\n        Object(_util_dedupeModelListeners__WEBPACK_IMPORTED_MODULE_3__["default"])(data);\n        var children = Object(_util_rebuildFunctionalSlots__WEBPACK_IMPORTED_MODULE_2__["default"])(slots(), h);\n        if (props.textarea) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_4__["deprecate"])(\'<v-text-field textarea>\', \'<v-textarea outline>\', wrapper, parent);\n        }\n        if (props.multiLine) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_4__["deprecate"])(\'<v-text-field multi-line>\', \'<v-textarea>\', wrapper, parent);\n        }\n        if (props.textarea || props.multiLine) {\n            data.attrs.outline = props.textarea;\n            return h(_VTextarea_VTextarea__WEBPACK_IMPORTED_MODULE_1__["default"], data, children);\n        } else {\n            return h(_VTextField__WEBPACK_IMPORTED_MODULE_0__["default"], data, children);\n        }\n    }\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (wrapper);\n\n/***/ }),\n\n/***/ "./src/components/VTextarea/VTextarea.js":\n/*!***********************************************!*\\\n  !*** ./src/components/VTextarea/VTextarea.js ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_textarea_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_textarea.styl */ "./src/stylus/components/_textarea.styl");\n/* harmony import */ var _stylus_components_textarea_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_textarea_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VTextField/VTextField */ "./src/components/VTextField/VTextField.js");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Extensions\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-textarea\',\n    extends: _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_1__["default"],\n    props: {\n        autoGrow: Boolean,\n        noResize: Boolean,\n        outline: Boolean,\n        rowHeight: {\n            type: [Number, String],\n            default: 24,\n            validator: function validator(v) {\n                return !isNaN(parseFloat(v));\n            }\n        },\n        rows: {\n            type: [Number, String],\n            default: 5,\n            validator: function validator(v) {\n                return !isNaN(parseInt(v, 10));\n            }\n        }\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-textarea\': true, \'v-textarea--auto-grow\': this.autoGrow, \'v-textarea--no-resize\': this.noResizeHandle }, _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_1__["default"].computed.classes.call(this, null));\n        },\n        dynamicHeight: function dynamicHeight() {\n            return this.autoGrow ? this.inputHeight : \'auto\';\n        },\n        isEnclosed: function isEnclosed() {\n            return this.textarea || _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_1__["default"].computed.isEnclosed.call(this);\n        },\n        noResizeHandle: function noResizeHandle() {\n            return this.noResize || this.autoGrow;\n        }\n    },\n    watch: {\n        lazyValue: function lazyValue() {\n            !this.internalChange && this.autoGrow && this.$nextTick(this.calculateInputHeight);\n        }\n    },\n    mounted: function mounted() {\n        var _this = this;\n        setTimeout(function () {\n            _this.autoGrow && _this.calculateInputHeight();\n        }, 0);\n        // TODO: remove (2.0)\n        if (this.autoGrow && this.noResize) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_2__["consoleInfo"])(\'"no-resize" is now implied when using "auto-grow", and can be removed\', this);\n        }\n    },\n    methods: {\n        calculateInputHeight: function calculateInputHeight() {\n            var input = this.$refs.input;\n            if (input) {\n                input.style.height = 0;\n                var height = input.scrollHeight;\n                var minHeight = parseInt(this.rows, 10) * parseFloat(this.rowHeight);\n                // This has to be done ASAP, waiting for Vue\n                // to update the DOM causes ugly layout jumping\n                input.style.height = Math.max(minHeight, height) + \'px\';\n            }\n        },\n        genInput: function genInput() {\n            var input = _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_1__["default"].methods.genInput.call(this);\n            input.tag = \'textarea\';\n            delete input.data.attrs.type;\n            input.data.attrs.rows = this.rows;\n            return input;\n        },\n        onInput: function onInput(e) {\n            _VTextField_VTextField__WEBPACK_IMPORTED_MODULE_1__["default"].methods.onInput.call(this, e);\n            this.autoGrow && this.calculateInputHeight();\n        },\n        onKeyDown: function onKeyDown(e) {\n            // Prevents closing of a\n            // dialog when pressing\n            // enter\n            if (this.isFocused && e.keyCode === 13) {\n                e.stopPropagation();\n            }\n            this.internalChange = true;\n            this.$emit(\'keydown\', e);\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTextarea/index.js":\n/*!*******************************************!*\\\n  !*** ./src/components/VTextarea/index.js ***!\n  \\*******************************************/\n/*! exports provided: VTextarea, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTextarea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTextarea */ "./src/components/VTextarea/VTextarea.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTextarea", function() { return _VTextarea__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VTextarea__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VTimePicker/VTimePicker.js":\n/*!***************************************************!*\\\n  !*** ./src/components/VTimePicker/VTimePicker.js ***!\n  \\***************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTimePickerTitle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTimePickerTitle */ "./src/components/VTimePicker/VTimePickerTitle.js");\n/* harmony import */ var _VTimePickerClock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VTimePickerClock */ "./src/components/VTimePicker/VTimePickerClock.js");\n/* harmony import */ var _mixins_picker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/picker */ "./src/mixins/picker.js");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _VDatePicker_util_pad__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VDatePicker/util/pad */ "./src/components/VDatePicker/util/pad.js");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\n// Components\n\n\n// Mixins\n\n// Utils\n\n\nvar rangeHours24 = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["createRange"])(24);\nvar rangeHours12am = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["createRange"])(12);\nvar rangeHours12pm = rangeHours12am.map(function (v) {\n    return v + 12;\n});\nvar rangeMinutes = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["createRange"])(60);\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-time-picker\',\n    mixins: [_mixins_picker__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        allowedHours: Function,\n        allowedMinutes: Function,\n        format: {\n            type: String,\n            default: \'ampm\',\n            validator: function validator(val) {\n                return [\'ampm\', \'24hr\'].includes(val);\n            }\n        },\n        min: String,\n        max: String,\n        readonly: Boolean,\n        scrollable: Boolean,\n        value: null\n    },\n    data: function data() {\n        return {\n            inputHour: null,\n            inputMinute: null,\n            period: \'am\',\n            selectingHour: true\n        };\n    },\n    computed: {\n        isAllowedHourCb: function isAllowedHourCb() {\n            var _this = this;\n            if (!this.min && !this.max) return this.allowedHours;\n            var minHour = this.min ? this.min.split(\':\')[0] : 0;\n            var maxHour = this.max ? this.max.split(\':\')[0] : 23;\n            return function (val) {\n                return val >= minHour * 1 && val <= maxHour * 1 && (!_this.allowedHours || _this.allowedHours(val));\n            };\n        },\n        isAllowedMinuteCb: function isAllowedMinuteCb() {\n            var _this = this;\n            var isHourAllowed = !this.allowedHours || this.allowedHours(this.inputHour);\n            if (!this.min && !this.max) {\n                return isHourAllowed ? this.allowedMinutes : function () {\n                    return false;\n                };\n            }\n            var _a = __read(this.min ? this.min.split(\':\') : [0, 0], 2),\n                minHour = _a[0],\n                minMinute = _a[1];\n            var _b = __read(this.max ? this.max.split(\':\') : [23, 59], 2),\n                maxHour = _b[0],\n                maxMinute = _b[1];\n            var minTime = minHour * 60 + minMinute * 1;\n            var maxTime = maxHour * 60 + maxMinute * 1;\n            return function (val) {\n                var time = 60 * _this.inputHour + val;\n                return time >= minTime && time <= maxTime && isHourAllowed && (!_this.allowedMinutes || _this.allowedMinutes(val));\n            };\n        },\n        isAmPm: function isAmPm() {\n            return this.format === \'ampm\';\n        }\n    },\n    watch: {\n        value: \'setInputData\'\n    },\n    mounted: function mounted() {\n        this.setInputData(this.value);\n    },\n    methods: {\n        emitValue: function emitValue() {\n            if (this.inputHour != null && this.inputMinute != null) {\n                this.$emit(\'input\', Object(_VDatePicker_util_pad__WEBPACK_IMPORTED_MODULE_4__["default"])(this.inputHour) + ":" + Object(_VDatePicker_util_pad__WEBPACK_IMPORTED_MODULE_4__["default"])(this.inputMinute));\n            }\n        },\n        setPeriod: function setPeriod(period) {\n            this.period = period;\n            if (this.inputHour != null) {\n                var newHour = this.inputHour + (period === \'am\' ? -12 : 12);\n                this.inputHour = this.firstAllowed(\'hour\', newHour);\n                this.emitValue();\n            }\n        },\n        setInputData: function setInputData(value) {\n            if (value == null || value === \'\') {\n                this.inputHour = null;\n                this.inputMinute = null;\n                return;\n            }\n            if (value instanceof Date) {\n                this.inputHour = value.getHours();\n                this.inputMinute = value.getMinutes();\n            } else {\n                var _a = __read(value.trim().toLowerCase().match(/^(\\d+):(\\d+)(:\\d+)?([ap]m)?$/, \'\') || [], 5),\n                    hour = _a[1],\n                    minute = _a[2],\n                    period = _a[4];\n                this.inputHour = period ? this.convert12to24(parseInt(hour, 10), period) : parseInt(hour, 10);\n                this.inputMinute = parseInt(minute, 10);\n            }\n            this.period = this.inputHour < 12 ? \'am\' : \'pm\';\n        },\n        convert24to12: function convert24to12(hour) {\n            return hour ? (hour - 1) % 12 + 1 : 12;\n        },\n        convert12to24: function convert12to24(hour, period) {\n            return hour % 12 + (period === \'pm\' ? 12 : 0);\n        },\n        onInput: function onInput(value) {\n            if (this.selectingHour) {\n                this.inputHour = this.isAmPm ? this.convert12to24(value, this.period) : value;\n            } else {\n                this.inputMinute = value;\n            }\n            this.emitValue();\n        },\n        onChange: function onChange() {\n            if (!this.selectingHour) {\n                this.$emit(\'change\', this.value);\n            } else {\n                this.selectingHour = false;\n            }\n        },\n        firstAllowed: function firstAllowed(type, value) {\n            var allowedFn = type === \'hour\' ? this.isAllowedHourCb : this.isAllowedMinuteCb;\n            if (!allowedFn) return value;\n            // TODO: clean up\n            var range = type === \'minute\' ? rangeMinutes : this.isAmPm ? value < 12 ? rangeHours12am : rangeHours12pm : rangeHours24;\n            var first = range.find(function (v) {\n                return allowedFn((v + value) % range.length + range[0]);\n            });\n            return ((first || 0) + value) % range.length + range[0];\n        },\n        genClock: function genClock() {\n            return this.$createElement(_VTimePickerClock__WEBPACK_IMPORTED_MODULE_1__["default"], {\n                props: {\n                    allowedValues: this.selectingHour ? this.isAllowedHourCb : this.isAllowedMinuteCb,\n                    color: this.color,\n                    dark: this.dark,\n                    double: this.selectingHour && !this.isAmPm,\n                    format: this.selectingHour ? this.isAmPm ? this.convert24to12 : function (val) {\n                        return val;\n                    } : function (val) {\n                        return Object(_VDatePicker_util_pad__WEBPACK_IMPORTED_MODULE_4__["default"])(val, 2);\n                    },\n                    light: this.light,\n                    max: this.selectingHour ? this.isAmPm && this.period === \'am\' ? 11 : 23 : 59,\n                    min: this.selectingHour && this.isAmPm && this.period === \'pm\' ? 12 : 0,\n                    readonly: this.readonly,\n                    scrollable: this.scrollable,\n                    size: this.width - (!this.fullWidth && this.landscape ? 80 : 20),\n                    step: this.selectingHour ? 1 : 5,\n                    value: this.selectingHour ? this.inputHour : this.inputMinute\n                },\n                on: {\n                    input: this.onInput,\n                    change: this.onChange\n                },\n                ref: \'clock\'\n            });\n        },\n        genPickerBody: function genPickerBody() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-time-picker-clock__container\',\n                key: this.selectingHour\n            }, [this.genClock()]);\n        },\n        genPickerTitle: function genPickerTitle() {\n            var _this = this;\n            return this.$createElement(_VTimePickerTitle__WEBPACK_IMPORTED_MODULE_0__["default"], {\n                props: {\n                    ampm: this.isAmPm,\n                    hour: this.inputHour,\n                    minute: this.inputMinute,\n                    period: this.period,\n                    readonly: this.readonly,\n                    selectingHour: this.selectingHour\n                },\n                on: {\n                    \'update:selectingHour\': function updateSelectingHour(value) {\n                        return _this.selectingHour = value;\n                    },\n                    \'update:period\': this.setPeriod\n                },\n                ref: \'title\',\n                slot: \'title\'\n            });\n        }\n    },\n    render: function render() {\n        return this.genPicker(\'v-picker--time\');\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTimePicker/VTimePickerClock.js":\n/*!********************************************************!*\\\n  !*** ./src/components/VTimePicker/VTimePickerClock.js ***!\n  \\********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_time_picker_clock_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_time-picker-clock.styl */ "./src/stylus/components/_time-picker-clock.styl");\n/* harmony import */ var _stylus_components_time_picker_clock_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_time_picker_clock_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n// Mixins\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-time-picker-clock\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        allowedValues: Function,\n        double: Boolean,\n        format: {\n            type: Function,\n            default: function _default(val) {\n                return val;\n            }\n        },\n        max: {\n            type: Number,\n            required: true\n        },\n        min: {\n            type: Number,\n            required: true\n        },\n        scrollable: Boolean,\n        readonly: Boolean,\n        rotate: {\n            type: Number,\n            default: 0\n        },\n        step: {\n            type: Number,\n            default: 1\n        },\n        value: Number\n    },\n    data: function data() {\n        return {\n            inputValue: this.value,\n            isDragging: false,\n            valueOnMouseDown: null,\n            valueOnMouseUp: null\n        };\n    },\n    computed: {\n        count: function count() {\n            return this.max - this.min + 1;\n        },\n        degreesPerUnit: function degreesPerUnit() {\n            return 360 / this.roundCount;\n        },\n        degrees: function degrees() {\n            return this.degreesPerUnit * Math.PI / 180;\n        },\n        displayedValue: function displayedValue() {\n            return this.value == null ? this.min : this.value;\n        },\n        innerRadius: function innerRadius() {\n            return 0.62;\n        },\n        roundCount: function roundCount() {\n            return this.double ? this.count / 2 : this.count;\n        }\n    },\n    watch: {\n        value: function value(_value) {\n            this.inputValue = _value;\n        }\n    },\n    methods: {\n        wheel: function wheel(e) {\n            e.preventDefault();\n            var delta = Math.sign(e.wheelDelta || 1);\n            var value = this.displayedValue;\n            do {\n                value = value + delta;\n                value = (value - this.min + this.count) % this.count + this.min;\n            } while (!this.isAllowed(value) && value !== this.displayedValue);\n            if (value !== this.displayedValue) {\n                this.update(value);\n            }\n        },\n        isInner: function isInner(value) {\n            return this.double && value - this.min >= this.roundCount;\n        },\n        handScale: function handScale(value) {\n            return this.isInner(value) ? this.innerRadius : 1;\n        },\n        isAllowed: function isAllowed(value) {\n            return !this.allowedValues || this.allowedValues(value);\n        },\n        genValues: function genValues() {\n            var children = [];\n            for (var value = this.min; value <= this.max; value = value + this.step) {\n                var color = value === this.value && (this.color || \'accent\');\n                children.push(this.$createElement(\'span\', this.setBackgroundColor(color, {\n                    staticClass: \'v-time-picker-clock__item\',\n                    \'class\': {\n                        \'v-time-picker-clock__item--active\': value === this.displayedValue,\n                        \'v-time-picker-clock__item--disabled\': !this.isAllowed(value)\n                    },\n                    style: this.getTransform(value),\n                    domProps: { innerHTML: "<span>" + this.format(value) + "</span>" }\n                })));\n            }\n            return children;\n        },\n        genHand: function genHand() {\n            var scale = "scaleY(" + this.handScale(this.displayedValue) + ")";\n            var angle = this.rotate + this.degreesPerUnit * (this.displayedValue - this.min);\n            var color = this.value != null && (this.color || \'accent\');\n            return this.$createElement(\'div\', this.setBackgroundColor(color, {\n                staticClass: \'v-time-picker-clock__hand\',\n                \'class\': {\n                    \'v-time-picker-clock__hand--inner\': this.isInner(this.value)\n                },\n                style: {\n                    transform: "rotate(" + angle + "deg) " + scale\n                }\n            }));\n        },\n        getTransform: function getTransform(i) {\n            var _a = this.getPosition(i),\n                x = _a.x,\n                y = _a.y;\n            return {\n                left: 50 + x * 50 + "%",\n                top: 50 + y * 50 + "%"\n            };\n        },\n        getPosition: function getPosition(value) {\n            var rotateRadians = this.rotate * Math.PI / 180;\n            return {\n                x: Math.sin((value - this.min) * this.degrees + rotateRadians) * this.handScale(value),\n                y: -Math.cos((value - this.min) * this.degrees + rotateRadians) * this.handScale(value)\n            };\n        },\n        onMouseDown: function onMouseDown(e) {\n            e.preventDefault();\n            this.valueOnMouseDown = null;\n            this.valueOnMouseUp = null;\n            this.isDragging = true;\n            this.onDragMove(e);\n        },\n        onMouseUp: function onMouseUp() {\n            this.isDragging = false;\n            if (this.valueOnMouseUp !== null && this.isAllowed(this.valueOnMouseUp)) {\n                this.$emit(\'change\', this.valueOnMouseUp);\n            }\n        },\n        onDragMove: function onDragMove(e) {\n            e.preventDefault();\n            if (!this.isDragging && e.type !== \'click\') return;\n            var _a = this.$refs.clock.getBoundingClientRect(),\n                width = _a.width,\n                top = _a.top,\n                left = _a.left;\n            var _b = \'touches\' in e ? e.touches[0] : e,\n                clientX = _b.clientX,\n                clientY = _b.clientY;\n            var center = { x: width / 2, y: -width / 2 };\n            var coords = { x: clientX - left, y: top - clientY };\n            var handAngle = Math.round(this.angle(center, coords) - this.rotate + 360) % 360;\n            // (1 + this.innerRadius) / 4 = radius of the circle equally distant from inner and outer circles\n            var insideClick = this.double && this.euclidean(center, coords) / width < (1 + this.innerRadius) / 4;\n            var value = Math.round(handAngle / this.degreesPerUnit) + this.min + (insideClick ? this.roundCount : 0);\n            // Necessary to fix edge case when selecting left part of the value(s) at 12 o\'clock\n            var newValue;\n            if (handAngle >= 360 - this.degreesPerUnit / 2) {\n                newValue = insideClick ? this.max - this.roundCount + 1 : this.min;\n            } else {\n                newValue = value;\n            }\n            if (this.isAllowed(value)) {\n                if (this.valueOnMouseDown === null) {\n                    this.valueOnMouseDown = newValue;\n                }\n                this.valueOnMouseUp = newValue;\n                this.update(newValue);\n            }\n        },\n        update: function update(value) {\n            if (this.inputValue !== value) {\n                this.inputValue = value;\n                this.$emit(\'input\', value);\n            }\n        },\n        euclidean: function euclidean(p0, p1) {\n            var dx = p1.x - p0.x;\n            var dy = p1.y - p0.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        },\n        angle: function angle(center, p1) {\n            var value = 2 * Math.atan2(p1.y - center.y - this.euclidean(center, p1), p1.x - center.x);\n            return Math.abs(value * 180 / Math.PI);\n        }\n    },\n    render: function render(h) {\n        var _this = this;\n        var data = {\n            staticClass: \'v-time-picker-clock\',\n            class: __assign({ \'v-time-picker-clock--indeterminate\': this.value == null }, this.themeClasses),\n            on: this.readonly ? undefined : {\n                mousedown: this.onMouseDown,\n                mouseup: this.onMouseUp,\n                mouseleave: function mouseleave() {\n                    return _this.isDragging && _this.onMouseUp();\n                },\n                touchstart: this.onMouseDown,\n                touchend: this.onMouseUp,\n                mousemove: this.onDragMove,\n                touchmove: this.onDragMove\n            },\n            ref: \'clock\'\n        };\n        !this.readonly && this.scrollable && (data.on.wheel = this.wheel);\n        return h(\'div\', data, [h(\'div\', {\n            staticClass: \'v-time-picker-clock__inner\'\n        }, [this.genHand(), this.genValues()])]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTimePicker/VTimePickerTitle.js":\n/*!********************************************************!*\\\n  !*** ./src/components/VTimePicker/VTimePickerTitle.js ***!\n  \\********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_time_picker_title_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_time-picker-title.styl */ "./src/stylus/components/_time-picker-title.styl");\n/* harmony import */ var _stylus_components_time_picker_title_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_time_picker_title_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_picker_button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/picker-button */ "./src/mixins/picker-button.js");\n/* harmony import */ var _VDatePicker_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../VDatePicker/util */ "./src/components/VDatePicker/util/index.js");\n\n// Mixins\n\n// Utils\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-time-picker-title\',\n    mixins: [_mixins_picker_button__WEBPACK_IMPORTED_MODULE_1__["default"]],\n    props: {\n        ampm: Boolean,\n        hour: Number,\n        minute: Number,\n        period: {\n            type: String,\n            validator: function validator(period) {\n                return period === \'am\' || period === \'pm\';\n            }\n        },\n        readonly: Boolean,\n        selectingHour: Boolean\n    },\n    methods: {\n        genTime: function genTime() {\n            var hour = this.hour;\n            if (this.ampm) {\n                hour = hour ? (hour - 1) % 12 + 1 : 12;\n            }\n            var displayedHour = this.hour == null ? \'--\' : this.ampm ? hour : Object(_VDatePicker_util__WEBPACK_IMPORTED_MODULE_2__["pad"])(hour);\n            var displayedMinute = this.minute == null ? \'--\' : Object(_VDatePicker_util__WEBPACK_IMPORTED_MODULE_2__["pad"])(this.minute);\n            return this.$createElement(\'div\', {\n                \'class\': \'v-time-picker-title__time\'\n            }, [this.genPickerButton(\'selectingHour\', true, displayedHour), this.$createElement(\'span\', \':\'), this.genPickerButton(\'selectingHour\', false, displayedMinute)]);\n        },\n        genAmPm: function genAmPm() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-time-picker-title__ampm\'\n            }, [this.genPickerButton(\'period\', \'am\', \'am\', this.readonly), this.genPickerButton(\'period\', \'pm\', \'pm\', this.readonly)]);\n        }\n    },\n    render: function render(h) {\n        return h(\'div\', {\n            staticClass: \'v-time-picker-title\'\n        }, [this.genTime(), this.ampm ? this.genAmPm() : null]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTimePicker/index.js":\n/*!*********************************************!*\\\n  !*** ./src/components/VTimePicker/index.js ***!\n  \\*********************************************/\n/*! exports provided: VTimePicker, VTimePickerClock, VTimePickerTitle, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTimePicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTimePicker */ "./src/components/VTimePicker/VTimePicker.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTimePicker", function() { return _VTimePicker__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _VTimePickerClock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VTimePickerClock */ "./src/components/VTimePicker/VTimePickerClock.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTimePickerClock", function() { return _VTimePickerClock__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _VTimePickerTitle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VTimePickerTitle */ "./src/components/VTimePicker/VTimePickerTitle.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTimePickerTitle", function() { return _VTimePickerTitle__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VTimePicker: _VTimePicker__WEBPACK_IMPORTED_MODULE_0__["default"],\n        VTimePickerClock: _VTimePickerClock__WEBPACK_IMPORTED_MODULE_1__["default"],\n        VTimePickerTitle: _VTimePickerTitle__WEBPACK_IMPORTED_MODULE_2__["default"]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTimeline/VTimeline.ts":\n/*!***********************************************!*\\\n  !*** ./src/components/VTimeline/VTimeline.ts ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_timeline_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_timeline.styl */ "./src/stylus/components/_timeline.styl");\n/* harmony import */ var _stylus_components_timeline_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_timeline_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n\n// Mixins\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_1__["default"])(_mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]\n/* @vue/component */\n).extend({\n    name: \'v-timeline\',\n    props: {\n        alignTop: Boolean,\n        dense: Boolean\n    },\n    computed: {\n        classes: function classes() {\n            return __assign({ \'v-timeline--align-top\': this.alignTop, \'v-timeline--dense\': this.dense }, this.themeClasses);\n        }\n    },\n    render: function render(h) {\n        return h(\'div\', {\n            staticClass: \'v-timeline\',\n            \'class\': this.classes\n        }, this.$slots.default);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VTimeline/VTimelineItem.ts":\n/*!***************************************************!*\\\n  !*** ./src/components/VTimeline/VTimelineItem.ts ***!\n  \\***************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Types\n\n// Components\n\n// Mixins\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_0__["default"])(_mixins_colorable__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]\n/* @vue/component */\n).extend({\n    name: \'v-timeline-item\',\n    props: {\n        color: {\n            type: String,\n            default: \'primary\'\n        },\n        fillDot: Boolean,\n        hideDot: Boolean,\n        icon: String,\n        iconColor: String,\n        large: Boolean,\n        left: Boolean,\n        right: Boolean,\n        small: Boolean\n    },\n    computed: {\n        hasIcon: function hasIcon() {\n            return !!this.icon || !!this.$slots.icon;\n        }\n    },\n    methods: {\n        genBody: function genBody() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-timeline-item__body\'\n            }, this.$slots.default);\n        },\n        genIcon: function genIcon() {\n            if (this.$slots.icon) {\n                return this.$slots.icon;\n            }\n            return this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], {\n                props: {\n                    color: this.iconColor,\n                    dark: !this.theme.isDark,\n                    small: this.small\n                }\n            }, this.icon);\n        },\n        genInnerDot: function genInnerDot() {\n            var children = [];\n            this.hasIcon && children.push(this.genIcon());\n            var data = this.setBackgroundColor(this.color);\n            return this.$createElement(\'div\', __assign({ staticClass: \'v-timeline-item__inner-dot\' }, data), children);\n        },\n        genDot: function genDot() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-timeline-item__dot\',\n                class: {\n                    \'v-timeline-item__dot--small\': this.small,\n                    \'v-timeline-item__dot--large\': this.large\n                }\n            }, [this.genInnerDot()]);\n        },\n        genOpposite: function genOpposite() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-timeline-item__opposite\'\n            }, [this.$slots.opposite]);\n        }\n    },\n    render: function render(h) {\n        var children = [this.genBody()];\n        if (!this.hideDot) children.unshift(this.genDot());\n        if (this.$slots.opposite) children.push(this.genOpposite());\n        return h(\'div\', {\n            staticClass: \'v-timeline-item\',\n            class: __assign({ \'v-timeline-item--fill-dot\': this.fillDot, \'v-timeline-item--left\': this.left, \'v-timeline-item--right\': this.right }, this.themeClasses)\n        }, children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VTimeline/index.ts":\n/*!*******************************************!*\\\n  !*** ./src/components/VTimeline/index.ts ***!\n  \\*******************************************/\n/*! exports provided: VTimeline, VTimelineItem, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTimeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTimeline */ "./src/components/VTimeline/VTimeline.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTimeline", function() { return _VTimeline__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _VTimelineItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VTimelineItem */ "./src/components/VTimeline/VTimelineItem.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTimelineItem", function() { return _VTimelineItem__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VTimeline: _VTimeline__WEBPACK_IMPORTED_MODULE_0__["default"],\n        VTimelineItem: _VTimelineItem__WEBPACK_IMPORTED_MODULE_1__["default"]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VToolbar/VToolbar.js":\n/*!*********************************************!*\\\n  !*** ./src/components/VToolbar/VToolbar.js ***!\n  \\*********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_toolbar_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_toolbar.styl */ "./src/stylus/components/_toolbar.styl");\n/* harmony import */ var _stylus_components_toolbar_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_toolbar_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/applicationable */ "./src/mixins/applicationable.ts");\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _mixins_ssr_bootable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/ssr-bootable */ "./src/mixins/ssr-bootable.ts");\n/* harmony import */ var _directives_scroll__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../directives/scroll */ "./src/directives/scroll.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Styles\n\n// Mixins\n\n\n\n\n// Directives\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-toolbar\',\n    directives: { Scroll: _directives_scroll__WEBPACK_IMPORTED_MODULE_5__["default"] },\n    mixins: [Object(_mixins_applicationable__WEBPACK_IMPORTED_MODULE_1__["default"])(\'top\', [\'clippedLeft\', \'clippedRight\', \'computedHeight\', \'invertedScroll\', \'manualScroll\']), _mixins_colorable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_ssr_bootable__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_themeable__WEBPACK_IMPORTED_MODULE_3__["default"]],\n    props: {\n        card: Boolean,\n        clippedLeft: Boolean,\n        clippedRight: Boolean,\n        dense: Boolean,\n        extended: Boolean,\n        extensionHeight: {\n            type: [Number, String],\n            validator: function validator(v) {\n                return !isNaN(parseInt(v));\n            }\n        },\n        flat: Boolean,\n        floating: Boolean,\n        height: {\n            type: [Number, String],\n            validator: function validator(v) {\n                return !isNaN(parseInt(v));\n            }\n        },\n        invertedScroll: Boolean,\n        manualScroll: Boolean,\n        prominent: Boolean,\n        scrollOffScreen: Boolean,\n        /* @deprecated */\n        scrollToolbarOffScreen: Boolean,\n        scrollTarget: String,\n        scrollThreshold: {\n            type: Number,\n            default: 300\n        },\n        tabs: Boolean\n    },\n    data: function data() {\n        return {\n            activeTimeout: null,\n            currentScroll: 0,\n            heights: {\n                mobileLandscape: 48,\n                mobile: 56,\n                desktop: 64,\n                dense: 48\n            },\n            isActive: true,\n            isExtended: false,\n            isScrollingUp: false,\n            previousScroll: null,\n            previousScrollDirection: null,\n            savedScroll: 0,\n            target: null\n        };\n    },\n    computed: {\n        canScroll: function canScroll() {\n            // TODO: remove\n            if (this.scrollToolbarOffScreen) {\n                Object(_util_console__WEBPACK_IMPORTED_MODULE_6__["deprecate"])(\'scrollToolbarOffScreen\', \'scrollOffScreen\', this);\n                return true;\n            }\n            return this.scrollOffScreen || this.invertedScroll;\n        },\n        computedContentHeight: function computedContentHeight() {\n            if (this.height) return parseInt(this.height);\n            if (this.dense) return this.heights.dense;\n            if (this.prominent || this.$vuetify.breakpoint.mdAndUp) return this.heights.desktop;\n            if (this.$vuetify.breakpoint.smAndDown && this.$vuetify.breakpoint.width > this.$vuetify.breakpoint.height) return this.heights.mobileLandscape;\n            return this.heights.mobile;\n        },\n        computedExtensionHeight: function computedExtensionHeight() {\n            if (this.tabs) return 48;\n            if (this.extensionHeight) return parseInt(this.extensionHeight);\n            return this.computedContentHeight;\n        },\n        computedHeight: function computedHeight() {\n            if (!this.isExtended) return this.computedContentHeight;\n            return this.computedContentHeight + this.computedExtensionHeight;\n        },\n        computedMarginTop: function computedMarginTop() {\n            if (!this.app) return 0;\n            return this.$vuetify.application.bar;\n        },\n        classes: function classes() {\n            return __assign({ \'v-toolbar\': true, \'elevation-0\': this.flat || !this.isActive && !this.tabs && this.canScroll, \'v-toolbar--absolute\': this.absolute, \'v-toolbar--card\': this.card, \'v-toolbar--clipped\': this.clippedLeft || this.clippedRight, \'v-toolbar--dense\': this.dense, \'v-toolbar--extended\': this.isExtended, \'v-toolbar--fixed\': !this.absolute && (this.app || this.fixed), \'v-toolbar--floating\': this.floating, \'v-toolbar--prominent\': this.prominent }, this.themeClasses);\n        },\n        computedPaddingLeft: function computedPaddingLeft() {\n            if (!this.app || this.clippedLeft) return 0;\n            return this.$vuetify.application.left;\n        },\n        computedPaddingRight: function computedPaddingRight() {\n            if (!this.app || this.clippedRight) return 0;\n            return this.$vuetify.application.right;\n        },\n        computedTransform: function computedTransform() {\n            return !this.isActive ? this.canScroll ? -this.computedContentHeight : -this.computedHeight : 0;\n        },\n        currentThreshold: function currentThreshold() {\n            return Math.abs(this.currentScroll - this.savedScroll);\n        },\n        styles: function styles() {\n            return {\n                marginTop: this.computedMarginTop + "px",\n                paddingRight: this.computedPaddingRight + "px",\n                paddingLeft: this.computedPaddingLeft + "px",\n                transform: "translateY(" + this.computedTransform + "px)"\n            };\n        }\n    },\n    watch: {\n        currentThreshold: function currentThreshold(val) {\n            if (this.invertedScroll) {\n                return this.isActive = this.currentScroll > this.scrollThreshold;\n            }\n            if (val < this.scrollThreshold || !this.isBooted) return;\n            this.isActive = this.isScrollingUp;\n            this.savedScroll = this.currentScroll;\n        },\n        isActive: function isActive() {\n            this.savedScroll = 0;\n        },\n        invertedScroll: function invertedScroll(val) {\n            this.isActive = !val;\n        },\n        manualScroll: function manualScroll(val) {\n            this.isActive = !val;\n        },\n        isScrollingUp: function isScrollingUp() {\n            this.savedScroll = this.savedScroll || this.currentScroll;\n        }\n    },\n    created: function created() {\n        if (this.invertedScroll || this.manualScroll) this.isActive = false;\n    },\n    mounted: function mounted() {\n        if (this.scrollTarget) {\n            this.target = document.querySelector(this.scrollTarget);\n        }\n    },\n    methods: {\n        onScroll: function onScroll() {\n            if (!this.canScroll || this.manualScroll || typeof window === \'undefined\') return;\n            var target = this.target || window;\n            this.currentScroll = this.scrollTarget ? target.scrollTop : target.pageYOffset || document.documentElement.scrollTop;\n            this.isScrollingUp = this.currentScroll < this.previousScroll;\n            this.previousScroll = this.currentScroll;\n        },\n        /**\n         * Update the application layout\n         *\n         * @return {number}\n         */\n        updateApplication: function updateApplication() {\n            return this.invertedScroll || this.manualScroll ? 0 : this.computedHeight;\n        }\n    },\n    render: function render(h) {\n        this.isExtended = this.extended || !!this.$slots.extension;\n        var children = [];\n        var data = this.setBackgroundColor(this.color, {\n            \'class\': this.classes,\n            style: this.styles,\n            on: this.$listeners\n        });\n        data.directives = [{\n            arg: this.scrollTarget,\n            name: \'scroll\',\n            value: this.onScroll\n        }];\n        children.push(h(\'div\', {\n            staticClass: \'v-toolbar__content\',\n            style: { height: this.computedContentHeight + "px" },\n            ref: \'content\'\n        }, this.$slots.default));\n        if (this.isExtended) {\n            children.push(h(\'div\', {\n                staticClass: \'v-toolbar__extension\',\n                style: { height: this.computedExtensionHeight + "px" }\n            }, this.$slots.extension));\n        }\n        return h(\'nav\', data, children);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VToolbar/VToolbarSideIcon.js":\n/*!*****************************************************!*\\\n  !*** ./src/components/VToolbar/VToolbarSideIcon.js ***!\n  \\*****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_VBtn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../components/VBtn */ "./src/components/VBtn/index.ts");\n/* harmony import */ var _components_VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/VIcon */ "./src/components/VIcon/index.ts");\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-toolbar-side-icon\',\n    functional: true,\n    render: function render(h, _a) {\n        var slots = _a.slots,\n            listeners = _a.listeners,\n            props = _a.props,\n            data = _a.data;\n        var classes = data.staticClass ? data.staticClass + " v-toolbar__side-icon" : \'v-toolbar__side-icon\';\n        var d = Object.assign(data, {\n            staticClass: classes,\n            props: Object.assign(props, {\n                icon: true\n            }),\n            on: listeners\n        });\n        var defaultSlot = slots().default;\n        return h(_components_VBtn__WEBPACK_IMPORTED_MODULE_0__["default"], d, defaultSlot || [h(_components_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], \'$vuetify.icons.menu\')]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VToolbar/index.js":\n/*!******************************************!*\\\n  !*** ./src/components/VToolbar/index.js ***!\n  \\******************************************/\n/*! exports provided: VToolbar, VToolbarSideIcon, VToolbarTitle, VToolbarItems, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VToolbarTitle", function() { return VToolbarTitle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VToolbarItems", function() { return VToolbarItems; });\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _VToolbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VToolbar */ "./src/components/VToolbar/VToolbar.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VToolbar", function() { return _VToolbar__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _VToolbarSideIcon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VToolbarSideIcon */ "./src/components/VToolbar/VToolbarSideIcon.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VToolbarSideIcon", function() { return _VToolbarSideIcon__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n\n\n\nvar VToolbarTitle = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'v-toolbar__title\');\nvar VToolbarItems = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleFunctional"])(\'v-toolbar__items\');\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VToolbar: _VToolbar__WEBPACK_IMPORTED_MODULE_1__["default"],\n        VToolbarItems: VToolbarItems,\n        VToolbarTitle: VToolbarTitle,\n        VToolbarSideIcon: _VToolbarSideIcon__WEBPACK_IMPORTED_MODULE_2__["default"]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTooltip/VTooltip.js":\n/*!*********************************************!*\\\n  !*** ./src/components/VTooltip/VTooltip.js ***!\n  \\*********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_tooltips_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_tooltips.styl */ "./src/stylus/components/_tooltips.styl");\n/* harmony import */ var _stylus_components_tooltips_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_tooltips_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _mixins_delayable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/delayable */ "./src/mixins/delayable.ts");\n/* harmony import */ var _mixins_dependent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/dependent */ "./src/mixins/dependent.ts");\n/* harmony import */ var _mixins_detachable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mixins/detachable */ "./src/mixins/detachable.js");\n/* harmony import */ var _mixins_menuable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../mixins/menuable */ "./src/mixins/menuable.js");\n/* harmony import */ var _mixins_toggleable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../mixins/toggleable */ "./src/mixins/toggleable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n\n// Mixins\n\n\n\n\n\n\n// Helpers\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'v-tooltip\',\n    mixins: [_mixins_colorable__WEBPACK_IMPORTED_MODULE_1__["default"], _mixins_delayable__WEBPACK_IMPORTED_MODULE_2__["default"], _mixins_dependent__WEBPACK_IMPORTED_MODULE_3__["default"], _mixins_detachable__WEBPACK_IMPORTED_MODULE_4__["default"], _mixins_menuable__WEBPACK_IMPORTED_MODULE_5__["default"], _mixins_toggleable__WEBPACK_IMPORTED_MODULE_6__["default"]],\n    props: {\n        closeDelay: {\n            type: [Number, String],\n            default: 200\n        },\n        debounce: {\n            type: [Number, String],\n            default: 0\n        },\n        disabled: Boolean,\n        fixed: {\n            type: Boolean,\n            default: true\n        },\n        openDelay: {\n            type: [Number, String],\n            default: 200\n        },\n        tag: {\n            type: String,\n            default: \'span\'\n        },\n        transition: String,\n        zIndex: {\n            default: null\n        }\n    },\n    data: function data() {\n        return {\n            calculatedMinWidth: 0,\n            closeDependents: false\n        };\n    },\n    computed: {\n        calculatedLeft: function calculatedLeft() {\n            var _a = this.dimensions,\n                activator = _a.activator,\n                content = _a.content;\n            var unknown = !this.bottom && !this.left && !this.top && !this.right;\n            var left = 0;\n            if (this.top || this.bottom || unknown) {\n                left = activator.left + activator.width / 2 - content.width / 2;\n            } else if (this.left || this.right) {\n                left = activator.left + (this.right ? activator.width : -content.width) + (this.right ? 10 : -10);\n            }\n            if (this.nudgeLeft) left -= parseInt(this.nudgeLeft);\n            if (this.nudgeRight) left += parseInt(this.nudgeRight);\n            return this.calcXOverflow(left) + "px";\n        },\n        calculatedTop: function calculatedTop() {\n            var _a = this.dimensions,\n                activator = _a.activator,\n                content = _a.content;\n            var top = 0;\n            if (this.top || this.bottom) {\n                top = activator.top + (this.bottom ? activator.height : -content.height) + (this.bottom ? 10 : -10);\n            } else if (this.left || this.right) {\n                top = activator.top + activator.height / 2 - content.height / 2;\n            }\n            if (this.nudgeTop) top -= parseInt(this.nudgeTop);\n            if (this.nudgeBottom) top += parseInt(this.nudgeBottom);\n            return this.calcYOverflow(top + this.pageYOffset) + "px";\n        },\n        classes: function classes() {\n            return {\n                \'v-tooltip--top\': this.top,\n                \'v-tooltip--right\': this.right,\n                \'v-tooltip--bottom\': this.bottom,\n                \'v-tooltip--left\': this.left\n            };\n        },\n        computedTransition: function computedTransition() {\n            if (this.transition) return this.transition;\n            if (this.top) return \'slide-y-reverse-transition\';\n            if (this.right) return \'slide-x-transition\';\n            if (this.bottom) return \'slide-y-transition\';\n            if (this.left) return \'slide-x-reverse-transition\';\n        },\n        offsetY: function offsetY() {\n            return this.top || this.bottom;\n        },\n        offsetX: function offsetX() {\n            return this.left || this.right;\n        },\n        styles: function styles() {\n            return {\n                left: this.calculatedLeft,\n                maxWidth: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_7__["convertToUnit"])(this.maxWidth),\n                opacity: this.isActive ? 0.9 : 0,\n                top: this.calculatedTop,\n                zIndex: this.zIndex || this.activeZIndex\n            };\n        }\n    },\n    mounted: function mounted() {\n        this.value && this.callActivate();\n    },\n    methods: {\n        activate: function activate() {\n            // Update coordinates and dimensions of menu\n            // and its activator\n            this.updateDimensions();\n            // Start the transition\n            requestAnimationFrame(this.startTransition);\n        }\n    },\n    render: function render(h) {\n        var _this = this;\n        var _a;\n        var tooltip = h(\'div\', this.setBackgroundColor(this.color, {\n            staticClass: \'v-tooltip__content\',\n            \'class\': (_a = {}, _a[this.contentClass] = true, _a[\'menuable__content__active\'] = this.isActive, _a),\n            style: this.styles,\n            attrs: this.getScopeIdAttrs(),\n            directives: [{\n                name: \'show\',\n                value: this.isContentActive\n            }],\n            ref: \'content\'\n        }), this.showLazyContent(this.$slots.default));\n        return h(this.tag, {\n            staticClass: \'v-tooltip\',\n            \'class\': this.classes\n        }, [h(\'transition\', {\n            props: {\n                name: this.computedTransition\n            }\n        }, [tooltip]), h(\'span\', {\n            on: this.disabled ? {} : {\n                mouseenter: function mouseenter() {\n                    _this.runDelay(\'open\', function () {\n                        return _this.isActive = true;\n                    });\n                },\n                mouseleave: function mouseleave() {\n                    _this.runDelay(\'close\', function () {\n                        return _this.isActive = false;\n                    });\n                }\n            },\n            ref: \'activator\'\n        }, this.$slots.activator)]);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VTooltip/index.js":\n/*!******************************************!*\\\n  !*** ./src/components/VTooltip/index.js ***!\n  \\******************************************/\n/*! exports provided: VTooltip, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTooltip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTooltip */ "./src/components/VTooltip/VTooltip.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTooltip", function() { return _VTooltip__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_VTooltip__WEBPACK_IMPORTED_MODULE_0__["default"]);\n\n/***/ }),\n\n/***/ "./src/components/VTreeview/VTreeview.ts":\n/*!***********************************************!*\\\n  !*** ./src/components/VTreeview/VTreeview.ts ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_treeview_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_treeview.styl */ "./src/stylus/components/_treeview.styl");\n/* harmony import */ var _stylus_components_treeview_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_treeview_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VTreeviewNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VTreeviewNode */ "./src/components/VTreeview/VTreeviewNode.ts");\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) {\n        ar = ar.concat(__read(arguments[i]));\n    }return ar;\n};\n// Styles\n\n// Components\n\n// Mixins\n\n\n// Utils\n\n\n\nfunction ston(s) {\n    var n = Number(s);\n    return !isNaN(n) ? n : s;\n}\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_5__["default"])(Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_3__["provide"])(\'treeview\'), _mixins_themeable__WEBPACK_IMPORTED_MODULE_2__["default"]\n/* @vue/component */\n).extend({\n    name: \'v-treeview\',\n    provide: function provide() {\n        return { treeview: this };\n    },\n    props: __assign({ active: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        }, items: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        }, hoverable: Boolean, multipleActive: Boolean, open: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        }, openAll: Boolean, value: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        } }, _VTreeviewNode__WEBPACK_IMPORTED_MODULE_1__["VTreeviewNodeProps"]),\n    data: function data() {\n        return {\n            nodes: {},\n            selectedCache: new Set(),\n            activeCache: new Set(),\n            openCache: new Set()\n        };\n    },\n    watch: {\n        items: {\n            handler: function handler() {\n                // We only care if nodes are removed or added\n                if (Object.keys(this.nodes).length === this.countItems(this.items)) return;\n                var oldSelectedCache = __spread(this.selectedCache);\n                this.selectedCache = new Set();\n                this.activeCache = new Set();\n                this.openCache = new Set();\n                this.buildTree(this.items);\n                // Only emit selected if selection has changed\n                // as a result of items changing. This fixes a\n                // potential double emit when selecting a node\n                // with dynamic children\n                if (!Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["deepEqual"])(oldSelectedCache, __spread(this.selectedCache))) this.emitSelected();\n            },\n            deep: true\n        },\n        active: function active(value) {\n            var _this = this;\n            var old = __spread(this.activeCache);\n            if (!value || Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["deepEqual"])(old, value)) return;\n            old.forEach(function (key) {\n                return _this.updateActive(key, false);\n            });\n            value.forEach(function (key) {\n                return _this.updateActive(key, true);\n            });\n            this.emitActive();\n        },\n        value: function value(_value) {\n            var _this = this;\n            var old = __spread(this.selectedCache);\n            if (!_value || Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["deepEqual"])(old, _value)) return;\n            old.forEach(function (key) {\n                return _this.updateSelected(key, false);\n            });\n            _value.forEach(function (key) {\n                return _this.updateSelected(key, true);\n            });\n            this.emitSelected();\n        },\n        open: function open(value) {\n            var _this = this;\n            var old = __spread(this.openCache);\n            if (Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["deepEqual"])(old, value)) return;\n            old.forEach(function (key) {\n                return _this.updateOpen(key, false);\n            });\n            value.forEach(function (key) {\n                return _this.updateOpen(key, true);\n            });\n            this.emitOpen();\n        }\n    },\n    created: function created() {\n        var _this = this;\n        this.buildTree(this.items);\n        this.value.forEach(function (key) {\n            return _this.updateSelected(key, true);\n        });\n        this.emitSelected();\n        this.active.forEach(function (key) {\n            return _this.updateActive(key, true);\n        });\n        this.emitActive();\n    },\n    mounted: function mounted() {\n        var _this = this;\n        // Save the developer from themselves\n        if (this.$slots.prepend || this.$slots.append) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_6__["consoleWarn"])(\'The prepend and append slots require a slot-scope attribute\', this);\n        }\n        if (this.openAll) {\n            Object.keys(this.nodes).forEach(function (key) {\n                return _this.updateOpen(ston(key), true);\n            });\n        } else {\n            this.open.forEach(function (key) {\n                return _this.updateOpen(key, true);\n            });\n        }\n        this.emitOpen();\n    },\n    methods: {\n        buildTree: function buildTree(items, parent) {\n            var _this = this;\n            if (parent === void 0) {\n                parent = null;\n            }\n            for (var i = 0; i < items.length; i++) {\n                var item = items[i];\n                var key = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["getObjectValueByPath"])(item, this.itemKey);\n                var children = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["getObjectValueByPath"])(item, this.itemChildren, []);\n                var oldNode = this.nodes.hasOwnProperty(key) ? this.nodes[key] : {\n                    isSelected: false, isIndeterminate: false, isActive: false, isOpen: false, vnode: null\n                };\n                var node = {\n                    vnode: oldNode.vnode,\n                    parent: parent,\n                    children: children.map(function (c) {\n                        return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["getObjectValueByPath"])(c, _this.itemKey);\n                    })\n                };\n                this.buildTree(children, key);\n                // This fixed bug with dynamic children resetting selected parent state\n                if (!this.nodes.hasOwnProperty(key) && parent !== null && this.nodes.hasOwnProperty(parent)) {\n                    node.isSelected = this.nodes[parent].isSelected;\n                    node.isIndeterminate = this.nodes[parent].isIndeterminate;\n                } else {\n                    node.isSelected = oldNode.isSelected;\n                    node.isIndeterminate = oldNode.isIndeterminate;\n                }\n                node.isActive = oldNode.isActive;\n                node.isOpen = oldNode.isOpen;\n                this.nodes[key] = !children.length ? node : this.calculateState(node, this.nodes);\n                // Don\'t forget to rebuild cache\n                if (this.nodes[key].isSelected) this.selectedCache.add(key);\n                if (this.nodes[key].isActive) this.activeCache.add(key);\n                if (this.nodes[key].isOpen) this.openCache.add(key);\n                this.updateVnodeState(key);\n            }\n        },\n        countItems: function countItems(items) {\n            var count = 0;\n            for (var i = 0; i < items.length; i++) {\n                var item = items[i];\n                count += 1;\n                count += item.children ? this.countItems(item.children) : 0;\n            }\n            return count;\n        },\n        calculateState: function calculateState(node, state) {\n            var counts = node.children.reduce(function (counts, child) {\n                counts[0] += +Boolean(state[child].isSelected);\n                counts[1] += +Boolean(state[child].isIndeterminate);\n                return counts;\n            }, [0, 0]);\n            node.isSelected = !!node.children.length && counts[0] === node.children.length;\n            node.isIndeterminate = !node.isSelected && (counts[0] > 0 || counts[1] > 0);\n            return node;\n        },\n        emitOpen: function emitOpen() {\n            this.$emit(\'update:open\', __spread(this.openCache));\n        },\n        emitSelected: function emitSelected() {\n            this.$emit(\'input\', __spread(this.selectedCache));\n        },\n        emitActive: function emitActive() {\n            this.$emit(\'update:active\', __spread(this.activeCache));\n        },\n        getDescendants: function getDescendants(key, descendants) {\n            if (descendants === void 0) {\n                descendants = [];\n            }\n            var children = this.nodes[key].children;\n            descendants.push.apply(descendants, __spread(children));\n            for (var i = 0; i < children.length; i++) {\n                descendants = this.getDescendants(children[i], descendants);\n            }\n            return descendants;\n        },\n        getParents: function getParents(key) {\n            var parent = this.nodes[key].parent;\n            var parents = [];\n            while (parent !== null) {\n                parents.push(parent);\n                parent = this.nodes[parent].parent;\n            }\n            return parents;\n        },\n        register: function register(node) {\n            var key = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["getObjectValueByPath"])(node.item, this.itemKey);\n            this.nodes[key].vnode = node;\n            this.updateVnodeState(key);\n        },\n        unregister: function unregister(node) {\n            var key = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_4__["getObjectValueByPath"])(node.item, this.itemKey);\n            this.nodes[key].vnode = null;\n        },\n        updateActive: function updateActive(key, isActive) {\n            var _this = this;\n            if (!this.nodes.hasOwnProperty(key)) return;\n            if (!this.multipleActive) {\n                this.activeCache.forEach(function (active) {\n                    _this.nodes[active].isActive = false;\n                    _this.updateVnodeState(active);\n                    _this.activeCache.delete(active);\n                });\n            }\n            var node = this.nodes[key];\n            if (!node) return;\n            if (isActive) this.activeCache.add(key);else this.activeCache.delete(key);\n            node.isActive = isActive;\n            this.updateVnodeState(key);\n        },\n        updateSelected: function updateSelected(key, isSelected) {\n            var _this = this;\n            if (!this.nodes.hasOwnProperty(key)) return;\n            var changed = {};\n            var descendants = __spread([key], this.getDescendants(key));\n            descendants.forEach(function (descendant) {\n                _this.nodes[descendant].isSelected = isSelected;\n                _this.nodes[descendant].isIndeterminate = false;\n                changed[descendant] = isSelected;\n            });\n            var parents = this.getParents(key);\n            parents.forEach(function (parent) {\n                _this.nodes[parent] = _this.calculateState(_this.nodes[parent], _this.nodes);\n                changed[parent] = _this.nodes[parent].isSelected;\n            });\n            var all = __spread([key], descendants, parents);\n            all.forEach(this.updateVnodeState);\n            Object.keys(changed).forEach(function (k) {\n                changed[k] === true ? _this.selectedCache.add(ston(k)) : _this.selectedCache.delete(ston(k));\n            });\n        },\n        updateOpen: function updateOpen(key, isOpen) {\n            var _this = this;\n            if (!this.nodes.hasOwnProperty(key)) return;\n            var node = this.nodes[key];\n            if (node.children && !node.children.length && node.vnode && !node.vnode.hasLoaded) {\n                node.vnode.checkChildren().then(function () {\n                    return _this.updateOpen(key, isOpen);\n                });\n            } else {\n                node.isOpen = isOpen;\n                node.isOpen ? this.openCache.add(key) : this.openCache.delete(key);\n                this.updateVnodeState(key);\n            }\n        },\n        updateVnodeState: function updateVnodeState(key) {\n            var node = this.nodes[key];\n            if (node && node.vnode) {\n                node.vnode.isSelected = node.isSelected;\n                node.vnode.isIndeterminate = node.isIndeterminate;\n                node.vnode.isActive = node.isActive;\n                node.vnode.isOpen = node.isOpen;\n            }\n        }\n    },\n    render: function render(h) {\n        var children = this.items.length ? this.items.map(_VTreeviewNode__WEBPACK_IMPORTED_MODULE_1__["default"].options.methods.genChild.bind(this))\n        /* istanbul ignore next */\n        : this.$slots.default;\n        return h(\'div\', {\n            staticClass: \'v-treeview\',\n            class: __assign({ \'v-treeview--hoverable\': this.hoverable }, this.themeClasses)\n        }, children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VTreeview/VTreeviewNode.ts":\n/*!***************************************************!*\\\n  !*** ./src/components/VTreeview/VTreeviewNode.ts ***!\n  \\***************************************************/\n/*! exports provided: VTreeviewNodeProps, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VTreeviewNodeProps", function() { return VTreeviewNodeProps; });\n/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transitions */ "./src/components/transitions/index.js");\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _VTreeviewNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VTreeviewNode */ "./src/components/VTreeview/VTreeviewNode.ts");\n/* harmony import */ var _mixins_registrable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../mixins/registrable */ "./src/mixins/registrable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// Components\n\n\n\n// Mixins\n\n// Utils\n\n\nvar VTreeviewNodeProps = {\n    activatable: Boolean,\n    activeClass: {\n        type: String,\n        default: \'v-treeview-node--active\'\n    },\n    selectable: Boolean,\n    selectedColor: {\n        type: String,\n        default: \'accent\'\n    },\n    indeterminateIcon: {\n        type: String,\n        default: \'$vuetify.icons.checkboxIndeterminate\'\n    },\n    onIcon: {\n        type: String,\n        default: \'$vuetify.icons.checkboxOn\'\n    },\n    offIcon: {\n        type: String,\n        default: \'$vuetify.icons.checkboxOff\'\n    },\n    expandIcon: {\n        type: String,\n        default: \'$vuetify.icons.subgroup\'\n    },\n    loadingIcon: {\n        type: String,\n        default: \'$vuetify.icons.loading\'\n    },\n    itemKey: {\n        type: String,\n        default: \'id\'\n    },\n    itemText: {\n        type: String,\n        default: \'name\'\n    },\n    itemChildren: {\n        type: String,\n        default: \'children\'\n    },\n    loadChildren: Function,\n    openOnClick: Boolean,\n    transition: Boolean\n};\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_4__["default"])(Object(_mixins_registrable__WEBPACK_IMPORTED_MODULE_3__["inject"])(\'treeview\')\n/* @vue/component */\n).extend({\n    name: \'v-treeview-node\',\n    inject: {\n        treeview: {\n            default: null\n        }\n    },\n    props: __assign({ item: {\n            type: Object,\n            default: function _default() {\n                return null;\n            }\n        } }, VTreeviewNodeProps),\n    data: function data() {\n        return {\n            isOpen: false,\n            isSelected: false,\n            isIndeterminate: false,\n            isActive: false,\n            isLoading: false,\n            hasLoaded: false\n        };\n    },\n    computed: {\n        key: function key() {\n            return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__["getObjectValueByPath"])(this.item, this.itemKey);\n        },\n        children: function children() {\n            return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__["getObjectValueByPath"])(this.item, this.itemChildren);\n        },\n        text: function text() {\n            return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__["getObjectValueByPath"])(this.item, this.itemText);\n        },\n        scopedProps: function scopedProps() {\n            return {\n                item: this.item,\n                leaf: !this.children,\n                selected: this.isSelected,\n                indeterminate: this.isIndeterminate,\n                active: this.isActive,\n                open: this.isOpen\n            };\n        },\n        computedIcon: function computedIcon() {\n            if (this.isIndeterminate) return this.indeterminateIcon;else if (this.isSelected) return this.onIcon;else return this.offIcon;\n        }\n    },\n    created: function created() {\n        this.treeview.register(this);\n    },\n    beforeDestroy: function beforeDestroy() {\n        this.treeview.unregister(this);\n    },\n    methods: {\n        checkChildren: function checkChildren() {\n            var _this = this;\n            return new Promise(function (resolve) {\n                // TODO: Potential issue with always trying\n                // to load children if response is empty?\n                if (!_this.children || _this.children.length || !_this.loadChildren || _this.hasLoaded) return resolve();\n                _this.isLoading = true;\n                resolve(_this.loadChildren(_this.item));\n            }).then(function () {\n                _this.isLoading = false;\n                _this.hasLoaded = true;\n            });\n        },\n        open: function open() {\n            this.isOpen = !this.isOpen;\n            this.treeview.updateOpen(this.key, this.isOpen);\n            this.treeview.emitOpen();\n        },\n        genLabel: function genLabel() {\n            return this.$createElement(\'label\', {\n                slot: \'label\',\n                staticClass: \'v-treeview-node__label\'\n            }, [this.text]);\n        },\n        genContent: function genContent() {\n            var children = [this.$scopedSlots.prepend && this.$scopedSlots.prepend(this.scopedProps), this.genLabel(), this.$scopedSlots.append && this.$scopedSlots.append(this.scopedProps)];\n            return this.$createElement(\'div\', {\n                staticClass: \'v-treeview-node__content\'\n            }, children);\n        },\n        genToggle: function genToggle() {\n            var _this = this;\n            return this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__["VIcon"], {\n                staticClass: \'v-treeview-node__toggle\',\n                class: {\n                    \'v-treeview-node__toggle--open\': this.isOpen,\n                    \'v-treeview-node__toggle--loading\': this.isLoading\n                },\n                slot: \'prepend\',\n                on: {\n                    click: function click(e) {\n                        e.stopPropagation();\n                        if (_this.isLoading) return;\n                        _this.checkChildren().then(function () {\n                            return _this.open();\n                        });\n                    }\n                }\n            }, [this.isLoading ? this.loadingIcon : this.expandIcon]);\n        },\n        genCheckbox: function genCheckbox() {\n            var _this = this;\n            return this.$createElement(_VIcon__WEBPACK_IMPORTED_MODULE_1__["VIcon"], {\n                staticClass: \'v-treeview-node__checkbox\',\n                props: {\n                    color: this.isSelected ? this.selectedColor : undefined\n                },\n                on: {\n                    click: function click(e) {\n                        e.stopPropagation();\n                        if (_this.isLoading) return;\n                        _this.checkChildren().then(function () {\n                            // We nextTick here so that items watch in VTreeview has a chance to run first\n                            _this.$nextTick(function () {\n                                _this.isSelected = !_this.isSelected;\n                                _this.isIndeterminate = false;\n                                _this.treeview.updateSelected(_this.key, _this.isSelected);\n                                _this.treeview.emitSelected();\n                            });\n                        });\n                    }\n                }\n            }, [this.computedIcon]);\n        },\n        genNode: function genNode() {\n            var _this = this;\n            var children = [this.genContent()];\n            if (this.selectable) children.unshift(this.genCheckbox());\n            if (this.children) children.unshift(this.genToggle());\n            return this.$createElement(\'div\', {\n                staticClass: \'v-treeview-node__root\',\n                on: {\n                    click: function click() {\n                        if (_this.openOnClick && _this.children) {\n                            _this.open();\n                        } else if (_this.activatable) {\n                            _this.isActive = !_this.isActive;\n                            _this.treeview.updateActive(_this.key, _this.isActive);\n                            _this.treeview.emitActive();\n                        }\n                    }\n                }\n            }, children);\n        },\n        genChild: function genChild(item) {\n            return this.$createElement(_VTreeviewNode__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                key: Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__["getObjectValueByPath"])(item, this.itemKey),\n                props: {\n                    activatable: this.activatable,\n                    activeClass: this.activeClass,\n                    item: item,\n                    selectable: this.selectable,\n                    selectedColor: this.selectedColor,\n                    expandIcon: this.expandIcon,\n                    indeterminateIcon: this.indeterminateIcon,\n                    offIcon: this.offIcon,\n                    onIcon: this.onIcon,\n                    loadingIcon: this.loadingIcon,\n                    itemKey: this.itemKey,\n                    itemText: this.itemText,\n                    itemChildren: this.itemChildren,\n                    loadChildren: this.loadChildren,\n                    transition: this.transition,\n                    openOnClick: this.openOnClick\n                },\n                scopedSlots: this.$scopedSlots\n            });\n        },\n        genChildrenWrapper: function genChildrenWrapper() {\n            if (!this.isOpen || !this.children) return null;\n            var children = [this.children.map(this.genChild)];\n            return this.$createElement(\'div\', {\n                staticClass: \'v-treeview-node__children\'\n            }, children);\n        },\n        genTransition: function genTransition() {\n            return this.$createElement(_transitions__WEBPACK_IMPORTED_MODULE_0__["VExpandTransition"], [this.genChildrenWrapper()]);\n        }\n    },\n    render: function render(h) {\n        var _a;\n        var children = [this.genNode()];\n        if (this.transition) children.push(this.genTransition());else children.push(this.genChildrenWrapper());\n        return h(\'div\', {\n            staticClass: \'v-treeview-node\',\n            class: (_a = {}, _a[this.activeClass] = this.isActive, _a[\'v-treeview-node--leaf\'] = !this.children, _a[\'v-treeview-node--click\'] = this.openOnClick, _a[\'v-treeview-node--selected\'] = this.isSelected, _a)\n        }, children);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VTreeview/index.ts":\n/*!*******************************************!*\\\n  !*** ./src/components/VTreeview/index.ts ***!\n  \\*******************************************/\n/*! exports provided: VTreeview, VTreeviewNode, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VTreeview__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VTreeview */ "./src/components/VTreeview/VTreeview.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTreeview", function() { return _VTreeview__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _VTreeviewNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VTreeviewNode */ "./src/components/VTreeview/VTreeviewNode.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTreeviewNode", function() { return _VTreeviewNode__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VTreeview: _VTreeview__WEBPACK_IMPORTED_MODULE_0__["default"],\n        VTreeviewNode: _VTreeviewNode__WEBPACK_IMPORTED_MODULE_1__["default"]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/VWindow/VWindow.ts":\n/*!*******************************************!*\\\n  !*** ./src/components/VWindow/VWindow.ts ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_windows_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stylus/components/_windows.styl */ "./src/stylus/components/_windows.styl");\n/* harmony import */ var _stylus_components_windows_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_windows_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VItemGroup/VItemGroup */ "./src/components/VItemGroup/VItemGroup.ts");\n/* harmony import */ var _directives_touch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../directives/touch */ "./src/directives/touch.ts");\n// Styles\n\n// Components\n\n// Directives\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (_VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_1__["BaseItemGroup"].extend({\n    name: \'v-window\',\n    provide: function provide() {\n        return {\n            windowGroup: this\n        };\n    },\n    directives: { Touch: _directives_touch__WEBPACK_IMPORTED_MODULE_2__["default"] },\n    props: {\n        mandatory: {\n            type: Boolean,\n            default: true\n        },\n        reverse: {\n            type: Boolean,\n            default: undefined\n        },\n        touch: Object,\n        touchless: Boolean,\n        value: {\n            required: false\n        },\n        vertical: Boolean\n    },\n    data: function data() {\n        return {\n            internalHeight: undefined,\n            isActive: false,\n            isBooted: false,\n            isReverse: false\n        };\n    },\n    computed: {\n        computedTransition: function computedTransition() {\n            if (!this.isBooted) return \'\';\n            var axis = this.vertical ? \'y\' : \'x\';\n            var direction = this.internalReverse === !this.$vuetify.rtl ? \'-reverse\' : \'\';\n            return "v-window-" + axis + direction + "-transition";\n        },\n        internalIndex: function internalIndex() {\n            var _this = this;\n            return this.items.findIndex(function (item, i) {\n                return _this.internalValue === _this.getValue(item, i);\n            });\n        },\n        internalReverse: function internalReverse() {\n            if (this.reverse !== undefined) return this.reverse;\n            return this.isReverse;\n        }\n    },\n    watch: {\n        internalIndex: \'updateReverse\'\n    },\n    mounted: function mounted() {\n        var _this = this;\n        this.$nextTick(function () {\n            return _this.isBooted = true;\n        });\n    },\n    methods: {\n        genContainer: function genContainer() {\n            return this.$createElement(\'div\', {\n                staticClass: \'v-window__container\',\n                class: {\n                    \'v-window__container--is-active\': this.isActive\n                },\n                style: {\n                    height: this.internalHeight\n                }\n            }, this.$slots.default);\n        },\n        next: function next() {\n            this.isReverse = false;\n            var nextIndex = (this.internalIndex + 1) % this.items.length;\n            var item = this.items[nextIndex];\n            this.internalValue = this.getValue(item, nextIndex);\n        },\n        prev: function prev() {\n            this.isReverse = true;\n            var lastIndex = (this.internalIndex + this.items.length - 1) % this.items.length;\n            var item = this.items[lastIndex];\n            this.internalValue = this.getValue(item, lastIndex);\n        },\n        updateReverse: function updateReverse(val, oldVal) {\n            this.isReverse = val < oldVal;\n        }\n    },\n    render: function render(h) {\n        var data = {\n            staticClass: \'v-window\',\n            directives: []\n        };\n        if (!this.touchless) {\n            var value = this.touch || {\n                left: this.next,\n                right: this.prev\n            };\n            data.directives.push({\n                name: \'touch\',\n                value: value\n            });\n        }\n        return h(\'div\', data, [this.genContainer()]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VWindow/VWindowItem.ts":\n/*!***********************************************!*\\\n  !*** ./src/components/VWindow/VWindowItem.ts ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mixins_bootable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mixins/bootable */ "./src/mixins/bootable.ts");\n/* harmony import */ var _mixins_groupable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/groupable */ "./src/mixins/groupable.ts");\n/* harmony import */ var _directives_touch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../directives/touch */ "./src/directives/touch.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/mixins */ "./src/util/mixins.ts");\n// Mixins\n\n\n// Directives\n\n// Utilities\n\n\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_4__["default"])(_mixins_bootable__WEBPACK_IMPORTED_MODULE_0__["default"], Object(_mixins_groupable__WEBPACK_IMPORTED_MODULE_1__["factory"])(\'windowGroup\', \'v-window-item\', \'v-window\')\n/* @vue/component */\n).extend({\n    name: \'v-window-item\',\n    directives: {\n        Touch: _directives_touch__WEBPACK_IMPORTED_MODULE_2__["default"]\n    },\n    props: {\n        reverseTransition: {\n            type: [Boolean, String],\n            default: undefined\n        },\n        transition: {\n            type: [Boolean, String],\n            default: undefined\n        },\n        value: {\n            required: false\n        }\n    },\n    data: function data() {\n        return {\n            isActive: false,\n            wasCancelled: false\n        };\n    },\n    computed: {\n        computedTransition: function computedTransition() {\n            if (!this.windowGroup.internalReverse) {\n                return typeof this.transition !== \'undefined\' ? this.transition || \'\' : this.windowGroup.computedTransition;\n            }\n            return typeof this.reverseTransition !== \'undefined\' ? this.reverseTransition || \'\' : this.windowGroup.computedTransition;\n        }\n    },\n    methods: {\n        genDefaultSlot: function genDefaultSlot() {\n            return this.$slots.default;\n        },\n        onAfterEnter: function onAfterEnter() {\n            var _this = this;\n            if (this.wasCancelled) {\n                this.wasCancelled = false;\n                return;\n            }\n            requestAnimationFrame(function () {\n                _this.windowGroup.internalHeight = undefined;\n                _this.windowGroup.isActive = false;\n            });\n        },\n        onBeforeEnter: function onBeforeEnter() {\n            this.windowGroup.isActive = true;\n        },\n        onBeforeLeave: function onBeforeLeave(el) {\n            this.windowGroup.internalHeight = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["convertToUnit"])(el.clientHeight);\n        },\n        onEnterCancelled: function onEnterCancelled() {\n            this.wasCancelled = true;\n        },\n        onEnter: function onEnter(el, done) {\n            var _this = this;\n            var isBooted = this.windowGroup.isBooted;\n            if (isBooted) {\n                Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["addOnceEventListener"])(el, \'transitionend\', done);\n            }\n            requestAnimationFrame(function () {\n                _this.windowGroup.internalHeight = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_3__["convertToUnit"])(el.clientHeight);\n                // On initial render, there is no transition\n                // Vue leaves a `enter` transition class\n                // if done is called too fast\n                !isBooted && setTimeout(done, 100);\n            });\n        }\n    },\n    render: function render(h) {\n        var div = h(\'div\', {\n            staticClass: \'v-window-item\',\n            directives: [{\n                name: \'show\',\n                value: this.isActive\n            }],\n            on: this.$listeners\n        }, this.showLazyContent(this.genDefaultSlot()));\n        return h(\'transition\', {\n            props: {\n                name: this.computedTransition\n            },\n            on: {\n                afterEnter: this.onAfterEnter,\n                beforeEnter: this.onBeforeEnter,\n                beforeLeave: this.onBeforeLeave,\n                enter: this.onEnter,\n                enterCancelled: this.onEnterCancelled\n            }\n        }, [div]);\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/components/VWindow/index.ts":\n/*!*****************************************!*\\\n  !*** ./src/components/VWindow/index.ts ***!\n  \\*****************************************/\n/*! exports provided: VWindow, VWindowItem, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VWindow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VWindow */ "./src/components/VWindow/VWindow.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VWindow", function() { return _VWindow__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _VWindowItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VWindowItem */ "./src/components/VWindow/VWindowItem.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VWindowItem", function() { return _VWindowItem__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VWindow: _VWindow__WEBPACK_IMPORTED_MODULE_0__["default"],\n        VWindowItem: _VWindowItem__WEBPACK_IMPORTED_MODULE_1__["default"]\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/Vuetify/index.ts":\n/*!*****************************************!*\\\n  !*** ./src/components/Vuetify/index.ts ***!\n  \\*****************************************/\n/*! exports provided: checkVueVersion, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkVueVersion", function() { return checkVueVersion; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_application__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mixins/application */ "./src/components/Vuetify/mixins/application.ts");\n/* harmony import */ var _mixins_breakpoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mixins/breakpoint */ "./src/components/Vuetify/mixins/breakpoint.ts");\n/* harmony import */ var _mixins_theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mixins/theme */ "./src/components/Vuetify/mixins/theme.ts");\n/* harmony import */ var _mixins_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mixins/icons */ "./src/components/Vuetify/mixins/icons.js");\n/* harmony import */ var _mixins_options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mixins/options */ "./src/components/Vuetify/mixins/options.js");\n/* harmony import */ var _mixins_lang__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mixins/lang */ "./src/components/Vuetify/mixins/lang.ts");\n/* harmony import */ var _util_goTo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/goTo */ "./src/components/Vuetify/util/goTo.js");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/console */ "./src/util/console.ts");\n\n\n\n\n\n\n\n\n// Utils\n\nvar Vuetify = {\n    install: function install(Vue, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        if (this.installed) return;\n        this.installed = true;\n        if (vue__WEBPACK_IMPORTED_MODULE_0___default.a !== Vue) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_8__["consoleError"])(\'Multiple instances of Vue detected\\nSee https://github.com/vuetifyjs/vuetify/issues/4068\\n\\nIf you\\\'re seeing "$attrs is readonly", it\\\'s caused by this\');\n        }\n        checkVueVersion(Vue);\n        var lang = Object(_mixins_lang__WEBPACK_IMPORTED_MODULE_6__["default"])(opts.lang);\n        Vue.prototype.$vuetify = new Vue({\n            mixins: [_mixins_breakpoint__WEBPACK_IMPORTED_MODULE_2__["default"]],\n            data: {\n                application: _mixins_application__WEBPACK_IMPORTED_MODULE_1__["default"],\n                dark: false,\n                icons: Object(_mixins_icons__WEBPACK_IMPORTED_MODULE_4__["default"])(opts.iconfont, opts.icons),\n                lang: lang,\n                options: Object(_mixins_options__WEBPACK_IMPORTED_MODULE_5__["default"])(opts.options),\n                rtl: opts.rtl,\n                theme: Object(_mixins_theme__WEBPACK_IMPORTED_MODULE_3__["default"])(opts.theme)\n            },\n            methods: {\n                goTo: _util_goTo__WEBPACK_IMPORTED_MODULE_7__["default"],\n                t: lang.t.bind(lang)\n            }\n        });\n        if (opts.directives) {\n            for (var name in opts.directives) {\n                Vue.directive(name, opts.directives[name]);\n            }\n        }\n        (function registerComponents(components) {\n            if (components) {\n                for (var key in components) {\n                    var component = components[key];\n                    if (component && !registerComponents(component.$_vuetify_subcomponents)) {\n                        Vue.component(key, component);\n                    }\n                }\n                return true;\n            }\n            return false;\n        })(opts.components);\n    },\n    version: \'1.3.7\'\n};\nfunction checkVueVersion(Vue, requiredVue) {\n    var vueDep = requiredVue || \'^2.5.10\';\n    var required = vueDep.split(\'.\', 3).map(function (v) {\n        return v.replace(/\\D/g, \'\');\n    }).map(Number);\n    var actual = Vue.version.split(\'.\', 3).map(function (n) {\n        return parseInt(n, 10);\n    });\n    // Simple semver caret range comparison\n    var passes = actual[0] === required[0] && ( // major matches\n    actual[1] > required[1] || // minor is greater\n    actual[1] === required[1] && actual[2] >= required[2] // or minor is eq and patch is >=\n    );\n    if (!passes) {\n        Object(_util_console__WEBPACK_IMPORTED_MODULE_8__["consoleWarn"])("Vuetify requires Vue version " + vueDep);\n    }\n}\n/* harmony default export */ __webpack_exports__["default"] = (Vuetify);\n\n/***/ }),\n\n/***/ "./src/components/Vuetify/mixins/application.ts":\n/*!******************************************************!*\\\n  !*** ./src/components/Vuetify/mixins/application.ts ***!\n  \\******************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ({\n    bar: 0,\n    bottom: 0,\n    footer: 0,\n    insetFooter: 0,\n    left: 0,\n    right: 0,\n    top: 0,\n    components: {\n        bar: {},\n        bottom: {},\n        footer: {},\n        insetFooter: {},\n        left: {},\n        right: {},\n        top: {}\n    },\n    bind: function bind(uid, target, value) {\n        var _a;\n        if (!this.components[target]) return;\n        this.components[target] = (_a = {}, _a[uid] = value, _a);\n        this.update(target);\n    },\n    unbind: function unbind(uid, target) {\n        if (this.components[target][uid] == null) return;\n        delete this.components[target][uid];\n        this.update(target);\n    },\n    update: function update(target) {\n        this[target] = Object.values(this.components[target]).reduce(function (acc, cur) {\n            return acc + cur;\n        }, 0);\n    }\n});\n\n/***/ }),\n\n/***/ "./src/components/Vuetify/mixins/breakpoint.ts":\n/*!*****************************************************!*\\\n  !*** ./src/components/Vuetify/mixins/breakpoint.ts ***!\n  \\*****************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * A modified version of https://gist.github.com/cb109/b074a65f7595cffc21cea59ce8d15f9b\n */\n/**\n * A Vue mixin to get the current width/height and the associated breakpoint.\n *\n *   <div v-if="$breakpoint.smAndDown">...</div>\n *\n */\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    data: function data() {\n        return {\n            clientHeight: getClientHeight(),\n            clientWidth: getClientWidth(),\n            resizeTimeout: undefined\n        };\n    },\n    computed: {\n        breakpoint: function breakpoint() {\n            var xs = this.clientWidth < 600;\n            var sm = this.clientWidth < 960 && !xs;\n            var md = this.clientWidth < 1280 - 16 && !(sm || xs);\n            var lg = this.clientWidth < 1920 - 16 && !(md || sm || xs);\n            var xl = this.clientWidth >= 1920 - 16;\n            var xsOnly = xs;\n            var smOnly = sm;\n            var smAndDown = (xs || sm) && !(md || lg || xl);\n            var smAndUp = !xs && (sm || md || lg || xl);\n            var mdOnly = md;\n            var mdAndDown = (xs || sm || md) && !(lg || xl);\n            var mdAndUp = !(xs || sm) && (md || lg || xl);\n            var lgOnly = lg;\n            var lgAndDown = (xs || sm || md || lg) && !xl;\n            var lgAndUp = !(xs || sm || md) && (lg || xl);\n            var xlOnly = xl;\n            var name;\n            switch (true) {\n                case xs:\n                    name = \'xs\';\n                    break;\n                case sm:\n                    name = \'sm\';\n                    break;\n                case md:\n                    name = \'md\';\n                    break;\n                case lg:\n                    name = \'lg\';\n                    break;\n                default:\n                    name = \'xl\';\n                    break;\n            }\n            return {\n                // Definite breakpoint.\n                xs: xs,\n                sm: sm,\n                md: md,\n                lg: lg,\n                xl: xl,\n                // Useful e.g. to construct CSS class names dynamically.\n                name: name,\n                // Breakpoint ranges.\n                xsOnly: xsOnly,\n                smOnly: smOnly,\n                smAndDown: smAndDown,\n                smAndUp: smAndUp,\n                mdOnly: mdOnly,\n                mdAndDown: mdAndDown,\n                mdAndUp: mdAndUp,\n                lgOnly: lgOnly,\n                lgAndDown: lgAndDown,\n                lgAndUp: lgAndUp,\n                xlOnly: xlOnly,\n                // For custom breakpoint logic.\n                width: this.clientWidth,\n                height: this.clientHeight\n            };\n        }\n    },\n    created: function created() {\n        if (typeof window === \'undefined\') return;\n        window.addEventListener(\'resize\', this.onResize, { passive: true });\n    },\n    beforeDestroy: function beforeDestroy() {\n        if (typeof window === \'undefined\') return;\n        window.removeEventListener(\'resize\', this.onResize);\n    },\n    methods: {\n        onResize: function onResize() {\n            clearTimeout(this.resizeTimeout);\n            // Added debounce to match what\n            // v-resize used to do but was\n            // removed due to a memory leak\n            // https://github.com/vuetifyjs/vuetify/pull/2997\n            this.resizeTimeout = window.setTimeout(this.setDimensions, 200);\n        },\n        setDimensions: function setDimensions() {\n            this.clientHeight = getClientHeight();\n            this.clientWidth = getClientWidth();\n        }\n    }\n}));\n// Cross-browser support as described in:\n// https://stackoverflow.com/questions/1248081\nfunction getClientWidth() {\n    if (typeof document === \'undefined\') return 0; // SSR\n    return Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n}\nfunction getClientHeight() {\n    if (typeof document === \'undefined\') return 0; // SSR\n    return Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n}\n\n/***/ }),\n\n/***/ "./src/components/Vuetify/mixins/icons.js":\n/*!************************************************!*\\\n  !*** ./src/components/Vuetify/mixins/icons.js ***!\n  \\************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return icons; });\n// Maps internal Vuetify icon names to actual Material Design icon names.\nvar ICONS_MATERIAL = {\n    \'complete\': \'check\',\n    \'cancel\': \'cancel\',\n    \'close\': \'close\',\n    \'delete\': \'cancel\',\n    \'clear\': \'clear\',\n    \'success\': \'check_circle\',\n    \'info\': \'info\',\n    \'warning\': \'priority_high\',\n    \'error\': \'warning\',\n    \'prev\': \'chevron_left\',\n    \'next\': \'chevron_right\',\n    \'checkboxOn\': \'check_box\',\n    \'checkboxOff\': \'check_box_outline_blank\',\n    \'checkboxIndeterminate\': \'indeterminate_check_box\',\n    \'delimiter\': \'fiber_manual_record\',\n    \'sort\': \'arrow_upward\',\n    \'expand\': \'keyboard_arrow_down\',\n    \'menu\': \'menu\',\n    \'subgroup\': \'arrow_drop_down\',\n    \'dropdown\': \'arrow_drop_down\',\n    \'radioOn\': \'radio_button_checked\',\n    \'radioOff\': \'radio_button_unchecked\',\n    \'edit\': \'edit\',\n    \'ratingEmpty\': \'star_border\',\n    \'ratingFull\': \'star\',\n    \'ratingHalf\': \'star_half\',\n    \'loading\': \'cached\'\n};\n// Maps internal Vuetify icon names to actual icons from materialdesignicons.com\nvar ICONS_MDI = {\n    \'complete\': \'mdi-check\',\n    \'cancel\': \'mdi-close-circle\',\n    \'close\': \'mdi-close\',\n    \'delete\': \'mdi-close-circle\',\n    \'clear\': \'mdi-close\',\n    \'success\': \'mdi-check-circle\',\n    \'info\': \'mdi-information\',\n    \'warning\': \'mdi-exclamation\',\n    \'error\': \'mdi-alert\',\n    \'prev\': \'mdi-chevron-left\',\n    \'next\': \'mdi-chevron-right\',\n    \'checkboxOn\': \'mdi-checkbox-marked\',\n    \'checkboxOff\': \'mdi-checkbox-blank-outline\',\n    \'checkboxIndeterminate\': \'mdi-minus-box\',\n    \'delimiter\': \'mdi-circle\',\n    \'sort\': \'mdi-arrow-up\',\n    \'expand\': \'mdi-chevron-down\',\n    \'menu\': \'mdi-menu\',\n    \'subgroup\': \'mdi-menu-down\',\n    \'dropdown\': \'mdi-menu-down\',\n    \'radioOn\': \'mdi-radiobox-marked\',\n    \'radioOff\': \'mdi-radiobox-blank\',\n    \'edit\': \'mdi-pencil\',\n    \'ratingEmpty\': \'mdi-star-outline\',\n    \'ratingFull\': \'mdi-star\',\n    \'ratingHalf\': \'mdi-star-half\'\n};\n// Maps internal Vuetify icon names to actual Font-Awesome 4 icon names.\nvar ICONS_FONTAWESOME4 = {\n    \'complete\': \'fa fa-check\',\n    \'cancel\': \'fa fa-times-circle\',\n    \'close\': \'fa fa-times\',\n    \'delete\': \'fa fa-times-circle\',\n    \'clear\': \'fa fa-times-circle\',\n    \'success\': \'fa fa-check-circle\',\n    \'info\': \'fa fa-info-circle\',\n    \'warning\': \'fa fa-exclamation\',\n    \'error\': \'fa fa-exclamation-triangle\',\n    \'prev\': \'fa fa-chevron-left\',\n    \'next\': \'fa fa-chevron-right\',\n    \'checkboxOn\': \'fa fa-check-square\',\n    \'checkboxOff\': \'fa fa-square-o\',\n    \'checkboxIndeterminate\': \'fa fa-minus-square\',\n    \'delimiter\': \'fa fa-circle\',\n    \'sort\': \'fa fa-sort-up\',\n    \'expand\': \'fa fa-chevron-down\',\n    \'menu\': \'fa fa-bars\',\n    \'subgroup\': \'fa fa-caret-down\',\n    \'dropdown\': \'fa fa-caret-down\',\n    \'radioOn\': \'fa fa-dot-circle\',\n    \'radioOff\': \'fa fa-circle-o\',\n    \'edit\': \'fa fa-pencil\',\n    \'ratingEmpty\': \'fa fa-star-o\',\n    \'ratingFull\': \'fa fa-star\',\n    \'ratingHalf\': \'fa fa-star-half-o\'\n};\n// Maps internal Vuetify icon names to actual Font-Awesome 5+ icon names.\nvar ICONS_FONTAWESOME = {\n    \'complete\': \'fas fa-check\',\n    \'cancel\': \'fas fa-times-circle\',\n    \'close\': \'fas fa-times\',\n    \'delete\': \'fas fa-times-circle\',\n    \'clear\': \'fas fa-times-circle\',\n    \'success\': \'fas fa-check-circle\',\n    \'info\': \'fas fa-info-circle\',\n    \'warning\': \'fas fa-exclamation\',\n    \'error\': \'fas fa-exclamation-triangle\',\n    \'prev\': \'fas fa-chevron-left\',\n    \'next\': \'fas fa-chevron-right\',\n    \'checkboxOn\': \'fas fa-check-square\',\n    \'checkboxOff\': \'far fa-square\',\n    \'checkboxIndeterminate\': \'fas fa-minus-square\',\n    \'delimiter\': \'fas fa-circle\',\n    \'sort\': \'fas fa-sort-up\',\n    \'expand\': \'fas fa-chevron-down\',\n    \'menu\': \'fas fa-bars\',\n    \'subgroup\': \'fas fa-caret-down\',\n    \'dropdown\': \'fas fa-caret-down\',\n    \'radioOn\': \'far fa-dot-circle\',\n    \'radioOff\': \'far fa-circle\',\n    \'edit\': \'fas fa-edit\',\n    \'ratingEmpty\': \'far fa-star\',\n    \'ratingFull\': \'fas fa-star\',\n    \'ratingHalf\': \'fas fa-star-half\'\n};\nvar iconSets = {\n    md: ICONS_MATERIAL,\n    mdi: ICONS_MDI,\n    fa: ICONS_FONTAWESOME,\n    fa4: ICONS_FONTAWESOME4\n};\nfunction icons(iconfont, icons) {\n    if (iconfont === void 0) {\n        iconfont = \'md\';\n    }\n    if (icons === void 0) {\n        icons = {};\n    }\n    return Object.assign({}, iconSets[iconfont] || iconSets.md, icons);\n}\n\n/***/ }),\n\n/***/ "./src/components/Vuetify/mixins/lang.ts":\n/*!***********************************************!*\\\n  !*** ./src/components/Vuetify/mixins/lang.ts ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lang; });\n/* harmony import */ var _locale_en__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../locale/en */ "./src/locale/en.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/console */ "./src/util/console.ts");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) {\n        ar = ar.concat(__read(arguments[i]));\n    }return ar;\n};\n\n\n\nvar LANG_PREFIX = \'$vuetify.\';\nvar fallback = Symbol(\'Lang fallback\');\nfunction getTranslation(locale, key, usingFallback) {\n    if (usingFallback === void 0) {\n        usingFallback = false;\n    }\n    var shortKey = key.replace(LANG_PREFIX, \'\');\n    var translation = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_1__["getObjectValueByPath"])(locale, shortKey, fallback);\n    if (translation === fallback) {\n        if (usingFallback) {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_2__["consoleError"])("Translation key \\"" + shortKey + "\\" not found in fallback");\n            translation = key;\n        } else {\n            Object(_util_console__WEBPACK_IMPORTED_MODULE_2__["consoleWarn"])("Translation key \\"" + shortKey + "\\" not found, falling back to default");\n            translation = getTranslation(_locale_en__WEBPACK_IMPORTED_MODULE_0__["default"], key, true);\n        }\n    }\n    return translation;\n}\nfunction lang(config) {\n    if (config === void 0) {\n        config = {};\n    }\n    return {\n        locales: Object.assign({ en: _locale_en__WEBPACK_IMPORTED_MODULE_0__["default"] }, config.locales),\n        current: config.current || \'en\',\n        t: function t(key) {\n            var params = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                params[_i - 1] = arguments[_i];\n            }\n            if (!key.startsWith(LANG_PREFIX)) return key;\n            if (config.t) return config.t.apply(config, __spread([key], params));\n            var translation = getTranslation(this.locales[this.current], key);\n            return translation.replace(/\\{(\\d+)\\}/g, function (match, index) {\n                return String(params[+index]);\n            });\n        }\n    };\n}\n\n/***/ }),\n\n/***/ "./src/components/Vuetify/mixins/options.js":\n/*!**************************************************!*\\\n  !*** ./src/components/Vuetify/mixins/options.js ***!\n  \\**************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return options; });\nvar OPTIONS_DEFAULTS = {\n    minifyTheme: null,\n    themeCache: null,\n    customProperties: false,\n    cspNonce: null\n};\nfunction options(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return Object.assign({}, OPTIONS_DEFAULTS, options);\n}\n\n/***/ }),\n\n/***/ "./src/components/Vuetify/mixins/theme.ts":\n/*!************************************************!*\\\n  !*** ./src/components/Vuetify/mixins/theme.ts ***!\n  \\************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return theme; });\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n/* eslint-disable no-multi-spaces */\nvar THEME_DEFAULTS = {\n    primary: \'#1976D2\',\n    secondary: \'#424242\',\n    accent: \'#82B1FF\',\n    error: \'#FF5252\',\n    info: \'#2196F3\',\n    success: \'#4CAF50\',\n    warning: \'#FFC107\' // amber.base\n};\nfunction theme(theme) {\n    if (theme === void 0) {\n        theme = {};\n    }\n    if (theme === false) return false;\n    return __assign({}, THEME_DEFAULTS, theme);\n}\n\n/***/ }),\n\n/***/ "./src/components/Vuetify/util/goTo.js":\n/*!*********************************************!*\\\n  !*** ./src/components/Vuetify/util/goTo.js ***!\n  \\*********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return goTo; });\n/* harmony import */ var _util_easing_patterns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/easing-patterns */ "./src/util/easing-patterns.js");\n\nvar defaults = {\n    duration: 500,\n    offset: 0,\n    easing: \'easeInOutCubic\'\n};\nfunction getDocumentHeight() {\n    return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);\n}\nfunction getWindowHeight() {\n    return window.innerHeight || (document.documentElement || document.body).clientHeight;\n}\nfunction isVueComponent(obj) {\n    return obj != null && obj._isVue;\n}\nfunction getTargetLocation(target, settings) {\n    var location;\n    if (isVueComponent(target)) {\n        target = target.$el;\n    }\n    if (target instanceof Element) {\n        location = target.getBoundingClientRect().top + window.pageYOffset;\n    } else if (typeof target === \'string\') {\n        var targetEl = document.querySelector(target);\n        if (!targetEl) throw new TypeError("Target element \\"" + target + "\\" not found.");\n        location = targetEl.getBoundingClientRect().top + window.pageYOffset;\n    } else if (typeof target === \'number\') {\n        location = target;\n    } else {\n        var type = target == null ? target : target.constructor.name;\n        throw new TypeError("Target must be a Selector/Number/DOMElement/VueComponent, received " + type + " instead.");\n    }\n    return Math.round(Math.min(Math.max(location + settings.offset, 0), getDocumentHeight() - getWindowHeight()));\n}\nfunction goTo(target, options) {\n    return new Promise(function (resolve, reject) {\n        if (typeof window === \'undefined\') return reject(\'Window is undefined\');\n        var settings = Object.assign({}, defaults, options);\n        var startTime = performance.now();\n        var startLocation = window.pageYOffset;\n        var targetLocation = getTargetLocation(target, settings);\n        var distanceToScroll = targetLocation - startLocation;\n        var easingFunction = typeof settings.easing === \'function\' ? settings.easing : _util_easing_patterns__WEBPACK_IMPORTED_MODULE_0__[settings.easing];\n        if (!easingFunction) throw new TypeError("Easing function \'" + settings.easing + "\' not found.");\n        function step(currentTime) {\n            var progressPercentage = Math.min(1, (currentTime - startTime) / settings.duration);\n            var targetPosition = Math.floor(startLocation + distanceToScroll * easingFunction(progressPercentage));\n            window.scrollTo(0, targetPosition);\n            if (Math.round(window.pageYOffset) === targetLocation || progressPercentage === 1) {\n                return resolve(target);\n            }\n            window.requestAnimationFrame(step);\n        }\n        window.requestAnimationFrame(step);\n    });\n}\n\n/***/ }),\n\n/***/ "./src/components/index.ts":\n/*!*********************************!*\\\n  !*** ./src/components/index.ts ***!\n  \\*********************************/\n/*! exports provided: VApp, VAlert, VAutocomplete, VAvatar, VBadge, VBottomNav, VBottomSheet, VBreadcrumbs, VBreadcrumbsItem, VBreadcrumbsDivider, VBtn, VBtnToggle, VCard, VCardMedia, VCardTitle, VCardActions, VCardText, VCarousel, VCarouselItem, VCheckbox, VChip, VCombobox, VCounter, VDataIterator, VDataTable, VEditDialog, VTableOverflow, VDatePicker, VDatePickerTitle, VDatePickerHeader, VDatePickerDateTable, VDatePickerMonthTable, VDatePickerYears, VDialog, VDivider, VExpansionPanel, VExpansionPanelContent, VFooter, VForm, VContainer, VContent, VFlex, VLayout, VSpacer, VHover, VIcon, VImg, VInput, VItem, VItemGroup, VJumbotron, VLabel, VList, VListGroup, VListTile, VListTileAction, VListTileAvatar, VListTileActionText, VListTileContent, VListTileTitle, VListTileSubTitle, VMenu, VMessages, VNavigationDrawer, VOverflowBtn, VPagination, VParallax, VPicker, VProgressCircular, VProgressLinear, VRadioGroup, VRadio, VRangeSlider, VRating, VResponsive, VSelect, VSlider, VSnackbar, VSpeedDial, VStepper, VStepperContent, VStepperStep, VStepperHeader, VStepperItems, VSubheader, VSwitch, VSystemBar, VTabs, VTab, VTabItem, VTabsItems, VTabsSlider, VTextarea, VTextField, VTimeline, VTimelineItem, VTimePicker, VTimePickerClock, VTimePickerTitle, VToolbar, VToolbarSideIcon, VToolbarTitle, VToolbarItems, VTooltip, VTreeview, VTreeviewNode, VWindow, VWindowItem, VBottomSheetTransition, VCarouselTransition, VCarouselReverseTransition, VTabTransition, VTabReverseTransition, VMenuTransition, VFabTransition, VDialogTransition, VDialogBottomTransition, VFadeTransition, VScaleTransition, VScrollXTransition, VScrollXReverseTransition, VScrollYTransition, VScrollYReverseTransition, VSlideXTransition, VSlideXReverseTransition, VSlideYTransition, VSlideYReverseTransition, VExpandTransition, VRowExpandTransition */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _VApp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VApp */ "./src/components/VApp/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VApp", function() { return _VApp__WEBPACK_IMPORTED_MODULE_0__["VApp"]; });\n\n/* harmony import */ var _VAlert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VAlert */ "./src/components/VAlert/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VAlert", function() { return _VAlert__WEBPACK_IMPORTED_MODULE_1__["VAlert"]; });\n\n/* harmony import */ var _VAutocomplete__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VAutocomplete */ "./src/components/VAutocomplete/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VAutocomplete", function() { return _VAutocomplete__WEBPACK_IMPORTED_MODULE_2__["VAutocomplete"]; });\n\n/* harmony import */ var _VAvatar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VAvatar */ "./src/components/VAvatar/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VAvatar", function() { return _VAvatar__WEBPACK_IMPORTED_MODULE_3__["VAvatar"]; });\n\n/* harmony import */ var _VBadge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./VBadge */ "./src/components/VBadge/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBadge", function() { return _VBadge__WEBPACK_IMPORTED_MODULE_4__["VBadge"]; });\n\n/* harmony import */ var _VBottomNav__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./VBottomNav */ "./src/components/VBottomNav/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBottomNav", function() { return _VBottomNav__WEBPACK_IMPORTED_MODULE_5__["VBottomNav"]; });\n\n/* harmony import */ var _VBottomSheet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./VBottomSheet */ "./src/components/VBottomSheet/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBottomSheet", function() { return _VBottomSheet__WEBPACK_IMPORTED_MODULE_6__["VBottomSheet"]; });\n\n/* harmony import */ var _VBreadcrumbs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./VBreadcrumbs */ "./src/components/VBreadcrumbs/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBreadcrumbs", function() { return _VBreadcrumbs__WEBPACK_IMPORTED_MODULE_7__["VBreadcrumbs"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBreadcrumbsItem", function() { return _VBreadcrumbs__WEBPACK_IMPORTED_MODULE_7__["VBreadcrumbsItem"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBreadcrumbsDivider", function() { return _VBreadcrumbs__WEBPACK_IMPORTED_MODULE_7__["VBreadcrumbsDivider"]; });\n\n/* harmony import */ var _VBtn__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./VBtn */ "./src/components/VBtn/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBtn", function() { return _VBtn__WEBPACK_IMPORTED_MODULE_8__["VBtn"]; });\n\n/* harmony import */ var _VBtnToggle__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./VBtnToggle */ "./src/components/VBtnToggle/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBtnToggle", function() { return _VBtnToggle__WEBPACK_IMPORTED_MODULE_9__["VBtnToggle"]; });\n\n/* harmony import */ var _VCard__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./VCard */ "./src/components/VCard/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCard", function() { return _VCard__WEBPACK_IMPORTED_MODULE_10__["VCard"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCardMedia", function() { return _VCard__WEBPACK_IMPORTED_MODULE_10__["VCardMedia"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCardTitle", function() { return _VCard__WEBPACK_IMPORTED_MODULE_10__["VCardTitle"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCardActions", function() { return _VCard__WEBPACK_IMPORTED_MODULE_10__["VCardActions"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCardText", function() { return _VCard__WEBPACK_IMPORTED_MODULE_10__["VCardText"]; });\n\n/* harmony import */ var _VCarousel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./VCarousel */ "./src/components/VCarousel/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCarousel", function() { return _VCarousel__WEBPACK_IMPORTED_MODULE_11__["VCarousel"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCarouselItem", function() { return _VCarousel__WEBPACK_IMPORTED_MODULE_11__["VCarouselItem"]; });\n\n/* harmony import */ var _VCheckbox__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./VCheckbox */ "./src/components/VCheckbox/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCheckbox", function() { return _VCheckbox__WEBPACK_IMPORTED_MODULE_12__["VCheckbox"]; });\n\n/* harmony import */ var _VChip__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./VChip */ "./src/components/VChip/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VChip", function() { return _VChip__WEBPACK_IMPORTED_MODULE_13__["VChip"]; });\n\n/* harmony import */ var _VCombobox__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./VCombobox */ "./src/components/VCombobox/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCombobox", function() { return _VCombobox__WEBPACK_IMPORTED_MODULE_14__["VCombobox"]; });\n\n/* harmony import */ var _VCounter__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./VCounter */ "./src/components/VCounter/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCounter", function() { return _VCounter__WEBPACK_IMPORTED_MODULE_15__["VCounter"]; });\n\n/* harmony import */ var _VDataIterator__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./VDataIterator */ "./src/components/VDataIterator/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDataIterator", function() { return _VDataIterator__WEBPACK_IMPORTED_MODULE_16__["VDataIterator"]; });\n\n/* harmony import */ var _VDataTable__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./VDataTable */ "./src/components/VDataTable/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDataTable", function() { return _VDataTable__WEBPACK_IMPORTED_MODULE_17__["VDataTable"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VEditDialog", function() { return _VDataTable__WEBPACK_IMPORTED_MODULE_17__["VEditDialog"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTableOverflow", function() { return _VDataTable__WEBPACK_IMPORTED_MODULE_17__["VTableOverflow"]; });\n\n/* harmony import */ var _VDatePicker__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./VDatePicker */ "./src/components/VDatePicker/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePicker", function() { return _VDatePicker__WEBPACK_IMPORTED_MODULE_18__["VDatePicker"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePickerTitle", function() { return _VDatePicker__WEBPACK_IMPORTED_MODULE_18__["VDatePickerTitle"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePickerHeader", function() { return _VDatePicker__WEBPACK_IMPORTED_MODULE_18__["VDatePickerHeader"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePickerDateTable", function() { return _VDatePicker__WEBPACK_IMPORTED_MODULE_18__["VDatePickerDateTable"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePickerMonthTable", function() { return _VDatePicker__WEBPACK_IMPORTED_MODULE_18__["VDatePickerMonthTable"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDatePickerYears", function() { return _VDatePicker__WEBPACK_IMPORTED_MODULE_18__["VDatePickerYears"]; });\n\n/* harmony import */ var _VDialog__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./VDialog */ "./src/components/VDialog/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDialog", function() { return _VDialog__WEBPACK_IMPORTED_MODULE_19__["VDialog"]; });\n\n/* harmony import */ var _VDivider__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./VDivider */ "./src/components/VDivider/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDivider", function() { return _VDivider__WEBPACK_IMPORTED_MODULE_20__["VDivider"]; });\n\n/* harmony import */ var _VExpansionPanel__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./VExpansionPanel */ "./src/components/VExpansionPanel/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VExpansionPanel", function() { return _VExpansionPanel__WEBPACK_IMPORTED_MODULE_21__["VExpansionPanel"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VExpansionPanelContent", function() { return _VExpansionPanel__WEBPACK_IMPORTED_MODULE_21__["VExpansionPanelContent"]; });\n\n/* harmony import */ var _VFooter__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./VFooter */ "./src/components/VFooter/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VFooter", function() { return _VFooter__WEBPACK_IMPORTED_MODULE_22__["VFooter"]; });\n\n/* harmony import */ var _VForm__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./VForm */ "./src/components/VForm/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VForm", function() { return _VForm__WEBPACK_IMPORTED_MODULE_23__["VForm"]; });\n\n/* harmony import */ var _VGrid__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./VGrid */ "./src/components/VGrid/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VContainer", function() { return _VGrid__WEBPACK_IMPORTED_MODULE_24__["VContainer"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VContent", function() { return _VGrid__WEBPACK_IMPORTED_MODULE_24__["VContent"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VFlex", function() { return _VGrid__WEBPACK_IMPORTED_MODULE_24__["VFlex"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VLayout", function() { return _VGrid__WEBPACK_IMPORTED_MODULE_24__["VLayout"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSpacer", function() { return _VGrid__WEBPACK_IMPORTED_MODULE_24__["VSpacer"]; });\n\n/* harmony import */ var _VHover__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./VHover */ "./src/components/VHover/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VHover", function() { return _VHover__WEBPACK_IMPORTED_MODULE_25__["VHover"]; });\n\n/* harmony import */ var _VIcon__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./VIcon */ "./src/components/VIcon/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VIcon", function() { return _VIcon__WEBPACK_IMPORTED_MODULE_26__["VIcon"]; });\n\n/* harmony import */ var _VImg__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./VImg */ "./src/components/VImg/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VImg", function() { return _VImg__WEBPACK_IMPORTED_MODULE_27__["VImg"]; });\n\n/* harmony import */ var _VInput__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./VInput */ "./src/components/VInput/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VInput", function() { return _VInput__WEBPACK_IMPORTED_MODULE_28__["VInput"]; });\n\n/* harmony import */ var _VItemGroup__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./VItemGroup */ "./src/components/VItemGroup/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VItem", function() { return _VItemGroup__WEBPACK_IMPORTED_MODULE_29__["VItem"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VItemGroup", function() { return _VItemGroup__WEBPACK_IMPORTED_MODULE_29__["VItemGroup"]; });\n\n/* harmony import */ var _VJumbotron__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./VJumbotron */ "./src/components/VJumbotron/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VJumbotron", function() { return _VJumbotron__WEBPACK_IMPORTED_MODULE_30__["VJumbotron"]; });\n\n/* harmony import */ var _VLabel__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./VLabel */ "./src/components/VLabel/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VLabel", function() { return _VLabel__WEBPACK_IMPORTED_MODULE_31__["VLabel"]; });\n\n/* harmony import */ var _VList__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./VList */ "./src/components/VList/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VList", function() { return _VList__WEBPACK_IMPORTED_MODULE_32__["VList"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListGroup", function() { return _VList__WEBPACK_IMPORTED_MODULE_32__["VListGroup"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListTile", function() { return _VList__WEBPACK_IMPORTED_MODULE_32__["VListTile"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListTileAction", function() { return _VList__WEBPACK_IMPORTED_MODULE_32__["VListTileAction"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListTileAvatar", function() { return _VList__WEBPACK_IMPORTED_MODULE_32__["VListTileAvatar"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListTileActionText", function() { return _VList__WEBPACK_IMPORTED_MODULE_32__["VListTileActionText"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListTileContent", function() { return _VList__WEBPACK_IMPORTED_MODULE_32__["VListTileContent"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListTileTitle", function() { return _VList__WEBPACK_IMPORTED_MODULE_32__["VListTileTitle"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VListTileSubTitle", function() { return _VList__WEBPACK_IMPORTED_MODULE_32__["VListTileSubTitle"]; });\n\n/* harmony import */ var _VMenu__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./VMenu */ "./src/components/VMenu/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VMenu", function() { return _VMenu__WEBPACK_IMPORTED_MODULE_33__["VMenu"]; });\n\n/* harmony import */ var _VMessages__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./VMessages */ "./src/components/VMessages/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VMessages", function() { return _VMessages__WEBPACK_IMPORTED_MODULE_34__["VMessages"]; });\n\n/* harmony import */ var _VNavigationDrawer__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./VNavigationDrawer */ "./src/components/VNavigationDrawer/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VNavigationDrawer", function() { return _VNavigationDrawer__WEBPACK_IMPORTED_MODULE_35__["VNavigationDrawer"]; });\n\n/* harmony import */ var _VOverflowBtn__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./VOverflowBtn */ "./src/components/VOverflowBtn/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VOverflowBtn", function() { return _VOverflowBtn__WEBPACK_IMPORTED_MODULE_36__["VOverflowBtn"]; });\n\n/* harmony import */ var _VPagination__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./VPagination */ "./src/components/VPagination/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VPagination", function() { return _VPagination__WEBPACK_IMPORTED_MODULE_37__["VPagination"]; });\n\n/* harmony import */ var _VParallax__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./VParallax */ "./src/components/VParallax/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VParallax", function() { return _VParallax__WEBPACK_IMPORTED_MODULE_38__["VParallax"]; });\n\n/* harmony import */ var _VPicker__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./VPicker */ "./src/components/VPicker/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VPicker", function() { return _VPicker__WEBPACK_IMPORTED_MODULE_39__["VPicker"]; });\n\n/* harmony import */ var _VProgressCircular__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./VProgressCircular */ "./src/components/VProgressCircular/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VProgressCircular", function() { return _VProgressCircular__WEBPACK_IMPORTED_MODULE_40__["VProgressCircular"]; });\n\n/* harmony import */ var _VProgressLinear__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./VProgressLinear */ "./src/components/VProgressLinear/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VProgressLinear", function() { return _VProgressLinear__WEBPACK_IMPORTED_MODULE_41__["VProgressLinear"]; });\n\n/* harmony import */ var _VRadioGroup__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./VRadioGroup */ "./src/components/VRadioGroup/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VRadioGroup", function() { return _VRadioGroup__WEBPACK_IMPORTED_MODULE_42__["VRadioGroup"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VRadio", function() { return _VRadioGroup__WEBPACK_IMPORTED_MODULE_42__["VRadio"]; });\n\n/* harmony import */ var _VRangeSlider__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./VRangeSlider */ "./src/components/VRangeSlider/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VRangeSlider", function() { return _VRangeSlider__WEBPACK_IMPORTED_MODULE_43__["VRangeSlider"]; });\n\n/* harmony import */ var _VRating__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./VRating */ "./src/components/VRating/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VRating", function() { return _VRating__WEBPACK_IMPORTED_MODULE_44__["VRating"]; });\n\n/* harmony import */ var _VResponsive__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./VResponsive */ "./src/components/VResponsive/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VResponsive", function() { return _VResponsive__WEBPACK_IMPORTED_MODULE_45__["VResponsive"]; });\n\n/* harmony import */ var _VSelect__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./VSelect */ "./src/components/VSelect/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSelect", function() { return _VSelect__WEBPACK_IMPORTED_MODULE_46__["VSelect"]; });\n\n/* harmony import */ var _VSlider__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./VSlider */ "./src/components/VSlider/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSlider", function() { return _VSlider__WEBPACK_IMPORTED_MODULE_47__["VSlider"]; });\n\n/* harmony import */ var _VSnackbar__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./VSnackbar */ "./src/components/VSnackbar/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSnackbar", function() { return _VSnackbar__WEBPACK_IMPORTED_MODULE_48__["VSnackbar"]; });\n\n/* harmony import */ var _VSpeedDial__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./VSpeedDial */ "./src/components/VSpeedDial/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSpeedDial", function() { return _VSpeedDial__WEBPACK_IMPORTED_MODULE_49__["VSpeedDial"]; });\n\n/* harmony import */ var _VStepper__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./VStepper */ "./src/components/VStepper/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VStepper", function() { return _VStepper__WEBPACK_IMPORTED_MODULE_50__["VStepper"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VStepperContent", function() { return _VStepper__WEBPACK_IMPORTED_MODULE_50__["VStepperContent"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VStepperStep", function() { return _VStepper__WEBPACK_IMPORTED_MODULE_50__["VStepperStep"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VStepperHeader", function() { return _VStepper__WEBPACK_IMPORTED_MODULE_50__["VStepperHeader"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VStepperItems", function() { return _VStepper__WEBPACK_IMPORTED_MODULE_50__["VStepperItems"]; });\n\n/* harmony import */ var _VSubheader__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./VSubheader */ "./src/components/VSubheader/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSubheader", function() { return _VSubheader__WEBPACK_IMPORTED_MODULE_51__["VSubheader"]; });\n\n/* harmony import */ var _VSwitch__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./VSwitch */ "./src/components/VSwitch/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSwitch", function() { return _VSwitch__WEBPACK_IMPORTED_MODULE_52__["VSwitch"]; });\n\n/* harmony import */ var _VSystemBar__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./VSystemBar */ "./src/components/VSystemBar/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSystemBar", function() { return _VSystemBar__WEBPACK_IMPORTED_MODULE_53__["VSystemBar"]; });\n\n/* harmony import */ var _VTabs__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./VTabs */ "./src/components/VTabs/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTabs", function() { return _VTabs__WEBPACK_IMPORTED_MODULE_54__["VTabs"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTab", function() { return _VTabs__WEBPACK_IMPORTED_MODULE_54__["VTab"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTabItem", function() { return _VTabs__WEBPACK_IMPORTED_MODULE_54__["VTabItem"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTabsItems", function() { return _VTabs__WEBPACK_IMPORTED_MODULE_54__["VTabsItems"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTabsSlider", function() { return _VTabs__WEBPACK_IMPORTED_MODULE_54__["VTabsSlider"]; });\n\n/* harmony import */ var _VTextarea__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./VTextarea */ "./src/components/VTextarea/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTextarea", function() { return _VTextarea__WEBPACK_IMPORTED_MODULE_55__["VTextarea"]; });\n\n/* harmony import */ var _VTextField__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./VTextField */ "./src/components/VTextField/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTextField", function() { return _VTextField__WEBPACK_IMPORTED_MODULE_56__["VTextField"]; });\n\n/* harmony import */ var _VTimeline__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./VTimeline */ "./src/components/VTimeline/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTimeline", function() { return _VTimeline__WEBPACK_IMPORTED_MODULE_57__["VTimeline"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTimelineItem", function() { return _VTimeline__WEBPACK_IMPORTED_MODULE_57__["VTimelineItem"]; });\n\n/* harmony import */ var _VTimePicker__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./VTimePicker */ "./src/components/VTimePicker/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTimePicker", function() { return _VTimePicker__WEBPACK_IMPORTED_MODULE_58__["VTimePicker"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTimePickerClock", function() { return _VTimePicker__WEBPACK_IMPORTED_MODULE_58__["VTimePickerClock"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTimePickerTitle", function() { return _VTimePicker__WEBPACK_IMPORTED_MODULE_58__["VTimePickerTitle"]; });\n\n/* harmony import */ var _VToolbar__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./VToolbar */ "./src/components/VToolbar/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VToolbar", function() { return _VToolbar__WEBPACK_IMPORTED_MODULE_59__["VToolbar"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VToolbarSideIcon", function() { return _VToolbar__WEBPACK_IMPORTED_MODULE_59__["VToolbarSideIcon"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VToolbarTitle", function() { return _VToolbar__WEBPACK_IMPORTED_MODULE_59__["VToolbarTitle"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VToolbarItems", function() { return _VToolbar__WEBPACK_IMPORTED_MODULE_59__["VToolbarItems"]; });\n\n/* harmony import */ var _VTooltip__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./VTooltip */ "./src/components/VTooltip/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTooltip", function() { return _VTooltip__WEBPACK_IMPORTED_MODULE_60__["VTooltip"]; });\n\n/* harmony import */ var _VTreeview__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./VTreeview */ "./src/components/VTreeview/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTreeview", function() { return _VTreeview__WEBPACK_IMPORTED_MODULE_61__["VTreeview"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTreeviewNode", function() { return _VTreeview__WEBPACK_IMPORTED_MODULE_61__["VTreeviewNode"]; });\n\n/* harmony import */ var _VWindow__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./VWindow */ "./src/components/VWindow/index.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VWindow", function() { return _VWindow__WEBPACK_IMPORTED_MODULE_62__["VWindow"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VWindowItem", function() { return _VWindow__WEBPACK_IMPORTED_MODULE_62__["VWindowItem"]; });\n\n/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./transitions */ "./src/components/transitions/index.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VBottomSheetTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VBottomSheetTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCarouselTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VCarouselTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VCarouselReverseTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VCarouselReverseTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTabTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VTabTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VTabReverseTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VTabReverseTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VMenuTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VMenuTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VFabTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VFabTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDialogTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VDialogTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VDialogBottomTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VDialogBottomTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VFadeTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VFadeTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VScaleTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VScaleTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VScrollXTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VScrollXTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VScrollXReverseTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VScrollXReverseTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VScrollYTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VScrollYTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VScrollYReverseTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VScrollYReverseTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSlideXTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VSlideXTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSlideXReverseTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VSlideXReverseTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSlideYTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VSlideYTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VSlideYReverseTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VSlideYReverseTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VExpandTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VExpandTransition"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VRowExpandTransition", function() { return _transitions__WEBPACK_IMPORTED_MODULE_63__["VRowExpandTransition"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n\n/***/ "./src/components/transitions/expand-transition.js":\n/*!*********************************************************!*\\\n  !*** ./src/components/transitions/expand-transition.js ***!\n  \\*********************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n\n/* harmony default export */ __webpack_exports__["default"] = (function (expandedParentClass) {\n    if (expandedParentClass === void 0) {\n        expandedParentClass = \'\';\n    }\n    return {\n        enter: function enter(el, done) {\n            el._parent = el.parentNode;\n            el._height = el._height != null ? el._height : el.style.height;\n            Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["addOnceEventListener"])(el, \'transitionend\', done);\n            // Get height that is to be scrolled\n            el.style.overflow = \'hidden\';\n            el.style.height = 0;\n            el.style.display = \'block\';\n            expandedParentClass && el._parent.classList.add(expandedParentClass);\n            setTimeout(function () {\n                el.style.height = el._height || (!el.scrollHeight ? \'auto\' : el.scrollHeight + "px");\n            }, 100);\n        },\n        afterEnter: function afterEnter(el) {\n            el.style.overflow = null;\n            // If user supplied height\n            // leave it\n            if (el._height) return;\n            el.style.height = null;\n        },\n        leave: function leave(el, done) {\n            // Remove initial transition\n            Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["addOnceEventListener"])(el, \'transitionend\', done);\n            // Set height before we transition to 0\n            el.style.overflow = \'hidden\';\n            // If no user supplied height\n            // pass in the scrollHeight\n            if (!el._height) {\n                el.style.height = el.scrollHeight + "px";\n            }\n            setTimeout(function () {\n                return el.style.height = 0;\n            }, 100);\n        },\n        afterLeave: function afterLeave(el) {\n            expandedParentClass && el._parent && el._parent.classList.remove(expandedParentClass);\n            // If user supplied height\n            // leave it\n            if (el._height) return;\n            el.style.height = null;\n        }\n    };\n});\n\n/***/ }),\n\n/***/ "./src/components/transitions/index.js":\n/*!*********************************************!*\\\n  !*** ./src/components/transitions/index.js ***!\n  \\*********************************************/\n/*! exports provided: VBottomSheetTransition, VCarouselTransition, VCarouselReverseTransition, VTabTransition, VTabReverseTransition, VMenuTransition, VFabTransition, VDialogTransition, VDialogBottomTransition, VFadeTransition, VScaleTransition, VScrollXTransition, VScrollXReverseTransition, VScrollYTransition, VScrollYReverseTransition, VSlideXTransition, VSlideXReverseTransition, VSlideYTransition, VSlideYReverseTransition, VExpandTransition, VRowExpandTransition, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VBottomSheetTransition", function() { return VBottomSheetTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VCarouselTransition", function() { return VCarouselTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VCarouselReverseTransition", function() { return VCarouselReverseTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VTabTransition", function() { return VTabTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VTabReverseTransition", function() { return VTabReverseTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VMenuTransition", function() { return VMenuTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VFabTransition", function() { return VFabTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VDialogTransition", function() { return VDialogTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VDialogBottomTransition", function() { return VDialogBottomTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VFadeTransition", function() { return VFadeTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VScaleTransition", function() { return VScaleTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VScrollXTransition", function() { return VScrollXTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VScrollXReverseTransition", function() { return VScrollXReverseTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VScrollYTransition", function() { return VScrollYTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VScrollYReverseTransition", function() { return VScrollYReverseTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSlideXTransition", function() { return VSlideXTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSlideXReverseTransition", function() { return VSlideXReverseTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSlideYTransition", function() { return VSlideYTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSlideYReverseTransition", function() { return VSlideYReverseTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VExpandTransition", function() { return VExpandTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VRowExpandTransition", function() { return VRowExpandTransition; });\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _expand_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./expand-transition */ "./src/components/transitions/expand-transition.js");\n\n\n// Component specific transitions\nvar VBottomSheetTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'bottom-sheet-transition\');\nvar VCarouselTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'carousel-transition\');\nvar VCarouselReverseTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'carousel-reverse-transition\');\nvar VTabTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'tab-transition\');\nvar VTabReverseTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'tab-reverse-transition\');\nvar VMenuTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'menu-transition\');\nvar VFabTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'fab-transition\', \'center center\', \'out-in\');\n// Generic transitions\nvar VDialogTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'dialog-transition\');\nvar VDialogBottomTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'dialog-bottom-transition\');\nvar VFadeTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'fade-transition\');\nvar VScaleTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'scale-transition\');\nvar VScrollXTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'scroll-x-transition\');\nvar VScrollXReverseTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'scroll-x-reverse-transition\');\nvar VScrollYTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'scroll-y-transition\');\nvar VScrollYReverseTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'scroll-y-reverse-transition\');\nvar VSlideXTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'slide-x-transition\');\nvar VSlideXReverseTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'slide-x-reverse-transition\');\nvar VSlideYTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'slide-y-transition\');\nvar VSlideYReverseTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createSimpleTransition"])(\'slide-y-reverse-transition\');\n// JavaScript transitions\nvar VExpandTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createJavaScriptTransition"])(\'expand-transition\', Object(_expand_transition__WEBPACK_IMPORTED_MODULE_1__["default"])());\nvar VRowExpandTransition = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["createJavaScriptTransition"])(\'row-expand-transition\', Object(_expand_transition__WEBPACK_IMPORTED_MODULE_1__["default"])(\'datatable__expand-col--expanded\'));\n/* harmony default export */ __webpack_exports__["default"] = ({\n    $_vuetify_subcomponents: {\n        VBottomSheetTransition: VBottomSheetTransition,\n        VCarouselTransition: VCarouselTransition,\n        VCarouselReverseTransition: VCarouselReverseTransition,\n        VDialogTransition: VDialogTransition,\n        VDialogBottomTransition: VDialogBottomTransition,\n        VFabTransition: VFabTransition,\n        VFadeTransition: VFadeTransition,\n        VMenuTransition: VMenuTransition,\n        VScaleTransition: VScaleTransition,\n        VScrollXTransition: VScrollXTransition,\n        VScrollXReverseTransition: VScrollXReverseTransition,\n        VScrollYTransition: VScrollYTransition,\n        VScrollYReverseTransition: VScrollYReverseTransition,\n        VSlideXTransition: VSlideXTransition,\n        VSlideXReverseTransition: VSlideXReverseTransition,\n        VSlideYTransition: VSlideYTransition,\n        VSlideYReverseTransition: VSlideYReverseTransition,\n        VTabReverseTransition: VTabReverseTransition,\n        VTabTransition: VTabTransition,\n        VExpandTransition: VExpandTransition,\n        VRowExpandTransition: VRowExpandTransition\n    }\n});\n\n/***/ }),\n\n/***/ "./src/directives/click-outside.ts":\n/*!*****************************************!*\\\n  !*** ./src/directives/click-outside.ts ***!\n  \\*****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\nvar __values = undefined && undefined.__values || function (o) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator],\n        i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function next() {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nfunction closeConditional() {\n    return false;\n}\nfunction directive(e, el, binding) {\n    // Args may not always be supplied\n    binding.args = binding.args || {};\n    // If no closeConditional was supplied assign a default\n    var isActive = binding.args.closeConditional || closeConditional;\n    // The include element callbacks below can be expensive\n    // so we should avoid calling them when we\'re not active.\n    // Explicitly check for false to allow fallback compatibility\n    // with non-toggleable components\n    if (!e || isActive(e) === false) return;\n    // If click was triggered programmaticaly (domEl.click()) then\n    // it shouldn\'t be treated as click-outside\n    // Chrome/Firefox support isTrusted property\n    // IE/Edge support pointerType property (empty if not triggered\n    // by pointing device)\n    if (\'isTrusted\' in e && !e.isTrusted || \'pointerType\' in e && !e.pointerType) return;\n    // Check if additional elements were passed to be included in check\n    // (click must be outside all included elements, if any)\n    var elements = (binding.args.include || function () {\n        return [];\n    })();\n    // Add the root element for the component this directive was defined on\n    elements.push(el);\n    // Check if it\'s a click outside our elements, and then if our callback returns true.\n    // Non-toggleable components should take action in their callback and return falsy.\n    // Toggleable can return true if it wants to deactivate.\n    // Note that, because we\'re in the capture phase, this callback will occure before\n    // the bubbling click event on any outside elements.\n    !clickedInEls(e, elements) && setTimeout(function () {\n        isActive(e) && binding.value(e);\n    }, 0);\n}\nfunction clickedInEls(e, elements) {\n    var e_1, _a;\n    // Get position of click\n    var x = e.clientX,\n        y = e.clientY;\n    try {\n        // Loop over all included elements to see if click was in any of them\n        for (var elements_1 = __values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {\n            var el = elements_1_1.value;\n            if (clickedInEl(el, x, y)) return true;\n        }\n    } catch (e_1_1) {\n        e_1 = { error: e_1_1 };\n    } finally {\n        try {\n            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);\n        } finally {\n            if (e_1) throw e_1.error;\n        }\n    }\n    return false;\n}\nfunction clickedInEl(el, x, y) {\n    // Get bounding rect for element\n    // (we\'re in capturing event and we want to check for multiple elements,\n    //  so can\'t use target.)\n    var b = el.getBoundingClientRect();\n    // Check if the click was in the element\'s bounding rect\n    return x >= b.left && x <= b.right && y >= b.top && y <= b.bottom;\n}\n/* harmony default export */ __webpack_exports__["default"] = ({\n    // [data-app] may not be found\n    // if using bind, inserted makes\n    // sure that the root element is\n    // available, iOS does not support\n    // clicks on body\n    inserted: function inserted(el, binding) {\n        var onClick = function onClick(e) {\n            return directive(e, el, binding);\n        };\n        // iOS does not recognize click events on document\n        // or body, this is the entire purpose of the v-app\n        // component and [data-app], stop removing this\n        var app = document.querySelector(\'[data-app]\') || document.body; // This is only for unit tests\n        app.addEventListener(\'click\', onClick, true);\n        el._clickOutside = onClick;\n    },\n    unbind: function unbind(el) {\n        if (!el._clickOutside) return;\n        var app = document.querySelector(\'[data-app]\') || document.body; // This is only for unit tests\n        app && app.removeEventListener(\'click\', el._clickOutside, true);\n        delete el._clickOutside;\n    }\n});\n\n/***/ }),\n\n/***/ "./src/directives/index.ts":\n/*!*********************************!*\\\n  !*** ./src/directives/index.ts ***!\n  \\*********************************/\n/*! exports provided: ClickOutside, Ripple, Resize, Scroll, Touch, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _click_outside__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./click-outside */ "./src/directives/click-outside.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClickOutside", function() { return _click_outside__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _resize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resize */ "./src/directives/resize.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Resize", function() { return _resize__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _ripple__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ripple */ "./src/directives/ripple.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Ripple", function() { return _ripple__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _scroll__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scroll */ "./src/directives/scroll.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Scroll", function() { return _scroll__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n/* harmony import */ var _touch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./touch */ "./src/directives/touch.ts");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Touch", function() { return _touch__WEBPACK_IMPORTED_MODULE_4__["default"]; });\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__["default"] = ({\n    ClickOutside: _click_outside__WEBPACK_IMPORTED_MODULE_0__["default"],\n    Ripple: _ripple__WEBPACK_IMPORTED_MODULE_2__["default"],\n    Resize: _resize__WEBPACK_IMPORTED_MODULE_1__["default"],\n    Scroll: _scroll__WEBPACK_IMPORTED_MODULE_3__["default"],\n    Touch: _touch__WEBPACK_IMPORTED_MODULE_4__["default"]\n});\n\n/***/ }),\n\n/***/ "./src/directives/resize.ts":\n/*!**********************************!*\\\n  !*** ./src/directives/resize.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\nfunction inserted(el, binding) {\n    var callback = binding.value;\n    var options = binding.options || { passive: true };\n    window.addEventListener(\'resize\', callback, options);\n    el._onResize = {\n        callback: callback,\n        options: options\n    };\n    if (!binding.modifiers || !binding.modifiers.quiet) {\n        callback();\n    }\n}\nfunction unbind(el) {\n    if (!el._onResize) return;\n    var _a = el._onResize,\n        callback = _a.callback,\n        options = _a.options;\n    window.removeEventListener(\'resize\', callback, options);\n    delete el._onResize;\n}\n/* harmony default export */ __webpack_exports__["default"] = ({\n    inserted: inserted,\n    unbind: unbind\n});\n\n/***/ }),\n\n/***/ "./src/directives/ripple.ts":\n/*!**********************************!*\\\n  !*** ./src/directives/ripple.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\nfunction transform(el, value) {\n    el.style[\'transform\'] = value;\n    el.style[\'webkitTransform\'] = value;\n}\nfunction opacity(el, value) {\n    el.style[\'opacity\'] = value.toString();\n}\nvar calculate = function calculate(e, el, value) {\n    if (value === void 0) {\n        value = {};\n    }\n    var offset = el.getBoundingClientRect();\n    var localX = e.clientX - offset.left;\n    var localY = e.clientY - offset.top;\n    var radius = 0;\n    var scale = 0.3;\n    if (el._ripple && el._ripple.circle) {\n        scale = 0.15;\n        radius = el.clientWidth / 2;\n        radius = value.center ? radius : radius + Math.sqrt(Math.pow(localX - radius, 2) + Math.pow(localY - radius, 2)) / 4;\n    } else {\n        radius = Math.sqrt(Math.pow(el.clientWidth, 2) + Math.pow(el.clientHeight, 2)) / 2;\n    }\n    var centerX = (el.clientWidth - radius * 2) / 2 + "px";\n    var centerY = (el.clientHeight - radius * 2) / 2 + "px";\n    var x = value.center ? centerX : localX - radius + "px";\n    var y = value.center ? centerY : localY - radius + "px";\n    return { radius: radius, scale: scale, x: x, y: y, centerX: centerX, centerY: centerY };\n};\nvar ripple = {\n    /* eslint-disable max-statements */\n    show: function show(e, el, value) {\n        if (value === void 0) {\n            value = {};\n        }\n        if (!el._ripple || !el._ripple.enabled) {\n            return;\n        }\n        var container = document.createElement(\'span\');\n        var animation = document.createElement(\'span\');\n        container.appendChild(animation);\n        container.className = \'v-ripple__container\';\n        if (value.class) {\n            container.className += " " + value.class;\n        }\n        var _a = calculate(e, el, value),\n            radius = _a.radius,\n            scale = _a.scale,\n            x = _a.x,\n            y = _a.y,\n            centerX = _a.centerX,\n            centerY = _a.centerY;\n        animation.className = \'v-ripple__animation\';\n        animation.style.width = radius * 2 + "px";\n        animation.style.height = animation.style.width;\n        el.appendChild(container);\n        var computed = window.getComputedStyle(el);\n        if (computed.position === \'static\') {\n            el.style.position = \'relative\';\n            el.dataset.previousPosition = \'static\';\n        }\n        animation.classList.add(\'v-ripple__animation--enter\');\n        animation.classList.add(\'v-ripple__animation--visible\');\n        transform(animation, "translate(" + x + ", " + y + ") scale3d(" + scale + "," + scale + "," + scale + ")");\n        opacity(animation, 0);\n        animation.dataset.activated = String(performance.now());\n        setTimeout(function () {\n            animation.classList.remove(\'v-ripple__animation--enter\');\n            animation.classList.add(\'v-ripple__animation--in\');\n            transform(animation, "translate(" + centerX + ", " + centerY + ") scale3d(1,1,1)");\n            opacity(animation, 0.25);\n            setTimeout(function () {\n                animation.classList.remove(\'v-ripple__animation--in\');\n                animation.classList.add(\'v-ripple__animation--out\');\n                opacity(animation, 0);\n            }, 300);\n        }, 0);\n    },\n    hide: function hide(el) {\n        if (!el || !el._ripple || !el._ripple.enabled) return;\n        var ripples = el.getElementsByClassName(\'v-ripple__animation\');\n        if (ripples.length === 0) return;\n        var animation = ripples[ripples.length - 1];\n        if (animation.dataset.isHiding) return;else animation.dataset.isHiding = \'true\';\n        var diff = performance.now() - Number(animation.dataset.activated);\n        var delay = Math.max(200 - diff, 0);\n        setTimeout(function () {\n            animation.classList.remove(\'v-ripple__animation--out\');\n            setTimeout(function () {\n                var ripples = el.getElementsByClassName(\'v-ripple__animation\');\n                if (ripples.length === 1 && el.dataset.previousPosition) {\n                    el.style.position = el.dataset.previousPosition;\n                    delete el.dataset.previousPosition;\n                }\n                animation.parentNode && el.removeChild(animation.parentNode);\n            }, 300);\n        }, delay);\n    }\n};\nfunction isRippleEnabled(value) {\n    return typeof value === \'undefined\' || !!value;\n}\nfunction rippleShow(e) {\n    var value = {};\n    var element = e.currentTarget;\n    if (!element) return;\n    value.center = element._ripple.centered;\n    if (element._ripple.class) {\n        value.class = element._ripple.class;\n    }\n    ripple.show(e, element, value);\n}\nfunction rippleHide(e) {\n    ripple.hide(e.currentTarget);\n}\nfunction updateRipple(el, binding, wasEnabled) {\n    var enabled = isRippleEnabled(binding.value);\n    if (!enabled) {\n        ripple.hide(el);\n    }\n    el._ripple = el._ripple || {};\n    el._ripple.enabled = enabled;\n    var value = binding.value || {};\n    if (value.center) {\n        el._ripple.centered = true;\n    }\n    if (value.class) {\n        el._ripple.class = binding.value.class;\n    }\n    if (value.circle) {\n        el._ripple.circle = value.circle;\n    }\n    if (enabled && !wasEnabled) {\n        if (\'ontouchstart\' in window) {\n            el.addEventListener(\'touchend\', rippleHide, false);\n            el.addEventListener(\'touchcancel\', rippleHide, false);\n        }\n        el.addEventListener(\'mousedown\', rippleShow, false);\n        el.addEventListener(\'mouseup\', rippleHide, false);\n        el.addEventListener(\'mouseleave\', rippleHide, false);\n        // Anchor tags can be dragged, causes other hides to fail - #1537\n        el.addEventListener(\'dragstart\', rippleHide, false);\n    } else if (!enabled && wasEnabled) {\n        removeListeners(el);\n    }\n}\nfunction removeListeners(el) {\n    el.removeEventListener(\'mousedown\', rippleShow, false);\n    el.removeEventListener(\'touchend\', rippleHide, false);\n    el.removeEventListener(\'touchcancel\', rippleHide, false);\n    el.removeEventListener(\'mouseup\', rippleHide, false);\n    el.removeEventListener(\'mouseleave\', rippleHide, false);\n    el.removeEventListener(\'dragstart\', rippleHide, false);\n}\nfunction directive(el, binding) {\n    updateRipple(el, binding, false);\n}\nfunction unbind(el) {\n    delete el._ripple;\n    removeListeners(el);\n}\nfunction update(el, binding) {\n    if (binding.value === binding.oldValue) {\n        return;\n    }\n    var wasEnabled = isRippleEnabled(binding.oldValue);\n    updateRipple(el, binding, wasEnabled);\n}\n/* harmony default export */ __webpack_exports__["default"] = ({\n    bind: directive,\n    unbind: unbind,\n    update: update\n});\n\n/***/ }),\n\n/***/ "./src/directives/scroll.ts":\n/*!**********************************!*\\\n  !*** ./src/directives/scroll.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\nfunction inserted(el, binding) {\n    var callback = binding.value;\n    var options = binding.options || { passive: true };\n    var target = binding.arg ? document.querySelector(binding.arg) : window;\n    if (!target) return;\n    target.addEventListener(\'scroll\', callback, options);\n    el._onScroll = {\n        callback: callback,\n        options: options,\n        target: target\n    };\n}\nfunction unbind(el) {\n    if (!el._onScroll) return;\n    var _a = el._onScroll,\n        callback = _a.callback,\n        options = _a.options,\n        target = _a.target;\n    target.removeEventListener(\'scroll\', callback, options);\n    delete el._onScroll;\n}\n/* harmony default export */ __webpack_exports__["default"] = ({\n    inserted: inserted,\n    unbind: unbind\n});\n\n/***/ }),\n\n/***/ "./src/directives/touch.ts":\n/*!*********************************!*\\\n  !*** ./src/directives/touch.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/helpers */ "./src/util/helpers.ts");\n\nvar handleGesture = function handleGesture(wrapper) {\n    var touchstartX = wrapper.touchstartX,\n        touchendX = wrapper.touchendX,\n        touchstartY = wrapper.touchstartY,\n        touchendY = wrapper.touchendY;\n    var dirRatio = 0.5;\n    var minDistance = 16;\n    wrapper.offsetX = touchendX - touchstartX;\n    wrapper.offsetY = touchendY - touchstartY;\n    if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {\n        wrapper.left && touchendX < touchstartX - minDistance && wrapper.left(wrapper);\n        wrapper.right && touchendX > touchstartX + minDistance && wrapper.right(wrapper);\n    }\n    if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {\n        wrapper.up && touchendY < touchstartY - minDistance && wrapper.up(wrapper);\n        wrapper.down && touchendY > touchstartY + minDistance && wrapper.down(wrapper);\n    }\n};\nfunction _touchstart(event, wrapper) {\n    var touch = event.changedTouches[0];\n    wrapper.touchstartX = touch.clientX;\n    wrapper.touchstartY = touch.clientY;\n    wrapper.start && wrapper.start(Object.assign(event, wrapper));\n}\nfunction _touchend(event, wrapper) {\n    var touch = event.changedTouches[0];\n    wrapper.touchendX = touch.clientX;\n    wrapper.touchendY = touch.clientY;\n    wrapper.end && wrapper.end(Object.assign(event, wrapper));\n    handleGesture(wrapper);\n}\nfunction _touchmove(event, wrapper) {\n    var touch = event.changedTouches[0];\n    wrapper.touchmoveX = touch.clientX;\n    wrapper.touchmoveY = touch.clientY;\n    wrapper.move && wrapper.move(Object.assign(event, wrapper));\n}\nfunction createHandlers(value) {\n    var wrapper = {\n        touchstartX: 0,\n        touchstartY: 0,\n        touchendX: 0,\n        touchendY: 0,\n        touchmoveX: 0,\n        touchmoveY: 0,\n        offsetX: 0,\n        offsetY: 0,\n        left: value.left,\n        right: value.right,\n        up: value.up,\n        down: value.down,\n        start: value.start,\n        move: value.move,\n        end: value.end\n    };\n    return {\n        touchstart: function touchstart(e) {\n            return _touchstart(e, wrapper);\n        },\n        touchend: function touchend(e) {\n            return _touchend(e, wrapper);\n        },\n        touchmove: function touchmove(e) {\n            return _touchmove(e, wrapper);\n        }\n    };\n}\nfunction inserted(el, binding, vnode) {\n    var value = binding.value;\n    var target = value.parent ? el.parentElement : el;\n    var options = value.options || { passive: true };\n    // Needed to pass unit tests\n    if (!target) return;\n    var handlers = createHandlers(binding.value);\n    target._touchHandlers = Object(target._touchHandlers);\n    target._touchHandlers[vnode.context._uid] = handlers;\n    Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["keys"])(handlers).forEach(function (eventName) {\n        target.addEventListener(eventName, handlers[eventName], options);\n    });\n}\nfunction unbind(el, binding, vnode) {\n    var target = binding.value.parent ? el.parentElement : el;\n    if (!target || !target._touchHandlers) return;\n    var handlers = target._touchHandlers[vnode.context._uid];\n    Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["keys"])(handlers).forEach(function (eventName) {\n        target.removeEventListener(eventName, handlers[eventName]);\n    });\n    delete target._touchHandlers[vnode.context._uid];\n}\n/* harmony default export */ __webpack_exports__["default"] = ({\n    inserted: inserted,\n    unbind: unbind\n});\n\n/***/ }),\n\n/***/ "./src/index.ts":\n/*!**********************!*\\\n  !*** ./src/index.ts ***!\n  \\**********************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_app_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stylus/app.styl */ "./src/stylus/app.styl");\n/* harmony import */ var _stylus_app_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_app_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Vuetify__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/Vuetify */ "./src/components/Vuetify/index.ts");\n/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components */ "./src/components/index.ts");\n/* harmony import */ var _directives__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./directives */ "./src/directives/index.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n\n\nvar Vuetify = {\n    install: function install(Vue, args) {\n        Vue.use(_components_Vuetify__WEBPACK_IMPORTED_MODULE_1__["default"], __assign({ components: _components__WEBPACK_IMPORTED_MODULE_2__,\n            directives: _directives__WEBPACK_IMPORTED_MODULE_3__["default"] }, args));\n    },\n    version: \'1.3.7\'\n};\nif (typeof window !== \'undefined\' && window.Vue) {\n    window.Vue.use(Vuetify);\n}\n/* harmony default export */ __webpack_exports__["default"] = (Vuetify);\n\n/***/ }),\n\n/***/ "./src/locale/en.ts":\n/*!**************************!*\\\n  !*** ./src/locale/en.ts ***!\n  \\**************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = ({\n    dataIterator: {\n        rowsPerPageText: \'Items per page:\',\n        rowsPerPageAll: \'All\',\n        pageText: \'{0}-{1} of {2}\',\n        noResultsText: \'No matching records found\',\n        nextPage: \'Next page\',\n        prevPage: \'Previous page\'\n    },\n    dataTable: {\n        rowsPerPageText: \'Rows per page:\'\n    },\n    noDataText: \'No data available\'\n});\n\n/***/ }),\n\n/***/ "./src/mixins/applicationable.ts":\n/*!***************************************!*\\\n  !*** ./src/mixins/applicationable.ts ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return applicationable; });\n/* harmony import */ var _positionable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./positionable */ "./src/mixins/positionable.ts");\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/mixins */ "./src/util/mixins.ts");\n\n// Util\n\nfunction applicationable(value, events) {\n    if (events === void 0) {\n        events = [];\n    }\n    /* @vue/component */\n    return Object(_util_mixins__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_positionable__WEBPACK_IMPORTED_MODULE_0__["factory"])([\'absolute\', \'fixed\'])).extend({\n        name: \'applicationable\',\n        props: {\n            app: Boolean\n        },\n        computed: {\n            applicationProperty: function applicationProperty() {\n                return value;\n            }\n        },\n        watch: {\n            // If previous value was app\n            // reset the provided prop\n            app: function app(x, prev) {\n                prev ? this.removeApplication(true) : this.callUpdate();\n            },\n            applicationProperty: function applicationProperty(newVal, oldVal) {\n                this.$vuetify.application.unbind(this._uid, oldVal);\n            }\n        },\n        activated: function activated() {\n            this.callUpdate();\n        },\n        created: function created() {\n            for (var i = 0, length = events.length; i < length; i++) {\n                this.$watch(events[i], this.callUpdate);\n            }\n            this.callUpdate();\n        },\n        mounted: function mounted() {\n            this.callUpdate();\n        },\n        deactivated: function deactivated() {\n            this.removeApplication();\n        },\n        destroyed: function destroyed() {\n            this.removeApplication();\n        },\n        methods: {\n            callUpdate: function callUpdate() {\n                if (!this.app) return;\n                this.$vuetify.application.bind(this._uid, this.applicationProperty, this.updateApplication());\n            },\n            removeApplication: function removeApplication(force) {\n                if (force === void 0) {\n                    force = false;\n                }\n                if (!force && !this.app) return;\n                this.$vuetify.application.unbind(this._uid, this.applicationProperty);\n            },\n            updateApplication: function updateApplication() {\n                return 0;\n            }\n        }\n    });\n}\n\n/***/ }),\n\n/***/ "./src/mixins/bootable.ts":\n/*!********************************!*\\\n  !*** ./src/mixins/bootable.ts ***!\n  \\********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Bootable\n * @mixin\n *\n * Used to add lazy content functionality to components\n * Looks for change in "isActive" to automatically boot\n * Otherwise can be set manually\n */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend().extend({\n    name: \'bootable\',\n    props: {\n        lazy: Boolean\n    },\n    data: function data() {\n        return {\n            isBooted: false\n        };\n    },\n    computed: {\n        hasContent: function hasContent() {\n            return this.isBooted || !this.lazy || this.isActive;\n        }\n    },\n    watch: {\n        isActive: function isActive() {\n            this.isBooted = true;\n        }\n    },\n    methods: {\n        showLazyContent: function showLazyContent(content) {\n            return this.hasContent ? content : undefined;\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/button-group.ts":\n/*!************************************!*\\\n  !*** ./src/mixins/button-group.ts ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/VItemGroup/VItemGroup */ "./src/components/VItemGroup/VItemGroup.ts");\n// Extensions\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (_components_VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_0__["BaseItemGroup"].extend({\n    name: \'button-group\',\n    provide: function provide() {\n        return {\n            btnToggle: this\n        };\n    },\n    props: {\n        activeClass: {\n            type: String,\n            default: \'v-btn--active\'\n        }\n    },\n    computed: {\n        classes: function classes() {\n            return _components_VItemGroup_VItemGroup__WEBPACK_IMPORTED_MODULE_0__["BaseItemGroup"].options.computed.classes.call(this);\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/colorable.ts":\n/*!*********************************!*\\\n  !*** ./src/mixins/colorable.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\n\nfunction isCssColor(color) {\n    return !!color && !!color.match(/^(#|(rgb|hsl)a?\\()/);\n}\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'colorable\',\n    props: {\n        color: String\n    },\n    methods: {\n        setBackgroundColor: function setBackgroundColor(color, data) {\n            if (data === void 0) {\n                data = {};\n            }\n            var _a;\n            if (isCssColor(color)) {\n                data.style = __assign({}, data.style, { \'background-color\': "" + color, \'border-color\': "" + color });\n            } else if (color) {\n                data.class = __assign({}, data.class, (_a = {}, _a[color] = true, _a));\n            }\n            return data;\n        },\n        setTextColor: function setTextColor(color, data) {\n            if (data === void 0) {\n                data = {};\n            }\n            var _a;\n            if (isCssColor(color)) {\n                data.style = __assign({}, data.style, { \'color\': "" + color, \'caret-color\': "" + color });\n            } else if (color) {\n                var _b = __read(color.toString().trim().split(\' \', 2), 2),\n                    colorName = _b[0],\n                    colorModifier = _b[1];\n                data.class = __assign({}, data.class, (_a = {}, _a[colorName + \'--text\'] = true, _a));\n                if (colorModifier) {\n                    data.class[\'text--\' + colorModifier] = true;\n                }\n            }\n            return data;\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/comparable.ts":\n/*!**********************************!*\\\n  !*** ./src/mixins/comparable.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/helpers */ "./src/util/helpers.ts");\n\n\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'comparable\',\n    props: {\n        valueComparator: {\n            type: Function,\n            default: _util_helpers__WEBPACK_IMPORTED_MODULE_1__["deepEqual"]\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/data-iterable.js":\n/*!*************************************!*\\\n  !*** ./src/mixins/data-iterable.js ***!\n  \\*************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_VBtn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/VBtn */ "./src/components/VBtn/index.ts");\n/* harmony import */ var _components_VIcon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/VIcon */ "./src/components/VIcon/index.ts");\n/* harmony import */ var _components_VSelect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/VSelect */ "./src/components/VSelect/index.js");\n/* harmony import */ var _filterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filterable */ "./src/mixins/filterable.ts");\n/* harmony import */ var _themeable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _loadable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./loadable */ "./src/mixins/loadable.ts");\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/console */ "./src/util/console.ts");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) {\n        ar = ar.concat(__read(arguments[i]));\n    }return ar;\n};\n\n\n\n\n\n\n\n\n/**\n * DataIterable\n *\n * @mixin\n *\n * Base behavior for data table and data iterator\n * providing selection, pagination, sorting and filtering.\n *\n */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'data-iterable\',\n    mixins: [_filterable__WEBPACK_IMPORTED_MODULE_3__["default"], _loadable__WEBPACK_IMPORTED_MODULE_5__["default"], _themeable__WEBPACK_IMPORTED_MODULE_4__["default"]],\n    props: {\n        expand: Boolean,\n        hideActions: Boolean,\n        disableInitialSort: Boolean,\n        mustSort: Boolean,\n        noResultsText: {\n            type: String,\n            default: \'$vuetify.dataIterator.noResultsText\'\n        },\n        nextIcon: {\n            type: String,\n            default: \'$vuetify.icons.next\'\n        },\n        prevIcon: {\n            type: String,\n            default: \'$vuetify.icons.prev\'\n        },\n        rowsPerPageItems: {\n            type: Array,\n            default: function _default() {\n                return [5, 10, 25, {\n                    text: \'$vuetify.dataIterator.rowsPerPageAll\',\n                    value: -1\n                }];\n            }\n        },\n        rowsPerPageText: {\n            type: String,\n            default: \'$vuetify.dataIterator.rowsPerPageText\'\n        },\n        selectAll: [Boolean, String],\n        search: {\n            required: false\n        },\n        filter: {\n            type: Function,\n            default: function _default(val, search) {\n                return val != null && typeof val !== \'boolean\' && val.toString().toLowerCase().indexOf(search) !== -1;\n            }\n        },\n        customFilter: {\n            type: Function,\n            default: function _default(items, search, filter) {\n                search = search.toString().toLowerCase();\n                if (search.trim() === \'\') return items;\n                return items.filter(function (i) {\n                    return Object.keys(i).some(function (j) {\n                        return filter(i[j], search);\n                    });\n                });\n            }\n        },\n        customSort: {\n            type: Function,\n            default: function _default(items, index, isDescending) {\n                if (index === null) return items;\n                return items.sort(function (a, b) {\n                    var _a, _b;\n                    var sortA = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_6__["getObjectValueByPath"])(a, index);\n                    var sortB = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_6__["getObjectValueByPath"])(b, index);\n                    if (isDescending) {\n                        _a = __read([sortB, sortA], 2), sortA = _a[0], sortB = _a[1];\n                    }\n                    // Check if both are numbers\n                    if (!isNaN(sortA) && !isNaN(sortB)) {\n                        return sortA - sortB;\n                    }\n                    // Check if both cannot be evaluated\n                    if (sortA === null && sortB === null) {\n                        return 0;\n                    }\n                    _b = __read([sortA, sortB].map(function (s) {\n                        return (s || \'\').toString().toLocaleLowerCase();\n                    }), 2), sortA = _b[0], sortB = _b[1];\n                    if (sortA > sortB) return 1;\n                    if (sortA < sortB) return -1;\n                    return 0;\n                });\n            }\n        },\n        value: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        },\n        items: {\n            type: Array,\n            required: true,\n            default: function _default() {\n                return [];\n            }\n        },\n        totalItems: {\n            type: Number,\n            default: null\n        },\n        itemKey: {\n            type: String,\n            default: \'id\'\n        },\n        pagination: {\n            type: Object,\n            default: function _default() {}\n        }\n    },\n    data: function data() {\n        return {\n            searchLength: 0,\n            defaultPagination: {\n                descending: false,\n                page: 1,\n                rowsPerPage: 5,\n                sortBy: null,\n                totalItems: 0\n            },\n            expanded: {},\n            actionsClasses: \'v-data-iterator__actions\',\n            actionsRangeControlsClasses: \'v-data-iterator__actions__range-controls\',\n            actionsSelectClasses: \'v-data-iterator__actions__select\',\n            actionsPaginationClasses: \'v-data-iterator__actions__pagination\'\n        };\n    },\n    computed: {\n        computedPagination: function computedPagination() {\n            return this.hasPagination ? this.pagination : this.defaultPagination;\n        },\n        computedRowsPerPageItems: function computedRowsPerPageItems() {\n            var _this = this;\n            return this.rowsPerPageItems.map(function (item) {\n                return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_6__["isObject"])(item) ? Object.assign({}, item, {\n                    text: _this.$vuetify.t(item.text)\n                }) : { value: item, text: Number(item).toLocaleString(_this.$vuetify.lang.current) };\n            });\n        },\n        hasPagination: function hasPagination() {\n            var pagination = this.pagination || {};\n            return Object.keys(pagination).length > 0;\n        },\n        hasSelectAll: function hasSelectAll() {\n            return this.selectAll !== undefined && this.selectAll !== false;\n        },\n        itemsLength: function itemsLength() {\n            if (this.hasSearch) return this.searchLength;\n            return this.totalItems || this.items.length;\n        },\n        indeterminate: function indeterminate() {\n            return this.hasSelectAll && this.someItems && !this.everyItem;\n        },\n        everyItem: function everyItem() {\n            var _this = this;\n            return this.filteredItems.length && this.filteredItems.every(function (i) {\n                return _this.isSelected(i);\n            });\n        },\n        someItems: function someItems() {\n            var _this = this;\n            return this.filteredItems.some(function (i) {\n                return _this.isSelected(i);\n            });\n        },\n        getPage: function getPage() {\n            var rowsPerPage = this.computedPagination.rowsPerPage;\n            return rowsPerPage === Object(rowsPerPage) ? rowsPerPage.value : rowsPerPage;\n        },\n        pageStart: function pageStart() {\n            return this.getPage === -1 ? 0 : (this.computedPagination.page - 1) * this.getPage;\n        },\n        pageStop: function pageStop() {\n            return this.getPage === -1 ? this.itemsLength : this.computedPagination.page * this.getPage;\n        },\n        filteredItems: function filteredItems() {\n            return this.filteredItemsImpl();\n        },\n        selected: function selected() {\n            var selected = {};\n            for (var index = 0; index < this.value.length; index++) {\n                var key = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_6__["getObjectValueByPath"])(this.value[index], this.itemKey);\n                selected[key] = true;\n            }\n            return selected;\n        },\n        hasSearch: function hasSearch() {\n            return this.search != null;\n        }\n    },\n    watch: {\n        items: function items() {\n            if (this.pageStart >= this.itemsLength) {\n                this.resetPagination();\n            }\n        },\n        search: function search() {\n            var _this = this;\n            this.$nextTick(function () {\n                _this.updatePagination({ page: 1, totalItems: _this.itemsLength });\n            });\n        },\n        \'computedPagination.sortBy\': \'resetPagination\',\n        \'computedPagination.descending\': \'resetPagination\'\n    },\n    methods: {\n        initPagination: function initPagination() {\n            if (!this.rowsPerPageItems.length) {\n                Object(_util_console__WEBPACK_IMPORTED_MODULE_7__["consoleWarn"])("The prop \'rows-per-page-items\' can not be empty", this);\n            } else {\n                this.defaultPagination.rowsPerPage = this.rowsPerPageItems[0];\n            }\n            this.defaultPagination.totalItems = this.items.length;\n            this.updatePagination(Object.assign({}, this.defaultPagination, this.pagination));\n        },\n        updatePagination: function updatePagination(val) {\n            var pagination = this.hasPagination ? this.pagination : this.defaultPagination;\n            var updatedPagination = Object.assign({}, pagination, val);\n            this.$emit(\'update:pagination\', updatedPagination);\n            if (!this.hasPagination) {\n                this.defaultPagination = updatedPagination;\n            }\n        },\n        isSelected: function isSelected(item) {\n            return this.selected[Object(_util_helpers__WEBPACK_IMPORTED_MODULE_6__["getObjectValueByPath"])(item, this.itemKey)];\n        },\n        isExpanded: function isExpanded(item) {\n            return this.expanded[Object(_util_helpers__WEBPACK_IMPORTED_MODULE_6__["getObjectValueByPath"])(item, this.itemKey)];\n        },\n        filteredItemsImpl: function filteredItemsImpl() {\n            var additionalFilterArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                additionalFilterArgs[_i] = arguments[_i];\n            }\n            if (this.totalItems) return this.items;\n            var items = this.items.slice();\n            if (this.hasSearch) {\n                items = this.customFilter.apply(this, __spread([items, this.search, this.filter], additionalFilterArgs));\n                this.searchLength = items.length;\n            }\n            items = this.customSort(items, this.computedPagination.sortBy, this.computedPagination.descending);\n            return this.hideActions && !this.hasPagination ? items : items.slice(this.pageStart, this.pageStop);\n        },\n        resetPagination: function resetPagination() {\n            this.computedPagination.page !== 1 && this.updatePagination({ page: 1 });\n        },\n        sort: function sort(index) {\n            var _a = this.computedPagination,\n                sortBy = _a.sortBy,\n                descending = _a.descending;\n            if (sortBy === null) {\n                this.updatePagination({ sortBy: index, descending: false });\n            } else if (sortBy === index && !descending) {\n                this.updatePagination({ descending: true });\n            } else if (sortBy !== index) {\n                this.updatePagination({ sortBy: index, descending: false });\n            } else if (!this.mustSort) {\n                this.updatePagination({ sortBy: null, descending: null });\n            } else {\n                this.updatePagination({ sortBy: index, descending: false });\n            }\n        },\n        toggle: function toggle(value) {\n            var _this = this;\n            var selected = Object.assign({}, this.selected);\n            for (var index = 0; index < this.filteredItems.length; index++) {\n                var key = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_6__["getObjectValueByPath"])(this.filteredItems[index], this.itemKey);\n                selected[key] = value;\n            }\n            this.$emit(\'input\', this.items.filter(function (i) {\n                var key = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_6__["getObjectValueByPath"])(i, _this.itemKey);\n                return selected[key];\n            }));\n        },\n        createProps: function createProps(item, index) {\n            var _this = this;\n            var props = { item: item, index: index };\n            var keyProp = this.itemKey;\n            var itemKey = Object(_util_helpers__WEBPACK_IMPORTED_MODULE_6__["getObjectValueByPath"])(item, keyProp);\n            Object.defineProperty(props, \'selected\', {\n                get: function get() {\n                    return _this.selected[itemKey];\n                },\n                set: function set(value) {\n                    if (itemKey == null) {\n                        Object(_util_console__WEBPACK_IMPORTED_MODULE_7__["consoleWarn"])("\\"" + keyProp + "\\" attribute must be defined for item", _this);\n                    }\n                    var selected = _this.value.slice();\n                    if (value) selected.push(item);else selected = selected.filter(function (i) {\n                        return Object(_util_helpers__WEBPACK_IMPORTED_MODULE_6__["getObjectValueByPath"])(i, keyProp) !== itemKey;\n                    });\n                    _this.$emit(\'input\', selected);\n                }\n            });\n            Object.defineProperty(props, \'expanded\', {\n                get: function get() {\n                    return _this.expanded[itemKey];\n                },\n                set: function set(value) {\n                    if (itemKey == null) {\n                        Object(_util_console__WEBPACK_IMPORTED_MODULE_7__["consoleWarn"])("\\"" + keyProp + "\\" attribute must be defined for item", _this);\n                    }\n                    if (!_this.expand) {\n                        for (var key in _this.expanded) {\n                            _this.expanded.hasOwnProperty(key) && _this.$set(_this.expanded, key, false);\n                        }\n                    }\n                    _this.$set(_this.expanded, itemKey, value);\n                }\n            });\n            return props;\n        },\n        genItems: function genItems() {\n            if (!this.itemsLength && !this.items.length) {\n                var noData = this.$slots[\'no-data\'] || this.$vuetify.t(this.noDataText);\n                return [this.genEmptyItems(noData)];\n            }\n            if (!this.filteredItems.length) {\n                var noResults = this.$slots[\'no-results\'] || this.$vuetify.t(this.noResultsText);\n                return [this.genEmptyItems(noResults)];\n            }\n            return this.genFilteredItems();\n        },\n        genPrevIcon: function genPrevIcon() {\n            var _this = this;\n            return this.$createElement(_components_VBtn__WEBPACK_IMPORTED_MODULE_0__["default"], {\n                props: {\n                    disabled: this.computedPagination.page === 1,\n                    icon: true,\n                    flat: true\n                },\n                on: {\n                    click: function click() {\n                        var page = _this.computedPagination.page;\n                        _this.updatePagination({ page: page - 1 });\n                    }\n                },\n                attrs: {\n                    \'aria-label\': this.$vuetify.t(\'$vuetify.dataIterator.prevPage\')\n                }\n            }, [this.$createElement(_components_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], this.$vuetify.rtl ? this.nextIcon : this.prevIcon)]);\n        },\n        genNextIcon: function genNextIcon() {\n            var _this = this;\n            var pagination = this.computedPagination;\n            var disabled = pagination.rowsPerPage < 0 || pagination.page * pagination.rowsPerPage >= this.itemsLength || this.pageStop < 0;\n            return this.$createElement(_components_VBtn__WEBPACK_IMPORTED_MODULE_0__["default"], {\n                props: {\n                    disabled: disabled,\n                    icon: true,\n                    flat: true\n                },\n                on: {\n                    click: function click() {\n                        var page = _this.computedPagination.page;\n                        _this.updatePagination({ page: page + 1 });\n                    }\n                },\n                attrs: {\n                    \'aria-label\': this.$vuetify.t(\'$vuetify.dataIterator.nextPage\')\n                }\n            }, [this.$createElement(_components_VIcon__WEBPACK_IMPORTED_MODULE_1__["default"], this.$vuetify.rtl ? this.prevIcon : this.nextIcon)]);\n        },\n        genSelect: function genSelect() {\n            var _this = this;\n            return this.$createElement(\'div\', {\n                \'class\': this.actionsSelectClasses\n            }, [this.$vuetify.t(this.rowsPerPageText), this.$createElement(_components_VSelect__WEBPACK_IMPORTED_MODULE_2__["default"], {\n                attrs: {\n                    \'aria-label\': this.$vuetify.t(this.rowsPerPageText)\n                },\n                props: {\n                    items: this.computedRowsPerPageItems,\n                    value: this.computedPagination.rowsPerPage,\n                    hideDetails: true,\n                    menuProps: {\n                        auto: true,\n                        dark: this.dark,\n                        light: this.light,\n                        minWidth: \'75px\'\n                    }\n                },\n                on: {\n                    input: function input(val) {\n                        _this.updatePagination({\n                            page: 1,\n                            rowsPerPage: val\n                        });\n                    }\n                }\n            })]);\n        },\n        genPagination: function genPagination() {\n            var _this = this;\n            var _a;\n            var pagination = \'\';\n            if (this.itemsLength) {\n                var stop = this.itemsLength < this.pageStop || this.pageStop < 0 ? this.itemsLength : this.pageStop;\n                pagination = this.$scopedSlots.pageText ? this.$scopedSlots.pageText({\n                    pageStart: this.pageStart + 1,\n                    pageStop: stop,\n                    itemsLength: this.itemsLength\n                }) : (_a = this.$vuetify).t.apply(_a, __spread([\'$vuetify.dataIterator.pageText\'], [this.pageStart + 1, stop, this.itemsLength].map(function (n) {\n                    return Number(n).toLocaleString(_this.$vuetify.lang.current);\n                })));\n            }\n            return this.$createElement(\'div\', {\n                \'class\': this.actionsPaginationClasses\n            }, [pagination]);\n        },\n        genActions: function genActions() {\n            var rangeControls = this.$createElement(\'div\', {\n                \'class\': this.actionsRangeControlsClasses\n            }, [this.genPagination(), this.genPrevIcon(), this.genNextIcon()]);\n            return [this.$createElement(\'div\', {\n                \'class\': this.actionsClasses\n            }, [this.$slots[\'actions-prepend\'] ? this.$createElement(\'div\', {}, this.$slots[\'actions-prepend\']) : null, this.rowsPerPageItems.length > 1 ? this.genSelect() : null, rangeControls, this.$slots[\'actions-append\'] ? this.$createElement(\'div\', {}, this.$slots[\'actions-append\']) : null])];\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/mixins/delayable.ts":\n/*!*********************************!*\\\n  !*** ./src/mixins/delayable.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Delayable\n *\n * @mixin\n *\n * Changes the open or close delay time for elements\n */\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'delayable\',\n    props: {\n        openDelay: {\n            type: [Number, String],\n            default: 0\n        },\n        closeDelay: {\n            type: [Number, String],\n            default: 0\n        }\n    },\n    data: function data() {\n        return {\n            openTimeout: undefined,\n            closeTimeout: undefined\n        };\n    },\n    methods: {\n        /**\n         * Clear any pending delay timers from executing\n         */\n        clearDelay: function clearDelay() {\n            clearTimeout(this.openTimeout);\n            clearTimeout(this.closeTimeout);\n        },\n        /**\n         * Runs callback after a specified delay\n         */\n        runDelay: function runDelay(type, cb) {\n            this.clearDelay();\n            var delay = parseInt(this[type + "Delay"], 10);\n            this[type + "Timeout"] = setTimeout(cb, delay);\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/dependent.ts":\n/*!*********************************!*\\\n  !*** ./src/mixins/dependent.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_mixins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/mixins */ "./src/util/mixins.ts");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) {\n        ar = ar.concat(__read(arguments[i]));\n    }return ar;\n};\n\nfunction searchChildren(children) {\n    var results = [];\n    for (var index = 0; index < children.length; index++) {\n        var child = children[index];\n        if (child.isActive && child.isDependent) {\n            results.push(child);\n        } else {\n            results.push.apply(results, __spread(searchChildren(child.$children)));\n        }\n    }\n    return results;\n}\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_util_mixins__WEBPACK_IMPORTED_MODULE_0__["default"])().extend({\n    name: \'dependent\',\n    data: function data() {\n        return {\n            closeDependents: true,\n            isActive: false,\n            isDependent: true\n        };\n    },\n    watch: {\n        isActive: function isActive(val) {\n            if (val) return;\n            var openDependents = this.getOpenDependents();\n            for (var index = 0; index < openDependents.length; index++) {\n                openDependents[index].isActive = false;\n            }\n        }\n    },\n    methods: {\n        getOpenDependents: function getOpenDependents() {\n            if (this.closeDependents) return searchChildren(this.$children);\n            return [];\n        },\n        getOpenDependentElements: function getOpenDependentElements() {\n            var result = [];\n            var openDependents = this.getOpenDependents();\n            for (var index = 0; index < openDependents.length; index++) {\n                result.push.apply(result, __spread(openDependents[index].getClickableDependentElements()));\n            }\n            return result;\n        },\n        getClickableDependentElements: function getClickableDependentElements() {\n            var result = [this.$el];\n            if (this.$refs.content) result.push(this.$refs.content);\n            result.push.apply(result, __spread(this.getOpenDependentElements()));\n            return result;\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/detachable.js":\n/*!**********************************!*\\\n  !*** ./src/mixins/detachable.js ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bootable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bootable */ "./src/mixins/bootable.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/console */ "./src/util/console.ts");\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\n\n\nfunction validateAttachTarget(val) {\n    var type = typeof val === \'undefined\' ? \'undefined\' : _typeof(val);\n    if (type === \'boolean\' || type === \'string\') return true;\n    return val.nodeType === Node.ELEMENT_NODE;\n}\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'detachable\',\n    mixins: [_bootable__WEBPACK_IMPORTED_MODULE_0__["default"]],\n    props: {\n        attach: {\n            type: null,\n            default: false,\n            validator: validateAttachTarget\n        },\n        contentClass: {\n            default: \'\'\n        }\n    },\n    data: function data() {\n        return {\n            hasDetached: false\n        };\n    },\n    watch: {\n        attach: function attach() {\n            this.hasDetached = false;\n            this.initDetach();\n        },\n        hasContent: \'initDetach\'\n    },\n    mounted: function mounted() {\n        !this.lazy && this.initDetach();\n    },\n    deactivated: function deactivated() {\n        this.isActive = false;\n    },\n    beforeDestroy: function beforeDestroy() {\n        if (!this.$refs.content) return;\n        // IE11 Fix\n        try {\n            this.$refs.content.parentNode.removeChild(this.$refs.content);\n        } catch (e) {\n            console.log(e);\n        }\n    },\n    methods: {\n        getScopeIdAttrs: function getScopeIdAttrs() {\n            var _a;\n            var scopeId = this.$vnode && this.$vnode.context.$options._scopeId;\n            return scopeId && (_a = {}, _a[scopeId] = \'\', _a);\n        },\n        initDetach: function initDetach() {\n            if (this._isDestroyed || !this.$refs.content || this.hasDetached ||\n            // Leave menu in place if attached\n            // and dev has not changed target\n            this.attach === \'\' || // If used as a boolean prop (<v-menu attach>)\n            this.attach === true || // If bound to a boolean (<v-menu :attach="true">)\n            this.attach === \'attach\' // If bound as boolean prop in pug (v-menu(attach))\n            ) return;\n            var target;\n            if (this.attach === false) {\n                // Default, detach to app\n                target = document.querySelector(\'[data-app]\');\n            } else if (typeof this.attach === \'string\') {\n                // CSS selector\n                target = document.querySelector(this.attach);\n            } else {\n                // DOM Element\n                target = this.attach;\n            }\n            if (!target) {\n                Object(_util_console__WEBPACK_IMPORTED_MODULE_1__["consoleWarn"])("Unable to locate target " + (this.attach || \'[data-app]\'), this);\n                return;\n            }\n            target.insertBefore(this.$refs.content, target.firstChild);\n            this.hasDetached = true;\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/mixins/filterable.ts":\n/*!**********************************!*\\\n  !*** ./src/mixins/filterable.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'filterable\',\n    props: {\n        noDataText: {\n            type: String,\n            default: \'$vuetify.noDataText\'\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/groupable.ts":\n/*!*********************************!*\\\n  !*** ./src/mixins/groupable.ts ***!\n  \\*********************************/\n/*! exports provided: factory, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "factory", function() { return factory; });\n/* harmony import */ var _registrable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./registrable */ "./src/mixins/registrable.ts");\n// Mixins\n\nfunction factory(namespace, child, parent) {\n    return Object(_registrable__WEBPACK_IMPORTED_MODULE_0__["inject"])(namespace, child, parent).extend({\n        name: \'groupable\',\n        props: {\n            activeClass: {\n                type: String,\n                default: function _default() {\n                    if (!this[namespace]) return undefined;\n                    return this[namespace].activeClass;\n                }\n            },\n            disabled: Boolean\n        },\n        data: function data() {\n            return {\n                isActive: false\n            };\n        },\n        computed: {\n            groupClasses: function groupClasses() {\n                var _a;\n                if (!this.activeClass) return {};\n                return _a = {}, _a[this.activeClass] = this.isActive, _a;\n            }\n        },\n        created: function created() {\n            this[namespace] && this[namespace].register(this);\n        },\n        beforeDestroy: function beforeDestroy() {\n            this[namespace] && this[namespace].unregister(this);\n        },\n        methods: {\n            toggle: function toggle() {\n                this.$emit(\'change\');\n            }\n        }\n    });\n}\n/* eslint-disable-next-line no-redeclare */\nvar Groupable = factory(\'itemGroup\');\n/* harmony default export */ __webpack_exports__["default"] = (Groupable);\n\n/***/ }),\n\n/***/ "./src/mixins/loadable.ts":\n/*!********************************!*\\\n  !*** ./src/mixins/loadable.ts ***!\n  \\********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_VProgressLinear__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/VProgressLinear */ "./src/components/VProgressLinear/index.ts");\n\n\n/**\n * Loadable\n *\n * @mixin\n *\n * Used to add linear progress bar to components\n * Can use a default bar with a specific color\n * or designate a custom progress linear bar\n */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend().extend({\n    name: \'loadable\',\n    props: {\n        loading: {\n            type: [Boolean, String],\n            default: false\n        }\n    },\n    methods: {\n        genProgress: function genProgress() {\n            if (this.loading === false) return null;\n            return this.$slots.progress || this.$createElement(_components_VProgressLinear__WEBPACK_IMPORTED_MODULE_1__["default"], {\n                props: {\n                    color: this.loading === true || this.loading === \'\' ? this.color || \'primary\' : this.loading,\n                    height: 2,\n                    indeterminate: true\n                }\n            });\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/maskable.js":\n/*!********************************!*\\\n  !*** ./src/mixins/maskable.js ***!\n  \\********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_mask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/mask */ "./src/util/mask.js");\n/**\n * Maskable\n *\n * @mixin\n *\n * Creates an input mask that is\n * generated from a masked str\n *\n * Example: mask="#### #### #### ####"\n */\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'maskable\',\n    props: {\n        dontFillMaskBlanks: Boolean,\n        mask: {\n            type: [Object, String],\n            default: null\n        },\n        returnMaskedValue: Boolean\n    },\n    data: function data() {\n        return {\n            selection: 0,\n            lazySelection: 0,\n            preDefined: {\n                \'credit-card\': \'#### - #### - #### - ####\',\n                \'date\': \'##/##/####\',\n                \'date-with-time\': \'##/##/#### ##:##\',\n                \'phone\': \'(###) ### - ####\',\n                \'social\': \'###-##-####\',\n                \'time\': \'##:##\',\n                \'time-with-seconds\': \'##:##:##\'\n            }\n        };\n    },\n    computed: {\n        masked: function masked() {\n            var preDefined = this.preDefined[this.mask];\n            var mask = preDefined || this.mask || \'\';\n            return mask.split(\'\');\n        }\n    },\n    watch: {\n        /**\n         * Make sure the cursor is in the correct\n         * location when the mask changes\n         */\n        mask: function mask() {\n            var _this = this;\n            if (!this.$refs.input) return;\n            var oldValue = this.$refs.input.value;\n            var newValue = this.maskText(Object(_util_mask__WEBPACK_IMPORTED_MODULE_0__["unmaskText"])(this.lazyValue));\n            var position = 0;\n            var selection = this.selection;\n            for (var index = 0; index < selection; index++) {\n                Object(_util_mask__WEBPACK_IMPORTED_MODULE_0__["isMaskDelimiter"])(oldValue[index]) || position++;\n            }\n            selection = 0;\n            if (newValue) {\n                for (var index = 0; index < newValue.length; index++) {\n                    Object(_util_mask__WEBPACK_IMPORTED_MODULE_0__["isMaskDelimiter"])(newValue[index]) || position--;\n                    selection++;\n                    if (position <= 0) break;\n                }\n            }\n            this.$nextTick(function () {\n                _this.$refs.input.value = newValue;\n                _this.setCaretPosition(selection);\n            });\n        }\n    },\n    beforeMount: function beforeMount() {\n        if (!this.mask || this.value == null || !this.returnMaskedValue) return;\n        var value = this.maskText(this.value);\n        // See if masked value does not\n        // match the user given value\n        if (value === this.value) return;\n        this.$emit(\'input\', value);\n    },\n    methods: {\n        setCaretPosition: function setCaretPosition(selection) {\n            var _this = this;\n            this.selection = selection;\n            window.setTimeout(function () {\n                _this.$refs.input && _this.$refs.input.setSelectionRange(_this.selection, _this.selection);\n            }, 0);\n        },\n        updateRange: function updateRange() {\n            if (!this.$refs.input) return;\n            var newValue = this.maskText(this.lazyValue);\n            var selection = 0;\n            this.$refs.input.value = newValue;\n            if (newValue) {\n                for (var index = 0; index < newValue.length; index++) {\n                    if (this.lazySelection <= 0) break;\n                    Object(_util_mask__WEBPACK_IMPORTED_MODULE_0__["isMaskDelimiter"])(newValue[index]) || this.lazySelection--;\n                    selection++;\n                }\n            }\n            this.setCaretPosition(selection);\n            // this.$emit() must occur only when all internal values are correct\n            this.$emit(\'input\', this.returnMaskedValue ? this.$refs.input.value : this.lazyValue);\n        },\n        maskText: function maskText(text) {\n            return this.mask ? Object(_util_mask__WEBPACK_IMPORTED_MODULE_0__["maskText"])(text, this.masked, this.dontFillMaskBlanks) : text;\n        },\n        unmaskText: function unmaskText(text) {\n            return this.mask && !this.returnMaskedValue ? Object(_util_mask__WEBPACK_IMPORTED_MODULE_0__["unmaskText"])(text) : text;\n        },\n        // When the input changes and is\n        // re-created, ensure that the\n        // caret location is correct\n        setSelectionRange: function setSelectionRange() {\n            this.$nextTick(this.updateRange);\n        },\n        resetSelections: function resetSelections(input) {\n            if (!input.selectionEnd) return;\n            this.selection = input.selectionEnd;\n            this.lazySelection = 0;\n            for (var index = 0; index < this.selection; index++) {\n                Object(_util_mask__WEBPACK_IMPORTED_MODULE_0__["isMaskDelimiter"])(input.value[index]) || this.lazySelection++;\n            }\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/mixins/measurable.ts":\n/*!**********************************!*\\\n  !*** ./src/mixins/measurable.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'measurable\',\n    props: {\n        height: [Number, String],\n        maxHeight: [Number, String],\n        maxWidth: [Number, String],\n        width: [Number, String]\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/menuable.js":\n/*!********************************!*\\\n  !*** ./src/mixins/menuable.js ***!\n  \\********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _positionable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./positionable */ "./src/mixins/positionable.ts");\n/* harmony import */ var _stackable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stackable */ "./src/mixins/stackable.js");\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\n\n\n\n/* eslint-disable object-property-newline */\nvar dimensions = {\n    activator: {\n        top: 0, left: 0,\n        bottom: 0, right: 0,\n        width: 0, height: 0,\n        offsetTop: 0, scrollHeight: 0\n    },\n    content: {\n        top: 0, left: 0,\n        bottom: 0, right: 0,\n        width: 0, height: 0,\n        offsetTop: 0, scrollHeight: 0\n    },\n    hasWindow: false\n};\n/* eslint-enable object-property-newline */\n/**\n * Menuable\n *\n * @mixin\n *\n * Used for fixed or absolutely positioning\n * elements within the DOM\n * Can calculate X and Y axis overflows\n * As well as be manually positioned\n */\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'menuable\',\n    mixins: [_positionable__WEBPACK_IMPORTED_MODULE_1__["default"], _stackable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        activator: {\n            default: null,\n            validator: function validator(val) {\n                return [\'string\', \'object\'].includes(typeof val === \'undefined\' ? \'undefined\' : _typeof(val));\n            }\n        },\n        allowOverflow: Boolean,\n        inputActivator: Boolean,\n        light: Boolean,\n        dark: Boolean,\n        maxWidth: {\n            type: [Number, String],\n            default: \'auto\'\n        },\n        minWidth: [Number, String],\n        nudgeBottom: {\n            type: [Number, String],\n            default: 0\n        },\n        nudgeLeft: {\n            type: [Number, String],\n            default: 0\n        },\n        nudgeRight: {\n            type: [Number, String],\n            default: 0\n        },\n        nudgeTop: {\n            type: [Number, String],\n            default: 0\n        },\n        nudgeWidth: {\n            type: [Number, String],\n            default: 0\n        },\n        offsetOverflow: Boolean,\n        positionX: {\n            type: Number,\n            default: null\n        },\n        positionY: {\n            type: Number,\n            default: null\n        },\n        zIndex: {\n            type: [Number, String],\n            default: null\n        }\n    },\n    data: function data() {\n        return {\n            absoluteX: 0,\n            absoluteY: 0,\n            dimensions: Object.assign({}, dimensions),\n            isContentActive: false,\n            pageYOffset: 0,\n            stackClass: \'v-menu__content--active\',\n            stackMinZIndex: 6\n        };\n    },\n    computed: {\n        computedLeft: function computedLeft() {\n            var a = this.dimensions.activator;\n            var c = this.dimensions.content;\n            var minWidth = a.width < c.width ? c.width : a.width;\n            var left = 0;\n            left += this.left ? a.left - (minWidth - a.width) : a.left;\n            if (this.offsetX) left += this.left ? -a.width : a.width;\n            if (this.nudgeLeft) left -= parseInt(this.nudgeLeft);\n            if (this.nudgeRight) left += parseInt(this.nudgeRight);\n            return left;\n        },\n        computedTop: function computedTop() {\n            var a = this.dimensions.activator;\n            var c = this.dimensions.content;\n            var top = this.top ? a.bottom - c.height : a.top;\n            if (!this.isAttached) top += this.pageYOffset;\n            if (this.offsetY) top += this.top ? -a.height : a.height;\n            if (this.nudgeTop) top -= parseInt(this.nudgeTop);\n            if (this.nudgeBottom) top += parseInt(this.nudgeBottom);\n            return top;\n        },\n        hasActivator: function hasActivator() {\n            return !!this.$slots.activator || this.activator || this.inputActivator;\n        },\n        isAttached: function isAttached() {\n            return this.attach !== false;\n        }\n    },\n    watch: {\n        disabled: function disabled(val) {\n            val && this.callDeactivate();\n        },\n        isActive: function isActive(val) {\n            if (this.disabled) return;\n            val ? this.callActivate() : this.callDeactivate();\n        }\n    },\n    beforeMount: function beforeMount() {\n        this.checkForWindow();\n    },\n    methods: {\n        absolutePosition: function absolutePosition() {\n            return {\n                offsetTop: 0,\n                scrollHeight: 0,\n                top: this.positionY || this.absoluteY,\n                bottom: this.positionY || this.absoluteY,\n                left: this.positionX || this.absoluteX,\n                right: this.positionX || this.absoluteX,\n                height: 0,\n                width: 0\n            };\n        },\n        activate: function activate() {},\n        calcLeft: function calcLeft() {\n            return (this.isAttached ? this.computedLeft : this.calcXOverflow(this.computedLeft)) + "px";\n        },\n        calcTop: function calcTop() {\n            return (this.isAttached ? this.computedTop : this.calcYOverflow(this.computedTop)) + "px";\n        },\n        calcXOverflow: function calcXOverflow(left) {\n            var parsedMaxWidth = isNaN(parseInt(this.maxWidth)) ? 0 : parseInt(this.maxWidth);\n            var innerWidth = this.getInnerWidth();\n            var maxWidth = Math.max(this.dimensions.content.width, parsedMaxWidth);\n            var totalWidth = left + maxWidth;\n            var availableWidth = totalWidth - innerWidth;\n            if ((!this.left || this.right) && availableWidth > 0) {\n                left = innerWidth - maxWidth - (innerWidth > 600 ? 30 : 12) // Account for scrollbar\n                ;\n            }\n            if (left < 0) left = 12;\n            return left;\n        },\n        calcYOverflow: function calcYOverflow(top) {\n            var documentHeight = this.getInnerHeight();\n            var toTop = this.pageYOffset + documentHeight;\n            var activator = this.dimensions.activator;\n            var contentHeight = this.dimensions.content.height;\n            var totalHeight = top + contentHeight;\n            var isOverflowing = toTop < totalHeight;\n            // If overflowing bottom and offset\n            // TODO: set \'bottom\' position instead of \'top\'\n            if (isOverflowing && this.offsetOverflow &&\n            // If we don\'t have enough room to offset\n            // the overflow, don\'t offset\n            activator.top > contentHeight) {\n                top = this.pageYOffset + (activator.top - contentHeight);\n                // If overflowing bottom\n            } else if (isOverflowing && !this.allowOverflow) {\n                top = toTop - contentHeight - 12;\n                // If overflowing top\n            } else if (top < this.pageYOffset && !this.allowOverflow) {\n                top = this.pageYOffset + 12;\n            }\n            return top < 12 ? 12 : top;\n        },\n        callActivate: function callActivate() {\n            if (!this.hasWindow) return;\n            this.activate();\n        },\n        callDeactivate: function callDeactivate() {\n            this.isContentActive = false;\n            this.deactivate();\n        },\n        checkForWindow: function checkForWindow() {\n            if (!this.hasWindow) {\n                this.hasWindow = typeof window !== \'undefined\';\n            }\n        },\n        checkForPageYOffset: function checkForPageYOffset() {\n            if (this.hasWindow) {\n                this.pageYOffset = this.getOffsetTop();\n            }\n        },\n        deactivate: function deactivate() {},\n        getActivator: function getActivator() {\n            if (this.inputActivator) {\n                return this.$el.querySelector(\'.v-input__slot\');\n            }\n            if (this.activator) {\n                return typeof this.activator === \'string\' ? document.querySelector(this.activator) : this.activator;\n            }\n            return this.$refs.activator.children.length > 0 ? this.$refs.activator.children[0] : this.$refs.activator;\n        },\n        getInnerHeight: function getInnerHeight() {\n            if (!this.hasWindow) return 0;\n            return window.innerHeight || document.documentElement.clientHeight;\n        },\n        getInnerWidth: function getInnerWidth() {\n            if (!this.hasWindow) return 0;\n            return window.innerWidth;\n        },\n        getOffsetTop: function getOffsetTop() {\n            if (!this.hasWindow) return 0;\n            return window.pageYOffset || document.documentElement.scrollTop;\n        },\n        getRoundedBoundedClientRect: function getRoundedBoundedClientRect(el) {\n            var rect = el.getBoundingClientRect();\n            return {\n                top: Math.round(rect.top),\n                left: Math.round(rect.left),\n                bottom: Math.round(rect.bottom),\n                right: Math.round(rect.right),\n                width: Math.round(rect.width),\n                height: Math.round(rect.height)\n            };\n        },\n        measure: function measure(el, selector) {\n            el = selector ? el.querySelector(selector) : el;\n            if (!el || !this.hasWindow) return null;\n            var rect = this.getRoundedBoundedClientRect(el);\n            // Account for activator margin\n            if (this.isAttached) {\n                var style = window.getComputedStyle(el);\n                rect.left = parseInt(style.marginLeft);\n                rect.top = parseInt(style.marginTop);\n            }\n            return rect;\n        },\n        sneakPeek: function sneakPeek(cb) {\n            var _this = this;\n            requestAnimationFrame(function () {\n                var el = _this.$refs.content;\n                if (!el || _this.isShown(el)) return cb();\n                el.style.display = \'inline-block\';\n                cb();\n                el.style.display = \'none\';\n            });\n        },\n        startTransition: function startTransition() {\n            var _this = this;\n            requestAnimationFrame(function () {\n                return _this.isContentActive = true;\n            });\n        },\n        isShown: function isShown(el) {\n            return el.style.display !== \'none\';\n        },\n        updateDimensions: function updateDimensions() {\n            var _this = this;\n            this.checkForWindow();\n            this.checkForPageYOffset();\n            var dimensions = {};\n            // Activator should already be shown\n            dimensions.activator = !this.hasActivator || this.absolute ? this.absolutePosition() : this.measure(this.getActivator());\n            // Display and hide to get dimensions\n            this.sneakPeek(function () {\n                dimensions.content = _this.measure(_this.$refs.content);\n                _this.dimensions = dimensions;\n            });\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/overlayable.js":\n/*!***********************************!*\\\n  !*** ./src/mixins/overlayable.js ***!\n  \\***********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _stylus_components_overlay_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stylus/components/_overlay.styl */ "./src/stylus/components/_overlay.styl");\n/* harmony import */ var _stylus_components_overlay_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylus_components_overlay_styl__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/helpers */ "./src/util/helpers.ts");\n\n// Utils\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'overlayable\',\n    props: {\n        hideOverlay: Boolean\n    },\n    data: function data() {\n        return {\n            overlay: null,\n            overlayOffset: 0,\n            overlayTimeout: null,\n            overlayTransitionDuration: 500 + 150 // transition + delay\n        };\n    },\n    beforeDestroy: function beforeDestroy() {\n        this.removeOverlay();\n    },\n    methods: {\n        genOverlay: function genOverlay() {\n            var _this = this;\n            // If fn is called and timeout is active\n            // or overlay already exists\n            // cancel removal of overlay and re-add active\n            if (!this.isActive || this.hideOverlay || this.isActive && this.overlayTimeout || this.overlay) {\n                clearTimeout(this.overlayTimeout);\n                return this.overlay && this.overlay.classList.add(\'v-overlay--active\');\n            }\n            this.overlay = document.createElement(\'div\');\n            this.overlay.className = \'v-overlay\';\n            if (this.absolute) this.overlay.className += \' v-overlay--absolute\';\n            this.hideScroll();\n            var parent = this.absolute ? this.$el.parentNode : document.querySelector(\'[data-app]\');\n            parent && parent.insertBefore(this.overlay, parent.firstChild);\n            // eslint-disable-next-line no-unused-expressions\n            this.overlay.clientHeight; // Force repaint\n            requestAnimationFrame(function () {\n                // https://github.com/vuetifyjs/vuetify/issues/4678\n                if (!_this.overlay) return;\n                _this.overlay.className += \' v-overlay--active\';\n                if (_this.activeZIndex !== undefined) {\n                    _this.overlay.style.zIndex = _this.activeZIndex - 1;\n                }\n            });\n            return true;\n        },\n        removeOverlay: function removeOverlay() {\n            var _this = this;\n            if (!this.overlay) {\n                return this.showScroll();\n            }\n            this.overlay.classList.remove(\'v-overlay--active\');\n            this.overlayTimeout = setTimeout(function () {\n                // IE11 Fix\n                try {\n                    if (_this.overlay && _this.overlay.parentNode) {\n                        _this.overlay.parentNode.removeChild(_this.overlay);\n                    }\n                    _this.overlay = null;\n                    _this.showScroll();\n                } catch (e) {\n                    console.log(e);\n                }\n                clearTimeout(_this.overlayTimeout);\n                _this.overlayTimeout = null;\n            }, this.overlayTransitionDuration);\n        },\n        /**\n         * @param {Event} e\n         * @returns void\n         */\n        scrollListener: function scrollListener(e) {\n            if (e.type === \'keydown\') {\n                if ([\'INPUT\', \'TEXTAREA\', \'SELECT\'].includes(e.target.tagName) ||\n                // https://github.com/vuetifyjs/vuetify/issues/4715\n                e.target.isContentEditable) return;\n                var up = [_util_helpers__WEBPACK_IMPORTED_MODULE_1__["keyCodes"].up, _util_helpers__WEBPACK_IMPORTED_MODULE_1__["keyCodes"].pageup];\n                var down = [_util_helpers__WEBPACK_IMPORTED_MODULE_1__["keyCodes"].down, _util_helpers__WEBPACK_IMPORTED_MODULE_1__["keyCodes"].pagedown];\n                if (up.includes(e.keyCode)) {\n                    e.deltaY = -1;\n                } else if (down.includes(e.keyCode)) {\n                    e.deltaY = 1;\n                } else {\n                    return;\n                }\n            }\n            if (e.target === this.overlay || e.type !== \'keydown\' && e.target === document.body || this.checkPath(e)) e.preventDefault();\n        },\n        hasScrollbar: function hasScrollbar(el) {\n            if (!el || el.nodeType !== Node.ELEMENT_NODE) return false;\n            var style = window.getComputedStyle(el);\n            return [\'auto\', \'scroll\'].includes(style[\'overflow-y\']) && el.scrollHeight > el.clientHeight;\n        },\n        shouldScroll: function shouldScroll(el, delta) {\n            if (el.scrollTop === 0 && delta < 0) return true;\n            return el.scrollTop + el.clientHeight === el.scrollHeight && delta > 0;\n        },\n        isInside: function isInside(el, parent) {\n            if (el === parent) {\n                return true;\n            } else if (el === null || el === document.body) {\n                return false;\n            } else {\n                return this.isInside(el.parentNode, parent);\n            }\n        },\n        /**\n         * @param {Event} e\n         * @returns boolean\n         */\n        checkPath: function checkPath(e) {\n            var path = e.path || this.composedPath(e);\n            var delta = e.deltaY || -e.wheelDelta;\n            if (e.type === \'keydown\' && path[0] === document.body) {\n                var dialog = this.$refs.dialog;\n                var selected = window.getSelection().anchorNode;\n                if (this.hasScrollbar(dialog) && this.isInside(selected, dialog)) {\n                    return this.shouldScroll(dialog, delta);\n                }\n                return true;\n            }\n            for (var index = 0; index < path.length; index++) {\n                var el = path[index];\n                if (el === document) return true;\n                if (el === document.documentElement) return true;\n                if (el === this.$refs.content) return true;\n                if (this.hasScrollbar(el)) return this.shouldScroll(el, delta);\n            }\n            return true;\n        },\n        /**\n         * Polyfill for Event.prototype.composedPath\n         * @param {Event} e\n         * @returns Element[]\n         */\n        composedPath: function composedPath(e) {\n            if (e.composedPath) return e.composedPath();\n            var path = [];\n            var el = e.target;\n            while (el) {\n                path.push(el);\n                if (el.tagName === \'HTML\') {\n                    path.push(document);\n                    path.push(window);\n                    return path;\n                }\n                el = el.parentElement;\n            }\n        },\n        hideScroll: function hideScroll() {\n            if (this.$vuetify.breakpoint.smAndDown) {\n                document.documentElement.classList.add(\'overflow-y-hidden\');\n            } else {\n                window.addEventListener(\'wheel\', this.scrollListener);\n                window.addEventListener(\'keydown\', this.scrollListener);\n            }\n        },\n        showScroll: function showScroll() {\n            document.documentElement.classList.remove(\'overflow-y-hidden\');\n            window.removeEventListener(\'wheel\', this.scrollListener);\n            window.removeEventListener(\'keydown\', this.scrollListener);\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/mixins/picker-button.js":\n/*!*************************************!*\\\n  !*** ./src/mixins/picker-button.js ***!\n  \\*************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    methods: {\n        genPickerButton: function genPickerButton(prop, value, content, readonly, staticClass) {\n            var _this = this;\n            if (readonly === void 0) {\n                readonly = false;\n            }\n            if (staticClass === void 0) {\n                staticClass = \'\';\n            }\n            var active = this[prop] === value;\n            var click = function click(event) {\n                event.stopPropagation();\n                _this.$emit("update:" + prop, value);\n            };\n            return this.$createElement(\'div\', {\n                staticClass: ("v-picker__title__btn " + staticClass).trim(),\n                \'class\': {\n                    \'v-picker__title__btn--active\': active,\n                    \'v-picker__title__btn--readonly\': readonly\n                },\n                on: active || readonly ? undefined : { click: click }\n            }, Array.isArray(content) ? content : [content]);\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/mixins/picker.js":\n/*!******************************!*\\\n  !*** ./src/mixins/picker.js ***!\n  \\******************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_VPicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/VPicker */ "./src/components/VPicker/index.js");\n/* harmony import */ var _colorable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colorable */ "./src/mixins/colorable.ts");\n/* harmony import */ var _themeable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./themeable */ "./src/mixins/themeable.ts");\n// Components\n\n// Mixins\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'picker\',\n    mixins: [_colorable__WEBPACK_IMPORTED_MODULE_1__["default"], _themeable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    props: {\n        fullWidth: Boolean,\n        headerColor: String,\n        landscape: Boolean,\n        noTitle: Boolean,\n        width: {\n            type: [Number, String],\n            default: 290\n        }\n    },\n    methods: {\n        genPickerTitle: function genPickerTitle() {},\n        genPickerBody: function genPickerBody() {},\n        genPickerActionsSlot: function genPickerActionsSlot() {\n            return this.$scopedSlots.default ? this.$scopedSlots.default({\n                save: this.save,\n                cancel: this.cancel\n            }) : this.$slots.default;\n        },\n        genPicker: function genPicker(staticClass) {\n            return this.$createElement(_components_VPicker__WEBPACK_IMPORTED_MODULE_0__["default"], {\n                staticClass: staticClass,\n                props: {\n                    color: this.headerColor || this.color,\n                    dark: this.dark,\n                    fullWidth: this.fullWidth,\n                    landscape: this.landscape,\n                    light: this.light,\n                    width: this.width\n                }\n            }, [this.noTitle ? null : this.genPickerTitle(), this.genPickerBody(), this.$createElement(\'template\', { slot: \'actions\' }, [this.genPickerActionsSlot()])]);\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/mixins/positionable.ts":\n/*!************************************!*\\\n  !*** ./src/mixins/positionable.ts ***!\n  \\************************************/\n/*! exports provided: factory, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "factory", function() { return factory; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/helpers */ "./src/util/helpers.ts");\n\n\nvar availableProps = {\n  absolute: Boolean,\n  bottom: Boolean,\n  fixed: Boolean,\n  left: Boolean,\n  right: Boolean,\n  top: Boolean\n};\nfunction factory(selected) {\n  if (selected === void 0) {\n    selected = [];\n  }\n  return vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'positionable\',\n    props: selected.length ? Object(_util_helpers__WEBPACK_IMPORTED_MODULE_1__["filterObjectOnKeys"])(availableProps, selected) : availableProps\n  });\n}\n/* harmony default export */ __webpack_exports__["default"] = (factory());\n// Add a `*` before the second `/`\n/* Tests /\nlet single = factory([\'top\']).extend({\n  created () {\n    this.top\n    this.bottom\n    this.absolute\n  }\n})\n\nlet some = factory([\'top\', \'bottom\']).extend({\n  created () {\n    this.top\n    this.bottom\n    this.absolute\n  }\n})\n\nlet all = factory().extend({\n  created () {\n    this.top\n    this.bottom\n    this.absolute\n    this.foobar\n  }\n})\n/**/\n\n/***/ }),\n\n/***/ "./src/mixins/proxyable.ts":\n/*!*********************************!*\\\n  !*** ./src/mixins/proxyable.ts ***!\n  \\*********************************/\n/*! exports provided: factory, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "factory", function() { return factory; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction factory(prop, event) {\n    if (prop === void 0) {\n        prop = \'value\';\n    }\n    if (event === void 0) {\n        event = \'change\';\n    }\n    var _a, _b;\n    return vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n        name: \'proxyable\',\n        model: {\n            prop: prop,\n            event: event\n        },\n        props: (_a = {}, _a[prop] = {\n            required: false\n        }, _a),\n        data: function data() {\n            return {\n                internalLazyValue: this[prop]\n            };\n        },\n        computed: {\n            internalValue: {\n                get: function get() {\n                    return this.internalLazyValue;\n                },\n                set: function set(val) {\n                    if (val === this.internalLazyValue) return;\n                    this.internalLazyValue = val;\n                    this.$emit(event, val);\n                }\n            }\n        },\n        watch: (_b = {}, _b[prop] = function (val) {\n            this.internalLazyValue = val;\n        }, _b)\n    });\n}\n/* eslint-disable-next-line no-redeclare */\nvar Proxyable = factory();\n/* harmony default export */ __webpack_exports__["default"] = (Proxyable);\n\n/***/ }),\n\n/***/ "./src/mixins/registrable.ts":\n/*!***********************************!*\\\n  !*** ./src/mixins/registrable.ts ***!\n  \\***********************************/\n/*! exports provided: inject, provide */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inject", function() { return inject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "provide", function() { return provide; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/console */ "./src/util/console.ts");\n\n\nfunction generateWarning(child, parent) {\n    return function () {\n        return Object(_util_console__WEBPACK_IMPORTED_MODULE_1__["consoleWarn"])("The " + child + " component must be used inside a " + parent);\n    };\n}\nfunction inject(namespace, child, parent) {\n    var _a;\n    var defaultImpl = child && parent ? {\n        register: generateWarning(child, parent),\n        unregister: generateWarning(child, parent)\n    } : null;\n    return vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n        name: \'registrable-inject\',\n        inject: (_a = {}, _a[namespace] = {\n            default: defaultImpl\n        }, _a)\n    });\n}\nfunction provide(namespace) {\n    return vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n        name: \'registrable-provide\',\n        methods: {\n            register: null,\n            unregister: null\n        },\n        provide: function provide() {\n            var _a;\n            return _a = {}, _a[namespace] = {\n                register: this.register,\n                unregister: this.unregister\n            }, _a;\n        }\n    });\n}\n\n/***/ }),\n\n/***/ "./src/mixins/returnable.ts":\n/*!**********************************!*\\\n  !*** ./src/mixins/returnable.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'returnable\',\n    props: {\n        returnValue: null\n    },\n    data: function data() {\n        return {\n            isActive: false,\n            originalValue: null\n        };\n    },\n    watch: {\n        isActive: function isActive(val) {\n            if (val) {\n                this.originalValue = this.returnValue;\n            } else {\n                this.$emit(\'update:returnValue\', this.originalValue);\n            }\n        }\n    },\n    methods: {\n        save: function save(value) {\n            this.originalValue = value;\n            this.isActive = false;\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/rippleable.ts":\n/*!**********************************!*\\\n  !*** ./src/mixins/rippleable.ts ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _directives_ripple__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../directives/ripple */ "./src/directives/ripple.ts");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_1__);\n// Directives\n\n// Types\n\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_1___default.a.extend({\n    name: \'rippleable\',\n    directives: { Ripple: _directives_ripple__WEBPACK_IMPORTED_MODULE_0__["default"] },\n    props: {\n        ripple: {\n            type: [Boolean, Object],\n            default: true\n        }\n    },\n    methods: {\n        genRipple: function genRipple(data) {\n            if (data === void 0) {\n                data = {};\n            }\n            if (!this.ripple) return null;\n            data.staticClass = \'v-input--selection-controls__ripple\';\n            data.directives = data.directives || [];\n            data.directives.push({\n                name: \'ripple\',\n                value: { center: true }\n            });\n            data.on = Object.assign({\n                click: this.onChange\n            }, this.$listeners);\n            return this.$createElement(\'div\', data);\n        },\n        onChange: function onChange() {}\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/routable.ts":\n/*!********************************!*\\\n  !*** ./src/mixins/routable.ts ***!\n  \\********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _directives_ripple__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../directives/ripple */ "./src/directives/ripple.ts");\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'routable\',\n    directives: {\n        Ripple: _directives_ripple__WEBPACK_IMPORTED_MODULE_1__["default"]\n    },\n    props: {\n        activeClass: String,\n        append: Boolean,\n        disabled: Boolean,\n        exact: {\n            type: Boolean,\n            default: undefined\n        },\n        exactActiveClass: String,\n        href: [String, Object],\n        to: [String, Object],\n        nuxt: Boolean,\n        replace: Boolean,\n        ripple: [Boolean, Object],\n        tag: String,\n        target: String\n    },\n    computed: {\n        computedRipple: function computedRipple() {\n            return this.ripple && !this.disabled ? this.ripple : false;\n        }\n    },\n    methods: {\n        /* eslint-disable-next-line no-unused-vars */\n        click: function click(e) {},\n        generateRouteLink: function generateRouteLink(classes) {\n            var _a;\n            var exact = this.exact;\n            var tag;\n            var data = (_a = {\n                attrs: { disabled: this.disabled },\n                class: classes,\n                props: {},\n                directives: [{\n                    name: \'ripple\',\n                    value: this.computedRipple\n                }]\n            }, _a[this.to ? \'nativeOn\' : \'on\'] = __assign({}, this.$listeners, { click: this.click }), _a);\n            if (typeof this.exact === \'undefined\') {\n                exact = this.to === \'/\' || this.to === Object(this.to) && this.to.path === \'/\';\n            }\n            if (this.to) {\n                // Add a special activeClass hook\n                // for component level styles\n                var activeClass = this.activeClass;\n                var exactActiveClass = this.exactActiveClass || activeClass;\n                // TODO: apply only in VListTile\n                if (this.proxyClass) {\n                    activeClass += \' \' + this.proxyClass;\n                    exactActiveClass += \' \' + this.proxyClass;\n                }\n                tag = this.nuxt ? \'nuxt-link\' : \'router-link\';\n                Object.assign(data.props, {\n                    to: this.to,\n                    exact: exact,\n                    activeClass: activeClass,\n                    exactActiveClass: exactActiveClass,\n                    append: this.append,\n                    replace: this.replace\n                });\n            } else {\n                tag = this.href && \'a\' || this.tag || \'a\';\n                if (tag === \'a\' && this.href) data.attrs.href = this.href;\n            }\n            if (this.target) data.attrs.target = this.target;\n            return { tag: tag, data: data };\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/selectable.js":\n/*!**********************************!*\\\n  !*** ./src/mixins/selectable.js ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_VInput__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/VInput */ "./src/components/VInput/index.js");\n/* harmony import */ var _rippleable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rippleable */ "./src/mixins/rippleable.ts");\n/* harmony import */ var _comparable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./comparable */ "./src/mixins/comparable.ts");\n// Components\n\n// Mixins\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'selectable\',\n    extends: _components_VInput__WEBPACK_IMPORTED_MODULE_0__["default"],\n    mixins: [_rippleable__WEBPACK_IMPORTED_MODULE_1__["default"], _comparable__WEBPACK_IMPORTED_MODULE_2__["default"]],\n    model: {\n        prop: \'inputValue\',\n        event: \'change\'\n    },\n    props: {\n        color: {\n            type: String,\n            default: \'accent\'\n        },\n        id: String,\n        inputValue: null,\n        falseValue: null,\n        trueValue: null,\n        multiple: {\n            type: Boolean,\n            default: null\n        },\n        label: String\n    },\n    data: function data(vm) {\n        return {\n            lazyValue: vm.inputValue\n        };\n    },\n    computed: {\n        computedColor: function computedColor() {\n            return this.isActive ? this.color : this.validationState;\n        },\n        isMultiple: function isMultiple() {\n            return this.multiple === true || this.multiple === null && Array.isArray(this.internalValue);\n        },\n        isActive: function isActive() {\n            var _this = this;\n            var value = this.value;\n            var input = this.internalValue;\n            if (this.isMultiple) {\n                if (!Array.isArray(input)) return false;\n                return input.some(function (item) {\n                    return _this.valueComparator(item, value);\n                });\n            }\n            if (this.trueValue === undefined || this.falseValue === undefined) {\n                return value ? this.valueComparator(value, input) : Boolean(input);\n            }\n            return this.valueComparator(input, this.trueValue);\n        },\n        isDirty: function isDirty() {\n            return this.isActive;\n        }\n    },\n    watch: {\n        inputValue: function inputValue(val) {\n            this.lazyValue = val;\n        }\n    },\n    methods: {\n        genLabel: function genLabel() {\n            if (!this.hasLabel) return null;\n            var label = _components_VInput__WEBPACK_IMPORTED_MODULE_0__["default"].methods.genLabel.call(this);\n            label.data.on = { click: this.onChange };\n            return label;\n        },\n        genInput: function genInput(type, attrs) {\n            return this.$createElement(\'input\', {\n                attrs: Object.assign({\n                    \'aria-label\': this.label,\n                    \'aria-checked\': this.isActive.toString(),\n                    disabled: this.isDisabled,\n                    id: this.id,\n                    role: type,\n                    type: type\n                }, attrs),\n                domProps: {\n                    value: this.value,\n                    checked: this.isActive\n                },\n                on: {\n                    blur: this.onBlur,\n                    change: this.onChange,\n                    focus: this.onFocus,\n                    keydown: this.onKeydown\n                },\n                ref: \'input\'\n            });\n        },\n        onBlur: function onBlur() {\n            this.isFocused = false;\n        },\n        onChange: function onChange() {\n            var _this = this;\n            if (this.isDisabled) return;\n            var value = this.value;\n            var input = this.internalValue;\n            if (this.isMultiple) {\n                if (!Array.isArray(input)) {\n                    input = [];\n                }\n                var length = input.length;\n                input = input.filter(function (item) {\n                    return !_this.valueComparator(item, value);\n                });\n                if (input.length === length) {\n                    input.push(value);\n                }\n            } else if (this.trueValue !== undefined && this.falseValue !== undefined) {\n                input = this.valueComparator(input, this.trueValue) ? this.falseValue : this.trueValue;\n            } else if (value) {\n                input = this.valueComparator(input, value) ? null : value;\n            } else {\n                input = !input;\n            }\n            this.validate(true, input);\n            this.internalValue = input;\n        },\n        onFocus: function onFocus() {\n            this.isFocused = true;\n        },\n        /** @abstract */\n        onKeydown: function onKeydown(e) {}\n    }\n});\n\n/***/ }),\n\n/***/ "./src/mixins/sizeable.ts":\n/*!********************************!*\\\n  !*** ./src/mixins/sizeable.ts ***!\n  \\********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'sizeable\',\n    props: {\n        large: Boolean,\n        medium: Boolean,\n        size: {\n            type: [Number, String]\n        },\n        small: Boolean,\n        xLarge: Boolean\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/ssr-bootable.ts":\n/*!************************************!*\\\n  !*** ./src/mixins/ssr-bootable.ts ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * SSRBootable\n *\n * @mixin\n *\n * Used in layout components (drawer, toolbar, content)\n * to avoid an entry animation when using SSR\n */\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'ssr-bootable\',\n    data: function data() {\n        return {\n            isBooted: false\n        };\n    },\n    mounted: function mounted() {\n        var _this = this;\n        // Use setAttribute instead of dataset\n        // because dataset does not work well\n        // with unit tests\n        window.requestAnimationFrame(function () {\n            _this.$el.setAttribute(\'data-booted\', \'true\');\n            _this.isBooted = true;\n        });\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/stackable.js":\n/*!*********************************!*\\\n  !*** ./src/mixins/stackable.js ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/helpers */ "./src/util/helpers.ts");\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\nvar __spread = undefined && undefined.__spread || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) {\n        ar = ar.concat(__read(arguments[i]));\n    }return ar;\n};\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'stackable\',\n    data: function data() {\n        return {\n            stackBase: null,\n            stackClass: \'unpecified\',\n            stackElement: null,\n            stackExclude: null,\n            stackMinZIndex: 0\n        };\n    },\n    computed: {\n        /**\n         * Currently active z-index\n         *\n         * @return {number}\n         */\n        activeZIndex: function activeZIndex() {\n            if (typeof window === \'undefined\') return 0;\n            var content = this.stackElement || this.$refs.content;\n            // Return current zindex if not active\n            var index = !this.isActive ? Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["getZIndex"])(content) : this.getMaxZIndex(this.stackExclude || [content]) + 2;\n            if (index == null) return index;\n            // Return max current z-index (excluding self) + 2\n            // (2 to leave room for an overlay below, if needed)\n            return parseInt(index);\n        }\n    },\n    methods: {\n        getMaxZIndex: function getMaxZIndex(exclude) {\n            if (exclude === void 0) {\n                exclude = [];\n            }\n            var base = this.stackBase || this.$el;\n            // Start with lowest allowed z-index or z-index of\n            // base component\'s element, whichever is greater\n            var zis = [this.stackMinZIndex, Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["getZIndex"])(base)];\n            // Convert the NodeList to an array to\n            // prevent an Edge bug with Symbol.iterator\n            // https://github.com/vuetifyjs/vuetify/issues/2146\n            var activeElements = __spread(document.getElementsByClassName(this.stackClass));\n            // Get z-index for all active dialogs\n            for (var index = 0; index < activeElements.length; index++) {\n                if (!exclude.includes(activeElements[index])) {\n                    zis.push(Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["getZIndex"])(activeElements[index]));\n                }\n            }\n            return Math.max.apply(Math, __spread(zis));\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/mixins/themeable.ts":\n/*!*********************************!*\\\n  !*** ./src/mixins/themeable.ts ***!\n  \\*********************************/\n/*! exports provided: functionalThemeClasses, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "functionalThemeClasses", function() { return functionalThemeClasses; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\nfunction functionalThemeClasses(context) {\n    var vm = __assign({}, context.props, context.injections);\n    var isDark = Themeable.options.computed.isDark.call(vm);\n    return Themeable.options.computed.themeClasses.call({ isDark: isDark });\n}\n/* @vue/component */\nvar Themeable = vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend().extend({\n    name: \'themeable\',\n    provide: function provide() {\n        return {\n            theme: this.themeableProvide\n        };\n    },\n    inject: {\n        theme: {\n            default: {\n                isDark: false\n            }\n        }\n    },\n    props: {\n        dark: {\n            type: Boolean,\n            default: null\n        },\n        light: {\n            type: Boolean,\n            default: null\n        }\n    },\n    data: function data() {\n        return {\n            themeableProvide: {\n                isDark: false\n            }\n        };\n    },\n    computed: {\n        isDark: function isDark() {\n            if (this.dark === true) {\n                // explicitly dark\n                return true;\n            } else if (this.light === true) {\n                // explicitly light\n                return false;\n            } else {\n                // inherit from parent, or default false if there is none\n                return this.theme.isDark;\n            }\n        },\n        themeClasses: function themeClasses() {\n            return {\n                \'theme--dark\': this.isDark,\n                \'theme--light\': !this.isDark\n            };\n        },\n        /** Used by menus and dialogs, inherits from v-app instead of the parent */\n        rootIsDark: function rootIsDark() {\n            if (this.dark === true) {\n                // explicitly dark\n                return true;\n            } else if (this.light === true) {\n                // explicitly light\n                return false;\n            } else {\n                // inherit from v-app\n                return this.$vuetify.dark;\n            }\n        },\n        rootThemeClasses: function rootThemeClasses() {\n            return {\n                \'theme--dark\': this.rootIsDark,\n                \'theme--light\': !this.rootIsDark\n            };\n        }\n    },\n    watch: {\n        isDark: {\n            handler: function handler(newVal, oldVal) {\n                if (newVal !== oldVal) {\n                    this.themeableProvide.isDark = this.isDark;\n                }\n            },\n            immediate: true\n        }\n    }\n});\n/* harmony default export */ __webpack_exports__["default"] = (Themeable);\n\n/***/ }),\n\n/***/ "./src/mixins/toggleable.ts":\n/*!**********************************!*\\\n  !*** ./src/mixins/toggleable.ts ***!\n  \\**********************************/\n/*! exports provided: factory, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "factory", function() { return factory; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction factory(prop, event) {\n    if (prop === void 0) {\n        prop = \'value\';\n    }\n    if (event === void 0) {\n        event = \'input\';\n    }\n    var _a, _b;\n    return vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n        name: \'toggleable\',\n        model: { prop: prop, event: event },\n        props: (_a = {}, _a[prop] = { required: false }, _a),\n        data: function data() {\n            return {\n                isActive: !!this[prop]\n            };\n        },\n        watch: (_b = {}, _b[prop] = function (val) {\n            this.isActive = !!val;\n        }, _b.isActive = function (val) {\n            !!val !== this[prop] && this.$emit(event, val);\n        }, _b)\n    });\n}\n/* eslint-disable-next-line no-redeclare */\nvar Toggleable = factory();\n/* harmony default export */ __webpack_exports__["default"] = (Toggleable);\n\n/***/ }),\n\n/***/ "./src/mixins/transitionable.ts":\n/*!**************************************!*\\\n  !*** ./src/mixins/transitionable.ts ***!\n  \\**************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'transitionable\',\n    props: {\n        mode: String,\n        origin: String,\n        transition: String\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/translatable.ts":\n/*!************************************!*\\\n  !*** ./src/mixins/translatable.ts ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({\n    name: \'translatable\',\n    props: {\n        height: Number\n    },\n    data: function data() {\n        return {\n            elOffsetTop: 0,\n            parallax: 0,\n            parallaxDist: 0,\n            percentScrolled: 0,\n            scrollTop: 0,\n            windowHeight: 0,\n            windowBottom: 0\n        };\n    },\n    computed: {\n        imgHeight: function imgHeight() {\n            return this.objHeight();\n        }\n    },\n    beforeDestroy: function beforeDestroy() {\n        window.removeEventListener(\'scroll\', this.translate, false);\n        window.removeEventListener(\'resize\', this.translate, false);\n    },\n    methods: {\n        calcDimensions: function calcDimensions() {\n            var offset = this.$el.getBoundingClientRect();\n            this.scrollTop = window.pageYOffset;\n            this.parallaxDist = this.imgHeight - this.height;\n            this.elOffsetTop = offset.top + this.scrollTop;\n            this.windowHeight = window.innerHeight;\n            this.windowBottom = this.scrollTop + this.windowHeight;\n        },\n        listeners: function listeners() {\n            window.addEventListener(\'scroll\', this.translate, false);\n            window.addEventListener(\'resize\', this.translate, false);\n        },\n        /** @abstract **/\n        objHeight: function objHeight() {\n            throw new Error(\'Not implemented !\');\n        },\n        translate: function translate() {\n            this.calcDimensions();\n            this.percentScrolled = (this.windowBottom - this.elOffsetTop) / (parseInt(this.height) + this.windowHeight);\n            this.parallax = Math.round(this.parallaxDist * this.percentScrolled);\n        }\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/mixins/validatable.js":\n/*!***********************************!*\\\n  !*** ./src/mixins/validatable.js ***!\n  \\***********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/helpers */ "./src/util/helpers.ts");\n/* harmony import */ var _registrable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./registrable */ "./src/mixins/registrable.ts");\n/* harmony import */ var _util_console__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/console */ "./src/util/console.ts");\n/* harmony import */ var _colorable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorable */ "./src/mixins/colorable.ts");\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\n\n\n\n// Mixins\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = ({\n    name: \'validatable\',\n    mixins: [_colorable__WEBPACK_IMPORTED_MODULE_3__["default"], Object(_registrable__WEBPACK_IMPORTED_MODULE_1__["inject"])(\'form\')],\n    props: {\n        disabled: Boolean,\n        error: Boolean,\n        errorCount: {\n            type: [Number, String],\n            default: 1\n        },\n        errorMessages: {\n            type: [String, Array],\n            default: function _default() {\n                return [];\n            }\n        },\n        messages: {\n            type: [String, Array],\n            default: function _default() {\n                return [];\n            }\n        },\n        readonly: Boolean,\n        rules: {\n            type: Array,\n            default: function _default() {\n                return [];\n            }\n        },\n        success: Boolean,\n        successMessages: {\n            type: [String, Array],\n            default: function _default() {\n                return [];\n            }\n        },\n        validateOnBlur: Boolean\n    },\n    data: function data() {\n        return {\n            errorBucket: [],\n            hasColor: false,\n            hasFocused: false,\n            hasInput: false,\n            isFocused: false,\n            isResetting: false,\n            valid: false\n        };\n    },\n    computed: {\n        hasError: function hasError() {\n            return this.internalErrorMessages.length > 0 || this.errorBucket.length > 0 || this.error;\n        },\n        externalError: function externalError() {\n            return this.internalErrorMessages.length > 0 || this.error;\n        },\n        // TODO: Add logic that allows the user to enable based\n        // upon a good validation\n        hasSuccess: function hasSuccess() {\n            return this.successMessages.length > 0 || this.success;\n        },\n        hasMessages: function hasMessages() {\n            return this.validations.length > 0;\n        },\n        hasState: function hasState() {\n            return this.hasSuccess || this.shouldValidate && this.hasError;\n        },\n        internalErrorMessages: function internalErrorMessages() {\n            return this.errorMessages || \'\';\n        },\n        shouldValidate: function shouldValidate() {\n            return this.externalError || !this.isResetting && (this.validateOnBlur ? this.hasFocused && !this.isFocused : this.hasInput || this.hasFocused);\n        },\n        validations: function validations() {\n            return this.validationTarget.slice(0, this.errorCount);\n        },\n        validationState: function validationState() {\n            if (this.hasError && this.shouldValidate) return \'error\';\n            if (this.hasSuccess) return \'success\';\n            if (this.hasColor) return this.color;\n            return null;\n        },\n        validationTarget: function validationTarget() {\n            var target = this.internalErrorMessages.length > 0 ? this.errorMessages : this.successMessages.length > 0 ? this.successMessages : this.messages;\n            // String\n            if (!Array.isArray(target)) {\n                return [target];\n                // Array with items\n            } else if (target.length > 0) {\n                return target;\n                // Currently has validation\n            } else if (this.shouldValidate) {\n                return this.errorBucket;\n            } else {\n                return [];\n            }\n        }\n    },\n    watch: {\n        rules: {\n            handler: function handler(newVal, oldVal) {\n                if (Object(_util_helpers__WEBPACK_IMPORTED_MODULE_0__["deepEqual"])(newVal, oldVal)) return;\n                this.validate();\n            },\n            deep: true\n        },\n        internalValue: function internalValue() {\n            // If it\'s the first time we\'re setting input,\n            // mark it with hasInput\n            this.hasInput = true;\n            this.validateOnBlur || this.$nextTick(this.validate);\n        },\n        isFocused: function isFocused(val) {\n            // Should not check validation\n            // if disabled or readonly\n            if (!val && !this.disabled && !this.readonly) {\n                this.hasFocused = true;\n                this.validateOnBlur && this.validate();\n            }\n        },\n        isResetting: function isResetting() {\n            var _this = this;\n            setTimeout(function () {\n                _this.hasInput = false;\n                _this.hasFocused = false;\n                _this.isResetting = false;\n            }, 0);\n        },\n        hasError: function hasError(val) {\n            if (this.shouldValidate) {\n                this.$emit(\'update:error\', val);\n            }\n        }\n    },\n    beforeMount: function beforeMount() {\n        this.validate();\n    },\n    created: function created() {\n        this.form && this.form.register(this);\n    },\n    beforeDestroy: function beforeDestroy() {\n        this.form && this.form.unregister(this);\n    },\n    methods: {\n        /** @public */\n        reset: function reset() {\n            this.isResetting = true;\n            this.internalValue = Array.isArray(this.internalValue) ? [] : undefined;\n        },\n        /** @public */\n        resetValidation: function resetValidation() {\n            this.isResetting = true;\n        },\n        /** @public */\n        validate: function validate(force, value) {\n            if (force === void 0) {\n                force = false;\n            }\n            if (value === void 0) {\n                value = this.internalValue;\n            }\n            var errorBucket = [];\n            if (force) this.hasInput = this.hasFocused = true;\n            for (var index = 0; index < this.rules.length; index++) {\n                var rule = this.rules[index];\n                var valid = typeof rule === \'function\' ? rule(value) : rule;\n                if (valid === false || typeof valid === \'string\') {\n                    errorBucket.push(valid);\n                } else if (valid !== true) {\n                    Object(_util_console__WEBPACK_IMPORTED_MODULE_2__["consoleError"])("Rules should return a string or boolean, received \'" + (typeof valid === \'undefined\' ? \'undefined\' : _typeof(valid)) + "\' instead", this);\n                }\n            }\n            this.errorBucket = errorBucket;\n            this.valid = errorBucket.length === 0;\n            return this.valid;\n        }\n    }\n});\n\n/***/ }),\n\n/***/ "./src/stylus/app.styl":\n/*!*****************************!*\\\n  !*** ./src/stylus/app.styl ***!\n  \\*****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_alerts.styl":\n/*!********************************************!*\\\n  !*** ./src/stylus/components/_alerts.styl ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_app.styl":\n/*!*****************************************!*\\\n  !*** ./src/stylus/components/_app.styl ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_autocompletes.styl":\n/*!***************************************************!*\\\n  !*** ./src/stylus/components/_autocompletes.styl ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_avatars.styl":\n/*!*********************************************!*\\\n  !*** ./src/stylus/components/_avatars.styl ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_badges.styl":\n/*!********************************************!*\\\n  !*** ./src/stylus/components/_badges.styl ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_bottom-navs.styl":\n/*!*************************************************!*\\\n  !*** ./src/stylus/components/_bottom-navs.styl ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_bottom-sheets.styl":\n/*!***************************************************!*\\\n  !*** ./src/stylus/components/_bottom-sheets.styl ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_breadcrumbs.styl":\n/*!*************************************************!*\\\n  !*** ./src/stylus/components/_breadcrumbs.styl ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_button-toggle.styl":\n/*!***************************************************!*\\\n  !*** ./src/stylus/components/_button-toggle.styl ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_buttons.styl":\n/*!*********************************************!*\\\n  !*** ./src/stylus/components/_buttons.styl ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_cards.styl":\n/*!*******************************************!*\\\n  !*** ./src/stylus/components/_cards.styl ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_carousel.styl":\n/*!**********************************************!*\\\n  !*** ./src/stylus/components/_carousel.styl ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_chips.styl":\n/*!*******************************************!*\\\n  !*** ./src/stylus/components/_chips.styl ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_content.styl":\n/*!*********************************************!*\\\n  !*** ./src/stylus/components/_content.styl ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_counters.styl":\n/*!**********************************************!*\\\n  !*** ./src/stylus/components/_counters.styl ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_data-iterator.styl":\n/*!***************************************************!*\\\n  !*** ./src/stylus/components/_data-iterator.styl ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_data-table.styl":\n/*!************************************************!*\\\n  !*** ./src/stylus/components/_data-table.styl ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_date-picker-header.styl":\n/*!********************************************************!*\\\n  !*** ./src/stylus/components/_date-picker-header.styl ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_date-picker-table.styl":\n/*!*******************************************************!*\\\n  !*** ./src/stylus/components/_date-picker-table.styl ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_date-picker-title.styl":\n/*!*******************************************************!*\\\n  !*** ./src/stylus/components/_date-picker-title.styl ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_date-picker-years.styl":\n/*!*******************************************************!*\\\n  !*** ./src/stylus/components/_date-picker-years.styl ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_dialogs.styl":\n/*!*********************************************!*\\\n  !*** ./src/stylus/components/_dialogs.styl ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_dividers.styl":\n/*!**********************************************!*\\\n  !*** ./src/stylus/components/_dividers.styl ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_expansion-panel.styl":\n/*!*****************************************************!*\\\n  !*** ./src/stylus/components/_expansion-panel.styl ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_footer.styl":\n/*!********************************************!*\\\n  !*** ./src/stylus/components/_footer.styl ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_forms.styl":\n/*!*******************************************!*\\\n  !*** ./src/stylus/components/_forms.styl ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_grid.styl":\n/*!******************************************!*\\\n  !*** ./src/stylus/components/_grid.styl ***!\n  \\******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_icons.styl":\n/*!*******************************************!*\\\n  !*** ./src/stylus/components/_icons.styl ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_images.styl":\n/*!********************************************!*\\\n  !*** ./src/stylus/components/_images.styl ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_inputs.styl":\n/*!********************************************!*\\\n  !*** ./src/stylus/components/_inputs.styl ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_item-group.styl":\n/*!************************************************!*\\\n  !*** ./src/stylus/components/_item-group.styl ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_jumbotrons.styl":\n/*!************************************************!*\\\n  !*** ./src/stylus/components/_jumbotrons.styl ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_labels.styl":\n/*!********************************************!*\\\n  !*** ./src/stylus/components/_labels.styl ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_lists.styl":\n/*!*******************************************!*\\\n  !*** ./src/stylus/components/_lists.styl ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_menus.styl":\n/*!*******************************************!*\\\n  !*** ./src/stylus/components/_menus.styl ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_messages.styl":\n/*!**********************************************!*\\\n  !*** ./src/stylus/components/_messages.styl ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_navigation-drawer.styl":\n/*!*******************************************************!*\\\n  !*** ./src/stylus/components/_navigation-drawer.styl ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_overflow-buttons.styl":\n/*!******************************************************!*\\\n  !*** ./src/stylus/components/_overflow-buttons.styl ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_overlay.styl":\n/*!*********************************************!*\\\n  !*** ./src/stylus/components/_overlay.styl ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_pagination.styl":\n/*!************************************************!*\\\n  !*** ./src/stylus/components/_pagination.styl ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_parallax.styl":\n/*!**********************************************!*\\\n  !*** ./src/stylus/components/_parallax.styl ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_pickers.styl":\n/*!*********************************************!*\\\n  !*** ./src/stylus/components/_pickers.styl ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_progress-circular.styl":\n/*!*******************************************************!*\\\n  !*** ./src/stylus/components/_progress-circular.styl ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_progress-linear.styl":\n/*!*****************************************************!*\\\n  !*** ./src/stylus/components/_progress-linear.styl ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_radio-group.styl":\n/*!*************************************************!*\\\n  !*** ./src/stylus/components/_radio-group.styl ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_radios.styl":\n/*!********************************************!*\\\n  !*** ./src/stylus/components/_radios.styl ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_range-sliders.styl":\n/*!***************************************************!*\\\n  !*** ./src/stylus/components/_range-sliders.styl ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_rating.styl":\n/*!********************************************!*\\\n  !*** ./src/stylus/components/_rating.styl ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_responsive.styl":\n/*!************************************************!*\\\n  !*** ./src/stylus/components/_responsive.styl ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_select.styl":\n/*!********************************************!*\\\n  !*** ./src/stylus/components/_select.styl ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_selection-controls.styl":\n/*!********************************************************!*\\\n  !*** ./src/stylus/components/_selection-controls.styl ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_sliders.styl":\n/*!*********************************************!*\\\n  !*** ./src/stylus/components/_sliders.styl ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_small-dialog.styl":\n/*!**************************************************!*\\\n  !*** ./src/stylus/components/_small-dialog.styl ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_snackbars.styl":\n/*!***********************************************!*\\\n  !*** ./src/stylus/components/_snackbars.styl ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_speed-dial.styl":\n/*!************************************************!*\\\n  !*** ./src/stylus/components/_speed-dial.styl ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_steppers.styl":\n/*!**********************************************!*\\\n  !*** ./src/stylus/components/_steppers.styl ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_subheaders.styl":\n/*!************************************************!*\\\n  !*** ./src/stylus/components/_subheaders.styl ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_switch.styl":\n/*!********************************************!*\\\n  !*** ./src/stylus/components/_switch.styl ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_system-bars.styl":\n/*!*************************************************!*\\\n  !*** ./src/stylus/components/_system-bars.styl ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_tables.styl":\n/*!********************************************!*\\\n  !*** ./src/stylus/components/_tables.styl ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_tabs.styl":\n/*!******************************************!*\\\n  !*** ./src/stylus/components/_tabs.styl ***!\n  \\******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_text-fields.styl":\n/*!*************************************************!*\\\n  !*** ./src/stylus/components/_text-fields.styl ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_textarea.styl":\n/*!**********************************************!*\\\n  !*** ./src/stylus/components/_textarea.styl ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_time-picker-clock.styl":\n/*!*******************************************************!*\\\n  !*** ./src/stylus/components/_time-picker-clock.styl ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_time-picker-title.styl":\n/*!*******************************************************!*\\\n  !*** ./src/stylus/components/_time-picker-title.styl ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_timeline.styl":\n/*!**********************************************!*\\\n  !*** ./src/stylus/components/_timeline.styl ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_toolbar.styl":\n/*!*********************************************!*\\\n  !*** ./src/stylus/components/_toolbar.styl ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_tooltips.styl":\n/*!**********************************************!*\\\n  !*** ./src/stylus/components/_tooltips.styl ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_treeview.styl":\n/*!**********************************************!*\\\n  !*** ./src/stylus/components/_treeview.styl ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/stylus/components/_windows.styl":\n/*!*********************************************!*\\\n  !*** ./src/stylus/components/_windows.styl ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ "./src/util/ThemeProvider.ts":\n/*!***********************************!*\\\n  !*** ./src/util/ThemeProvider.ts ***!\n  \\***********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mixins_themeable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mixins/themeable */ "./src/mixins/themeable.ts");\n/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mixins */ "./src/util/mixins.ts");\n\n\n/* @vue/component */\n/* harmony default export */ __webpack_exports__["default"] = (Object(_mixins__WEBPACK_IMPORTED_MODULE_1__["default"])(_mixins_themeable__WEBPACK_IMPORTED_MODULE_0__["default"]).extend({\n    name: \'theme-provider\',\n    props: {\n        root: Boolean\n    },\n    computed: {\n        isDark: function isDark() {\n            return this.root ? this.rootIsDark : _mixins_themeable__WEBPACK_IMPORTED_MODULE_0__["default"].options.computed.isDark.call(this);\n        }\n    },\n    render: function render() {\n        return this.$slots.default && this.$slots.default.find(function (node) {\n            return !node.isComment && node.text !== \' \';\n        });\n    }\n}));\n\n/***/ }),\n\n/***/ "./src/util/color/transformCIELAB.ts":\n/*!*******************************************!*\\\n  !*** ./src/util/color/transformCIELAB.ts ***!\n  \\*******************************************/\n/*! exports provided: fromXYZ, toXYZ */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXYZ", function() { return fromXYZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toXYZ", function() { return toXYZ; });\nvar delta = 0.20689655172413793; // 629\nvar cielabForwardTransform = function cielabForwardTransform(t) {\n    return t > Math.pow(delta, 3) ? Math.cbrt(t) : t / (3 * Math.pow(delta, 2)) + 4 / 29;\n};\nvar cielabReverseTransform = function cielabReverseTransform(t) {\n    return t > delta ? Math.pow(t, 3) : 3 * Math.pow(delta, 2) * (t - 4 / 29);\n};\nfunction fromXYZ(xyz) {\n    var transform = cielabForwardTransform;\n    var transformedY = transform(xyz[1]);\n    return [116 * transformedY - 16, 500 * (transform(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform(xyz[2] / 1.08883))];\n}\nfunction toXYZ(lab) {\n    var transform = cielabReverseTransform;\n    var Ln = (lab[0] + 16) / 116;\n    return [transform(Ln + lab[1] / 500) * 0.95047, transform(Ln), transform(Ln - lab[2] / 200) * 1.08883];\n}\n\n/***/ }),\n\n/***/ "./src/util/color/transformSRGB.ts":\n/*!*****************************************!*\\\n  !*** ./src/util/color/transformSRGB.ts ***!\n  \\*****************************************/\n/*! exports provided: fromXYZ, toXYZ */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXYZ", function() { return fromXYZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toXYZ", function() { return toXYZ; });\n// For converting XYZ to sRGB\nvar srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.2040, 1.0570]];\n// Forward gamma adjust\nvar srgbForwardTransform = function srgbForwardTransform(C) {\n    return C <= 0.0031308 ? C * 12.92 : 1.055 * Math.pow(C, 1 / 2.4) - 0.055;\n};\n// For converting sRGB to XYZ\nvar srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];\n// Reverse gamma adjust\nvar srgbReverseTransform = function srgbReverseTransform(C) {\n    return C <= 0.04045 ? C / 12.92 : Math.pow((C + 0.055) / 1.055, 2.4);\n};\nfunction clamp(value) {\n    return Math.max(0, Math.min(1, value));\n}\nfunction fromXYZ(xyz) {\n    var rgb = Array(3);\n    var transform = srgbForwardTransform;\n    var matrix = srgbForwardMatrix;\n    // Matrix transform, then gamma adjustment\n    for (var i = 0; i < 3; ++i) {\n        rgb[i] = Math.round(clamp(transform(matrix[i][0] * xyz[0] + matrix[i][1] * xyz[1] + matrix[i][2] * xyz[2])) * 255);\n    }\n    // Rescale back to [0, 255]\n    return (rgb[0] << 16) + (rgb[1] << 8) + (rgb[2] << 0);\n}\nfunction toXYZ(rgb) {\n    var xyz = [0, 0, 0];\n    var transform = srgbReverseTransform;\n    var matrix = srgbReverseMatrix;\n    // Rescale from [0, 255] to [0, 1] then adjust sRGB gamma to linear RGB\n    var r = transform((rgb >> 16 & 0xff) / 255);\n    var g = transform((rgb >> 8 & 0xff) / 255);\n    var b = transform((rgb >> 0 & 0xff) / 255);\n    // Matrix color space transform\n    for (var i = 0; i < 3; ++i) {\n        xyz[i] = matrix[i][0] * r + matrix[i][1] * g + matrix[i][2] * b;\n    }\n    return xyz;\n}\n\n/***/ }),\n\n/***/ "./src/util/colorUtils.ts":\n/*!********************************!*\\\n  !*** ./src/util/colorUtils.ts ***!\n  \\********************************/\n/*! exports provided: colorToInt, intToHex, colorToHex */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorToInt", function() { return colorToInt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intToHex", function() { return intToHex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorToHex", function() { return colorToHex; });\n/* harmony import */ var _console__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./console */ "./src/util/console.ts");\n\nfunction colorToInt(color) {\n    var rgb;\n    if (typeof color === \'number\') {\n        rgb = color;\n    } else if (typeof color === \'string\') {\n        var c = color[0] === \'#\' ? color.substring(1) : color;\n        if (c.length === 3) {\n            c = c.split(\'\').map(function (char) {\n                return char + char;\n            }).join(\'\');\n        }\n        if (c.length !== 6) {\n            Object(_console__WEBPACK_IMPORTED_MODULE_0__["consoleWarn"])("\'" + color + "\' is not a valid rgb color");\n        }\n        rgb = parseInt(c, 16);\n    } else {\n        throw new TypeError("Colors can only be numbers or strings, recieved " + (color == null ? color : color.constructor.name) + " instead");\n    }\n    if (rgb < 0) {\n        Object(_console__WEBPACK_IMPORTED_MODULE_0__["consoleWarn"])("Colors cannot be negative: \'" + color + "\'");\n        rgb = 0;\n    } else if (rgb > 0xffffff || isNaN(rgb)) {\n        Object(_console__WEBPACK_IMPORTED_MODULE_0__["consoleWarn"])("\'" + color + "\' is not a valid rgb color");\n        rgb = 0xffffff;\n    }\n    return rgb;\n}\nfunction intToHex(color) {\n    var hexColor = color.toString(16);\n    if (hexColor.length < 6) hexColor = \'0\'.repeat(6 - hexColor.length) + hexColor;\n    return \'#\' + hexColor;\n}\nfunction colorToHex(color) {\n    return intToHex(colorToInt(color));\n}\n\n/***/ }),\n\n/***/ "./src/util/console.ts":\n/*!*****************************!*\\\n  !*** ./src/util/console.ts ***!\n  \\*****************************/\n/*! exports provided: consoleInfo, consoleWarn, consoleError, deprecate */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "consoleInfo", function() { return consoleInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "consoleWarn", function() { return consoleWarn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "consoleError", function() { return consoleError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deprecate", function() { return deprecate; });\nfunction createMessage(message, vm, parent) {\n    if (parent) {\n        vm = {\n            _isVue: true,\n            $parent: parent,\n            $options: vm\n        };\n    }\n    if (vm) {\n        // Only show each message once per instance\n        vm.$_alreadyWarned = vm.$_alreadyWarned || [];\n        if (vm.$_alreadyWarned.includes(message)) return;\n        vm.$_alreadyWarned.push(message);\n    }\n    return "[Vuetify] " + message + (vm ? generateComponentTrace(vm) : \'\');\n}\nfunction consoleInfo(message, vm, parent) {\n    var newMessage = createMessage(message, vm, parent);\n    newMessage != null && console.info(newMessage);\n}\nfunction consoleWarn(message, vm, parent) {\n    var newMessage = createMessage(message, vm, parent);\n    newMessage != null && console.warn(newMessage);\n}\nfunction consoleError(message, vm, parent) {\n    var newMessage = createMessage(message, vm, parent);\n    newMessage != null && console.error(newMessage);\n}\nfunction deprecate(original, replacement, vm, parent) {\n    consoleWarn("\'" + original + "\' is deprecated, use \'" + replacement + "\' instead", vm, parent);\n}\n/**\n * Shamelessly stolen from vuejs/vue/blob/dev/src/core/util/debug.js\n */\nvar classifyRE = /(?:^|[-_])(\\w)/g;\nvar classify = function classify(str) {\n    return str.replace(classifyRE, function (c) {\n        return c.toUpperCase();\n    }).replace(/[-_]/g, \'\');\n};\nfunction formatComponentName(vm, includeFile) {\n    if (vm.$root === vm) {\n        return \'<Root>\';\n    }\n    var options = typeof vm === \'function\' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n    }\n    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : \'\');\n}\nfunction generateComponentTrace(vm) {\n    if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n        while (vm) {\n            if (tree.length > 0) {\n                var last = tree[tree.length - 1];\n                if (last.constructor === vm.constructor) {\n                    currentRecursiveSequence++;\n                    vm = vm.$parent;\n                    continue;\n                } else if (currentRecursiveSequence > 0) {\n                    tree[tree.length - 1] = [last, currentRecursiveSequence];\n                    currentRecursiveSequence = 0;\n                }\n            }\n            tree.push(vm);\n            vm = vm.$parent;\n        }\n        return \'\\n\\nfound in\\n\\n\' + tree.map(function (vm, i) {\n            return "" + (i === 0 ? \'---\x3e \' : \' \'.repeat(5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));\n        }).join(\'\\n\');\n    } else {\n        return "\\n\\n(found in " + formatComponentName(vm) + ")";\n    }\n}\n\n/***/ }),\n\n/***/ "./src/util/dedupeModelListeners.ts":\n/*!******************************************!*\\\n  !*** ./src/util/dedupeModelListeners.ts ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return dedupeModelListeners; });\n/**\n * Removes duplicate `@input` listeners when\n * using v-model with functional components\n *\n * @see https://github.com/vuetifyjs/vuetify/issues/4460\n */\nfunction dedupeModelListeners(data) {\n    if (data.model && data.on && data.on.input) {\n        if (Array.isArray(data.on.input)) {\n            var i = data.on.input.indexOf(data.model.callback);\n            if (i > -1) data.on.input.splice(i, 1);\n        } else {\n            delete data.on.input;\n        }\n    }\n}\n\n/***/ }),\n\n/***/ "./src/util/easing-patterns.js":\n/*!*************************************!*\\\n  !*** ./src/util/easing-patterns.js ***!\n  \\*************************************/\n/*! exports provided: linear, easeInQuad, easeOutQuad, easeInOutQuad, easeInCubic, easeOutCubic, easeInOutCubic, easeInQuart, easeOutQuart, easeInOutQuart, easeInQuint, easeOutQuint, easeInOutQuint */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeInQuad", function() { return easeInQuad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeOutQuad", function() { return easeOutQuad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeInOutQuad", function() { return easeInOutQuad; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeInCubic", function() { return easeInCubic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeOutCubic", function() { return easeOutCubic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeInOutCubic", function() { return easeInOutCubic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeInQuart", function() { return easeInQuart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeOutQuart", function() { return easeOutQuart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeInOutQuart", function() { return easeInOutQuart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeInQuint", function() { return easeInQuint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeOutQuint", function() { return easeOutQuint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeInOutQuint", function() { return easeInOutQuint; });\n// linear\nvar linear = function linear(t) {\n  return t;\n};\n// accelerating from zero velocity\nvar easeInQuad = function easeInQuad(t) {\n  return t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuad = function easeOutQuad(t) {\n  return t * (2 - t);\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuad = function easeInOutQuad(t) {\n  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n};\n// accelerating from zero velocity\nvar easeInCubic = function easeInCubic(t) {\n  return t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutCubic = function easeOutCubic(t) {\n  return --t * t * t + 1;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutCubic = function easeInOutCubic(t) {\n  return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n};\n// accelerating from zero velocity\nvar easeInQuart = function easeInQuart(t) {\n  return t * t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuart = function easeOutQuart(t) {\n  return 1 - --t * t * t * t;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuart = function easeInOutQuart(t) {\n  return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n};\n// accelerating from zero velocity\nvar easeInQuint = function easeInQuint(t) {\n  return t * t * t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuint = function easeOutQuint(t) {\n  return 1 + --t * t * t * t * t;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuint = function easeInOutQuint(t) {\n  return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n};\n\n/***/ }),\n\n/***/ "./src/util/helpers.ts":\n/*!*****************************!*\\\n  !*** ./src/util/helpers.ts ***!\n  \\*****************************/\n/*! exports provided: createSimpleFunctional, createSimpleTransition, createJavaScriptTransition, directiveConfig, addOnceEventListener, getNestedValue, deepEqual, getObjectValueByPath, getPropertyFromItem, createRange, getZIndex, escapeHTML, filterObjectOnKeys, filterChildren, convertToUnit, kebabCase, isObject, keyCodes, remapInternalIcon, keys, camelize */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSimpleFunctional", function() { return createSimpleFunctional; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSimpleTransition", function() { return createSimpleTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createJavaScriptTransition", function() { return createJavaScriptTransition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "directiveConfig", function() { return directiveConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addOnceEventListener", function() { return addOnceEventListener; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNestedValue", function() { return getNestedValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepEqual", function() { return deepEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getObjectValueByPath", function() { return getObjectValueByPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPropertyFromItem", function() { return getPropertyFromItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRange", function() { return createRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getZIndex", function() { return getZIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "escapeHTML", function() { return escapeHTML; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterObjectOnKeys", function() { return filterObjectOnKeys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterChildren", function() { return filterChildren; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToUnit", function() { return convertToUnit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kebabCase", function() { return kebabCase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keyCodes", function() { return keyCodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remapInternalIcon", function() { return remapInternalIcon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return keys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "camelize", function() { return camelize; });\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) {\n                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction createSimpleFunctional(c, el, name) {\n    if (el === void 0) {\n        el = \'div\';\n    }\n    return {\n        name: name || c.replace(/__/g, \'-\'),\n        functional: true,\n        render: function render(h, _a) {\n            var data = _a.data,\n                children = _a.children;\n            data.staticClass = (c + " " + (data.staticClass || \'\')).trim();\n            return h(el, data, children);\n        }\n    };\n}\nfunction mergeTransitions(transitions, array) {\n    if (Array.isArray(transitions)) return transitions.concat(array);\n    if (transitions) array.push(transitions);\n    return array;\n}\nfunction createSimpleTransition(name, origin, mode) {\n    if (origin === void 0) {\n        origin = \'top center 0\';\n    }\n    return {\n        name: name,\n        functional: true,\n        props: {\n            group: {\n                type: Boolean,\n                default: false\n            },\n            hideOnLeave: {\n                type: Boolean,\n                default: false\n            },\n            leaveAbsolute: {\n                type: Boolean,\n                default: false\n            },\n            mode: {\n                type: String,\n                default: mode\n            },\n            origin: {\n                type: String,\n                default: origin\n            }\n        },\n        render: function render(h, context) {\n            var tag = "transition" + (context.props.group ? \'-group\' : \'\');\n            context.data = context.data || {};\n            context.data.props = {\n                name: name,\n                mode: context.props.mode\n            };\n            context.data.on = context.data.on || {};\n            if (!Object.isExtensible(context.data.on)) {\n                context.data.on = __assign({}, context.data.on);\n            }\n            var ourBeforeEnter = [];\n            var ourLeave = [];\n            var absolute = function absolute(el) {\n                return el.style.position = \'absolute\';\n            };\n            ourBeforeEnter.push(function (el) {\n                el.style.transformOrigin = context.props.origin;\n                el.style.webkitTransformOrigin = context.props.origin;\n            });\n            if (context.props.leaveAbsolute) ourLeave.push(absolute);\n            if (context.props.hideOnLeave) {\n                ourLeave.push(function (el) {\n                    return el.style.display = \'none\';\n                });\n            }\n            var _a = context.data.on,\n                beforeEnter = _a.beforeEnter,\n                leave = _a.leave;\n            // Type says Function | Function[] but\n            // will only work if provided a function\n            context.data.on.beforeEnter = function () {\n                return mergeTransitions(beforeEnter, ourBeforeEnter);\n            };\n            context.data.on.leave = mergeTransitions(leave, ourLeave);\n            return h(tag, context.data, context.children);\n        }\n    };\n}\nfunction createJavaScriptTransition(name, functions, mode) {\n    if (mode === void 0) {\n        mode = \'in-out\';\n    }\n    return {\n        name: name,\n        functional: true,\n        props: {\n            mode: {\n                type: String,\n                default: mode\n            }\n        },\n        render: function render(h, context) {\n            var data = {\n                props: __assign({}, context.props, { name: name }),\n                on: functions\n            };\n            return h(\'transition\', data, context.children);\n        }\n    };\n}\nfunction directiveConfig(binding, defaults) {\n    if (defaults === void 0) {\n        defaults = {};\n    }\n    return __assign({}, defaults, binding.modifiers, { value: binding.arg }, binding.value || {});\n}\nfunction addOnceEventListener(el, event, cb) {\n    var once = function once() {\n        cb();\n        el.removeEventListener(event, once, false);\n    };\n    el.addEventListener(event, once, false);\n}\nfunction getNestedValue(obj, path, fallback) {\n    var last = path.length - 1;\n    if (last < 0) return obj === undefined ? fallback : obj;\n    for (var i = 0; i < last; i++) {\n        if (obj == null) {\n            return fallback;\n        }\n        obj = obj[path[i]];\n    }\n    if (obj == null) return fallback;\n    return obj[path[last]] === undefined ? fallback : obj[path[last]];\n}\nfunction deepEqual(a, b) {\n    if (a === b) return true;\n    if (a instanceof Date && b instanceof Date) {\n        // If the values are Date, they were convert to timestamp with getTime and compare it\n        if (a.getTime() !== b.getTime()) return false;\n    }\n    if (a !== Object(a) || b !== Object(b)) {\n        // If the values aren\'t objects, they were already checked for equality\n        return false;\n    }\n    var props = Object.keys(a);\n    if (props.length !== Object.keys(b).length) {\n        // Different number of props, don\'t bother to check\n        return false;\n    }\n    return props.every(function (p) {\n        return deepEqual(a[p], b[p]);\n    });\n}\nfunction getObjectValueByPath(obj, path, fallback) {\n    // credit: http://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-with-string-key#comment55278413_6491621\n    if (!path || path.constructor !== String) return fallback;\n    path = path.replace(/\\[(\\w+)\\]/g, \'.$1\'); // convert indexes to properties\n    path = path.replace(/^\\./, \'\'); // strip a leading dot\n    return getNestedValue(obj, path.split(\'.\'), fallback);\n}\nfunction getPropertyFromItem(item, property, fallback) {\n    if (property == null) return item === undefined ? fallback : item;\n    if (item !== Object(item)) return fallback === undefined ? item : fallback;\n    if (typeof property === \'string\') return getObjectValueByPath(item, property, fallback);\n    if (Array.isArray(property)) return getNestedValue(item, property, fallback);\n    if (typeof property !== \'function\') return fallback;\n    var value = property(item, fallback);\n    return typeof value === \'undefined\' ? fallback : value;\n}\nfunction createRange(length) {\n    return Array.from({ length: length }, function (v, k) {\n        return k;\n    });\n}\nfunction getZIndex(el) {\n    if (!el || el.nodeType !== Node.ELEMENT_NODE) return 0;\n    var index = +window.getComputedStyle(el).getPropertyValue(\'z-index\');\n    if (isNaN(index)) return getZIndex(el.parentNode);\n    return index;\n}\nvar tagsToReplace = {\n    \'&\': \'&amp;\',\n    \'<\': \'&lt;\',\n    \'>\': \'&gt;\'\n};\nfunction escapeHTML(str) {\n    return str.replace(/[&<>]/g, function (tag) {\n        return tagsToReplace[tag] || tag;\n    });\n}\nfunction filterObjectOnKeys(obj, keys) {\n    var filtered = {};\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (typeof obj[key] !== \'undefined\') {\n            filtered[key] = obj[key];\n        }\n    }\n    return filtered;\n}\nfunction filterChildren(array, tag) {\n    if (array === void 0) {\n        array = [];\n    }\n    return array.filter(function (child) {\n        return child.componentOptions && child.componentOptions.Ctor.options.name === tag;\n    });\n}\nfunction convertToUnit(str, unit) {\n    if (unit === void 0) {\n        unit = \'px\';\n    }\n    if (str == null || str === \'\') {\n        return undefined;\n    } else if (isNaN(+str)) {\n        return String(str);\n    } else {\n        return "" + Number(str) + unit;\n    }\n}\nfunction kebabCase(str) {\n    return (str || \'\').replace(/([a-z])([A-Z])/g, \'$1-$2\').toLowerCase();\n}\nfunction isObject(obj) {\n    return obj !== null && (typeof obj === \'undefined\' ? \'undefined\' : _typeof(obj)) === \'object\';\n}\n// KeyboardEvent.keyCode aliases\nvar keyCodes = Object.freeze({\n    enter: 13,\n    tab: 9,\n    delete: 46,\n    esc: 27,\n    space: 32,\n    up: 38,\n    down: 40,\n    left: 37,\n    right: 39,\n    end: 35,\n    home: 36,\n    del: 46,\n    backspace: 8,\n    insert: 45,\n    pageup: 33,\n    pagedown: 34\n});\nvar ICONS_PREFIX = \'$vuetify.icons.\';\n// This remaps internal names like \'$vuetify.icons.cancel\' to the current name\n// for that icon.\nfunction remapInternalIcon(vm, iconName) {\n    if (!iconName.startsWith(ICONS_PREFIX)) {\n        return iconName;\n    }\n    // Now look up icon indirection name, e.g. \'$vuetify.icons.cancel\'\n    return getObjectValueByPath(vm, iconName, iconName);\n}\nfunction keys(o) {\n    return Object.keys(o);\n}\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = function camelize(str) {\n    return str.replace(camelizeRE, function (_, c) {\n        return c ? c.toUpperCase() : \'\';\n    });\n};\n\n/***/ }),\n\n/***/ "./src/util/mask.js":\n/*!**************************!*\\\n  !*** ./src/util/mask.js ***!\n  \\**************************/\n/*! exports provided: defaultDelimiters, isMaskDelimiter, maskText, unmaskText */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultDelimiters", function() { return defaultDelimiters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMaskDelimiter", function() { return isMaskDelimiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "maskText", function() { return maskText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unmaskText", function() { return unmaskText; });\n/**\n * Default delimiter RegExp\n *\n * @type {RegExp}\n */\nvar defaultDelimiters = /[-!$%^&*()_+|~=`{}[\\]:";\'<>?,./\\\\ ]/;\n/**\n *\n * @param {String} char\n *\n * @return {Boolean}\n */\nvar isMaskDelimiter = function isMaskDelimiter(char) {\n    return char && defaultDelimiters.test(char);\n};\n/**\n * Mask keys\n *\n * @type {Object}\n */\nvar allowedMasks = {\n    \'#\': {\n        test: function test(char) {\n            return char.match(/[0-9]/);\n        }\n    },\n    \'A\': {\n        test: function test(char) {\n            return char.match(/[A-Z]/i);\n        },\n        convert: function convert(char) {\n            return char.toUpperCase();\n        }\n    },\n    \'a\': {\n        test: function test(char) {\n            return char.match(/[a-z]/i);\n        },\n        convert: function convert(char) {\n            return char.toLowerCase();\n        }\n    },\n    \'N\': {\n        test: function test(char) {\n            return char.match(/[0-9A-Z]/i);\n        },\n        convert: function convert(char) {\n            return char.toUpperCase();\n        }\n    },\n    \'n\': {\n        test: function test(char) {\n            return char.match(/[0-9a-z]/i);\n        },\n        convert: function convert(char) {\n            return char.toLowerCase();\n        }\n    },\n    \'X\': {\n        test: isMaskDelimiter\n    }\n};\n/**\n * Is Character mask\n *\n * @param  {String} char\n *\n * @return {Boolean}\n */\nvar isMask = function isMask(char) {\n    return allowedMasks.hasOwnProperty(char);\n};\n/**\n * Automatically convert char case\n *\n * @param  {String} mask\n * @param  {String} char\n *\n * @return {String}\n */\nvar convert = function convert(mask, char) {\n    return allowedMasks[mask].convert ? allowedMasks[mask].convert(char) : char;\n};\n/**\n * Mask Validation\n *\n * @param  {String} mask\n * @param  {String} char\n *\n * @return {Boolean}\n */\nvar maskValidates = function maskValidates(mask, char) {\n    if (char == null || !isMask(mask)) return false;\n    return allowedMasks[mask].test(char);\n};\n/**\n * Mask Text\n *\n * Takes a string or an array of characters\n * and returns a masked string\n *\n * @param {*} text\n * @param {Array|String} masked\n * @param {Boolean} [dontFillMaskBlanks]\n *\n * @return {String}\n */\nvar maskText = function maskText(text, masked, dontFillMaskBlanks) {\n    if (text == null) return \'\';\n    text = String(text);\n    if (!masked.length || !text.length) return text;\n    if (!Array.isArray(masked)) masked = masked.split(\'\');\n    var textIndex = 0;\n    var maskIndex = 0;\n    var newText = \'\';\n    while (maskIndex < masked.length) {\n        var mask = masked[maskIndex];\n        // Assign the next character\n        var char = text[textIndex];\n        // Check if mask is delimiter\n        // and current char matches\n        if (!isMask(mask) && char === mask) {\n            newText += mask;\n            textIndex++;\n            // Check if not mask\n        } else if (!isMask(mask) && !dontFillMaskBlanks) {\n            newText += mask;\n            // Check if is mask and validates\n        } else if (maskValidates(mask, char)) {\n            newText += convert(mask, char);\n            textIndex++;\n        } else {\n            return newText;\n        }\n        maskIndex++;\n    }\n    return newText;\n};\n/**\n * Unmask Text\n *\n * @param {String} text\n *\n * @return {String}\n */\nvar unmaskText = function unmaskText(text) {\n    return text ? String(text).replace(new RegExp(defaultDelimiters, \'g\'), \'\') : text;\n};\n\n/***/ }),\n\n/***/ "./src/util/mixins.ts":\n/*!****************************!*\\\n  !*** ./src/util/mixins.ts ***!\n  \\****************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return mixins; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n/* eslint-disable max-len, import/export, no-use-before-define */\n\nfunction mixins() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({ mixins: args });\n}\n\n/***/ }),\n\n/***/ "./src/util/rebuildFunctionalSlots.js":\n/*!********************************************!*\\\n  !*** ./src/util/rebuildFunctionalSlots.js ***!\n  \\********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return rebuildFunctionalSlots; });\n/**\n *\n * @param {object} slots\n * @param {function} h\n * @returns {array}\n */\nfunction rebuildFunctionalSlots(slots, h) {\n    var children = [];\n    for (var slot in slots) {\n        if (slots.hasOwnProperty(slot)) {\n            children.push(h(\'template\', { slot: slot }, slots[slot]));\n        }\n    }\n    return children;\n}\n\n/***/ }),\n\n/***/ "./src/util/theme.ts":\n/*!***************************!*\\\n  !*** ./src/util/theme.ts ***!\n  \\***************************/\n/*! exports provided: parse, genStyles, genVariations */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genStyles", function() { return genStyles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genVariations", function() { return genVariations; });\n/* harmony import */ var _colorUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./colorUtils */ "./src/util/colorUtils.ts");\n/* harmony import */ var _color_transformSRGB__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color/transformSRGB */ "./src/util/color/transformSRGB.ts");\n/* harmony import */ var _color_transformCIELAB__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./color/transformCIELAB */ "./src/util/color/transformCIELAB.ts");\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar __read = undefined && undefined.__read || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n        r,\n        ar = [],\n        e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n            ar.push(r.value);\n        }\n    } catch (error) {\n        e = { error: error };\n    } finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        } finally {\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n};\n\n\n\nfunction parse(theme, isItem) {\n    if (isItem === void 0) {\n        isItem = false;\n    }\n    var colors = Object.keys(theme);\n    var parsedTheme = {};\n    for (var i = 0; i < colors.length; ++i) {\n        var name = colors[i];\n        var value = theme[name];\n        if (isItem) {\n            if (name === \'base\' || name.startsWith(\'lighten\') || name.startsWith(\'darken\')) {\n                parsedTheme[name] = Object(_colorUtils__WEBPACK_IMPORTED_MODULE_0__["colorToHex"])(value);\n            }\n        } else if ((typeof value === "undefined" ? "undefined" : _typeof(value)) === \'object\') {\n            parsedTheme[name] = parse(value, true);\n        } else {\n            parsedTheme[name] = genVariations(name, Object(_colorUtils__WEBPACK_IMPORTED_MODULE_0__["colorToInt"])(value));\n        }\n    }\n    return parsedTheme;\n}\n/**\n * Generate the CSS for a base color (.primary)\n */\nvar genBaseColor = function genBaseColor(name, value) {\n    return "\\n." + name + " {\\n  background-color: " + value + " !important;\\n  border-color: " + value + " !important;\\n}\\n." + name + "--text {\\n  color: " + value + " !important;\\n  caret-color: " + value + " !important;\\n}";\n};\n/**\n * Generate the CSS for a variant color (.primary.darken-2)\n */\nvar genVariantColor = function genVariantColor(name, variant, value) {\n    var _a = __read(variant.split(/(\\d)/, 2), 2),\n        type = _a[0],\n        n = _a[1];\n    return "\\n." + name + "." + type + "-" + n + " {\\n  background-color: " + value + " !important;\\n  border-color: " + value + " !important;\\n}\\n." + name + "--text.text--" + type + "-" + n + " {\\n  color: " + value + " !important;\\n  caret-color: " + value + " !important;\\n}";\n};\nvar genColorVariableName = function genColorVariableName(name, variant) {\n    if (variant === void 0) {\n        variant = \'base\';\n    }\n    return "--v-" + name + "-" + variant;\n};\nvar genColorVariable = function genColorVariable(name, variant) {\n    if (variant === void 0) {\n        variant = \'base\';\n    }\n    return "var(" + genColorVariableName(name, variant) + ")";\n};\nfunction genStyles(theme, cssVar) {\n    if (cssVar === void 0) {\n        cssVar = false;\n    }\n    var colors = Object.keys(theme);\n    if (!colors.length) return \'\';\n    var variablesCss = \'\';\n    var css = \'\';\n    var aColor = cssVar ? genColorVariable(\'primary\') : theme.primary.base;\n    css += "a { color: " + aColor + "; }";\n    for (var i = 0; i < colors.length; ++i) {\n        var name = colors[i];\n        var value = theme[name];\n        if ((typeof value === "undefined" ? "undefined" : _typeof(value)) !== \'object\') continue;\n        css += genBaseColor(name, cssVar ? genColorVariable(name) : value.base);\n        cssVar && (variablesCss += "  " + genColorVariableName(name) + ": " + value.base + ";\\n");\n        var variants = Object.keys(value);\n        for (var i_1 = 0; i_1 < variants.length; ++i_1) {\n            var variant = variants[i_1];\n            var variantValue = value[variant];\n            if (variant === \'base\') continue;\n            css += genVariantColor(name, variant, cssVar ? genColorVariable(name, variant) : variantValue);\n            cssVar && (variablesCss += "  " + genColorVariableName(name, variant) + ": " + variantValue + ";\\n");\n        }\n    }\n    if (cssVar) {\n        variablesCss = ":root {\\n" + variablesCss + "}\\n\\n";\n    }\n    return variablesCss + css;\n}\nfunction genVariations(name, value) {\n    var values = {\n        base: Object(_colorUtils__WEBPACK_IMPORTED_MODULE_0__["intToHex"])(value)\n    };\n    for (var i = 5; i > 0; --i) {\n        values["lighten" + i] = Object(_colorUtils__WEBPACK_IMPORTED_MODULE_0__["intToHex"])(lighten(value, i));\n    }\n    for (var i = 1; i <= 4; ++i) {\n        values["darken" + i] = Object(_colorUtils__WEBPACK_IMPORTED_MODULE_0__["intToHex"])(darken(value, i));\n    }\n    return values;\n}\nfunction lighten(value, amount) {\n    var lab = _color_transformCIELAB__WEBPACK_IMPORTED_MODULE_2__["fromXYZ"](_color_transformSRGB__WEBPACK_IMPORTED_MODULE_1__["toXYZ"](value));\n    lab[0] = lab[0] + amount * 10;\n    return _color_transformSRGB__WEBPACK_IMPORTED_MODULE_1__["fromXYZ"](_color_transformCIELAB__WEBPACK_IMPORTED_MODULE_2__["toXYZ"](lab));\n}\nfunction darken(value, amount) {\n    var lab = _color_transformCIELAB__WEBPACK_IMPORTED_MODULE_2__["fromXYZ"](_color_transformSRGB__WEBPACK_IMPORTED_MODULE_1__["toXYZ"](value));\n    lab[0] = lab[0] - amount * 10;\n    return _color_transformSRGB__WEBPACK_IMPORTED_MODULE_1__["fromXYZ"](_color_transformCIELAB__WEBPACK_IMPORTED_MODULE_2__["toXYZ"](lab));\n}\n\n/***/ }),\n\n/***/ "vue":\n/*!******************************************************************************!*\\\n  !*** external {"commonjs":"vue","commonjs2":"vue","amd":"vue","root":"Vue"} ***!\n  \\******************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_vue__;\n\n/***/ })\n\n/******/ })["default"];\n});\n//# sourceMappingURL=vuetify.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVldGlmeS9kaXN0L3Z1ZXRpZnkuanM/Y2U1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsQ0FBSztBQUN4QyxNQUFNLEVBS21DO0FBQ3pDLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0NBQWdDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxrQkFBa0I7QUFDbEY7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQ0FBaUM7QUFDbEYsd0hBQXdILG1CQUFtQixFQUFFO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtEQUErRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLCtEQUErRCxFQUFFOzs7O0FBSXZLOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0cseURBQXlELEVBQUU7Ozs7QUFJM0o7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Ysd0RBQXdELEVBQUU7Ozs7QUFJeko7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLDREQUE0RCxFQUFFOzs7O0FBSWpLOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsOERBQThELEVBQUU7Ozs7QUFJcks7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkJBQTZCLDJHQUEyRztBQUN4STtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBLGdFQUFnRSxhQUFhLEdBQUcseUZBQXlGLDhCQUE4QjtBQUN2TTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2R0FBNkcsNEJBQTRCLEVBQUU7QUFDM0k7QUFDQSxxR0FBcUcsOERBQThELEVBQUU7O0FBRXJLO0FBQ0EseUdBQXlHLGtFQUFrRSxFQUFFOztBQUU3Szs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLG1CQUFtQixFQUFFLG1CQUFtQiw4SEFBOEg7O0FBRTFRO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxTQUFTO0FBQ1Q7QUFDQSx5REFBeUQsZUFBZTtBQUN4RSw0Q0FBNEM7QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0NBQStDLDRCQUE0QjtBQUMzRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0RBQWdELDRCQUE0QjtBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsc0RBQXNELEVBQUU7Ozs7QUFJcko7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIscUdBQXFHLDZJQUE2STtBQUNoUjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsNERBQTRELEVBQUU7Ozs7QUFJaks7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZCQUE2QixtSUFBbUk7QUFDaEssU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0dBQXNHLHFCQUFxQixFQUFFO0FBQzdILG1HQUFtRyxrQkFBa0IsRUFBRTtBQUN2SDtBQUNBO0FBQ0EsOEZBQThGLHVEQUF1RCxFQUFFOztBQUV2SjtBQUNBLG1HQUFtRyw0REFBNEQsRUFBRTs7QUFFaks7QUFDQSxtR0FBbUcsNERBQTRELEVBQUU7O0FBRWpLO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYix3QkFBd0I7QUFDeEIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0IsMENBQTBDO0FBQzVGO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxrREFBa0Q7QUFDbEQsc0NBQXNDO0FBQ3RDLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLDJEQUEyRCxFQUFFOztBQUUvSjtBQUNBLHNHQUFzRywrREFBK0QsRUFBRTs7Ozs7QUFLdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdDQUF3QyxnQkFBZ0IsK0VBQStFO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLDJEQUEyRCxFQUFFOzs7O0FBSS9KOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZCQUE2QixxTkFBcU47QUFDbFA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLHVEQUF1RCxFQUFFOzs7O0FBSXZKOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNLQUFzSyw4QkFBOEI7QUFDcE0sU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEhBQTBILGtDQUFrQyxHQUFHLHNCQUFzQjtBQUNyTCxTQUFTO0FBQ1Q7QUFDQSxpSUFBaUkscUNBQXFDO0FBQ3RLLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNB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Q2pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtB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QUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZCQUE2QixvaEJBQW9oQjtBQUNqakIsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUM7QUFDdkMsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx5Q0FBeUM7QUFDekc7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxtRUFBbUUsRUFBRTs7OztBQUkvSzs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVOQUF1TjtBQUN2TixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsOERBQThELEVBQUU7Ozs7QUFJcks7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7OztBQUdBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFxRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZCQUE2QixxR0FBcUc7QUFDbEksU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUNBQWlDLElBQUk7QUFDckMsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhLGlDQUFpQyw4QkFBOEI7QUFDNUcsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLDZEQUE2RCxFQUFFOzs7O0FBSW5LOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLDJEQUEyRCxFQUFFOzs7O0FBSS9KOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnRkFBZ0Y7QUFDL0csU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0cseURBQXlELEVBQUU7Ozs7QUFJM0o7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBLDZCQUE2QiwyQ0FBMkM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxtRUFBbUUsRUFBRTs7OztBQUkvSzs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csaUVBQWlFLEVBQUU7Ozs7QUFJM0s7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYixLQUFLO0FBQ0w7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7OztBQUdBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUZBQWlGO0FBQ3BILGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0NBQW9DLHVHQUF1RztBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyw2REFBNkQsRUFBRTs7QUFFbks7QUFDQSwrRkFBK0Ysd0RBQXdELEVBQUU7Ozs7O0FBS3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsYUFBYTtBQUNiO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyw4REFBOEQsRUFBRTs7OztBQUlySzs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7O0FBTUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0cseURBQXlELEVBQUU7Ozs7QUFJM0o7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0NBQStDLDBEQUEwRDtBQUN6RyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csNkRBQTZELEVBQUU7Ozs7QUFJbks7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBHQUEwRyx5QkFBeUIsRUFBRTtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7O0FBR0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNB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LFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztB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OztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFxRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxT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QUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7O0FBTUE7Ozs7QUFJQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFT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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7O0FBR0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFFQUFxRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0Q0FBNEM7QUFDNUMsdUNBQXVDO0FBQ3ZDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUNBQWlDLGdFQUFnRSxnQkFBZ0IsK0ZBQStGO0FBQ2hOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9HQUFvRyxnQkFBZ0IsRUFBRTtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkJBQTZCLDJHQUEyRztBQUN4SSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLDJEQUEyRCxFQUFFOzs7O0FBSS9KOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNB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O0FBQ0w7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUU7QUFDWDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBDQUEwQztBQUN2RSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0R0FBNEcsMkJBQTJCLEVBQUU7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUFFO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0VBQW9FLDZDQUE2QztBQUNqSDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csMkRBQTJELEVBQUU7O0FBRS9KO0FBQ0Esc0dBQXNHLCtEQUErRCxFQUFFOzs7OztBQUt2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsbUVBQW1FO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLHlEQUF5RCxFQUFFOztBQUUzSjtBQUNBLG9HQUFvRyw2REFBNkQsRUFBRTs7Ozs7QUFLbks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlHQUF5Ryx3QkFBd0IsRUFBRTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwREFBMEQsZ0JBQWdCO0FBQzFFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUdBQWlHLGNBQWMsRUFBRTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLG1CQUFtQixFQUFFLG1CQUFtQiw4SEFBOEg7Ozs7O0FBSzFROztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxP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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QixFQUFFO0FBQ3hDLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxpQkFBaUIsNERBQTREO0FBQzdFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQLFVBQVU7QUFDVixDQUFDO0FBQ0QiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInZ1ZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJ2dWVcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiVnVldGlmeVwiXSA9IGZhY3RvcnkocmVxdWlyZShcInZ1ZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiVnVldGlmeVwiXSA9IGZhY3Rvcnkocm9vdFtcIlZ1ZVwiXSk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV92dWVfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvZGlzdC9cIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC50c1wiKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZBbGVydC9WQWxlcnQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkFsZXJ0L1ZBbGVydC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfYWxlcnRzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19hbGVydHMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19hbGVydHMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfYWxlcnRzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfYWxlcnRzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WSWNvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkljb24vaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdG9nZ2xlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RvZ2dsZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdG9nZ2xlYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RyYW5zaXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdHJhbnNpdGlvbmFibGUgKi8gXCIuL3NyYy9taXhpbnMvdHJhbnNpdGlvbmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL21peGlucyAqLyBcIi4vc3JjL3V0aWwvbWl4aW5zLnRzXCIpO1xuLy8gU3R5bGVzXG5cbi8vIENvbXBvbmVudHNcblxuLy8gTWl4aW5zXG5cblxuXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE9iamVjdChfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0pKF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RvZ2dsZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdHJhbnNpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0pLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtYWxlcnQnLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGRpc21pc3NpYmxlOiBCb29sZWFuLFxuICAgICAgICBpY29uOiBTdHJpbmcsXG4gICAgICAgIG91dGxpbmU6IEJvb2xlYW4sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2luZm8nLCAnZXJyb3InLCAnc3VjY2VzcycsICd3YXJuaW5nJ10uaW5jbHVkZXModmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29tcHV0ZWRDb2xvcjogZnVuY3Rpb24gY29tcHV0ZWRDb2xvcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgJiYgIXRoaXMuY29sb3IgPyB0aGlzLnR5cGUgOiB0aGlzLmNvbG9yIHx8ICdlcnJvcic7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkSWNvbjogZnVuY3Rpb24gY29tcHV0ZWRJY29uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWNvbiB8fCAhdGhpcy50eXBlKSByZXR1cm4gdGhpcy5pY29uO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbmZvJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckdnVldGlmeS5pY29ucy5pbmZvJztcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJHZ1ZXRpZnkuaWNvbnMuZXJyb3InO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyR2dWV0aWZ5Lmljb25zLnN1Y2Nlc3MnO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dhcm5pbmcnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyR2dWV0aWZ5Lmljb25zLndhcm5pbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlbkljb246IGZ1bmN0aW9uIGdlbkljb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29tcHV0ZWRJY29uKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgICdjbGFzcyc6ICd2LWFsZXJ0X19pY29uJ1xuICAgICAgICAgICAgfSwgdGhpcy5jb21wdXRlZEljb24pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5EaXNtaXNzaWJsZTogZnVuY3Rpb24gZ2VuRGlzbWlzc2libGUoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpc21pc3NpYmxlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdhJywge1xuICAgICAgICAgICAgICAgICdjbGFzcyc6ICd2LWFsZXJ0X19kaXNtaXNzaWJsZScsXG4gICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSB9XG4gICAgICAgICAgICB9LCBbdGhpcy4kY3JlYXRlRWxlbWVudChfVkljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sICckdnVldGlmeS5pY29ucy5jYW5jZWwnKV0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFt0aGlzLmdlbkljb24oKSwgaCgnZGl2JywgdGhpcy4kc2xvdHMuZGVmYXVsdCksIHRoaXMuZ2VuRGlzbWlzc2libGUoKV07XG4gICAgICAgIHZhciBzZXRDb2xvciA9IHRoaXMub3V0bGluZSA/IHRoaXMuc2V0VGV4dENvbG9yIDogdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIHZhciBhbGVydCA9IGgoJ2RpdicsIHNldENvbG9yKHRoaXMuY29tcHV0ZWRDb2xvciwge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWFsZXJ0JyxcbiAgICAgICAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgICAgICAgICAndi1hbGVydC0tb3V0bGluZSc6IHRoaXMub3V0bGluZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3Nob3cnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmlzQWN0aXZlXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgICAgfSksIGNoaWxkcmVuKTtcbiAgICAgICAgaWYgKCF0aGlzLnRyYW5zaXRpb24pIHJldHVybiBhbGVydDtcbiAgICAgICAgcmV0dXJuIGgoJ3RyYW5zaXRpb24nLCB7XG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMudHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICBvcmlnaW46IHRoaXMub3JpZ2luLFxuICAgICAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbYWxlcnRdKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkFsZXJ0L2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkFsZXJ0L2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZBbGVydCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkFsZXJ0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZBbGVydCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkFsZXJ0L1ZBbGVydC50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZBbGVydFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQWxlcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkFsZXJ0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WQXBwL1ZBcHAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WQXBwL1ZBcHAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfYXBwX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19hcHAuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19hcHAuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfYXBwX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfYXBwX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19hcHBfdGhlbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL2FwcC10aGVtZSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkFwcC9taXhpbnMvYXBwLXRoZW1lLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlyZWN0aXZlc19yZXNpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplICovIFwiLi9zcmMvZGlyZWN0aXZlcy9yZXNpemUudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8vIENvbXBvbmVudCBsZXZlbCBtaXhpbnNcblxuXG4vLyBEaXJlY3RpdmVzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1hcHAnLFxuICAgIGRpcmVjdGl2ZXM6IHtcbiAgICAgICAgUmVzaXplOiBfZGlyZWN0aXZlc19yZXNpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl1cbiAgICB9LFxuICAgIG1peGluczogW19taXhpbnNfYXBwX3RoZW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhcHAnXG4gICAgICAgIH0sXG4gICAgICAgIGRhcms6IEJvb2xlYW5cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oeyAnYXBwbGljYXRpb24tLWlzLXJ0bCc6IHRoaXMuJHZ1ZXRpZnkucnRsIH0sIHRoaXMudGhlbWVDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgZGFyazogZnVuY3Rpb24gZGFyaygpIHtcbiAgICAgICAgICAgIHRoaXMuJHZ1ZXRpZnkuZGFyayA9IHRoaXMuZGFyaztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy4kdnVldGlmeS5kYXJrID0gdGhpcy5kYXJrO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAnYXBwbGljYXRpb24nLFxuICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy5jbGFzc2VzLFxuICAgICAgICAgICAgYXR0cnM6IHsgJ2RhdGEtYXBwJzogdHJ1ZSB9LFxuICAgICAgICAgICAgZG9tUHJvcHM6IHsgaWQ6IHRoaXMuaWQgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgd3JhcHBlciA9IGgoJ2RpdicsIHsgc3RhdGljQ2xhc3M6ICdhcHBsaWNhdGlvbi0td3JhcCcgfSwgdGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCBkYXRhLCBbd3JhcHBlcl0pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZBcHAvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkFwcC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVkFwcCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkFwcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQXBwICovIFwiLi9zcmMvY29tcG9uZW50cy9WQXBwL1ZBcHAuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQXBwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZBcHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkFwcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkFwcC9taXhpbnMvYXBwLXRoZW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkFwcC9taXhpbnMvYXBwLXRoZW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdGhlbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3V0aWwvdGhlbWUgKi8gXCIuL3NyYy91dGlsL3RoZW1lLnRzXCIpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3R5bGU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHBhcnNlZFRoZW1lOiBmdW5jdGlvbiBwYXJzZWRUaGVtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdXRpbF90aGVtZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wicGFyc2VcIl0odGhpcy4kdnVldGlmeS50aGVtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAcmV0dXJuIHN0cmluZyAqL1xuICAgICAgICBnZW5lcmF0ZWRTdHlsZXM6IGZ1bmN0aW9uIGdlbmVyYXRlZFN0eWxlcygpIHtcbiAgICAgICAgICAgIHZhciB0aGVtZSA9IHRoaXMucGFyc2VkVGhlbWU7XG4gICAgICAgICAgICB2YXIgY3NzO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHZ1ZXRpZnkub3B0aW9ucy50aGVtZUNhY2hlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjc3MgPSB0aGlzLiR2dWV0aWZ5Lm9wdGlvbnMudGhlbWVDYWNoZS5nZXQodGhlbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjc3MgIT0gbnVsbCkgcmV0dXJuIGNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNzcyA9IF91dGlsX3RoZW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZW5TdHlsZXNcIl0odGhlbWUsIHRoaXMuJHZ1ZXRpZnkub3B0aW9ucy5jdXN0b21Qcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR2dWV0aWZ5Lm9wdGlvbnMubWluaWZ5VGhlbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNzcyA9IHRoaXMuJHZ1ZXRpZnkub3B0aW9ucy5taW5pZnlUaGVtZShjc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuJHZ1ZXRpZnkub3B0aW9ucy50aGVtZUNhY2hlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR2dWV0aWZ5Lm9wdGlvbnMudGhlbWVDYWNoZS5zZXQodGhlbWUsIGNzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3NzO1xuICAgICAgICB9LFxuICAgICAgICB2dWVNZXRhOiBmdW5jdGlvbiB2dWVNZXRhKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHZ1ZXRpZnkudGhlbWUgPT09IGZhbHNlKSByZXR1cm4ge307XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBjc3NUZXh0OiB0aGlzLmdlbmVyYXRlZFN0eWxlcyxcbiAgICAgICAgICAgICAgICBpZDogJ3Z1ZXRpZnktdGhlbWUtc3R5bGVzaGVldCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQvY3NzJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLiR2dWV0aWZ5Lm9wdGlvbnMuY3NwTm9uY2UpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm5vbmNlID0gdGhpcy4kdnVldGlmeS5vcHRpb25zLmNzcE5vbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogW29wdGlvbnNdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBSZWd1bGFyIHZ1ZS1tZXRhXG4gICAgbWV0YUluZm86IGZ1bmN0aW9uIG1ldGFJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52dWVNZXRhO1xuICAgIH0sXG4gICAgLy8gTnV4dFxuICAgIGhlYWQ6IGZ1bmN0aW9uIGhlYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZ1ZU1ldGE7XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBnZW5lcmF0ZWRTdHlsZXM6IGZ1bmN0aW9uIGdlbmVyYXRlZFN0eWxlcygpIHtcbiAgICAgICAgICAgICF0aGlzLm1ldGEgJiYgdGhpcy5hcHBseVRoZW1lKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLiR2dWV0aWZ5LnRoZW1lID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy4kbWV0YSkge1xuICAgICAgICAgICAgLy8gVnVlLW1ldGFcbiAgICAgICAgICAgIC8vIEhhbmRsZWQgYnkgbWV0YUluZm8oKS9udXh0KClcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnICYmIHRoaXMuJHNzckNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIFNTUlxuICAgICAgICAgICAgdmFyIG5vbmNlID0gdGhpcy4kdnVldGlmeS5vcHRpb25zLmNzcE5vbmNlID8gXCIgbm9uY2U9XFxcIlwiICsgdGhpcy4kdnVldGlmeS5vcHRpb25zLmNzcE5vbmNlICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgICAgIHRoaXMuJHNzckNvbnRleHQuaGVhZCA9IHRoaXMuJHNzckNvbnRleHQuaGVhZCB8fCAnJztcbiAgICAgICAgICAgIHRoaXMuJHNzckNvbnRleHQuaGVhZCArPSBcIjxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCIgaWQ9XFxcInZ1ZXRpZnktdGhlbWUtc3R5bGVzaGVldFxcXCJcIiArIG5vbmNlICsgXCI+XCIgKyB0aGlzLmdlbmVyYXRlZFN0eWxlcyArIFwiPC9zdHlsZT5cIjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBDbGllbnQtc2lkZVxuICAgICAgICAgICAgdGhpcy5nZW5TdHlsZSgpO1xuICAgICAgICAgICAgdGhpcy5hcHBseVRoZW1lKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXBwbHlUaGVtZTogZnVuY3Rpb24gYXBwbHlUaGVtZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlKSB0aGlzLnN0eWxlLmlubmVySFRNTCA9IHRoaXMuZ2VuZXJhdGVkU3R5bGVzO1xuICAgICAgICB9LFxuICAgICAgICBnZW5TdHlsZTogZnVuY3Rpb24gZ2VuU3R5bGUoKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndnVldGlmeS10aGVtZS1zdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgICAgICAgICAgIHN0eWxlLmlkID0gJ3Z1ZXRpZnktdGhlbWUtc3R5bGVzaGVldCc7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuJHZ1ZXRpZnkub3B0aW9ucy5jc3BOb25jZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgdGhpcy4kdnVldGlmeS5vcHRpb25zLmNzcE5vbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WQXV0b2NvbXBsZXRlL1ZBdXRvY29tcGxldGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WQXV0b2NvbXBsZXRlL1ZBdXRvY29tcGxldGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfYXV0b2NvbXBsZXRlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fYXV0b2NvbXBsZXRlcy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2F1dG9jb21wbGV0ZXMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfYXV0b2NvbXBsZXRlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2F1dG9jb21wbGV0ZXNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlNlbGVjdF9WU2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WU2VsZWN0L1ZTZWxlY3QgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTZWxlY3QvVlNlbGVjdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRleHRGaWVsZF9WVGV4dEZpZWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WVGV4dEZpZWxkL1ZUZXh0RmllbGQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUZXh0RmllbGQvVlRleHRGaWVsZC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBTdHlsZXNcblxuLy8gRXh0ZW5zaW9uc1xuXG5cbi8vIFV0aWxzXG5cbnZhciBkZWZhdWx0TWVudVByb3BzID0gX19hc3NpZ24oe30sIF9WU2VsZWN0X1ZTZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRNZW51UHJvcHNcIl0sIHsgb2Zmc2V0WTogdHJ1ZSwgb2Zmc2V0T3ZlcmZsb3c6IHRydWUsIHRyYW5zaXRpb246IGZhbHNlIH0pO1xuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LWF1dG9jb21wbGV0ZScsXG4gICAgZXh0ZW5kczogX1ZTZWxlY3RfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSxcbiAgICBwcm9wczoge1xuICAgICAgICBhbGxvd092ZXJmbG93OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBicm93c2VyQXV0b2NvbXBsZXRlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnb2ZmJ1xuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoaXRlbSwgcXVlcnlUZXh0LCBpdGVtVGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBoYXNWYWx1ZSA9IGZ1bmN0aW9uIGhhc1ZhbHVlKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsICE9IG51bGwgPyB2YWwgOiAnJztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gaGFzVmFsdWUoaXRlbVRleHQpO1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IGhhc1ZhbHVlKHF1ZXJ5VGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocXVlcnkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKSA+IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoaWRlTm9EYXRhOiBCb29sZWFuLFxuICAgICAgICBub0ZpbHRlcjogQm9vbGVhbixcbiAgICAgICAgc2VhcmNoSW5wdXQ6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBtZW51UHJvcHM6IHtcbiAgICAgICAgICAgIHR5cGU6IF9WU2VsZWN0X1ZTZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0ucHJvcHMubWVudVByb3BzLnR5cGUsXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdE1lbnVQcm9wcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSh2bSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cnNJbnB1dDogbnVsbCxcbiAgICAgICAgICAgIGxhenlTZWFyY2g6IHZtLnNlYXJjaElucHV0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIF9WU2VsZWN0X1ZTZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uY29tcHV0ZWQuY2xhc3Nlcy5jYWxsKHRoaXMpLCB7XG4gICAgICAgICAgICAgICAgJ3YtYXV0b2NvbXBsZXRlJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndi1hdXRvY29tcGxldGUtLWlzLXNlbGVjdGluZy1pbmRleCc6IHRoaXMuc2VsZWN0ZWRJbmRleCA+IC0xXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWRJdGVtczogZnVuY3Rpb24gY29tcHV0ZWRJdGVtcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkSXRlbXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXllZEl0ZW1zQ291bnQ6IGZ1bmN0aW9uIGRpc3BsYXllZEl0ZW1zQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlU2VsZWN0ZWQgPyB0aGlzLmZpbHRlcmVkSXRlbXMubGVuZ3RoIC0gdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCA6IHRoaXMuZmlsdGVyZWRJdGVtcy5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmFuZ2Ugb2YgdGhlIGN1cnJlbnQgaW5wdXQgdGV4dFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjdXJyZW50UmFuZ2U6IGZ1bmN0aW9uIGN1cnJlbnRSYW5nZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbSA9PSBudWxsKSByZXR1cm4gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRleHQodGhpcy5zZWxlY3RlZEl0ZW0pLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXJlZEl0ZW1zOiBmdW5jdGlvbiBmaWx0ZXJlZEl0ZW1zKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1NlYXJjaGluZyB8fCB0aGlzLm5vRmlsdGVyKSByZXR1cm4gdGhpcy5hbGxJdGVtcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsbEl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5maWx0ZXIoaSwgX3RoaXMuaW50ZXJuYWxTZWFyY2gsIF90aGlzLmdldFRleHQoaSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVybmFsU2VhcmNoOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXp5U2VhcmNoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF6eVNlYXJjaCA9IHZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6c2VhcmNoSW5wdXQnLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc0FueVZhbHVlQWxsb3dlZDogZnVuY3Rpb24gaXNBbnlWYWx1ZUFsbG93ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGlydHk6IGZ1bmN0aW9uIGlzRGlydHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hJc0RpcnR5IHx8IHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwO1xuICAgICAgICB9LFxuICAgICAgICBpc1NlYXJjaGluZzogZnVuY3Rpb24gaXNTZWFyY2hpbmcoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkgcmV0dXJuIHRoaXMuc2VhcmNoSXNEaXJ0eTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaElzRGlydHkgJiYgdGhpcy5pbnRlcm5hbFNlYXJjaCAhPT0gdGhpcy5nZXRUZXh0KHRoaXMuc2VsZWN0ZWRJdGVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVudUNhblNob3c6IGZ1bmN0aW9uIG1lbnVDYW5TaG93KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheWVkSXRlbXNDb3VudCA+IDAgfHwgIXRoaXMuaGlkZU5vRGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgJF9tZW51UHJvcHM6IGZ1bmN0aW9uICRfbWVudVByb3BzKCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gX1ZTZWxlY3RfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5jb21wdXRlZC4kX21lbnVQcm9wcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcHJvcHMuY29udGVudENsYXNzID0gKFwidi1hdXRvY29tcGxldGVfX2NvbnRlbnQgXCIgKyAocHJvcHMuY29udGVudENsYXNzIHx8ICcnKSkudHJpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCBkZWZhdWx0TWVudVByb3BzLCBwcm9wcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlYXJjaElzRGlydHk6IGZ1bmN0aW9uIHNlYXJjaElzRGlydHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFNlYXJjaCAhPSBudWxsICYmIHRoaXMuaW50ZXJuYWxTZWFyY2ggIT09ICcnO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RlZEl0ZW06IGZ1bmN0aW9uIHNlbGVjdGVkSXRlbSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEl0ZW1zLmZpbmQoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudmFsdWVDb21wYXJhdG9yKF90aGlzLmdldFZhbHVlKGkpLCBfdGhpcy5nZXRWYWx1ZShfdGhpcy5pbnRlcm5hbFZhbHVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdERhdGE6IGZ1bmN0aW9uIGxpc3REYXRhKCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBfVlNlbGVjdF9WU2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLmNvbXB1dGVkLmxpc3REYXRhLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEucHJvcHMsIHtcbiAgICAgICAgICAgICAgICBpdGVtczogdGhpcy52aXJ0dWFsaXplZEl0ZW1zLFxuICAgICAgICAgICAgICAgIG5vRmlsdGVyOiB0aGlzLm5vRmlsdGVyIHx8ICF0aGlzLmlzU2VhcmNoaW5nIHx8ICF0aGlzLmZpbHRlcmVkSXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHNlYXJjaElucHV0OiB0aGlzLmludGVybmFsU2VhcmNoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBmaWx0ZXJlZEl0ZW1zOiBmdW5jdGlvbiBmaWx0ZXJlZEl0ZW1zKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5vbkZpbHRlcmVkSXRlbXNDaGFuZ2VkKHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVybmFsVmFsdWU6IGZ1bmN0aW9uIGludGVybmFsVmFsdWUoKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlYXJjaCgpO1xuICAgICAgICB9LFxuICAgICAgICBpc0ZvY3VzZWQ6IGZ1bmN0aW9uIGlzRm9jdXNlZCh2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0ICYmIHRoaXMuJHJlZnMuaW5wdXQuc2VsZWN0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc01lbnVBY3RpdmU6IGZ1bmN0aW9uIGlzTWVudUFjdGl2ZSh2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgfHwgIXRoaXMuaGFzU2xvdCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5sYXp5U2VhcmNoID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbXM6IGZ1bmN0aW9uIGl0ZW1zKHZhbCwgb2xkVmFsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZm9jdXNlZCwgdGhlIG1lbnVcbiAgICAgICAgICAgIC8vIGlzIG5vdCBhY3RpdmUsIGhpZGUgbm8gZGF0YSBpcyBlbmFibGVkLFxuICAgICAgICAgICAgLy8gYW5kIGl0ZW1zIGNoYW5nZVxuICAgICAgICAgICAgLy8gVXNlciBpcyBwcm9iYWJseSBhc3luYyBsb2FkaW5nXG4gICAgICAgICAgICAvLyBpdGVtcywgdHJ5IHRvIGFjdGl2YXRlIHRoZSBtZW51XG4gICAgICAgICAgICBpZiAoIShvbGRWYWwgJiYgb2xkVmFsLmxlbmd0aCkgJiYgdGhpcy5oaWRlTm9EYXRhICYmIHRoaXMuaXNGb2N1c2VkICYmICF0aGlzLmlzTWVudUFjdGl2ZSAmJiB2YWwubGVuZ3RoKSB0aGlzLmFjdGl2YXRlTWVudSgpO1xuICAgICAgICB9LFxuICAgICAgICBzZWFyY2hJbnB1dDogZnVuY3Rpb24gc2VhcmNoSW5wdXQodmFsKSB7XG4gICAgICAgICAgICB0aGlzLmxhenlTZWFyY2ggPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVybmFsU2VhcmNoOiBmdW5jdGlvbiBpbnRlcm5hbFNlYXJjaCh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMub25JbnRlcm5hbFNlYXJjaENoYW5nZWQodmFsKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy5zZXRTZWFyY2goKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgb25GaWx0ZXJlZEl0ZW1zQ2hhbmdlZDogZnVuY3Rpb24gb25GaWx0ZXJlZEl0ZW1zQ2hhbmdlZCh2YWwpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnNldE1lbnVJbmRleCgtMSk7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0TWVudUluZGV4KHZhbC5sZW5ndGggPT09IDEgPyAwIDogLTEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uSW50ZXJuYWxTZWFyY2hDaGFuZ2VkOiBmdW5jdGlvbiBvbkludGVybmFsU2VhcmNoQ2hhbmdlZCh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWVudURpbWVuc2lvbnMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlTWVudURpbWVuc2lvbnM6IGZ1bmN0aW9uIHVwZGF0ZU1lbnVEaW1lbnNpb25zKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNNZW51QWN0aXZlICYmIHRoaXMuJHJlZnMubWVudSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMubWVudS51cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZVNlbGVjdGVkSW5kZXg6IGZ1bmN0aW9uIGNoYW5nZVNlbGVjdGVkSW5kZXgoa2V5Q29kZSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGNoYW5naW5nIG9mIHNlbGVjdGVkSW5kZXhcbiAgICAgICAgICAgIC8vIHdoZW4gc2VhcmNoIGlzIGRpcnR5XG4gICAgICAgICAgICBpZiAodGhpcy5zZWFyY2hJc0RpcnR5KSByZXR1cm47XG4gICAgICAgICAgICBpZiAoIVtfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJrZXlDb2Rlc1wiXS5iYWNrc3BhY2UsIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImtleUNvZGVzXCJdLmxlZnQsIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImtleUNvZGVzXCJdLnJpZ2h0LCBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJrZXlDb2Rlc1wiXS5kZWxldGVdLmluY2x1ZGVzKGtleUNvZGUpKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgaW5kZXhlcyA9IHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImtleUNvZGVzXCJdLmxlZnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXggPT09IC0xID8gaW5kZXhlcyA6IHRoaXMuc2VsZWN0ZWRJbmRleCAtIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImtleUNvZGVzXCJdLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4ID49IGluZGV4ZXMgPyAtMSA6IHRoaXMuc2VsZWN0ZWRJbmRleCArIDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBpbmRleGVzO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50SXRlbSA9IHRoaXMuc2VsZWN0ZWRJdGVtc1t0aGlzLnNlbGVjdGVkSW5kZXhdO1xuICAgICAgICAgICAgaWYgKFtfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJrZXlDb2Rlc1wiXS5iYWNrc3BhY2UsIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImtleUNvZGVzXCJdLmRlbGV0ZV0uaW5jbHVkZXMoa2V5Q29kZSkgJiYgIXRoaXMuZ2V0RGlzYWJsZWQoY3VycmVudEl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0luZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4ID09PSBpbmRleGVzID8gdGhpcy5zZWxlY3RlZEluZGV4IC0gMSA6IHRoaXMuc2VsZWN0ZWRJdGVtc1t0aGlzLnNlbGVjdGVkSW5kZXggKyAxXSA/IHRoaXMuc2VsZWN0ZWRJbmRleCA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLm11bHRpcGxlID8gW10gOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0SXRlbShjdXJyZW50SXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IG5ld0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGVhcmFibGVDYWxsYmFjazogZnVuY3Rpb24gY2xlYXJhYmxlQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsU2VhcmNoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgX1ZTZWxlY3RfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLmNsZWFyYWJsZUNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbklucHV0OiBmdW5jdGlvbiBnZW5JbnB1dCgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IF9WVGV4dEZpZWxkX1ZUZXh0RmllbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0ubWV0aG9kcy5nZW5JbnB1dC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaW5wdXQuZGF0YS5hdHRycy5yb2xlID0gJ2NvbWJvYm94JztcbiAgICAgICAgICAgIGlucHV0LmRhdGEuZG9tUHJvcHMudmFsdWUgPSB0aGlzLmludGVybmFsU2VhcmNoO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9LFxuICAgICAgICBnZW5TZWxlY3Rpb25zOiBmdW5jdGlvbiBnZW5TZWxlY3Rpb25zKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzU2xvdCB8fCB0aGlzLm11bHRpcGxlID8gX1ZTZWxlY3RfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLmdlblNlbGVjdGlvbnMuY2FsbCh0aGlzKSA6IFtdO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID4gLTEgPyB0aGlzLnNlbGVjdGVkSW5kZXggPSAtMSA6IHRoaXMub25Gb2N1cygpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZU1lbnUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlckRvd246IGZ1bmN0aW9uIG9uRW50ZXJEb3duKCkge1xuICAgICAgICAgICAgLy8gQXZvaWQgaW52b2tpbmcgdGhpcyBtZXRob2RcbiAgICAgICAgICAgIC8vIHdpbGwgY2F1c2UgdXBkYXRlU2VsZiB0b1xuICAgICAgICAgICAgLy8gYmUgY2FsbGVkIGVtcHR5aW5nIHNlYXJjaFxuICAgICAgICB9LFxuICAgICAgICBvbklucHV0OiBmdW5jdGlvbiBvbklucHV0KGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPiAtMSkgcmV0dXJuO1xuICAgICAgICAgICAgLy8gSWYgdHlwaW5nIGFuZCBtZW51IGlzIG5vdCBjdXJyZW50bHkgYWN0aXZlXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2YXRlTWVudSgpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0FueVZhbHVlQWxsb3dlZCkgdGhpcy5zZXRNZW51SW5kZXgoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hc2sgJiYgdGhpcy5yZXNldFNlbGVjdGlvbnMoZS50YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFNlYXJjaCA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5iYWRJbnB1dCA9IGUudGFyZ2V0LnZhbGlkaXR5ICYmIGUudGFyZ2V0LnZhbGlkaXR5LmJhZElucHV0O1xuICAgICAgICB9LFxuICAgICAgICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgICAgICAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgICAgIF9WU2VsZWN0X1ZTZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0ubWV0aG9kcy5vbktleURvd24uY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIC8vIFRoZSBvcmRlcmluZyBpcyBpbXBvcnRhbnQgaGVyZVxuICAgICAgICAgICAgLy8gYWxsb3dzIG5ldyB2YWx1ZSB0byBiZSB1cGRhdGVkXG4gICAgICAgICAgICAvLyBhbmQgdGhlbiBtb3ZlcyB0aGUgaW5kZXggdG8gdGhlXG4gICAgICAgICAgICAvLyBwcm9wZXIgbG9jYXRpb25cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlU2VsZWN0ZWRJbmRleChrZXlDb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UYWJEb3duOiBmdW5jdGlvbiBvblRhYkRvd24oZSkge1xuICAgICAgICAgICAgX1ZTZWxlY3RfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLm9uVGFiRG93bi5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxmKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFNlbGVjdGVkSXRlbXM6IGZ1bmN0aW9uIHNldFNlbGVjdGVkSXRlbXMoKSB7XG4gICAgICAgICAgICBfVlNlbGVjdF9WU2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLm1ldGhvZHMuc2V0U2VsZWN0ZWRJdGVtcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLy8gIzQyNzMgRG9uJ3QgcmVwbGFjZSBpZiBzZWFyY2hpbmdcbiAgICAgICAgICAgIC8vICM0NDAzIERvbid0IHJlcGxhY2UgaWYgZm9jdXNlZFxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNlZCkgdGhpcy5zZXRTZWFyY2goKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U2VhcmNoOiBmdW5jdGlvbiBzZXRTZWFyY2goKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgbmV4dFRpY2sgc28gc2VsZWN0ZWRJdGVtXG4gICAgICAgICAgICAvLyBoYXMgaGFkIHRpbWUgdG8gdXBkYXRlXG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW50ZXJuYWxTZWFyY2ggPSAhX3RoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggfHwgX3RoaXMubXVsdGlwbGUgfHwgX3RoaXMuaGFzU2xvdCA/IG51bGwgOiBfdGhpcy5nZXRUZXh0KF90aGlzLnNlbGVjdGVkSXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlU2VsZjogZnVuY3Rpb24gdXBkYXRlU2VsZigpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXV0b2NvbXBsZXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUF1dG9jb21wbGV0ZTogZnVuY3Rpb24gdXBkYXRlQXV0b2NvbXBsZXRlKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlYXJjaElzRGlydHkgJiYgIXRoaXMuaW50ZXJuYWxWYWx1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZhbHVlQ29tcGFyYXRvcih0aGlzLmludGVybmFsU2VhcmNoLCB0aGlzLmdldFZhbHVlKHRoaXMuaW50ZXJuYWxWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWFyY2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZBdXRvY29tcGxldGUvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkF1dG9jb21wbGV0ZS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVkF1dG9jb21wbGV0ZSwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkF1dG9jb21wbGV0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQXV0b2NvbXBsZXRlICovIFwiLi9zcmMvY29tcG9uZW50cy9WQXV0b2NvbXBsZXRlL1ZBdXRvY29tcGxldGUuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQXV0b2NvbXBsZXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZBdXRvY29tcGxldGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkF1dG9jb21wbGV0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkF2YXRhci9WQXZhdGFyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkF2YXRhci9WQXZhdGFyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2F2YXRhcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2F2YXRhcnMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19hdmF0YXJzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2F2YXRhcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19hdmF0YXJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8vIE1peGluc1xuXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoT2JqZWN0KF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSkoX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtYXZhdGFyJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHByb3BzOiB7XG4gICAgICAgIC8vIFRPRE86IGluaGVyaXQgdGhlc2VcbiAgICAgICAgY29sb3I6IFN0cmluZyxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDQ4XG4gICAgICAgIH0sXG4gICAgICAgIHRpbGU6IEJvb2xlYW5cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9hKSB7XG4gICAgICAgIHZhciBkYXRhID0gX2EuZGF0YSxcbiAgICAgICAgICAgIHByb3BzID0gX2EucHJvcHMsXG4gICAgICAgICAgICBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgICAgICBkYXRhLnN0YXRpY0NsYXNzID0gKFwidi1hdmF0YXIgXCIgKyAoZGF0YS5zdGF0aWNDbGFzcyB8fCAnJykpLnRyaW0oKTtcbiAgICAgICAgaWYgKHByb3BzLnRpbGUpIGRhdGEuc3RhdGljQ2xhc3MgKz0gJyB2LWF2YXRhci0tdGlsZSc7XG4gICAgICAgIHZhciBzaXplID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImNvbnZlcnRUb1VuaXRcIl0pKHByb3BzLnNpemUpO1xuICAgICAgICBkYXRhLnN0eWxlID0gX19hc3NpZ24oeyBoZWlnaHQ6IHNpemUsIHdpZHRoOiBzaXplIH0sIGRhdGEuc3R5bGUpO1xuICAgICAgICByZXR1cm4gaCgnZGl2JywgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0ub3B0aW9ucy5tZXRob2RzLnNldEJhY2tncm91bmRDb2xvcihwcm9wcy5jb2xvciwgZGF0YSksIGNoaWxkcmVuKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkF2YXRhci9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WQXZhdGFyL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWQXZhdGFyLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQXZhdGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZBdmF0YXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZBdmF0YXIvVkF2YXRhci50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZBdmF0YXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkF2YXRhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WQXZhdGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WQmFkZ2UvVkJhZGdlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZCYWRnZS9WQmFkZ2UudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2JhZGdlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fYmFkZ2VzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fYmFkZ2VzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2JhZGdlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2JhZGdlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RvZ2dsZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90b2dnbGVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RvZ2dsZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19wb3NpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9wb3NpdGlvbmFibGUgKi8gXCIuL3NyYy9taXhpbnMvcG9zaXRpb25hYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdHJhbnNpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90cmFuc2l0aW9uYWJsZSAqLyBcIi4vc3JjL21peGlucy90cmFuc2l0aW9uYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG4vLyBTdHlsZXNcblxuLy8gTWl4aW5zXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdKShfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgX21peGluc190b2dnbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCBPYmplY3QoX21peGluc19wb3NpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImZhY3RvcnlcIl0pKFsnbGVmdCcsICdib3R0b20nXSksIF9taXhpbnNfdHJhbnNpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl1cbi8qIEB2dWUvY29tcG9uZW50ICovXG4pLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtYmFkZ2UnLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAncHJpbWFyeSdcbiAgICAgICAgfSxcbiAgICAgICAgb3ZlcmxhcDogQm9vbGVhbixcbiAgICAgICAgdHJhbnNpdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2ZhYi10cmFuc2l0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndi1iYWRnZS0tYm90dG9tJzogdGhpcy5ib3R0b20sXG4gICAgICAgICAgICAgICAgJ3YtYmFkZ2UtLWxlZnQnOiB0aGlzLmxlZnQsXG4gICAgICAgICAgICAgICAgJ3YtYmFkZ2UtLW92ZXJsYXAnOiB0aGlzLm92ZXJsYXBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIGJhZGdlID0gdGhpcy4kc2xvdHMuYmFkZ2UgPyBbaCgnc3BhbicsIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMuY29sb3IsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1iYWRnZV9fYmFkZ2UnLFxuICAgICAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzLFxuICAgICAgICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2hvdycsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaXNBY3RpdmVcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0pLCB0aGlzLiRzbG90cy5iYWRnZSldIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIGgoJ3NwYW4nLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtYmFkZ2UnLFxuICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy5jbGFzc2VzXG4gICAgICAgIH0sIFt0aGlzLiRzbG90cy5kZWZhdWx0LCBoKCd0cmFuc2l0aW9uJywge1xuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLnRyYW5zaXRpb24sXG4gICAgICAgICAgICAgICAgb3JpZ2luOiB0aGlzLm9yaWdpbixcbiAgICAgICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYmFkZ2UpXSk7XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZCYWRnZS9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZCYWRnZS9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWQmFkZ2UsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZCYWRnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQmFkZ2UgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZCYWRnZS9WQmFkZ2UudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQmFkZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkJhZGdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX1ZCYWRnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkJvdHRvbU5hdi9WQm90dG9tTmF2LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkJvdHRvbU5hdi9WQm90dG9tTmF2LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2JvdHRvbV9uYXZzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19ib3R0b20tbmF2cy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2JvdHRvbS1uYXZzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2JvdHRvbV9uYXZzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfYm90dG9tX25hdnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2FwcGxpY2F0aW9uYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2FwcGxpY2F0aW9uYWJsZSAqLyBcIi4vc3JjL21peGlucy9hcHBsaWNhdGlvbmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19idXR0b25fZ3JvdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9idXR0b24tZ3JvdXAgKi8gXCIuL3NyYy9taXhpbnMvYnV0dG9uLWdyb3VwLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG4vLyBTdHlsZXNcblxuLy8gTWl4aW5zXG5cblxuXG4vLyBVdGlsXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoT2JqZWN0KF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSkoT2JqZWN0KF9taXhpbnNfYXBwbGljYXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKSgnYm90dG9tJywgWydoZWlnaHQnLCAndmFsdWUnXSksIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LWJvdHRvbS1uYXYnLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFjdGl2ZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgbWFuZGF0b3J5OiBCb29sZWFuLFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IDU2LFxuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlSW50KHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hpZnQ6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndi1ib3R0b20tbmF2LS1hYnNvbHV0ZSc6IHRoaXMuYWJzb2x1dGUsXG4gICAgICAgICAgICAgICAgJ3YtYm90dG9tLW5hdi0tZml4ZWQnOiAhdGhpcy5hYnNvbHV0ZSAmJiAodGhpcy5hcHAgfHwgdGhpcy5maXhlZCksXG4gICAgICAgICAgICAgICAgJ3YtYm90dG9tLW5hdi0tc2hpZnQnOiB0aGlzLnNoaWZ0LFxuICAgICAgICAgICAgICAgICd2LWJvdHRvbS1uYXYtLWFjdGl2ZSc6IHRoaXMudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkSGVpZ2h0OiBmdW5jdGlvbiBjb21wdXRlZEhlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdXBkYXRlQXBwbGljYXRpb246IGZ1bmN0aW9uIHVwZGF0ZUFwcGxpY2F0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnZhbHVlID8gMCA6IHRoaXMuY29tcHV0ZWRIZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVZhbHVlOiBmdW5jdGlvbiB1cGRhdGVWYWx1ZSh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTphY3RpdmUnLCB2YWwpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHJldHVybiBoKF9taXhpbnNfYnV0dG9uX2dyb3VwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCB0aGlzLnNldEJhY2tncm91bmRDb2xvcih0aGlzLmNvbG9yLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtYm90dG9tLW5hdicsXG4gICAgICAgICAgICBjbGFzczogdGhpcy5jbGFzc2VzLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KHRoaXMuY29tcHV0ZWRIZWlnaHQpICsgXCJweFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBtYW5kYXRvcnk6IEJvb2xlYW4odGhpcy5tYW5kYXRvcnkgfHwgdGhpcy5hY3RpdmUgIT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuYWN0aXZlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHsgY2hhbmdlOiB0aGlzLnVwZGF0ZVZhbHVlIH1cbiAgICAgICAgfSksIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WQm90dG9tTmF2L2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZCb3R0b21OYXYvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZCb3R0b21OYXYsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZCb3R0b21OYXZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkJvdHRvbU5hdiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkJvdHRvbU5hdi9WQm90dG9tTmF2LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkJvdHRvbU5hdlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQm90dG9tTmF2X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX1ZCb3R0b21OYXZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZCb3R0b21TaGVldC9WQm90dG9tU2hlZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkJvdHRvbVNoZWV0L1ZCb3R0b21TaGVldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfYm90dG9tX3NoZWV0c19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fYm90dG9tLXNoZWV0cy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2JvdHRvbS1zaGVldHMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfYm90dG9tX3NoZWV0c19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2JvdHRvbV9zaGVldHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkRpYWxvZ19WRGlhbG9nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WRGlhbG9nL1ZEaWFsb2cgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEaWFsb2cvVkRpYWxvZy5qc1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtYm90dG9tLXNoZWV0JyxcbiAgICBwcm9wczoge1xuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgZnVsbFdpZHRoOiBCb29sZWFuLFxuICAgICAgICBoaWRlT3ZlcmxheTogQm9vbGVhbixcbiAgICAgICAgaW5zZXQ6IEJvb2xlYW4sXG4gICAgICAgIGxhenk6IEJvb2xlYW4sXG4gICAgICAgIG1heFdpZHRoOiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2F1dG8nXG4gICAgICAgIH0sXG4gICAgICAgIHBlcnNpc3RlbnQ6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBhY3RpdmF0b3IgPSBoKCd0ZW1wbGF0ZScsIHtcbiAgICAgICAgICAgIHNsb3Q6ICdhY3RpdmF0b3InXG4gICAgICAgIH0sIHRoaXMuJHNsb3RzLmFjdGl2YXRvcik7XG4gICAgICAgIHZhciBjb250ZW50Q2xhc3MgPSBbJ3YtYm90dG9tLXNoZWV0JywgdGhpcy5pbnNldCA/ICd2LWJvdHRvbS1zaGVldC0taW5zZXQnIDogJyddLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIGgoX1ZEaWFsb2dfVkRpYWxvZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduKHt9LCB0aGlzLiRwcm9wcyksXG4gICAgICAgICAgICBvbjogX19hc3NpZ24oe30sIHRoaXMuJGxpc3RlbmVycyksXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRDbGFzczogY29udGVudENsYXNzLFxuICAgICAgICAgICAgICAgIG5vQ2xpY2tBbmltYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2JvdHRvbS1zaGVldC10cmFuc2l0aW9uJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbYWN0aXZhdG9yLCB0aGlzLiRzbG90cy5kZWZhdWx0XSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkJvdHRvbVNoZWV0L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkJvdHRvbVNoZWV0L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZCb3R0b21TaGVldCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkJvdHRvbVNoZWV0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZCb3R0b21TaGVldCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkJvdHRvbVNoZWV0L1ZCb3R0b21TaGVldC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZCb3R0b21TaGVldFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQm90dG9tU2hlZXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkJvdHRvbVNoZWV0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WQnJlYWRjcnVtYnMvVkJyZWFkY3J1bWJzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZCcmVhZGNydW1icy9WQnJlYWRjcnVtYnMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2JyZWFkY3J1bWJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19icmVhZGNydW1icy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2JyZWFkY3J1bWJzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2JyZWFkY3J1bWJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfYnJlYWRjcnVtYnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuICovIFwiLi9zcmMvY29tcG9uZW50cy9WQnJlYWRjcnVtYnMvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvY29uc29sZSAqLyBcIi4vc3JjL3V0aWwvY29uc29sZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBTdHlsZXNcblxuLy8gQ29tcG9uZW50c1xuXG4vLyBNaXhpbnNcblxuLy8gVXRpbHNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE9iamVjdChfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0pKF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LWJyZWFkY3J1bWJzJyxcbiAgICBwcm9wczoge1xuICAgICAgICBkaXZpZGVyOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnLydcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsYXJnZTogQm9vbGVhbixcbiAgICAgICAganVzdGlmeUNlbnRlcjogQm9vbGVhbixcbiAgICAgICAganVzdGlmeUVuZDogQm9vbGVhblxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7ICd2LWJyZWFkY3J1bWJzLS1sYXJnZSc6IHRoaXMubGFyZ2UsICdqdXN0aWZ5LWNlbnRlcic6IHRoaXMuanVzdGlmeUNlbnRlciwgJ2p1c3RpZnktZW5kJzogdGhpcy5qdXN0aWZ5RW5kIH0sIHRoaXMudGhlbWVDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuanVzdGlmeUNlbnRlcikgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlcHJlY2F0ZVwiXSkoJ2p1c3RpZnktY2VudGVyJywgJ2NsYXNzPVwianVzdGlmeS1jZW50ZXJcIicsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5qdXN0aWZ5RW5kKSBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVwcmVjYXRlXCJdKSgnanVzdGlmeS1lbmQnLCAnY2xhc3M9XCJqdXN0aWZ5LWVuZFwiJywgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLiRzbG90cy5kZWZhdWx0KSBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVwcmVjYXRlXCJdKSgnZGVmYXVsdCBzbG90JywgJzppdGVtcyBhbmQgc2NvcGVkIHNsb3QgXCJpdGVtXCInLCB0aGlzKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgLyogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgZ2VuQ2hpbGRyZW4gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi86IGZ1bmN0aW9uIGdlbkNoaWxkcmVuKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiRzbG90cy5kZWZhdWx0KSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICB2YXIgY3JlYXRlRGl2aWRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy4kc2xvdHMuZGVmYXVsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbG0gPSB0aGlzLiRzbG90cy5kZWZhdWx0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghZWxtLmNvbXBvbmVudE9wdGlvbnMgfHwgZWxtLmNvbXBvbmVudE9wdGlvbnMuQ3Rvci5vcHRpb25zLm5hbWUgIT09ICd2LWJyZWFkY3J1bWJzLWl0ZW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goZWxtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRlRGl2aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5nZW5EaXZpZGVyKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goZWxtKTtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRGl2aWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuRGl2aWRlcjogZnVuY3Rpb24gZ2VuRGl2aWRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlZCcmVhZGNydW1ic0RpdmlkZXJcIl0sIHRoaXMuJHNsb3RzLmRpdmlkZXIgPyB0aGlzLiRzbG90cy5kaXZpZGVyIDogdGhpcy5kaXZpZGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSXRlbXM6IGZ1bmN0aW9uIGdlbkl0ZW1zKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgICAgICB2YXIgaGFzU2xvdCA9ICEhdGhpcy4kc2NvcGVkU2xvdHMuaXRlbTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5pdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2xvdCkgaXRlbXMucHVzaCh0aGlzLiRzY29wZWRTbG90cy5pdGVtKHsgaXRlbTogaXRlbSB9KSk7ZWxzZSBpdGVtcy5wdXNoKHRoaXMuJGNyZWF0ZUVsZW1lbnQoX19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiVkJyZWFkY3J1bWJzSXRlbVwiXSwgeyBrZXk6IGl0ZW0udGV4dCwgcHJvcHM6IGl0ZW0gfSwgW2l0ZW0udGV4dF0pKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IHRoaXMuaXRlbXMubGVuZ3RoIC0gMSkgaXRlbXMucHVzaCh0aGlzLmdlbkRpdmlkZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCA/IHRoaXMuZ2VuQ2hpbGRyZW4oKSA6IHRoaXMuZ2VuSXRlbXMoKTtcbiAgICAgICAgcmV0dXJuIGgoJ3VsJywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWJyZWFkY3J1bWJzJyxcbiAgICAgICAgICAgICdjbGFzcyc6IHRoaXMuY2xhc3Nlc1xuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZCcmVhZGNydW1icy9WQnJlYWRjcnVtYnNJdGVtLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WQnJlYWRjcnVtYnMvVkJyZWFkY3J1bWJzSXRlbS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19yb3V0YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3JvdXRhYmxlICovIFwiLi9zcmMvbWl4aW5zL3JvdXRhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9taXhpbnMgKi8gXCIuL3NyYy91dGlsL21peGlucy50c1wiKTtcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKShfbWl4aW5zX3JvdXRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LWJyZWFkY3J1bWJzLWl0ZW0nLFxuICAgIHByb3BzOiB7XG4gICAgICAgIC8vIEluIGEgYnJlYWRjcnVtYiwgdGhlIGN1cnJlbnRseVxuICAgICAgICAvLyBhY3RpdmUgaXRlbSBzaG91bGQgYmUgZGltbWVkXG4gICAgICAgIGFjdGl2ZUNsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAndi1icmVhZGNydW1ic19faXRlbS0tZGlzYWJsZWQnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gX2EgPSB7XG4gICAgICAgICAgICAgICAgJ3YtYnJlYWRjcnVtYnNfX2l0ZW0nOiB0cnVlXG4gICAgICAgICAgICB9LCBfYVt0aGlzLmFjdGl2ZUNsYXNzXSA9IHRoaXMuZGlzYWJsZWQsIF9hO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2VuZXJhdGVSb3V0ZUxpbmsodGhpcy5jbGFzc2VzKSxcbiAgICAgICAgICAgIHRhZyA9IF9hLnRhZyxcbiAgICAgICAgICAgIGRhdGEgPSBfYS5kYXRhO1xuICAgICAgICByZXR1cm4gaCgnbGknLCBbaCh0YWcsIGRhdGEsIHRoaXMuJHNsb3RzLmRlZmF1bHQpXSk7XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZCcmVhZGNydW1icy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZCcmVhZGNydW1icy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWQnJlYWRjcnVtYnMsIFZCcmVhZGNydW1ic0l0ZW0sIFZCcmVhZGNydW1ic0RpdmlkZXIsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkJyZWFkY3J1bWJzRGl2aWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZCcmVhZGNydW1ic0RpdmlkZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQnJlYWRjcnVtYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkJyZWFkY3J1bWJzICovIFwiLi9zcmMvY29tcG9uZW50cy9WQnJlYWRjcnVtYnMvVkJyZWFkY3J1bWJzLnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkJyZWFkY3J1bWJzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZCcmVhZGNydW1ic19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkJyZWFkY3J1bWJzSXRlbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQnJlYWRjcnVtYnNJdGVtICovIFwiLi9zcmMvY29tcG9uZW50cy9WQnJlYWRjcnVtYnMvVkJyZWFkY3J1bWJzSXRlbS50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZCcmVhZGNydW1ic0l0ZW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkJyZWFkY3J1bWJzSXRlbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG5cblxuXG52YXIgVkJyZWFkY3J1bWJzRGl2aWRlciA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJjcmVhdGVTaW1wbGVGdW5jdGlvbmFsXCJdKSgndi1icmVhZGNydW1ic19fZGl2aWRlcicsICdsaScpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICAkX3Z1ZXRpZnlfc3ViY29tcG9uZW50czoge1xuICAgICAgICBWQnJlYWRjcnVtYnM6IF9WQnJlYWRjcnVtYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZCcmVhZGNydW1ic0l0ZW06IF9WQnJlYWRjcnVtYnNJdGVtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWQnJlYWRjcnVtYnNEaXZpZGVyOiBWQnJlYWRjcnVtYnNEaXZpZGVyXG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkJ0bi9WQnRuLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkJ0bi9WQnRuLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2J1dHRvbnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2J1dHRvbnMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19idXR0b25zLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2J1dHRvbnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19idXR0b25zX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL21peGlucyAqLyBcIi4vc3JjL3V0aWwvbWl4aW5zLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WUHJvZ3Jlc3NDaXJjdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVlByb2dyZXNzQ2lyY3VsYXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZQcm9ncmVzc0NpcmN1bGFyL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2dyb3VwYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2dyb3VwYWJsZSAqLyBcIi4vc3JjL21peGlucy9ncm91cGFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19wb3NpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9wb3NpdGlvbmFibGUgKi8gXCIuL3NyYy9taXhpbnMvcG9zaXRpb25hYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcm91dGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9yb3V0YWJsZSAqLyBcIi4vc3JjL21peGlucy9yb3V0YWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RoZW1lYWJsZSAqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190b2dnbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdG9nZ2xlYWJsZSAqLyBcIi4vc3JjL21peGlucy90b2dnbGVhYmxlLnRzXCIpO1xudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBTdHlsZXNcblxuXG4vLyBDb21wb25lbnRzXG5cbi8vIE1peGluc1xuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKShfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSwgX21peGluc19yb3V0YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZGVmYXVsdFwiXSwgX21peGluc19wb3NpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdLCBPYmplY3QoX21peGluc19ncm91cGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImZhY3RvcnlcIl0pKCdidG5Ub2dnbGUnKSwgT2JqZWN0KF9taXhpbnNfdG9nZ2xlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiZmFjdG9yeVwiXSkoJ2lucHV0VmFsdWUnKVxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbikuZXh0ZW5kKHtcbiAgICBuYW1lOiAndi1idG4nLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFjdGl2ZUNsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAndi1idG4tLWFjdGl2ZSdcbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2s6IEJvb2xlYW4sXG4gICAgICAgIGRlcHJlc3NlZDogQm9vbGVhbixcbiAgICAgICAgZmFiOiBCb29sZWFuLFxuICAgICAgICBmbGF0OiBCb29sZWFuLFxuICAgICAgICBpY29uOiBCb29sZWFuLFxuICAgICAgICBsYXJnZTogQm9vbGVhbixcbiAgICAgICAgbG9hZGluZzogQm9vbGVhbixcbiAgICAgICAgb3V0bGluZTogQm9vbGVhbixcbiAgICAgICAgcmlwcGxlOiB7XG4gICAgICAgICAgICB0eXBlOiBbQm9vbGVhbiwgT2JqZWN0XSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgcm91bmQ6IEJvb2xlYW4sXG4gICAgICAgIHNtYWxsOiBCb29sZWFuLFxuICAgICAgICB0YWc6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdidXR0b24nXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdidXR0b24nXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKChfYSA9IHsgJ3YtYnRuJzogdHJ1ZSB9LCBfYVt0aGlzLmFjdGl2ZUNsYXNzXSA9IHRoaXMuaXNBY3RpdmUsIF9hWyd2LWJ0bi0tYWJzb2x1dGUnXSA9IHRoaXMuYWJzb2x1dGUsIF9hWyd2LWJ0bi0tYmxvY2snXSA9IHRoaXMuYmxvY2ssIF9hWyd2LWJ0bi0tYm90dG9tJ10gPSB0aGlzLmJvdHRvbSwgX2FbJ3YtYnRuLS1kaXNhYmxlZCddID0gdGhpcy5kaXNhYmxlZCwgX2FbJ3YtYnRuLS1mbGF0J10gPSB0aGlzLmZsYXQsIF9hWyd2LWJ0bi0tZmxvYXRpbmcnXSA9IHRoaXMuZmFiLCBfYVsndi1idG4tLWZpeGVkJ10gPSB0aGlzLmZpeGVkLCBfYVsndi1idG4tLWljb24nXSA9IHRoaXMuaWNvbiwgX2FbJ3YtYnRuLS1sYXJnZSddID0gdGhpcy5sYXJnZSwgX2FbJ3YtYnRuLS1sZWZ0J10gPSB0aGlzLmxlZnQsIF9hWyd2LWJ0bi0tbG9hZGVyJ10gPSB0aGlzLmxvYWRpbmcsIF9hWyd2LWJ0bi0tb3V0bGluZSddID0gdGhpcy5vdXRsaW5lLCBfYVsndi1idG4tLWRlcHJlc3NlZCddID0gdGhpcy5kZXByZXNzZWQgJiYgIXRoaXMuZmxhdCB8fCB0aGlzLm91dGxpbmUsIF9hWyd2LWJ0bi0tcmlnaHQnXSA9IHRoaXMucmlnaHQsIF9hWyd2LWJ0bi0tcm91bmQnXSA9IHRoaXMucm91bmQsIF9hWyd2LWJ0bi0tcm91dGVyJ10gPSB0aGlzLnRvLCBfYVsndi1idG4tLXNtYWxsJ10gPSB0aGlzLnNtYWxsLCBfYVsndi1idG4tLXRvcCddID0gdGhpcy50b3AsIF9hKSwgdGhpcy50aGVtZUNsYXNzZXMpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wdXRlZFJpcHBsZTogZnVuY3Rpb24gY29tcHV0ZWRSaXBwbGUoKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFJpcHBsZSA9IHRoaXMuaWNvbiB8fCB0aGlzLmZhYiA/IHsgY2lyY2xlOiB0cnVlIH0gOiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHJldHVybiBmYWxzZTtlbHNlIHJldHVybiB0aGlzLnJpcHBsZSAhPT0gbnVsbCA/IHRoaXMucmlwcGxlIDogZGVmYXVsdFJpcHBsZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICAvLyBQcmV2ZW50IGZvY3VzIHRvIG1hdGNoIG1kIHNwZWNcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGUpIHtcbiAgICAgICAgICAgICF0aGlzLmZhYiAmJiBlLmRldGFpbCAmJiB0aGlzLiRlbC5ibHVyKCk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGUpO1xuICAgICAgICAgICAgdGhpcy5idG5Ub2dnbGUgJiYgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuQ29udGVudDogZnVuY3Rpb24gZ2VuQ29udGVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7ICdjbGFzcyc6ICd2LWJ0bl9fY29udGVudCcgfSwgW3RoaXMuJHNsb3RzLmRlZmF1bHRdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuTG9hZGVyOiBmdW5jdGlvbiBnZW5Mb2FkZXIoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGlmICghdGhpcy4kc2xvdHMubG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLiRjcmVhdGVFbGVtZW50KF9WUHJvZ3Jlc3NDaXJjdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDIzLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLiRzbG90cy5sb2FkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7ICdjbGFzcyc6ICd2LWJ0bl9fbG9hZGluZycgfSwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBzZXRDb2xvciA9ICF0aGlzLm91dGxpbmUgJiYgIXRoaXMuZmxhdCA/IHRoaXMuc2V0QmFja2dyb3VuZENvbG9yIDogdGhpcy5zZXRUZXh0Q29sb3I7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2VuZXJhdGVSb3V0ZUxpbmsodGhpcy5jbGFzc2VzKSxcbiAgICAgICAgICAgIHRhZyA9IF9hLnRhZyxcbiAgICAgICAgICAgIGRhdGEgPSBfYS5kYXRhO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbdGhpcy5nZW5Db250ZW50KCldO1xuICAgICAgICB0YWcgPT09ICdidXR0b24nICYmIChkYXRhLmF0dHJzLnR5cGUgPSB0aGlzLnR5cGUpO1xuICAgICAgICB0aGlzLmxvYWRpbmcgJiYgY2hpbGRyZW4ucHVzaCh0aGlzLmdlbkxvYWRlcigpKTtcbiAgICAgICAgZGF0YS5hdHRycy52YWx1ZSA9IFsnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKF90eXBlb2YodGhpcy52YWx1ZSkpID8gdGhpcy52YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpO1xuICAgICAgICByZXR1cm4gaCh0YWcsIHNldENvbG9yKHRoaXMuY29sb3IsIGRhdGEpLCBjaGlsZHJlbik7XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZCdG4vaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkJ0bi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVkJ0biwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkJ0bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQnRuICovIFwiLi9zcmMvY29tcG9uZW50cy9WQnRuL1ZCdG4udHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQnRuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZCdG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkJ0bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkJ0blRvZ2dsZS9WQnRuVG9nZ2xlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkJ0blRvZ2dsZS9WQnRuVG9nZ2xlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2J1dHRvbl90b2dnbGVfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2J1dHRvbi10b2dnbGUuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19idXR0b24tdG9nZ2xlLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2J1dHRvbl90b2dnbGVfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19idXR0b25fdG9nZ2xlX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19idXR0b25fZ3JvdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9idXR0b24tZ3JvdXAgKi8gXCIuL3NyYy9taXhpbnMvYnV0dG9uLWdyb3VwLnRzXCIpO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuLy8gU3R5bGVzXG5cbi8vIE1peGluc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfbWl4aW5zX2J1dHRvbl9ncm91cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LWJ0bi10b2dnbGUnLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFjdGl2ZUNsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAndi1idG4tLWFjdGl2ZSdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7fSwgX21peGluc19idXR0b25fZ3JvdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0ub3B0aW9ucy5jb21wdXRlZC5jbGFzc2VzLmNhbGwodGhpcyksIHsgJ3YtYnRuLXRvZ2dsZSc6IHRydWUsICd2LWJ0bi10b2dnbGUtLW9ubHktY2hpbGQnOiB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoID09PSAxLCAndi1idG4tdG9nZ2xlLS1zZWxlY3RlZCc6IHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwIH0pO1xuICAgICAgICB9XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZCdG5Ub2dnbGUvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkJ0blRvZ2dsZS9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVkJ0blRvZ2dsZSwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkJ0blRvZ2dsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQnRuVG9nZ2xlICovIFwiLi9zcmMvY29tcG9uZW50cy9WQnRuVG9nZ2xlL1ZCdG5Ub2dnbGUudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQnRuVG9nZ2xlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZCdG5Ub2dnbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkJ0blRvZ2dsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkNhcmQvVkNhcmQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZDYXJkL1ZDYXJkLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfY2FyZHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2NhcmRzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fY2FyZHMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfY2FyZHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19jYXJkc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX21lYXN1cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9tZWFzdXJhYmxlICovIFwiLi9zcmMvbWl4aW5zL21lYXN1cmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19yb3V0YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3JvdXRhYmxlICovIFwiLi9zcmMvbWl4aW5zL3JvdXRhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL21peGlucyAqLyBcIi4vc3JjL3V0aWwvbWl4aW5zLnRzXCIpO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuLy8gU3R5bGVzXG5cbi8vIE1peGluc1xuXG5cblxuXG4vLyBIZWxwZXJzXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoT2JqZWN0KF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZGVmYXVsdFwiXSkoX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfbWVhc3VyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwgX21peGluc19yb3V0YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSwgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0pLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtY2FyZCcsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZmxhdDogQm9vbGVhbixcbiAgICAgICAgaG92ZXI6IEJvb2xlYW4sXG4gICAgICAgIGltZzogU3RyaW5nLFxuICAgICAgICByYWlzZWQ6IEJvb2xlYW4sXG4gICAgICAgIHRhZzoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICAgICAgfSxcbiAgICAgICAgdGlsZTogQm9vbGVhblxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7ICd2LWNhcmQnOiB0cnVlLCAndi1jYXJkLS1mbGF0JzogdGhpcy5mbGF0LCAndi1jYXJkLS1ob3Zlcic6IHRoaXMuaG92ZXIsICd2LWNhcmQtLXJhaXNlZCc6IHRoaXMucmFpc2VkLCAndi1jYXJkLS10aWxlJzogdGhpcy50aWxlIH0sIHRoaXMudGhlbWVDbGFzc2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGVzOiBmdW5jdGlvbiBzdHlsZXMoKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiY29udmVydFRvVW5pdFwiXSkodGhpcy5oZWlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuaW1nKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuYmFja2dyb3VuZCA9IFwidXJsKFxcXCJcIiArIHRoaXMuaW1nICsgXCJcXFwiKSBjZW50ZXIgY2VudGVyIC8gY292ZXIgbm8tcmVwZWF0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQpIHN0eWxlLmhlaWdodCA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJjb252ZXJ0VG9Vbml0XCJdKSh0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXhIZWlnaHQpIHN0eWxlLm1heEhlaWdodCA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJjb252ZXJ0VG9Vbml0XCJdKSh0aGlzLm1heEhlaWdodCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXhXaWR0aCkgc3R5bGUubWF4V2lkdGggPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiY29udmVydFRvVW5pdFwiXSkodGhpcy5tYXhXaWR0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCkgc3R5bGUud2lkdGggPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiY29udmVydFRvVW5pdFwiXSkodGhpcy53aWR0aCk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZW5lcmF0ZVJvdXRlTGluayh0aGlzLmNsYXNzZXMpLFxuICAgICAgICAgICAgdGFnID0gX2EudGFnLFxuICAgICAgICAgICAgZGF0YSA9IF9hLmRhdGE7XG4gICAgICAgIGRhdGEuc3R5bGUgPSB0aGlzLnN0eWxlcztcbiAgICAgICAgcmV0dXJuIGgodGFnLCB0aGlzLnNldEJhY2tncm91bmRDb2xvcih0aGlzLmNvbG9yLCBkYXRhKSwgdGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDYXJkL1ZDYXJkTWVkaWEudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkNhcmQvVkNhcmRNZWRpYS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkltZ19WSW1nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WSW1nL1ZJbWcgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJbWcvVkltZy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG4vLyBDb21wb25lbnRzXG5cbi8vIFV0aWxzXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkltZ19WSW1nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtY2FyZC1tZWRpYScsXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgICAgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlcHJlY2F0ZVwiXSkoJ3YtY2FyZC1tZWRpYScsIHRoaXMuc3JjID8gJ3YtaW1nJyA6ICd2LXJlc3BvbnNpdmUnLCB0aGlzKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkNhcmQvVkNhcmRUaXRsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WQ2FyZC9WQ2FyZFRpdGxlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFwidnVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8vIFR5cGVzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LWNhcmQtdGl0bGUnLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgcHJpbWFyeVRpdGxlOiBCb29sZWFuXG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfYSkge1xuICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGEsXG4gICAgICAgICAgICBwcm9wcyA9IF9hLnByb3BzLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICAgICAgZGF0YS5zdGF0aWNDbGFzcyA9IChcInYtY2FyZF9fdGl0bGUgXCIgKyAoZGF0YS5zdGF0aWNDbGFzcyB8fCAnJykpLnRyaW0oKTtcbiAgICAgICAgaWYgKHByb3BzLnByaW1hcnlUaXRsZSkgZGF0YS5zdGF0aWNDbGFzcyArPSAnIHYtY2FyZF9fdGl0bGUtLXByaW1hcnknO1xuICAgICAgICByZXR1cm4gaCgnZGl2JywgZGF0YSwgY2hpbGRyZW4pO1xuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WQ2FyZC9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkNhcmQvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWQ2FyZCwgVkNhcmRNZWRpYSwgVkNhcmRUaXRsZSwgVkNhcmRBY3Rpb25zLCBWQ2FyZFRleHQsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNhcmRBY3Rpb25zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVkNhcmRBY3Rpb25zOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQ2FyZFRleHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWQ2FyZFRleHQ7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkNhcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkNhcmQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDYXJkL1ZDYXJkLnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNhcmRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNhcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZDYXJkTWVkaWFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkNhcmRNZWRpYSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkNhcmQvVkNhcmRNZWRpYS50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZDYXJkTWVkaWFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNhcmRNZWRpYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkNhcmRUaXRsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQ2FyZFRpdGxlICovIFwiLi9zcmMvY29tcG9uZW50cy9WQ2FyZC9WQ2FyZFRpdGxlLnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNhcmRUaXRsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQ2FyZFRpdGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFwidnVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcblxuXG5cblxuXG52YXIgVkNhcmRBY3Rpb25zID0gdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdC5hLmV4dGVuZChPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY3JlYXRlU2ltcGxlRnVuY3Rpb25hbFwiXSkoJ3YtY2FyZF9fYWN0aW9ucycpKTtcbnZhciBWQ2FyZFRleHQgPSB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0LmEuZXh0ZW5kKE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVTaW1wbGVGdW5jdGlvbmFsXCJdKSgndi1jYXJkX190ZXh0JykpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICAkX3Z1ZXRpZnlfc3ViY29tcG9uZW50czoge1xuICAgICAgICBWQ2FyZDogX1ZDYXJkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWQ2FyZE1lZGlhOiBfVkNhcmRNZWRpYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgVkNhcmRUaXRsZTogX1ZDYXJkVGl0bGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZDYXJkQWN0aW9uczogVkNhcmRBY3Rpb25zLFxuICAgICAgICBWQ2FyZFRleHQ6IFZDYXJkVGV4dFxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDYXJvdXNlbC9WQ2Fyb3VzZWwudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkNhcm91c2VsL1ZDYXJvdXNlbC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfY2Fyb3VzZWxfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2Nhcm91c2VsLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fY2Fyb3VzZWwuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfY2Fyb3VzZWxfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19jYXJvdXNlbF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WV2luZG93X1ZXaW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZXaW5kb3cvVldpbmRvdyAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVldpbmRvdy9WV2luZG93LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQnRuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WQnRuICovIFwiLi9zcmMvY29tcG9uZW50cy9WQnRuL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVkljb24gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJY29uL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfYnV0dG9uX2dyb3VwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvYnV0dG9uLWdyb3VwICovIFwiLi9zcmMvbWl4aW5zL2J1dHRvbi1ncm91cC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG4vLyBTdHlsZXNcblxuLy8gRXh0ZW5zaW9uc1xuXG4vLyBDb21wb25lbnRzXG5cblxuLy8gTWl4aW5zXG4vLyBUT0RPOiBNb3ZlIHRoaXMgaW50byBjb3JlIGNvbXBvbmVudHMgdjIuMFxuXG4vLyBVdGlsaXRpZXNcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVldpbmRvd19WV2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtY2Fyb3VzZWwnLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGN5Y2xlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBkZWxpbWl0ZXJJY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMuZGVsaW1pdGVyJ1xuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiA1MDBcbiAgICAgICAgfSxcbiAgICAgICAgaGlkZUNvbnRyb2xzOiBCb29sZWFuLFxuICAgICAgICBoaWRlRGVsaW1pdGVyczogQm9vbGVhbixcbiAgICAgICAgaW50ZXJ2YWw6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiA2MDAwLFxuICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtYW5kYXRvcnk6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG5leHRJY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5uZXh0J1xuICAgICAgICB9LFxuICAgICAgICBwcmV2SWNvbjoge1xuICAgICAgICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMucHJldidcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZWRCeUNvbnRyb2xzOiBmYWxzZSxcbiAgICAgICAgICAgIGludGVybmFsSGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIHNsaWRlVGltZW91dDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBpc0Rhcms6IGZ1bmN0aW9uIGlzRGFyaygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhcmsgfHwgIXRoaXMubGlnaHQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIGludGVybmFsVmFsdWU6ICdyZXN0YXJ0VGltZW91dCcsXG4gICAgICAgIGludGVydmFsOiAncmVzdGFydFRpbWVvdXQnLFxuICAgICAgICBjeWNsZTogZnVuY3Rpb24gY3ljbGUodmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0VGltZW91dCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zbGlkZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZW91dCgpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZW5EZWxpbWl0ZXJzOiBmdW5jdGlvbiBnZW5EZWxpbWl0ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtY2Fyb3VzZWxfX2NvbnRyb2xzJ1xuICAgICAgICAgICAgfSwgW3RoaXMuZ2VuSXRlbXMoKV0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5JY29uOiBmdW5jdGlvbiBnZW5JY29uKGRpcmVjdGlvbiwgaWNvbiwgZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidi1jYXJvdXNlbF9fXCIgKyBkaXJlY3Rpb25cbiAgICAgICAgICAgIH0sIFt0aGlzLiRjcmVhdGVFbGVtZW50KF9WQnRuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IGZuIH1cbiAgICAgICAgICAgIH0sIFt0aGlzLiRjcmVhdGVFbGVtZW50KF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIHByb3BzOiB7ICdzaXplJzogJzQ2cHgnIH1cbiAgICAgICAgICAgIH0sIGljb24pXSldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSWNvbnM6IGZ1bmN0aW9uIGdlbkljb25zKCkge1xuICAgICAgICAgICAgdmFyIGljb25zID0gW107XG4gICAgICAgICAgICB2YXIgcHJldkljb24gPSB0aGlzLiR2dWV0aWZ5LnJ0bCA/IHRoaXMubmV4dEljb24gOiB0aGlzLnByZXZJY29uO1xuICAgICAgICAgICAgaWYgKHByZXZJY29uICYmIHR5cGVvZiBwcmV2SWNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpY29ucy5wdXNoKHRoaXMuZ2VuSWNvbigncHJldicsIHByZXZJY29uLCB0aGlzLnByZXYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXh0SWNvbiA9IHRoaXMuJHZ1ZXRpZnkucnRsID8gdGhpcy5wcmV2SWNvbiA6IHRoaXMubmV4dEljb247XG4gICAgICAgICAgICBpZiAobmV4dEljb24gJiYgdHlwZW9mIG5leHRJY29uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGljb25zLnB1c2godGhpcy5nZW5JY29uKCduZXh0JywgbmV4dEljb24sIHRoaXMubmV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGljb25zO1xuICAgICAgICB9LFxuICAgICAgICBnZW5JdGVtczogZnVuY3Rpb24gZ2VuSXRlbXMoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy4kY3JlYXRlRWxlbWVudChfVkJ0bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3YtY2Fyb3VzZWxfX2NvbnRyb2xzX19pdGVtJzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBbdGhpcy4kY3JlYXRlRWxlbWVudChfVkljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHsgc2l6ZTogMTggfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMuZGVsaW1pdGVySWNvbildKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9taXhpbnNfYnV0dG9uX2dyb3VwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaW50ZXJuYWxWYWx1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBmdW5jdGlvbiBjaGFuZ2UodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VkQnlDb250cm9scyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnRlcm5hbFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgICAgICB9LFxuICAgICAgICByZXN0YXJ0VGltZW91dDogZnVuY3Rpb24gcmVzdGFydFRpbWVvdXQoKSB7XG4gICAgICAgICAgICB0aGlzLnNsaWRlVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5zbGlkZVRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5zbGlkZVRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHNldFRpbWVvdXQ7XG4gICAgICAgICAgICByYWYodGhpcy5zdGFydFRpbWVvdXQpO1xuICAgICAgICB9LFxuICAgICAgICBzdGFydFRpbWVvdXQ6IGZ1bmN0aW9uIHN0YXJ0VGltZW91dCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jeWNsZSkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zbGlkZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLm5leHQsICt0aGlzLmludGVydmFsID4gMCA/ICt0aGlzLmludGVydmFsIDogNjAwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVJldmVyc2U6IGZ1bmN0aW9uIHVwZGF0ZVJldmVyc2UodmFsLCBvbGRWYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5nZWRCeUNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkQnlDb250cm9scyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF9WV2luZG93X1ZXaW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0ub3B0aW9ucy5tZXRob2RzLnVwZGF0ZVJldmVyc2UuY2FsbCh0aGlzLCB2YWwsIG9sZFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXdpbmRvdyB2LWNhcm91c2VsJyxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiY29udmVydFRvVW5pdFwiXSkodGhpcy5oZWlnaHQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlyZWN0aXZlczogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLnRvdWNobGVzcykge1xuICAgICAgICAgICAgZGF0YS5kaXJlY3RpdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5uZXh0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5wcmV2XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhpZGVDb250cm9scykge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmdlbkljb25zKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5oaWRlRGVsaW1pdGVycykge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmdlbkRlbGltaXRlcnMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIGRhdGEsIFtjaGlsZHJlbiwgdGhpcy5nZW5Db250YWluZXIoKV0pO1xuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WQ2Fyb3VzZWwvVkNhcm91c2VsSXRlbS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkNhcm91c2VsL1ZDYXJvdXNlbEl0ZW0udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WV2luZG93X1ZXaW5kb3dJdGVtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WV2luZG93L1ZXaW5kb3dJdGVtICovIFwiLi9zcmMvY29tcG9uZW50cy9WV2luZG93L1ZXaW5kb3dJdGVtLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WSW1nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WSW1nICovIFwiLi9zcmMvY29tcG9uZW50cy9WSW1nL2luZGV4LnRzXCIpO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuLy8gRXh0ZW5zaW9uc1xuXG4vLyBDb21wb25lbnRzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WV2luZG93X1ZXaW5kb3dJdGVtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtY2Fyb3VzZWwtaXRlbScsXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlbkRlZmF1bHRTbG90OiBmdW5jdGlvbiBnZW5EZWZhdWx0U2xvdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy4kY3JlYXRlRWxlbWVudChfVkltZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiVkltZ1wiXSwge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1jYXJvdXNlbF9faXRlbScsXG4gICAgICAgICAgICAgICAgcHJvcHM6IF9fYXNzaWduKHt9LCB0aGlzLiRhdHRycywgeyBoZWlnaHQ6IHRoaXMud2luZG93R3JvdXAuaW50ZXJuYWxIZWlnaHQgfSksXG4gICAgICAgICAgICAgICAgb246IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgICAgICAgfSwgdGhpcy4kc2xvdHMuZGVmYXVsdCldO1xuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZUVudGVyOiBmdW5jdGlvbiBvbkJlZm9yZUVudGVyKCkge30sXG4gICAgICAgIG9uRW50ZXI6IGZ1bmN0aW9uIG9uRW50ZXIoKSB7fSxcbiAgICAgICAgb25BZnRlckVudGVyOiBmdW5jdGlvbiBvbkFmdGVyRW50ZXIoKSB7fSxcbiAgICAgICAgb25CZWZvcmVMZWF2ZTogZnVuY3Rpb24gb25CZWZvcmVMZWF2ZSgpIHt9LFxuICAgICAgICBvbkVudGVyQ2FuY2VsbGVkOiBmdW5jdGlvbiBvbkVudGVyQ2FuY2VsbGVkKCkge31cbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkNhcm91c2VsL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkNhcm91c2VsL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZDYXJvdXNlbCwgVkNhcm91c2VsSXRlbSwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkNhcm91c2VsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZDYXJvdXNlbCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkNhcm91c2VsL1ZDYXJvdXNlbC50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZDYXJvdXNlbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQ2Fyb3VzZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZDYXJvdXNlbEl0ZW1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkNhcm91c2VsSXRlbSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkNhcm91c2VsL1ZDYXJvdXNlbEl0ZW0udHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQ2Fyb3VzZWxJdGVtXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZDYXJvdXNlbEl0ZW1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICAkX3Z1ZXRpZnlfc3ViY29tcG9uZW50czoge1xuICAgICAgICBWQ2Fyb3VzZWw6IF9WQ2Fyb3VzZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZDYXJvdXNlbEl0ZW06IF9WQ2Fyb3VzZWxJdGVtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdXG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkNoZWNrYm94L1ZDaGVja2JveC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WQ2hlY2tib3gvVkNoZWNrYm94LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19zZWxlY3Rpb25fY29udHJvbHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3NlbGVjdGlvbi1jb250cm9scy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3NlbGVjdGlvbi1jb250cm9scy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19zZWxlY3Rpb25fY29udHJvbHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19zZWxlY3Rpb25fY29udHJvbHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZJY29uICovIFwiLi9zcmMvY29tcG9uZW50cy9WSWNvbi9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3NlbGVjdGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9zZWxlY3RhYmxlICovIFwiLi9zcmMvbWl4aW5zL3NlbGVjdGFibGUuanNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBTdHlsZXNcblxuLy8gQ29tcG9uZW50c1xuXG4vLyBpbXBvcnQgeyBWRmFkZVRyYW5zaXRpb24gfSBmcm9tICcuLi90cmFuc2l0aW9ucydcbi8vIE1peGluc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtY2hlY2tib3gnLFxuICAgIG1peGluczogW19taXhpbnNfc2VsZWN0YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgaW5kZXRlcm1pbmF0ZTogQm9vbGVhbixcbiAgICAgICAgaW5kZXRlcm1pbmF0ZUljb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5jaGVja2JveEluZGV0ZXJtaW5hdGUnXG4gICAgICAgIH0sXG4gICAgICAgIG9uSWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5Lmljb25zLmNoZWNrYm94T24nXG4gICAgICAgIH0sXG4gICAgICAgIG9mZkljb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5jaGVja2JveE9mZidcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSh2bSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXRJbmRldGVybWluYXRlOiB2bS5pbmRldGVybWluYXRlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndi1pbnB1dC0tc2VsZWN0aW9uLWNvbnRyb2xzJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndi1pbnB1dC0tY2hlY2tib3gnOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjb21wdXRlZEljb246IGZ1bmN0aW9uIGNvbXB1dGVkSWNvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0SW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGVJY29uO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25JY29uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZJY29uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBpbmRldGVybWluYXRlOiBmdW5jdGlvbiBpbmRldGVybWluYXRlKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEluZGV0ZXJtaW5hdGUgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuQ2hlY2tib3g6IGZ1bmN0aW9uIGdlbkNoZWNrYm94KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtaW5wdXQtLXNlbGVjdGlvbi1jb250cm9sc19faW5wdXQnXG4gICAgICAgICAgICB9LCBbdGhpcy5nZW5JbnB1dCgnY2hlY2tib3gnLCBfX2Fzc2lnbih7fSwgdGhpcy4kYXR0cnMsIHsgJ2FyaWEtY2hlY2tlZCc6IHRoaXMuaW5wdXRJbmRldGVybWluYXRlID8gJ21peGVkJyA6IHRoaXMuaXNBY3RpdmUudG9TdHJpbmcoKSB9KSksICF0aGlzLmRpc2FibGVkICYmIHRoaXMuZ2VuUmlwcGxlKHRoaXMuc2V0VGV4dENvbG9yKHRoaXMuY29tcHV0ZWRDb2xvcikpLCB0aGlzLiRjcmVhdGVFbGVtZW50KF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgdGhpcy5zZXRUZXh0Q29sb3IodGhpcy5jb21wdXRlZENvbG9yLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGFyazogdGhpcy5kYXJrLFxuICAgICAgICAgICAgICAgICAgICBsaWdodDogdGhpcy5saWdodFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCB0aGlzLmNvbXB1dGVkSWNvbildKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuRGVmYXVsdFNsb3Q6IGZ1bmN0aW9uIGdlbkRlZmF1bHRTbG90KCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmdlbkNoZWNrYm94KCksIHRoaXMuZ2VuTGFiZWwoKV07XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WQ2hlY2tib3gvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WQ2hlY2tib3gvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVkNoZWNrYm94LCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQ2hlY2tib3hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkNoZWNrYm94ICovIFwiLi9zcmMvY29tcG9uZW50cy9WQ2hlY2tib3gvVkNoZWNrYm94LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNoZWNrYm94XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZDaGVja2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WQ2hlY2tib3hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDaGlwL1ZDaGlwLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WQ2hpcC9WQ2hpcC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2NoaXBzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19jaGlwcy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2NoaXBzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2NoaXBzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfY2hpcHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WSWNvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkljb24vaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RvZ2dsZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90b2dnbGVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RvZ2dsZWFibGUudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cblxuLy8gQ29tcG9uZW50c1xuXG4vLyBNaXhpbnNcblxuXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE9iamVjdChfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pKF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSwgX21peGluc190b2dnbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LWNoaXAnLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNsb3NlOiBCb29sZWFuLFxuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgbGFiZWw6IEJvb2xlYW4sXG4gICAgICAgIG91dGxpbmU6IEJvb2xlYW4sXG4gICAgICAgIC8vIFVzZWQgZm9yIHNlbGVjdHMvdGFnZ2luZ1xuICAgICAgICBzZWxlY3RlZDogQm9vbGVhbixcbiAgICAgICAgc21hbGw6IEJvb2xlYW4sXG4gICAgICAgIHRleHRDb2xvcjogU3RyaW5nLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7ICd2LWNoaXAtLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCwgJ3YtY2hpcC0tc2VsZWN0ZWQnOiB0aGlzLnNlbGVjdGVkICYmICF0aGlzLmRpc2FibGVkLCAndi1jaGlwLS1sYWJlbCc6IHRoaXMubGFiZWwsICd2LWNoaXAtLW91dGxpbmUnOiB0aGlzLm91dGxpbmUsICd2LWNoaXAtLXNtYWxsJzogdGhpcy5zbWFsbCwgJ3YtY2hpcC0tcmVtb3ZhYmxlJzogdGhpcy5jbG9zZSB9LCB0aGlzLnRoZW1lQ2xhc3Nlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuQ2xvc2U6IGZ1bmN0aW9uIGdlbkNsb3NlKGgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtY2hpcF9fY2xvc2UnLFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGVtaXQoJ2lucHV0JywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBoKCdkaXYnLCBkYXRhLCBbaChfVkljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sICckdnVldGlmeS5pY29ucy5kZWxldGUnKV0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5Db250ZW50OiBmdW5jdGlvbiBnZW5Db250ZW50KGgpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFt0aGlzLiRzbG90cy5kZWZhdWx0XTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UgJiYgY2hpbGRyZW4ucHVzaCh0aGlzLmdlbkNsb3NlKGgpKTtcbiAgICAgICAgICAgIHJldHVybiBoKCdzcGFuJywge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1jaGlwX19jb250ZW50J1xuICAgICAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5jb2xvciwge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWNoaXAnLFxuICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy5jbGFzc2VzLFxuICAgICAgICAgICAgYXR0cnM6IHsgdGFiaW5kZXg6IHRoaXMuZGlzYWJsZWQgPyAtMSA6IDAgfSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3Nob3cnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmlzQWN0aXZlXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMudGV4dENvbG9yIHx8IHRoaXMub3V0bGluZSAmJiB0aGlzLmNvbG9yO1xuICAgICAgICByZXR1cm4gaCgnc3BhbicsIHRoaXMuc2V0VGV4dENvbG9yKGNvbG9yLCBkYXRhKSwgW3RoaXMuZ2VuQ29udGVudChoKV0pO1xuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WQ2hpcC9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkNoaXAvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWQ2hpcCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkNoaXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkNoaXAgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDaGlwL1ZDaGlwLnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNoaXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNoaXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkNoaXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDb21ib2JveC9WQ29tYm9ib3guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkNvbWJvYm94L1ZDb21ib2JveC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfYXV0b2NvbXBsZXRlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fYXV0b2NvbXBsZXRlcy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2F1dG9jb21wbGV0ZXMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfYXV0b2NvbXBsZXRlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2F1dG9jb21wbGV0ZXNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlNlbGVjdF9WU2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WU2VsZWN0L1ZTZWxlY3QgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTZWxlY3QvVlNlbGVjdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkF1dG9jb21wbGV0ZV9WQXV0b2NvbXBsZXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WQXV0b2NvbXBsZXRlL1ZBdXRvY29tcGxldGUgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZBdXRvY29tcGxldGUvVkF1dG9jb21wbGV0ZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG4vLyBTdHlsZXNcblxuLy8gRXh0ZW5zaW9uc1xuXG5cbi8vIFV0aWxzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1jb21ib2JveCcsXG4gICAgZXh0ZW5kczogX1ZBdXRvY29tcGxldGVfVkF1dG9jb21wbGV0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSxcbiAgICBwcm9wczoge1xuICAgICAgICBkZWxpbWl0ZXJzOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmV0dXJuT2JqZWN0OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRpdGluZ0luZGV4OiAtMVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY291bnRlclZhbHVlOiBmdW5jdGlvbiBjb3VudGVyVmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSA/IHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggOiAodGhpcy5pbnRlcm5hbFNlYXJjaCB8fCAnJykudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc1Nsb3Q6IGZ1bmN0aW9uIGhhc1Nsb3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gX1ZTZWxlY3RfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5jb21wdXRlZC5oYXNTbG90LmNhbGwodGhpcykgfHwgdGhpcy5tdWx0aXBsZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNBbnlWYWx1ZUFsbG93ZWQ6IGZ1bmN0aW9uIGlzQW55VmFsdWVBbGxvd2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG1lbnVDYW5TaG93OiBmdW5jdGlvbiBtZW51Q2FuU2hvdygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXllZEl0ZW1zQ291bnQgPiAwIHx8ICEhdGhpcy4kc2xvdHNbJ25vLWRhdGEnXSAmJiAhdGhpcy5oaWRlTm9EYXRhO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIG9uRmlsdGVyZWRJdGVtc0NoYW5nZWQ6IGZ1bmN0aW9uIG9uRmlsdGVyZWRJdGVtc0NoYW5nZWQoKSB7XG4gICAgICAgICAgICAvLyBub3BcbiAgICAgICAgfSxcbiAgICAgICAgb25JbnRlcm5hbFNlYXJjaENoYW5nZWQ6IGZ1bmN0aW9uIG9uSW50ZXJuYWxTZWFyY2hDaGFuZ2VkKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB0aGlzLm11bHRpcGxlICYmIHRoaXMuZGVsaW1pdGVycykge1xuICAgICAgICAgICAgICAgIHZhciBkZWxpbWl0ZXIgPSB0aGlzLmRlbGltaXRlcnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmVuZHNXaXRoKGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChkZWxpbWl0ZXIgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTZWFyY2ggPSB2YWwuc2xpY2UoMCwgdmFsLmxlbmd0aCAtIGRlbGltaXRlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGFncygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVNZW51RGltZW5zaW9ucygpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5DaGlwU2VsZWN0aW9uOiBmdW5jdGlvbiBnZW5DaGlwU2VsZWN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNoaXAgPSBfVlNlbGVjdF9WU2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLm1ldGhvZHMuZ2VuQ2hpcFNlbGVjdGlvbi5jYWxsKHRoaXMsIGl0ZW0sIGluZGV4KTtcbiAgICAgICAgICAgIC8vIEFsbG93IHVzZXIgdG8gdXBkYXRlIGFuIGV4aXN0aW5nIHZhbHVlXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNoaXAuY29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMuZGJsY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVkaXRpbmdJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnRlcm5hbFNlYXJjaCA9IF90aGlzLmdldFRleHQoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoaXA7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hpcElucHV0OiBmdW5jdGlvbiBvbkNoaXBJbnB1dChpdGVtKSB7XG4gICAgICAgICAgICBfVlNlbGVjdF9WU2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLm1ldGhvZHMub25DaGlwSW5wdXQuY2FsbCh0aGlzLCBpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdGluZ0luZGV4ID0gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJlcXVpcmVzIGEgbWFudWFsIGRlZmluaXRpb25cbiAgICAgICAgLy8gdG8gb3ZlcndyaXRlIHJlbW92YWwgaW4gdi1hdXRvY29tcGxldGVcbiAgICAgICAgb25FbnRlckRvd246IGZ1bmN0aW9uIG9uRW50ZXJEb3duKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF9WU2VsZWN0X1ZTZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0ubWV0aG9kcy5vbkVudGVyRG93bi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLy8gSWYgaGFzIG1lbnUgaW5kZXgsIGxldCB2LXNlbGVjdC1saXN0IGhhbmRsZVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0TWVudUluZGV4KCkgPiAtMSkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxmKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICAgICAgX1ZTZWxlY3RfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLm9uS2V5RG93bi5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgLy8gSWYgdXNlciBpcyBhdCBzZWxlY3Rpb24gaW5kZXggb2YgMFxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHRhZ1xuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUgJiYga2V5Q29kZSA9PT0gX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wia2V5Q29kZXNcIl0ubGVmdCAmJiB0aGlzLiRyZWZzLmlucHV0LnNlbGVjdGlvblN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgb3JkZXJpbmcgaXMgaW1wb3J0YW50IGhlcmVcbiAgICAgICAgICAgIC8vIGFsbG93cyBuZXcgdmFsdWUgdG8gYmUgdXBkYXRlZFxuICAgICAgICAgICAgLy8gYW5kIHRoZW4gbW92ZXMgdGhlIGluZGV4IHRvIHRoZVxuICAgICAgICAgICAgLy8gcHJvcGVyIGxvY2F0aW9uXG4gICAgICAgICAgICB0aGlzLmNoYW5nZVNlbGVjdGVkSW5kZXgoa2V5Q29kZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGFiRG93bjogZnVuY3Rpb24gb25UYWJEb3duKGUpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYWRkaW5nIHRhZ3MsIGlmIHNlYXJjaGluZyBhbmRcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vdCBhIGZpbHRlcmVkIG9wdGlvbnMsXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHZhbHVlIHRvIHRoZSB0YWdzIGxpc3RcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmIHRoaXMuaW50ZXJuYWxTZWFyY2ggJiYgdGhpcy5nZXRNZW51SW5kZXgoKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVUYWdzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfVkF1dG9jb21wbGV0ZV9WQXV0b2NvbXBsZXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLm1ldGhvZHMub25UYWJEb3duLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdEl0ZW06IGZ1bmN0aW9uIHNlbGVjdEl0ZW0oaXRlbSkge1xuICAgICAgICAgICAgLy8gQ3VycmVudGx5IG9ubHkgc3VwcG9ydHMgaXRlbXM6PHN0cmluZ1tdPlxuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdGluZ0luZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVkaXRpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX1ZTZWxlY3RfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLnNlbGVjdEl0ZW0uY2FsbCh0aGlzLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0U2VsZWN0ZWRJdGVtczogZnVuY3Rpb24gc2V0U2VsZWN0ZWRJdGVtcygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsVmFsdWUgPT0gbnVsbCB8fCB0aGlzLmludGVybmFsVmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtcyA9IHRoaXMubXVsdGlwbGUgPyB0aGlzLmludGVybmFsVmFsdWUgOiBbdGhpcy5pbnRlcm5hbFZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5pbnRlcm5hbFNlYXJjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9WU2VsZWN0X1ZTZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0ubWV0aG9kcy5zZXRWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlRWRpdGluZzogZnVuY3Rpb24gdXBkYXRlRWRpdGluZygpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaW50ZXJuYWxWYWx1ZS5zbGljZSgpO1xuICAgICAgICAgICAgdmFsdWVbdGhpcy5lZGl0aW5nSW5kZXhdID0gdGhpcy5pbnRlcm5hbFNlYXJjaDtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5lZGl0aW5nSW5kZXggPSAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlQ29tYm9ib3g6IGZ1bmN0aW9uIHVwZGF0ZUNvbWJvYm94KCkge1xuICAgICAgICAgICAgdmFyIGlzVXNpbmdTbG90ID0gQm9vbGVhbih0aGlzLiRzY29wZWRTbG90cy5zZWxlY3Rpb24pIHx8IHRoaXMuaGFzQ2hpcHM7XG4gICAgICAgICAgICAvLyBJZiBzZWFyY2ggaXMgbm90IGRpcnR5IGFuZCBpc1xuICAgICAgICAgICAgLy8gdXNpbmcgc2xvdCwgZG8gbm90aGluZ1xuICAgICAgICAgICAgaWYgKGlzVXNpbmdTbG90ICYmICF0aGlzLnNlYXJjaElzRGlydHkpIHJldHVybjtcbiAgICAgICAgICAgIC8vIFRoZSBpbnRlcm5hbCBzZWFyY2ggaXMgbm90IG1hdGNoaW5nXG4gICAgICAgICAgICAvLyB0aGUgaW50ZXJuYWwgdmFsdWUsIHVwZGF0ZSB0aGUgaW5wdXRcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsU2VhcmNoICE9PSB0aGlzLmdldFRleHQodGhpcy5pbnRlcm5hbFZhbHVlKSkgdGhpcy5zZXRWYWx1ZSgpO1xuICAgICAgICAgICAgLy8gUmVzZXQgc2VhcmNoIGlmIHVzaW5nIHNsb3RcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIGEgZG91YmxlIGlucHV0XG4gICAgICAgICAgICBpZiAoaXNVc2luZ1Nsb3QpIHRoaXMuaW50ZXJuYWxTZWFyY2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVNlbGY6IGZ1bmN0aW9uIHVwZGF0ZVNlbGYoKSB7XG4gICAgICAgICAgICB0aGlzLm11bHRpcGxlID8gdGhpcy51cGRhdGVUYWdzKCkgOiB0aGlzLnVwZGF0ZUNvbWJvYm94KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVRhZ3M6IGZ1bmN0aW9uIHVwZGF0ZVRhZ3MoKSB7XG4gICAgICAgICAgICB2YXIgbWVudUluZGV4ID0gdGhpcy5nZXRNZW51SW5kZXgoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIG5vdCBzZWFyY2hpbmdcbiAgICAgICAgICAgIC8vIGFuZCBubyBtZW51IGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIGlmIChtZW51SW5kZXggPCAwICYmICF0aGlzLnNlYXJjaElzRGlydHkpIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRpbmdJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlRWRpdGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5zZWxlY3RlZEl0ZW1zLmluZGV4T2YodGhpcy5pbnRlcm5hbFNlYXJjaCk7XG4gICAgICAgICAgICAvLyBJZiBpdCBhbHJlYWR5IGV4aXN0cywgZG8gbm90aGluZ1xuICAgICAgICAgICAgLy8gdGhpcyBtaWdodCBuZWVkIHRvIGNoYW5nZSB0byBicmluZ1xuICAgICAgICAgICAgLy8gdGhlIGR1cGxpY2F0ZWQgaXRlbSB0byB0aGUgbGFzdCBlbnRlcmVkXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcm5hbFZhbHVlID0gdGhpcy5pbnRlcm5hbFZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxWYWx1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoaW50ZXJuYWxWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBtZW51IGluZGV4IGlzIGdyZWF0ZXIgdGhhbiAxXG4gICAgICAgICAgICAvLyB0aGUgc2VsZWN0aW9uIGlzIGhhbmRsZWQgZWxzZXdoZXJlXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kIG91dCB3aGVyZVxuICAgICAgICAgICAgaWYgKG1lbnVJbmRleCA+IC0xKSByZXR1cm4gdGhpcy5pbnRlcm5hbFNlYXJjaCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEl0ZW0odGhpcy5pbnRlcm5hbFNlYXJjaCk7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsU2VhcmNoID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDb21ib2JveC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZDb21ib2JveC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWQ29tYm9ib3gsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZDb21ib2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQ29tYm9ib3ggKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDb21ib2JveC9WQ29tYm9ib3guanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQ29tYm9ib3hcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNvbWJvYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX1ZDb21ib2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkNvdW50ZXIvVkNvdW50ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZDb3VudGVyL1ZDb3VudGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfY291bnRlcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2NvdW50ZXJzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fY291bnRlcnMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfY291bnRlcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19jb3VudGVyc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbi8vIFN0eWxlc1xuXG4vLyBNaXhpbnNcblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LWNvdW50ZXInLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgbWl4aW5zOiBbX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogJydcbiAgICAgICAgfSxcbiAgICAgICAgbWF4OiBbTnVtYmVyLCBTdHJpbmddXG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBjdHgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gY3R4LnByb3BzO1xuICAgICAgICB2YXIgbWF4ID0gcGFyc2VJbnQocHJvcHMubWF4LCAxMCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlSW50KHByb3BzLnZhbHVlLCAxMCk7XG4gICAgICAgIHZhciBjb250ZW50ID0gbWF4ID8gdmFsdWUgKyBcIiAvIFwiICsgbWF4IDogcHJvcHMudmFsdWU7XG4gICAgICAgIHZhciBpc0dyZWF0ZXIgPSBtYXggJiYgdmFsdWUgPiBtYXg7XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtY291bnRlcicsXG4gICAgICAgICAgICBjbGFzczogX19hc3NpZ24oeyAnZXJyb3ItLXRleHQnOiBpc0dyZWF0ZXIgfSwgT2JqZWN0KF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJmdW5jdGlvbmFsVGhlbWVDbGFzc2VzXCJdKShjdHgpKVxuICAgICAgICB9LCBjb250ZW50KTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WQ291bnRlci9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkNvdW50ZXIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWQ291bnRlciwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkNvdW50ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkNvdW50ZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDb3VudGVyL1ZDb3VudGVyLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNvdW50ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNvdW50ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkNvdW50ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRhSXRlcmF0b3IvVkRhdGFJdGVyYXRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZEYXRhSXRlcmF0b3IvVkRhdGFJdGVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19kYXRhX2l0ZXJhdG9yX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19kYXRhLWl0ZXJhdG9yLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZGF0YS1pdGVyYXRvci5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19kYXRhX2l0ZXJhdG9yX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfZGF0YV9pdGVyYXRvcl9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfZGF0YV9pdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2RhdGEtaXRlcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvZGF0YS1pdGVyYWJsZS5qc1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtZGF0YS1pdGVyYXRvcicsXG4gICAgbWl4aW5zOiBbX21peGluc19kYXRhX2l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdXSxcbiAgICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbnRlbnRUYWc6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRQcm9wczoge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRDbGFzczoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oeyAndi1kYXRhLWl0ZXJhdG9yJzogdHJ1ZSwgJ3YtZGF0YS1pdGVyYXRvci0tc2VsZWN0LWFsbCc6IHRoaXMuc2VsZWN0QWxsICE9PSBmYWxzZSB9LCB0aGlzLnRoZW1lQ2xhc3Nlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAgIHRoaXMuaW5pdFBhZ2luYXRpb24oKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuQ29udGVudDogZnVuY3Rpb24gZ2VuQ29udGVudCgpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2VuSXRlbXMoKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgICdjbGFzcyc6IHRoaXMuY29udGVudENsYXNzLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB0aGlzLiRhdHRycyxcbiAgICAgICAgICAgICAgICBvbjogdGhpcy4kbGlzdGVuZXJzLFxuICAgICAgICAgICAgICAgIHByb3BzOiB0aGlzLmNvbnRlbnRQcm9wc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KHRoaXMuY29udGVudFRhZywgZGF0YSwgY2hpbGRyZW4pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5FbXB0eUl0ZW1zOiBmdW5jdGlvbiBnZW5FbXB0eUl0ZW1zKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgICAgICdjbGFzcyc6ICd0ZXh0LXhzLWNlbnRlcicsXG4gICAgICAgICAgICAgICAgc3R5bGU6ICd3aWR0aDogMTAwJSdcbiAgICAgICAgICAgIH0sIGNvbnRlbnQpXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuRmlsdGVyZWRJdGVtczogZnVuY3Rpb24gZ2VuRmlsdGVyZWRJdGVtcygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kc2NvcGVkU2xvdHMuaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbiA9IHRoaXMuZmlsdGVyZWRJdGVtcy5sZW5ndGg7IGluZGV4IDwgbGVuOyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmZpbHRlcmVkSXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoaXMuY3JlYXRlUHJvcHMoaXRlbSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2godGhpcy4kc2NvcGVkU2xvdHMuaXRlbShwcm9wcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9LFxuICAgICAgICBnZW5Gb290ZXI6IGZ1bmN0aW9uIGdlbkZvb3RlcigpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNsb3RzLmZvb3Rlcikge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy4kc2xvdHMuZm9vdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5oaWRlQWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5nZW5BY3Rpb25zKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIGNoaWxkcmVuKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSGVhZGVyOiBmdW5jdGlvbiBnZW5IZWFkZXIoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzbG90cy5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuJHNsb3RzLmhlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2JywgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgICAgICAnY2xhc3MnOiB0aGlzLmNsYXNzZXNcbiAgICAgICAgfSwgW3RoaXMuZ2VuSGVhZGVyKCksIHRoaXMuZ2VuQ29udGVudCgpLCB0aGlzLmdlbkZvb3RlcigpXSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGFJdGVyYXRvci9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WRGF0YUl0ZXJhdG9yL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWRGF0YUl0ZXJhdG9yLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WRGF0YUl0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZEYXRhSXRlcmF0b3IgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRhSXRlcmF0b3IvVkRhdGFJdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZEYXRhSXRlcmF0b3JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGFJdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WRGF0YUl0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0YVRhYmxlL1ZEYXRhVGFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WRGF0YVRhYmxlL1ZEYXRhVGFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfdGFibGVzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL190YWJsZXMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL190YWJsZXMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfdGFibGVzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfdGFibGVzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2RhdGFfdGFibGVfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2RhdGEtdGFibGUuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19kYXRhLXRhYmxlLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2RhdGFfdGFibGVfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19kYXRhX3RhYmxlX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19kYXRhX2l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvZGF0YS1pdGVyYWJsZSAqLyBcIi4vc3JjL21peGlucy9kYXRhLWl0ZXJhYmxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfaGVhZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9taXhpbnMvaGVhZCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGFUYWJsZS9taXhpbnMvaGVhZC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2JvZHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL2JvZHkgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRhVGFibGUvbWl4aW5zL2JvZHkuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19mb290X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21peGlucy9mb290ICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0YVRhYmxlL21peGlucy9mb290LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcHJvZ3Jlc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL3Byb2dyZXNzICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0YVRhYmxlL21peGlucy9wcm9ncmVzcy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cblxuXG5cblxuXG5cblxuLy8gSW1wb3J0aW5nIGRvZXMgbm90IHdvcmsgcHJvcGVybHlcbnZhciBWVGFibGVPdmVyZmxvdyA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJjcmVhdGVTaW1wbGVGdW5jdGlvbmFsXCJdKSgndi10YWJsZV9fb3ZlcmZsb3cnKTtcbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1kYXRhLXRhYmxlJyxcbiAgICBtaXhpbnM6IFtfbWl4aW5zX2RhdGFfaXRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfaGVhZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSwgX21peGluc19ib2R5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX2Zvb3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfcHJvZ3Jlc3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzTGVuZ3RoOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyVGV4dDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcktleToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBoaWRlSGVhZGVyczogQm9vbGVhbixcbiAgICAgICAgcm93c1BlclBhZ2VUZXh0OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuZGF0YVRhYmxlLnJvd3NQZXJQYWdlVGV4dCdcbiAgICAgICAgfSxcbiAgICAgICAgY3VzdG9tRmlsdGVyOiB7XG4gICAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KGl0ZW1zLCBzZWFyY2gsIGZpbHRlciwgaGVhZGVycykge1xuICAgICAgICAgICAgICAgIHNlYXJjaCA9IHNlYXJjaC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaC50cmltKCkgPT09ICcnKSByZXR1cm4gaXRlbXM7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gaGVhZGVycy5tYXAoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgudmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuc29tZShmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcihPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZ2V0T2JqZWN0VmFsdWVCeVBhdGhcIl0pKGl0ZW0sIHByb3AsIGl0ZW1bcHJvcF0pLCBzZWFyY2gpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGlvbnNDbGFzc2VzOiAndi1kYXRhdGFibGVfX2FjdGlvbnMnLFxuICAgICAgICAgICAgYWN0aW9uc1JhbmdlQ29udHJvbHNDbGFzc2VzOiAndi1kYXRhdGFibGVfX2FjdGlvbnNfX3JhbmdlLWNvbnRyb2xzJyxcbiAgICAgICAgICAgIGFjdGlvbnNTZWxlY3RDbGFzc2VzOiAndi1kYXRhdGFibGVfX2FjdGlvbnNfX3NlbGVjdCcsXG4gICAgICAgICAgICBhY3Rpb25zUGFnaW5hdGlvbkNsYXNzZXM6ICd2LWRhdGF0YWJsZV9fYWN0aW9uc19fcGFnaW5hdGlvbidcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oeyAndi1kYXRhdGFibGUgdi10YWJsZSc6IHRydWUsICd2LWRhdGF0YWJsZS0tc2VsZWN0LWFsbCc6IHRoaXMuc2VsZWN0QWxsICE9PSBmYWxzZSB9LCB0aGlzLnRoZW1lQ2xhc3Nlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlcmVkSXRlbXM6IGZ1bmN0aW9uIGZpbHRlcmVkSXRlbXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJlZEl0ZW1zSW1wbCh0aGlzLmhlYWRlcnMpO1xuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJDb2x1bW5zOiBmdW5jdGlvbiBoZWFkZXJDb2x1bW5zKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyc0xlbmd0aCB8fCB0aGlzLmhlYWRlcnMubGVuZ3RoICsgKHRoaXMuc2VsZWN0QWxsICE9PSBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAgIHZhciBmaXJzdFNvcnRhYmxlID0gdGhpcy5oZWFkZXJzLmZpbmQoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgIHJldHVybiAhKCdzb3J0YWJsZScgaW4gaCkgfHwgaC5zb3J0YWJsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFBhZ2luYXRpb24uc29ydEJ5ID0gIXRoaXMuZGlzYWJsZUluaXRpYWxTb3J0ICYmIGZpcnN0U29ydGFibGUgPyBmaXJzdFNvcnRhYmxlLnZhbHVlIDogbnVsbDtcbiAgICAgICAgdGhpcy5pbml0UGFnaW5hdGlvbigpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBoYXNUYWc6IGZ1bmN0aW9uIGhhc1RhZyhlbGVtZW50cywgdGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShlbGVtZW50cykgJiYgZWxlbWVudHMuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLnRhZyA9PT0gdGFnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblRSOiBmdW5jdGlvbiBnZW5UUihjaGlsZHJlbiwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0cicsIGRhdGEsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICB2YXIgdGFibGVPdmVyZmxvdyA9IGgoVlRhYmxlT3ZlcmZsb3csIHt9LCBbaCgndGFibGUnLCB7XG4gICAgICAgICAgICAnY2xhc3MnOiB0aGlzLmNsYXNzZXNcbiAgICAgICAgfSwgW3RoaXMuZ2VuVEhlYWQoKSwgdGhpcy5nZW5UQm9keSgpLCB0aGlzLmdlblRGb290KCldKV0pO1xuICAgICAgICByZXR1cm4gaCgnZGl2JywgW3RhYmxlT3ZlcmZsb3csIHRoaXMuZ2VuQWN0aW9uc0Zvb3RlcigpXSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGFUYWJsZS9WRWRpdERpYWxvZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WRGF0YVRhYmxlL1ZFZGl0RGlhbG9nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19zbWFsbF9kaWFsb2dfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3NtYWxsLWRpYWxvZy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3NtYWxsLWRpYWxvZy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19zbWFsbF9kaWFsb2dfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19zbWFsbF9kaWFsb2dfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3JldHVybmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9yZXR1cm5hYmxlICovIFwiLi9zcmMvbWl4aW5zL3JldHVybmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkJ0bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVkJ0biAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkJ0bi9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVk1lbnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZNZW51ICovIFwiLi9zcmMvY29tcG9uZW50cy9WTWVudS9pbmRleC5qc1wiKTtcblxuLy8gTWl4aW5zXG5cblxuLy8gVXRpbHNcblxuXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1lZGl0LWRpYWxvZycsXG4gICAgbWl4aW5zOiBbX21peGluc19yZXR1cm5hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY2FuY2VsVGV4dDoge1xuICAgICAgICAgICAgZGVmYXVsdDogJ0NhbmNlbCdcbiAgICAgICAgfSxcbiAgICAgICAgbGFyZ2U6IEJvb2xlYW4sXG4gICAgICAgIGxhenk6IEJvb2xlYW4sXG4gICAgICAgIHBlcnNpc3RlbnQ6IEJvb2xlYW4sXG4gICAgICAgIHNhdmVUZXh0OiB7XG4gICAgICAgICAgICBkZWZhdWx0OiAnU2F2ZSdcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNpdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3NsaWRlLXgtcmV2ZXJzZS10cmFuc2l0aW9uJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNBY3RpdmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUodmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnb3BlbicpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5mb2N1cywgNTApOyAvLyBHaXZlIERPTSB0aW1lIHRvIHBhaW50XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjYW5jZWwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy4kcmVmcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgICAgICBpbnB1dCAmJiBpbnB1dC5mb2N1cygpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5CdXR0b246IGZ1bmN0aW9uIGdlbkJ1dHRvbihmbiwgdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZCdG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBmbGF0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3ByaW1hcnknLFxuICAgICAgICAgICAgICAgICAgICBsaWdodDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IGZuIH1cbiAgICAgICAgICAgIH0sIHRleHQpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5BY3Rpb25zOiBmdW5jdGlvbiBnZW5BY3Rpb25zKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogJ3Ytc21hbGwtZGlhbG9nX19hY3Rpb25zJ1xuICAgICAgICAgICAgfSwgW3RoaXMuZ2VuQnV0dG9uKHRoaXMuY2FuY2VsLCB0aGlzLmNhbmNlbFRleHQpLCB0aGlzLmdlbkJ1dHRvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2F2ZShfdGhpcy5yZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuJGVtaXQoJ3NhdmUnKTtcbiAgICAgICAgICAgIH0sIHRoaXMuc2F2ZVRleHQpXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkNvbnRlbnQ6IGZ1bmN0aW9uIGdlbkNvbnRlbnQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IF90aGlzLiRyZWZzLmNvbnRlbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUua2V5Q29kZSA9PT0gX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wia2V5Q29kZXNcIl0uZXNjICYmIF90aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wia2V5Q29kZXNcIl0uZW50ZXIgJiYgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zYXZlKGlucHV0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kZW1pdCgnc2F2ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWY6ICdjb250ZW50J1xuICAgICAgICAgICAgfSwgW3RoaXMuJHNsb3RzLmlucHV0XSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGgoX1ZNZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3Ytc21hbGwtZGlhbG9nJyxcbiAgICAgICAgICAgIGNsYXNzOiB0aGlzLnRoZW1lQ2xhc3NlcyxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgY29udGVudENsYXNzOiAndi1zbWFsbC1kaWFsb2dfX2NvbnRlbnQnLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IHRoaXMudHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICBvcmlnaW46ICd0b3AgcmlnaHQnLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmlzQWN0aXZlLFxuICAgICAgICAgICAgICAgIGNsb3NlT25DbGljazogIXRoaXMucGVyc2lzdGVudCxcbiAgICAgICAgICAgICAgICBjbG9zZU9uQ29udGVudENsaWNrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYXp5OiB0aGlzLmxhenksXG4gICAgICAgICAgICAgICAgbGlnaHQ6IHRoaXMubGlnaHQsXG4gICAgICAgICAgICAgICAgZGFyazogdGhpcy5kYXJrXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24gaW5wdXQodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc0FjdGl2ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtoKCdhJywge1xuICAgICAgICAgICAgc2xvdDogJ2FjdGl2YXRvcidcbiAgICAgICAgfSwgdGhpcy4kc2xvdHMuZGVmYXVsdCksIHRoaXMuZ2VuQ29udGVudCgpLCB0aGlzLmxhcmdlID8gdGhpcy5nZW5BY3Rpb25zKCkgOiBudWxsXSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGFUYWJsZS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WRGF0YVRhYmxlL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWRGF0YVRhYmxlLCBWRWRpdERpYWxvZywgVlRhYmxlT3ZlcmZsb3csIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRhYmxlT3ZlcmZsb3dcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWVGFibGVPdmVyZmxvdzsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WRGF0YVRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZEYXRhVGFibGUgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRhVGFibGUvVkRhdGFUYWJsZS5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZEYXRhVGFibGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGFUYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkVkaXREaWFsb2dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkVkaXREaWFsb2cgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRhVGFibGUvVkVkaXREaWFsb2cuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRWRpdERpYWxvZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WRWRpdERpYWxvZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG5cbnZhciBWVGFibGVPdmVyZmxvdyA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVTaW1wbGVGdW5jdGlvbmFsXCJdKSgndi10YWJsZV9fb3ZlcmZsb3cnKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgJF92dWV0aWZ5X3N1YmNvbXBvbmVudHM6IHtcbiAgICAgICAgVkRhdGFUYWJsZTogX1ZEYXRhVGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZFZGl0RGlhbG9nOiBfVkVkaXREaWFsb2dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZUYWJsZU92ZXJmbG93OiBWVGFibGVPdmVyZmxvd1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRhVGFibGUvbWl4aW5zL2JvZHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkRhdGFUYWJsZS9taXhpbnMvYm9keS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNpdGlvbnNfZXhwYW5kX3RyYW5zaXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3RyYW5zaXRpb25zL2V4cGFuZC10cmFuc2l0aW9uICovIFwiLi9zcmMvY29tcG9uZW50cy90cmFuc2l0aW9ucy9leHBhbmQtdHJhbnNpdGlvbi5qc1wiKTtcblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuVEJvZHk6IGZ1bmN0aW9uIGdlblRCb2R5KCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZW5JdGVtcygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3Rib2R5JywgY2hpbGRyZW4pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5FeHBhbmRlZFJvdzogZnVuY3Rpb24gZ2VuRXhwYW5kZWRSb3cocHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFeHBhbmRlZChwcm9wcy5pdGVtKSkge1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmQgPSB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiAndi1kYXRhdGFibGVfX2V4cGFuZC1jb250ZW50JyxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBwcm9wcy5pdGVtW3RoaXMuaXRlbUtleV1cbiAgICAgICAgICAgICAgICB9LCBbdGhpcy4kc2NvcGVkU2xvdHMuZXhwYW5kKHByb3BzKV0pO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goZXhwYW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy4kY3JlYXRlRWxlbWVudCgndHJhbnNpdGlvbi1ncm91cCcsIHtcbiAgICAgICAgICAgICAgICBjbGFzczogJ3YtZGF0YXRhYmxlX19leHBhbmQtY29sJyxcbiAgICAgICAgICAgICAgICBhdHRyczogeyBjb2xzcGFuOiB0aGlzLmhlYWRlckNvbHVtbnMgfSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICB0YWc6ICd0ZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uOiBPYmplY3QoX3RyYW5zaXRpb25zX2V4cGFuZF90cmFuc2l0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKSgndi1kYXRhdGFibGVfX2V4cGFuZC1jb2wtLWV4cGFuZGVkJylcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlblRSKFt0cmFuc2l0aW9uXSwgeyBjbGFzczogJ3YtZGF0YXRhYmxlX19leHBhbmQtcm93JyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuRmlsdGVyZWRJdGVtczogZnVuY3Rpb24gZ2VuRmlsdGVyZWRJdGVtcygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kc2NvcGVkU2xvdHMuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByb3dzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbiA9IHRoaXMuZmlsdGVyZWRJdGVtcy5sZW5ndGg7IGluZGV4IDwgbGVuOyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmZpbHRlcmVkSXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoaXMuY3JlYXRlUHJvcHMoaXRlbSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLiRzY29wZWRTbG90cy5pdGVtcyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKHRoaXMuaGFzVGFnKHJvdywgJ3RkJykgPyB0aGlzLmdlblRSKHJvdywge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHRoaXMuaXRlbUtleSA/IHByb3BzLml0ZW1bdGhpcy5pdGVtS2V5XSA6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBhY3RpdmU6IHRoaXMuaXNTZWxlY3RlZChpdGVtKSB9XG4gICAgICAgICAgICAgICAgfSkgOiByb3cpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRzY29wZWRTbG90cy5leHBhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGFuZFJvdyA9IHRoaXMuZ2VuRXhwYW5kZWRSb3cocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2goZXhwYW5kUm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93cztcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuRW1wdHlJdGVtczogZnVuY3Rpb24gZ2VuRW1wdHlJdGVtcyhjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNUYWcoY29udGVudCwgJ3RyJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNUYWcoY29udGVudCwgJ3RkJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5UUihjb250ZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuVFIoW3RoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RkJywge1xuICAgICAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQteHMtY2VudGVyJzogdHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IGNvbHNwYW46IHRoaXMuaGVhZGVyQ29sdW1ucyB9XG4gICAgICAgICAgICAgICAgfSwgY29udGVudCldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRhVGFibGUvbWl4aW5zL2Zvb3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkRhdGFUYWJsZS9taXhpbnMvZm9vdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlblRGb290OiBmdW5jdGlvbiBnZW5URm9vdCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kc2xvdHMuZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm9vdGVyID0gdGhpcy4kc2xvdHMuZm9vdGVyO1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMuaGFzVGFnKGZvb3RlciwgJ3RkJykgPyB0aGlzLmdlblRSKGZvb3RlcikgOiBmb290ZXI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGZvb3QnLCBbcm93XSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkFjdGlvbnNGb290ZXI6IGZ1bmN0aW9uIGdlbkFjdGlvbnNGb290ZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWRlQWN0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiB0aGlzLmNsYXNzZXNcbiAgICAgICAgICAgIH0sIHRoaXMuZ2VuQWN0aW9ucygpKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRhVGFibGUvbWl4aW5zL2hlYWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkRhdGFUYWJsZS9taXhpbnMvaGVhZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZDaGVja2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vVkNoZWNrYm94ICovIFwiLi9zcmMvY29tcG9uZW50cy9WQ2hlY2tib3gvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9WSWNvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkljb24vaW5kZXgudHNcIik7XG52YXIgX19yZWFkID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3JlYWQgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSxcbiAgICAgICAgcixcbiAgICAgICAgYXIgPSBbXSxcbiAgICAgICAgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlKSB0aHJvdyBlLmVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fc3ByZWFkIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gICAgfXJldHVybiBhcjtcbn07XG5cblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgcHJvcHM6IHtcbiAgICAgICAgc29ydEljb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5zb3J0J1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlblRIZWFkOiBmdW5jdGlvbiBnZW5USGVhZCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWRlSGVhZGVycykgcmV0dXJuOyAvLyBFeGl0IEVhcmx5IHNpbmNlIG5vIGhlYWRlcnMgYXJlIG5lZWRlZC5cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlZFNsb3RzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gdGhpcy4kc2NvcGVkU2xvdHMuaGVhZGVycyh7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZTogdGhpcy5pbmRldGVybWluYXRlLFxuICAgICAgICAgICAgICAgICAgICBhbGw6IHRoaXMuZXZlcnlJdGVtXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBbdGhpcy5oYXNUYWcocm93LCAndGgnKSA/IHRoaXMuZ2VuVFIocm93KSA6IHJvdywgdGhpcy5nZW5UUHJvZ3Jlc3MoKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLmhlYWRlcnMubWFwKGZ1bmN0aW9uIChvLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZW5IZWFkZXIobywgX3RoaXMuaGVhZGVyS2V5ID8gb1tfdGhpcy5oZWFkZXJLZXldIDogaSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrYm94ID0gdGhpcy4kY3JlYXRlRWxlbWVudChfVkNoZWNrYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXJrOiB0aGlzLmRhcmssXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWdodDogdGhpcy5saWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLnNlbGVjdEFsbCA9PT0gdHJ1ZSA/ICcnIDogdGhpcy5zZWxlY3RBbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlRGV0YWlsczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IHRoaXMuZXZlcnlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZTogdGhpcy5pbmRldGVybWluYXRlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uOiB7IGNoYW5nZTogdGhpcy50b2dnbGUgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzU2VsZWN0QWxsICYmIHJvdy51bnNoaWZ0KHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RoJywgW2NoZWNrYm94XSkpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gW3RoaXMuZ2VuVFIocm93KSwgdGhpcy5nZW5UUHJvZ3Jlc3MoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGhlYWQnLCBbY2hpbGRyZW5dKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSGVhZGVyOiBmdW5jdGlvbiBnZW5IZWFkZXIoaGVhZGVyLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IFt0aGlzLiRzY29wZWRTbG90cy5oZWFkZXJDZWxsID8gdGhpcy4kc2NvcGVkU2xvdHMuaGVhZGVyQ2VsbCh7IGhlYWRlcjogaGVhZGVyIH0pIDogaGVhZGVyW3RoaXMuaGVhZGVyVGV4dF1dO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgX19zcHJlYWQoWyd0aCddLCB0aGlzLmdlbkhlYWRlckRhdGEoaGVhZGVyLCBhcnJheSwga2V5KSkpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5IZWFkZXJEYXRhOiBmdW5jdGlvbiBnZW5IZWFkZXJEYXRhKGhlYWRlciwgY2hpbGRyZW4sIGtleSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbJ2NvbHVtbiddO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2NvbHVtbmhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlOiAnY29sJyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGhlYWRlci53aWR0aCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAnYXJpYS1sYWJlbCc6IGhlYWRlclt0aGlzLmhlYWRlclRleHRdIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAnYXJpYS1zb3J0JzogJ25vbmUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoZWFkZXIuc29ydGFibGUgPT0gbnVsbCB8fCBoZWFkZXIuc29ydGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbkhlYWRlclNvcnRpbmdEYXRhKGhlYWRlciwgY2hpbGRyZW4sIGRhdGEsIGNsYXNzZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhLmF0dHJzWydhcmlhLWxhYmVsJ10gKz0gJzogTm90IHNvcnRlZC4nOyAvLyBUT0RPOiBMb2NhbGl6YXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzZXMucHVzaChcInRleHQteHMtXCIgKyAoaGVhZGVyLmFsaWduIHx8ICdsZWZ0JykpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyLmNsYXNzKSkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaC5hcHBseShjbGFzc2VzLCBfX3NwcmVhZChoZWFkZXIuY2xhc3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyLmNsYXNzKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGhlYWRlci5jbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmNsYXNzID0gY2xhc3NlcztcbiAgICAgICAgICAgIHJldHVybiBbZGF0YSwgY2hpbGRyZW5dO1xuICAgICAgICB9LFxuICAgICAgICBnZW5IZWFkZXJTb3J0aW5nRGF0YTogZnVuY3Rpb24gZ2VuSGVhZGVyU29ydGluZ0RhdGEoaGVhZGVyLCBjaGlsZHJlbiwgZGF0YSwgY2xhc3Nlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghKCd2YWx1ZScgaW4gaGVhZGVyKSkge1xuICAgICAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjb25zb2xlV2FyblwiXSkoJ0hlYWRlcnMgbXVzdCBoYXZlIGEgdmFsdWUgcHJvcGVydHkgdGhhdCBjb3JyZXNwb25kcyB0byBhIHZhbHVlIGluIHRoZSB2LW1vZGVsIGFycmF5JywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmF0dHJzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgIGRhdGEub24gPSB7XG4gICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5leHBhbmRlZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zb3J0KGhlYWRlci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zb3J0KGhlYWRlci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdzb3J0YWJsZScpO1xuICAgICAgICAgICAgdmFyIGljb24gPSB0aGlzLiRjcmVhdGVFbGVtZW50KF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy5zb3J0SWNvbik7XG4gICAgICAgICAgICBpZiAoIWhlYWRlci5hbGlnbiB8fCBoZWFkZXIuYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goaWNvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnVuc2hpZnQoaWNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFnaW5hdGlvbiA9IHRoaXMuY29tcHV0ZWRQYWdpbmF0aW9uO1xuICAgICAgICAgICAgdmFyIGJlaW5nU29ydGVkID0gcGFnaW5hdGlvbi5zb3J0QnkgPT09IGhlYWRlci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChiZWluZ1NvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhZ2luYXRpb24uZGVzY2VuZGluZykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2Rlc2MnKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hdHRyc1snYXJpYS1zb3J0J10gPSAnZGVzY2VuZGluZyc7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYXR0cnNbJ2FyaWEtbGFiZWwnXSArPSAnOiBTb3J0ZWQgZGVzY2VuZGluZy4gQWN0aXZhdGUgdG8gcmVtb3ZlIHNvcnRpbmcuJzsgLy8gVE9ETzogTG9jYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdhc2MnKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hdHRyc1snYXJpYS1zb3J0J10gPSAnYXNjZW5kaW5nJztcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hdHRyc1snYXJpYS1sYWJlbCddICs9ICc6IFNvcnRlZCBhc2NlbmRpbmcuIEFjdGl2YXRlIHRvIHNvcnQgZGVzY2VuZGluZy4nOyAvLyBUT0RPOiBMb2NhbGl6YXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEuYXR0cnNbJ2FyaWEtbGFiZWwnXSArPSAnOiBOb3Qgc29ydGVkLiBBY3RpdmF0ZSB0byBzb3J0IGFzY2VuZGluZy4nOyAvLyBUT0RPOiBMb2NhbGl6YXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRhVGFibGUvbWl4aW5zL3Byb2dyZXNzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WRGF0YVRhYmxlL21peGlucy9wcm9ncmVzcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZW5UUHJvZ3Jlc3M6IGZ1bmN0aW9uIGdlblRQcm9ncmVzcygpIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSB0aGlzLiRjcmVhdGVFbGVtZW50KCd0aCcsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sc3BhbjogdGhpcy5oZWFkZXJDb2x1bW5zXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW3RoaXMuZ2VuUHJvZ3Jlc3MoKV0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuVFIoW2NvbF0sIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtZGF0YXRhYmxlX19wcm9ncmVzcydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvVkRhdGVQaWNrZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL1ZEYXRlUGlja2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkRhdGVQaWNrZXJUaXRsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WRGF0ZVBpY2tlclRpdGxlICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci9WRGF0ZVBpY2tlclRpdGxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WRGF0ZVBpY2tlckhlYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WRGF0ZVBpY2tlckhlYWRlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvVkRhdGVQaWNrZXJIZWFkZXIuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZEYXRlUGlja2VyRGF0ZVRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZEYXRlUGlja2VyRGF0ZVRhYmxlICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci9WRGF0ZVBpY2tlckRhdGVUYWJsZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkRhdGVQaWNrZXJNb250aFRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZEYXRlUGlja2VyTW9udGhUYWJsZSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvVkRhdGVQaWNrZXJNb250aFRhYmxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WRGF0ZVBpY2tlclllYXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZEYXRlUGlja2VyWWVhcnMgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL1ZEYXRlUGlja2VyWWVhcnMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19waWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9waWNrZXIgKi8gXCIuL3NyYy9taXhpbnMvcGlja2VyLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL3V0aWwvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaXNEYXRlQWxsb3dlZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsL2lzRGF0ZUFsbG93ZWQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL3V0aWwvaXNEYXRlQWxsb3dlZC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG52YXIgX19yZWFkID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3JlYWQgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSxcbiAgICAgICAgcixcbiAgICAgICAgYXIgPSBbXSxcbiAgICAgICAgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlKSB0aHJvdyBlLmVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG4vLyBDb21wb25lbnRzXG5cblxuXG5cblxuLy8gTWl4aW5zXG5cbi8vIFV0aWxzXG5cblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtZGF0ZS1waWNrZXInLFxuICAgIG1peGluczogW19taXhpbnNfcGlja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdXSxcbiAgICBwcm9wczoge1xuICAgICAgICBhbGxvd2VkRGF0ZXM6IEZ1bmN0aW9uLFxuICAgICAgICAvLyBGdW5jdGlvbiBmb3JtYXR0aW5nIHRoZSBkYXkgaW4gZGF0ZSBwaWNrZXIgdGFibGVcbiAgICAgICAgZGF5Rm9ybWF0OiB7XG4gICAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICB0eXBlOiBbQXJyYXksIE9iamVjdCwgRnVuY3Rpb25dLFxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50Q29sb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEZ1bmN0aW9uLCBPYmplY3RdLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3dhcm5pbmcnXG4gICAgICAgIH0sXG4gICAgICAgIGZpcnN0RGF5T2ZXZWVrOiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICB9LFxuICAgICAgICAvLyBGdW5jdGlvbiBmb3JtYXR0aW5nIHRoZSB0YWJsZURhdGUgaW4gdGhlIGRheS9tb250aCB0YWJsZSBoZWFkZXJcbiAgICAgICAgaGVhZGVyRGF0ZUZvcm1hdDoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGxvY2FsZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2VuLXVzJ1xuICAgICAgICB9LFxuICAgICAgICBtYXg6IFN0cmluZyxcbiAgICAgICAgbWluOiBTdHJpbmcsXG4gICAgICAgIC8vIEZ1bmN0aW9uIGZvcm1hdHRpbmcgbW9udGggaW4gdGhlIG1vbnRocyB0YWJsZVxuICAgICAgICBtb250aEZvcm1hdDoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIG11bHRpcGxlOiBCb29sZWFuLFxuICAgICAgICBuZXh0SWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5Lmljb25zLm5leHQnXG4gICAgICAgIH0sXG4gICAgICAgIHBpY2tlckRhdGU6IFN0cmluZyxcbiAgICAgICAgcHJldkljb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5wcmV2J1xuICAgICAgICB9LFxuICAgICAgICByZWFjdGl2ZTogQm9vbGVhbixcbiAgICAgICAgcmVhZG9ubHk6IEJvb2xlYW4sXG4gICAgICAgIHNjcm9sbGFibGU6IEJvb2xlYW4sXG4gICAgICAgIHNob3dDdXJyZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRnVuY3Rpb24gZm9ybWF0dGluZyBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZSBpbiB0aGUgcGlja2VyIHRpdGxlXG4gICAgICAgIHRpdGxlRGF0ZUZvcm1hdDoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdkYXRlJyxcbiAgICAgICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydkYXRlJywgJ21vbnRoJ10uaW5jbHVkZXModHlwZSk7XG4gICAgICAgICAgICB9IC8vIFRPRE86IHllYXJcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IFtBcnJheSwgU3RyaW5nXSxcbiAgICAgICAgd2Vla2RheUZvcm1hdDoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEZ1bmN0aW9uIGZvcm1hdHRpbmcgdGhlIHllYXIgaW4gdGFibGUgaGVhZGVyIGFuZCBwaWNrdXAgdGl0bGVcbiAgICAgICAgeWVhckZvcm1hdDoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHllYXJJY29uOiBTdHJpbmdcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0aXZlUGlja2VyOiB0aGlzLnR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIGlucHV0RGF5OiBudWxsLFxuICAgICAgICAgICAgaW5wdXRNb250aDogbnVsbCxcbiAgICAgICAgICAgIGlucHV0WWVhcjogbnVsbCxcbiAgICAgICAgICAgIGlzUmV2ZXJzaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIG5vdzogbm93LFxuICAgICAgICAgICAgLy8gdGFibGVEYXRlIGlzIGEgc3RyaW5nIGluICdZWVlZJyAvICdZWVlZLU0nIGZvcm1hdCAobGVhZGluZyB6ZXJvIGZvciBtb250aCBpcyBub3QgcmVxdWlyZWQpXG4gICAgICAgICAgICB0YWJsZURhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucGlja2VyRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucGlja2VyRGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSAoX3RoaXMubXVsdGlwbGUgPyBfdGhpcy52YWx1ZVtfdGhpcy52YWx1ZS5sZW5ndGggLSAxXSA6IF90aGlzLnZhbHVlKSB8fCBub3cuZ2V0RnVsbFllYXIoKSArIFwiLVwiICsgKG5vdy5nZXRNb250aCgpICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfdGhpcy50eXBlID09PSAnZGF0ZScgPyAnbW9udGgnIDogJ3llYXInO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zYW5pdGl6ZURhdGVTdHJpbmcoZGF0ZSwgdHlwZSk7XG4gICAgICAgICAgICB9KClcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGxhc3RWYWx1ZTogZnVuY3Rpb24gbGFzdFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGUgPyB0aGlzLnZhbHVlW3RoaXMudmFsdWUubGVuZ3RoIC0gMV0gOiB0aGlzLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RlZE1vbnRoczogZnVuY3Rpb24gc2VsZWN0ZWRNb250aHMoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsdWUgfHwgIXRoaXMudmFsdWUubGVuZ3RoIHx8IHRoaXMudHlwZSA9PT0gJ21vbnRoJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5zdWJzdHIoMCwgNyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnN1YnN0cigwLCA3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVudDogZnVuY3Rpb24gY3VycmVudCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dDdXJyZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2FuaXRpemVEYXRlU3RyaW5nKHRoaXMubm93LmdldEZ1bGxZZWFyKCkgKyBcIi1cIiArICh0aGlzLm5vdy5nZXRNb250aCgpICsgMSkgKyBcIi1cIiArIHRoaXMubm93LmdldERhdGUoKSwgdGhpcy50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dDdXJyZW50IHx8IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0RGF0ZTogZnVuY3Rpb24gaW5wdXREYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2RhdGUnID8gdGhpcy5pbnB1dFllYXIgKyBcIi1cIiArIE9iamVjdChfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wicGFkXCJdKSh0aGlzLmlucHV0TW9udGggKyAxKSArIFwiLVwiICsgT2JqZWN0KF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJwYWRcIl0pKHRoaXMuaW5wdXREYXkpIDogdGhpcy5pbnB1dFllYXIgKyBcIi1cIiArIE9iamVjdChfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wicGFkXCJdKSh0aGlzLmlucHV0TW9udGggKyAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGFibGVNb250aDogZnVuY3Rpb24gdGFibGVNb250aCgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5waWNrZXJEYXRlIHx8IHRoaXMudGFibGVEYXRlKS5zcGxpdCgnLScpWzFdIC0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgdGFibGVZZWFyOiBmdW5jdGlvbiB0YWJsZVllYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucGlja2VyRGF0ZSB8fCB0aGlzLnRhYmxlRGF0ZSkuc3BsaXQoJy0nKVswXSAqIDE7XG4gICAgICAgIH0sXG4gICAgICAgIG1pbk1vbnRoOiBmdW5jdGlvbiBtaW5Nb250aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbiA/IHRoaXMuc2FuaXRpemVEYXRlU3RyaW5nKHRoaXMubWluLCAnbW9udGgnKSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG1heE1vbnRoOiBmdW5jdGlvbiBtYXhNb250aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heCA/IHRoaXMuc2FuaXRpemVEYXRlU3RyaW5nKHRoaXMubWF4LCAnbW9udGgnKSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG1pblllYXI6IGZ1bmN0aW9uIG1pblllYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW4gPyB0aGlzLnNhbml0aXplRGF0ZVN0cmluZyh0aGlzLm1pbiwgJ3llYXInKSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG1heFllYXI6IGZ1bmN0aW9uIG1heFllYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXggPyB0aGlzLnNhbml0aXplRGF0ZVN0cmluZyh0aGlzLm1heCwgJ3llYXInKSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcnM6IGZ1bmN0aW9uIGZvcm1hdHRlcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHllYXI6IHRoaXMueWVhckZvcm1hdCB8fCBPYmplY3QoX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImNyZWF0ZU5hdGl2ZUxvY2FsZUZvcm1hdHRlclwiXSkodGhpcy5sb2NhbGUsIHsgeWVhcjogJ251bWVyaWMnLCB0aW1lWm9uZTogJ1VUQycgfSwgeyBsZW5ndGg6IDQgfSksXG4gICAgICAgICAgICAgICAgdGl0bGVEYXRlOiB0aGlzLnRpdGxlRGF0ZUZvcm1hdCB8fCAodGhpcy5tdWx0aXBsZSA/IHRoaXMuZGVmYXVsdFRpdGxlTXVsdGlwbGVEYXRlRm9ybWF0dGVyIDogdGhpcy5kZWZhdWx0VGl0bGVEYXRlRm9ybWF0dGVyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdFRpdGxlTXVsdGlwbGVEYXRlRm9ybWF0dGVyOiBmdW5jdGlvbiBkZWZhdWx0VGl0bGVNdWx0aXBsZURhdGVGb3JtYXR0ZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVzLmxlbmd0aCA/IF90aGlzLmRlZmF1bHRUaXRsZURhdGVGb3JtYXR0ZXIoZGF0ZXNbMF0pIDogJzAgc2VsZWN0ZWQnO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVzLmxlbmd0aCArIFwiIHNlbGVjdGVkXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0VGl0bGVEYXRlRm9ybWF0dGVyOiBmdW5jdGlvbiBkZWZhdWx0VGl0bGVEYXRlRm9ybWF0dGVyKCkge1xuICAgICAgICAgICAgdmFyIHRpdGxlRm9ybWF0cyA9IHtcbiAgICAgICAgICAgICAgICB5ZWFyOiB7IHllYXI6ICdudW1lcmljJywgdGltZVpvbmU6ICdVVEMnIH0sXG4gICAgICAgICAgICAgICAgbW9udGg6IHsgbW9udGg6ICdsb25nJywgdGltZVpvbmU6ICdVVEMnIH0sXG4gICAgICAgICAgICAgICAgZGF0ZTogeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ3Nob3J0JywgZGF5OiAnbnVtZXJpYycsIHRpbWVab25lOiAnVVRDJyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRpdGxlRGF0ZUZvcm1hdHRlciA9IE9iamVjdChfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiY3JlYXRlTmF0aXZlTG9jYWxlRm9ybWF0dGVyXCJdKSh0aGlzLmxvY2FsZSwgdGl0bGVGb3JtYXRzW3RoaXMudHlwZV0sIHtcbiAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHsgZGF0ZTogMTAsIG1vbnRoOiA3LCB5ZWFyOiA0IH1bdGhpcy50eXBlXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbGFuZHNjYXBlRm9ybWF0dGVyID0gZnVuY3Rpb24gbGFuZHNjYXBlRm9ybWF0dGVyKGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGl0bGVEYXRlRm9ybWF0dGVyKGRhdGUpLnJlcGxhY2UoLyhbXlxcZFxcc10pKFtcXGRdKS9nLCBmdW5jdGlvbiAobWF0Y2gsIG5vbkRpZ2l0LCBkaWdpdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9uRGlnaXQgKyBcIiBcIiArIGRpZ2l0O1xuICAgICAgICAgICAgICAgIH0pLnJlcGxhY2UoJywgJywgJyw8YnI+Jyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZHNjYXBlID8gbGFuZHNjYXBlRm9ybWF0dGVyIDogdGl0bGVEYXRlRm9ybWF0dGVyO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICB0YWJsZURhdGU6IGZ1bmN0aW9uIHRhYmxlRGF0ZSh2YWwsIHByZXYpIHtcbiAgICAgICAgICAgIC8vIE1ha2UgYSBJU08gODYwMSBzdHJpbmdzIGZyb20gdmFsIGFuZCBwcmV2IGZvciBjb21wYXJpc2lvbiwgb3RoZXJ3aXNlIGl0IHdpbGwgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgIC8vIGNvbXBhcmUgZm9yIGV4YW1wbGUgJzIwMDAtOScgYW5kICcyMDAwLTEwJ1xuICAgICAgICAgICAgdmFyIHNhbml0aXplVHlwZSA9IHRoaXMudHlwZSA9PT0gJ21vbnRoJyA/ICd5ZWFyJyA6ICdtb250aCc7XG4gICAgICAgICAgICB0aGlzLmlzUmV2ZXJzaW5nID0gdGhpcy5zYW5pdGl6ZURhdGVTdHJpbmcodmFsLCBzYW5pdGl6ZVR5cGUpIDwgdGhpcy5zYW5pdGl6ZURhdGVTdHJpbmcocHJldiwgc2FuaXRpemVUeXBlKTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpwaWNrZXJEYXRlJywgdmFsKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGlja2VyRGF0ZTogZnVuY3Rpb24gcGlja2VyRGF0ZSh2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlRGF0ZSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYXN0VmFsdWUgJiYgdGhpcy50eXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlRGF0ZSA9IHRoaXMuc2FuaXRpemVEYXRlU3RyaW5nKHRoaXMubGFzdFZhbHVlLCAnbW9udGgnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYXN0VmFsdWUgJiYgdGhpcy50eXBlID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWJsZURhdGUgPSB0aGlzLnNhbml0aXplRGF0ZVN0cmluZyh0aGlzLmxhc3RWYWx1ZSwgJ3llYXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja011bHRpcGxlUHJvcCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRJbnB1dERhdGUoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSAmJiB0aGlzLnZhbHVlICYmICF0aGlzLnBpY2tlckRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlRGF0ZSA9IHRoaXMuc2FuaXRpemVEYXRlU3RyaW5nKHRoaXMuaW5wdXREYXRlLCB0aGlzLnR5cGUgPT09ICdtb250aCcgPyAneWVhcicgOiAnbW9udGgnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tdWx0aXBsZSAmJiB0aGlzLnZhbHVlLmxlbmd0aCAmJiAhb2xkVmFsdWUubGVuZ3RoICYmICF0aGlzLnBpY2tlckRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlRGF0ZSA9IHRoaXMuc2FuaXRpemVEYXRlU3RyaW5nKHRoaXMuaW5wdXREYXRlLCB0aGlzLnR5cGUgPT09ICdtb250aCcgPyAneWVhcicgOiAnbW9udGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogZnVuY3Rpb24gdHlwZShfdHlwZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUGlja2VyID0gX3R5cGUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9ICh0aGlzLm11bHRpcGxlID8gdGhpcy52YWx1ZSA6IFt0aGlzLnZhbHVlXSkubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNhbml0aXplRGF0ZVN0cmluZyh2YWwsIF90eXBlKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIodGhpcy5pc0RhdGVBbGxvd2VkKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHRoaXMubXVsdGlwbGUgPyBvdXRwdXQgOiBvdXRwdXRbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLmNoZWNrTXVsdGlwbGVQcm9wKCk7XG4gICAgICAgIGlmICh0aGlzLnBpY2tlckRhdGUgIT09IHRoaXMudGFibGVEYXRlKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6cGlja2VyRGF0ZScsIHRoaXMudGFibGVEYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldElucHV0RGF0ZSgpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBlbWl0SW5wdXQ6IGZ1bmN0aW9uIGVtaXRJbnB1dChuZXdJbnB1dCkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubXVsdGlwbGUgPyB0aGlzLnZhbHVlLmluZGV4T2YobmV3SW5wdXQpID09PSAtMSA/IHRoaXMudmFsdWUuY29uY2F0KFtuZXdJbnB1dF0pIDogdGhpcy52YWx1ZS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geCAhPT0gbmV3SW5wdXQ7XG4gICAgICAgICAgICB9KSA6IG5ld0lucHV0O1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBvdXRwdXQpO1xuICAgICAgICAgICAgdGhpcy5tdWx0aXBsZSB8fCB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBuZXdJbnB1dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrTXVsdGlwbGVQcm9wOiBmdW5jdGlvbiBjaGVja011bHRpcGxlUHJvcCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSB0aGlzLnZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSB0aGlzLm11bHRpcGxlID8gJ0FycmF5JyA6ICdTdHJpbmcnO1xuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiY29uc29sZVdhcm5cIl0pKFwiVmFsdWUgbXVzdCBiZSBcIiArICh0aGlzLm11bHRpcGxlID8gJ2FuJyA6ICdhJykgKyBcIiBcIiArIGV4cGVjdGVkICsgXCIsIGdvdCBcIiArIHZhbHVlVHlwZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGF0ZUFsbG93ZWQ6IGZ1bmN0aW9uIGlzRGF0ZUFsbG93ZWQodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QoX3V0aWxfaXNEYXRlQWxsb3dlZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXSkodmFsdWUsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5hbGxvd2VkRGF0ZXMpO1xuICAgICAgICB9LFxuICAgICAgICB5ZWFyQ2xpY2s6IGZ1bmN0aW9uIHllYXJDbGljayh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFllYXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtb250aCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlRGF0ZSA9IFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWJsZURhdGUgPSB2YWx1ZSArIFwiLVwiICsgT2JqZWN0KF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJwYWRcIl0pKHRoaXMudGFibGVNb250aCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmVQaWNrZXIgPSAnTU9OVEgnO1xuICAgICAgICAgICAgdGhpcy5yZWFjdGl2ZSAmJiAhdGhpcy5tdWx0aXBsZSAmJiB0aGlzLmlzRGF0ZUFsbG93ZWQodGhpcy5pbnB1dERhdGUpICYmIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy5pbnB1dERhdGUpO1xuICAgICAgICB9LFxuICAgICAgICBtb250aENsaWNrOiBmdW5jdGlvbiBtb250aENsaWNrKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0WWVhciA9IHBhcnNlSW50KHZhbHVlLnNwbGl0KCctJylbMF0sIDEwKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRNb250aCA9IHBhcnNlSW50KHZhbHVlLnNwbGl0KCctJylbMV0sIDEwKSAtIDE7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlRGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUGlja2VyID0gJ0RBVEUnO1xuICAgICAgICAgICAgICAgIHRoaXMucmVhY3RpdmUgJiYgIXRoaXMubXVsdGlwbGUgJiYgdGhpcy5pc0RhdGVBbGxvd2VkKHRoaXMuaW5wdXREYXRlKSAmJiB0aGlzLiRlbWl0KCdpbnB1dCcsIHRoaXMuaW5wdXREYXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0SW5wdXQodGhpcy5pbnB1dERhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXRlQ2xpY2s6IGZ1bmN0aW9uIGRhdGVDbGljayh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFllYXIgPSBwYXJzZUludCh2YWx1ZS5zcGxpdCgnLScpWzBdLCAxMCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0TW9udGggPSBwYXJzZUludCh2YWx1ZS5zcGxpdCgnLScpWzFdLCAxMCkgLSAxO1xuICAgICAgICAgICAgdGhpcy5pbnB1dERheSA9IHBhcnNlSW50KHZhbHVlLnNwbGl0KCctJylbMl0sIDEwKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdElucHV0KHRoaXMuaW5wdXREYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuUGlja2VyVGl0bGU6IGZ1bmN0aW9uIGdlblBpY2tlclRpdGxlKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WRGF0ZVBpY2tlclRpdGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogdGhpcy52YWx1ZSA/IHRoaXMuZm9ybWF0dGVycy50aXRsZURhdGUodGhpcy52YWx1ZSkgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW5nWWVhcjogdGhpcy5hY3RpdmVQaWNrZXIgPT09ICdZRUFSJyxcbiAgICAgICAgICAgICAgICAgICAgeWVhcjogdGhpcy5mb3JtYXR0ZXJzLnllYXIoXCJcIiArIHRoaXMuaW5wdXRZZWFyKSxcbiAgICAgICAgICAgICAgICAgICAgeWVhckljb246IHRoaXMueWVhckljb24sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLm11bHRpcGxlID8gdGhpcy52YWx1ZVswXSA6IHRoaXMudmFsdWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNsb3Q6ICd0aXRsZScsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHRoaXMucmVhZG9ubHkgPyB7XG4gICAgICAgICAgICAgICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJ1xuICAgICAgICAgICAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgJ3VwZGF0ZTpzZWxlY3RpbmdZZWFyJzogZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW5nWWVhcih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFjdGl2ZVBpY2tlciA9IHZhbHVlID8gJ1lFQVInIDogX3RoaXMudHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblRhYmxlSGVhZGVyOiBmdW5jdGlvbiBnZW5UYWJsZUhlYWRlcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVkRhdGVQaWNrZXJIZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBuZXh0SWNvbjogdGhpcy5uZXh0SWNvbixcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGRhcms6IHRoaXMuZGFyayxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMucmVhZG9ubHksXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5oZWFkZXJEYXRlRm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICBsaWdodDogdGhpcy5saWdodCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgbWluOiB0aGlzLmFjdGl2ZVBpY2tlciA9PT0gJ0RBVEUnID8gdGhpcy5taW5Nb250aCA6IHRoaXMubWluWWVhcixcbiAgICAgICAgICAgICAgICAgICAgbWF4OiB0aGlzLmFjdGl2ZVBpY2tlciA9PT0gJ0RBVEUnID8gdGhpcy5tYXhNb250aCA6IHRoaXMubWF4WWVhcixcbiAgICAgICAgICAgICAgICAgICAgcHJldkljb246IHRoaXMucHJldkljb24sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmFjdGl2ZVBpY2tlciA9PT0gJ0RBVEUnID8gdGhpcy50YWJsZVllYXIgKyBcIi1cIiArIE9iamVjdChfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wicGFkXCJdKSh0aGlzLnRhYmxlTW9udGggKyAxKSA6IFwiXCIgKyB0aGlzLnRhYmxlWWVhclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYWN0aXZlUGlja2VyID0gX3RoaXMuYWN0aXZlUGlja2VyID09PSAnREFURScgPyAnTU9OVEgnIDogJ1lFQVInO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24gaW5wdXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50YWJsZURhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5EYXRlVGFibGU6IGZ1bmN0aW9uIGdlbkRhdGVUYWJsZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVkRhdGVQaWNrZXJEYXRlVGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkRGF0ZXM6IHRoaXMuYWxsb3dlZERhdGVzLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDogdGhpcy5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICBkYXJrOiB0aGlzLmRhcmssXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLnJlYWRvbmx5LFxuICAgICAgICAgICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICBldmVudENvbG9yOiB0aGlzLmV2ZW50Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0RGF5T2ZXZWVrOiB0aGlzLmZpcnN0RGF5T2ZXZWVrLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuZGF5Rm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICBsaWdodDogdGhpcy5saWdodCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgbWluOiB0aGlzLm1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1heCxcbiAgICAgICAgICAgICAgICAgICAgdGFibGVEYXRlOiB0aGlzLnRhYmxlWWVhciArIFwiLVwiICsgT2JqZWN0KF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJwYWRcIl0pKHRoaXMudGFibGVNb250aCArIDEpLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxhYmxlOiB0aGlzLnNjcm9sbGFibGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5Rm9ybWF0OiB0aGlzLndlZWtkYXlGb3JtYXRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZjogJ3RhYmxlJyxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5kYXRlQ2xpY2ssXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlRGF0ZTogZnVuY3Rpb24gdGFibGVEYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudGFibGVEYXRlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuTW9udGhUYWJsZTogZnVuY3Rpb24gZ2VuTW9udGhUYWJsZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVkRhdGVQaWNrZXJNb250aFRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZERhdGVzOiB0aGlzLnR5cGUgPT09ICdtb250aCcgPyB0aGlzLmFsbG93ZWREYXRlcyA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiB0aGlzLmN1cnJlbnQgPyB0aGlzLnNhbml0aXplRGF0ZVN0cmluZyh0aGlzLmN1cnJlbnQsICdtb250aCcpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGFyazogdGhpcy5kYXJrLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5yZWFkb25seSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm1vbnRoRm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICBsaWdodDogdGhpcy5saWdodCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgbWluOiB0aGlzLm1pbk1vbnRoLFxuICAgICAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWF4TW9udGgsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGFibGU6IHRoaXMuc2Nyb2xsYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2VsZWN0ZWRNb250aHMsXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlRGF0ZTogXCJcIiArIHRoaXMudGFibGVZZWFyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWY6ICd0YWJsZScsXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMubW9udGhDbGljayxcbiAgICAgICAgICAgICAgICAgICAgdGFibGVEYXRlOiBmdW5jdGlvbiB0YWJsZURhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50YWJsZURhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5ZZWFyczogZnVuY3Rpb24gZ2VuWWVhcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVkRhdGVQaWNrZXJZZWFyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMueWVhckZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgbWluOiB0aGlzLm1pblllYXIsXG4gICAgICAgICAgICAgICAgICAgIG1heDogdGhpcy5tYXhZZWFyLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIiArIHRoaXMudGFibGVZZWFyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy55ZWFyQ2xpY2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuUGlja2VyQm9keTogZnVuY3Rpb24gZ2VuUGlja2VyQm9keSgpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuYWN0aXZlUGlja2VyID09PSAnWUVBUicgPyBbdGhpcy5nZW5ZZWFycygpXSA6IFt0aGlzLmdlblRhYmxlSGVhZGVyKCksIHRoaXMuYWN0aXZlUGlja2VyID09PSAnREFURScgPyB0aGlzLmdlbkRhdGVUYWJsZSgpIDogdGhpcy5nZW5Nb250aFRhYmxlKCldO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuYWN0aXZlUGlja2VyLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLnJlYWRvbmx5ID8ge1xuICAgICAgICAgICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZSdcbiAgICAgICAgICAgICAgICB9IDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFkZHMgbGVhZGluZyB6ZXJvIHRvIG1vbnRoL2RheSBpZiBuZWNlc3NhcnksIHJldHVybnMgJ1lZWVknIGlmIHR5cGUgPSAneWVhcicsXG4gICAgICAgIC8vICdZWVlZLU1NJyBpZiAnbW9udGgnIGFuZCAnWVlZWS1NTS1ERCcgaWYgJ2RhdGUnXG4gICAgICAgIHNhbml0aXplRGF0ZVN0cmluZzogZnVuY3Rpb24gc2FuaXRpemVEYXRlU3RyaW5nKGRhdGVTdHJpbmcsIHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF9fcmVhZChkYXRlU3RyaW5nLnNwbGl0KCctJyksIDMpLFxuICAgICAgICAgICAgICAgIHllYXIgPSBfYVswXSxcbiAgICAgICAgICAgICAgICBfYiA9IF9hWzFdLFxuICAgICAgICAgICAgICAgIG1vbnRoID0gX2IgPT09IHZvaWQgMCA/IDEgOiBfYixcbiAgICAgICAgICAgICAgICBfYyA9IF9hWzJdLFxuICAgICAgICAgICAgICAgIGRhdGUgPSBfYyA9PT0gdm9pZCAwID8gMSA6IF9jO1xuICAgICAgICAgICAgcmV0dXJuICh5ZWFyICsgXCItXCIgKyBPYmplY3QoX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInBhZFwiXSkobW9udGgpICsgXCItXCIgKyBPYmplY3QoX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInBhZFwiXSkoZGF0ZSkpLnN1YnN0cigwLCB7IGRhdGU6IDEwLCBtb250aDogNywgeWVhcjogNCB9W3R5cGVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW5wdXREYXRlOiBmdW5jdGlvbiBzZXRJbnB1dERhdGUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmxhc3RWYWx1ZS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRZZWFyID0gcGFyc2VJbnQoYXJyYXlbMF0sIDEwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0TW9udGggPSBwYXJzZUludChhcnJheVsxXSwgMTApIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dERheSA9IHBhcnNlSW50KGFycmF5WzJdLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0WWVhciA9IHRoaXMuaW5wdXRZZWFyIHx8IHRoaXMubm93LmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dE1vbnRoID0gdGhpcy5pbnB1dE1vbnRoID09IG51bGwgPyB0aGlzLmlucHV0TW9udGggOiB0aGlzLm5vdy5nZXRNb250aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXREYXkgPSB0aGlzLmlucHV0RGF5IHx8IHRoaXMubm93LmdldERhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlblBpY2tlcigndi1waWNrZXItLWRhdGUnKTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci9WRGF0ZVBpY2tlckRhdGVUYWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvVkRhdGVQaWNrZXJEYXRlVGFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2RhdGVfcGlja2VyX3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21peGlucy9kYXRlLXBpY2tlci10YWJsZSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvbWl4aW5zL2RhdGUtcGlja2VyLXRhYmxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci91dGlsL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbi8vIE1peGluc1xuXG5cblxuLy8gVXRpbHNcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtZGF0ZS1waWNrZXItZGF0ZS10YWJsZScsXG4gICAgbWl4aW5zOiBbX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfZGF0ZV9waWNrZXJfdGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdXSxcbiAgICBwcm9wczoge1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIHR5cGU6IFtBcnJheSwgT2JqZWN0LCBGdW5jdGlvbl0sXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRDb2xvcjoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgRnVuY3Rpb24sIE9iamVjdF0sXG4gICAgICAgICAgICBkZWZhdWx0OiAnd2FybmluZydcbiAgICAgICAgfSxcbiAgICAgICAgZmlyc3REYXlPZldlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHdlZWtkYXlGb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCB8fCBPYmplY3QoX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImNyZWF0ZU5hdGl2ZUxvY2FsZUZvcm1hdHRlclwiXSkodGhpcy5sb2NhbGUsIHsgZGF5OiAnbnVtZXJpYycsIHRpbWVab25lOiAnVVRDJyB9LCB7IHN0YXJ0OiA4LCBsZW5ndGg6IDIgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHdlZWtkYXlGb3JtYXR0ZXI6IGZ1bmN0aW9uIHdlZWtkYXlGb3JtYXR0ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWVrZGF5Rm9ybWF0IHx8IE9iamVjdChfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiY3JlYXRlTmF0aXZlTG9jYWxlRm9ybWF0dGVyXCJdKSh0aGlzLmxvY2FsZSwgeyB3ZWVrZGF5OiAnbmFycm93JywgdGltZVpvbmU6ICdVVEMnIH0pO1xuICAgICAgICB9LFxuICAgICAgICB3ZWVrRGF5czogZnVuY3Rpb24gd2Vla0RheXMoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gcGFyc2VJbnQodGhpcy5maXJzdERheU9mV2VlaywgMTApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2Vla2RheUZvcm1hdHRlciA/IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJjcmVhdGVSYW5nZVwiXSkoNykubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLndlZWtkYXlGb3JtYXR0ZXIoXCIyMDE3LTAxLVwiICsgKGZpcnN0ICsgaSArIDE1KSk7XG4gICAgICAgICAgICB9KSAvLyAyMDE3LTAxLTE1IGlzIFN1bmRheVxuICAgICAgICAgICAgOiBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiY3JlYXRlUmFuZ2VcIl0pKDcpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXVsoaSArIGZpcnN0KSAlIDddO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgY2FsY3VsYXRlVGFibGVEYXRlOiBmdW5jdGlvbiBjYWxjdWxhdGVUYWJsZURhdGUoZGVsdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QoX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIm1vbnRoQ2hhbmdlXCJdKSh0aGlzLnRhYmxlRGF0ZSwgTWF0aC5zaWduKGRlbHRhIHx8IDEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuVEhlYWQ6IGZ1bmN0aW9uIGdlblRIZWFkKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBkYXlzID0gdGhpcy53ZWVrRGF5cy5tYXAoZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kY3JlYXRlRWxlbWVudCgndGgnLCBkYXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGhlYWQnLCB0aGlzLmdlblRSKGRheXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuRXZlbnQ6IGZ1bmN0aW9uIGdlbkV2ZW50KGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBldmVudENvbG9yO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmV2ZW50Q29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRDb2xvciA9IHRoaXMuZXZlbnRDb2xvcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuZXZlbnRDb2xvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGV2ZW50Q29sb3IgPSB0aGlzLmV2ZW50Q29sb3IoZGF0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50Q29sb3IgPSB0aGlzLmV2ZW50Q29sb3JbZGF0ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2JywgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IoZXZlbnRDb2xvciB8fCB0aGlzLmNvbG9yIHx8ICdhY2NlbnQnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWRhdGUtcGlja2VyLXRhYmxlX19ldmVudCdcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUmV0dXJucyBudW1iZXIgb2YgdGhlIGRheXMgZnJvbSB0aGUgZmlyc3REYXlPZldlZWsgdG8gdGhlIGZpcnN0IGRheSBvZiB0aGUgY3VycmVudCBtb250aFxuICAgICAgICB3ZWVrRGF5c0JlZm9yZUZpcnN0RGF5T2ZUaGVNb250aDogZnVuY3Rpb24gd2Vla0RheXNCZWZvcmVGaXJzdERheU9mVGhlTW9udGgoKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3REYXlPZlRoZU1vbnRoID0gbmV3IERhdGUodGhpcy5kaXNwbGF5ZWRZZWFyICsgXCItXCIgKyBPYmplY3QoX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcInBhZFwiXSkodGhpcy5kaXNwbGF5ZWRNb250aCArIDEpICsgXCItMDFUMDA6MDA6MDArMDA6MDBcIik7XG4gICAgICAgICAgICB2YXIgd2Vla0RheSA9IGZpcnN0RGF5T2ZUaGVNb250aC5nZXRVVENEYXkoKTtcbiAgICAgICAgICAgIHJldHVybiAod2Vla0RheSAtIHBhcnNlSW50KHRoaXMuZmlyc3REYXlPZldlZWspICsgNykgJSA3O1xuICAgICAgICB9LFxuICAgICAgICBpc0V2ZW50OiBmdW5jdGlvbiBpc0V2ZW50KGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXZlbnRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50cy5pbmRleE9mKGRhdGUpID4gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZXZlbnRzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHMoZGF0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VuVEJvZHk6IGZ1bmN0aW9uIGdlblRCb2R5KCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBuZXcgRGF0ZSh0aGlzLmRpc3BsYXllZFllYXIsIHRoaXMuZGlzcGxheWVkTW9udGggKyAxLCAwKS5nZXREYXRlKCk7XG4gICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRheSA9IHRoaXMud2Vla0RheXNCZWZvcmVGaXJzdERheU9mVGhlTW9udGgoKTtcbiAgICAgICAgICAgIHdoaWxlIChkYXktLSkge1xuICAgICAgICAgICAgICAgIHJvd3MucHVzaCh0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZCcpKTtcbiAgICAgICAgICAgIH1mb3IgKGRheSA9IDE7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuZGlzcGxheWVkWWVhciArIFwiLVwiICsgT2JqZWN0KF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJwYWRcIl0pKHRoaXMuZGlzcGxheWVkTW9udGggKyAxKSArIFwiLVwiICsgT2JqZWN0KF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJwYWRcIl0pKGRheSk7XG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RkJywgW3RoaXMuZ2VuQnV0dG9uKGRhdGUsIHRydWUpLCB0aGlzLmlzRXZlbnQoZGF0ZSkgPyB0aGlzLmdlbkV2ZW50KGRhdGUpIDogbnVsbF0pKTtcbiAgICAgICAgICAgICAgICBpZiAocm93cy5sZW5ndGggJSA3ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5nZW5UUihyb3dzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuZ2VuVFIocm93cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3Rib2R5JywgY2hpbGRyZW4pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5UUjogZnVuY3Rpb24gZ2VuVFIoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy4kY3JlYXRlRWxlbWVudCgndHInLCBjaGlsZHJlbildO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuVGFibGUoJ3YtZGF0ZS1waWNrZXItdGFibGUgdi1kYXRlLXBpY2tlci10YWJsZS0tZGF0ZScsIFt0aGlzLmdlblRIZWFkKCksIHRoaXMuZ2VuVEJvZHkoKV0pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL1ZEYXRlUGlja2VySGVhZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci9WRGF0ZVBpY2tlckhlYWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2RhdGVfcGlja2VyX2hlYWRlcl9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fZGF0ZS1waWNrZXItaGVhZGVyLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZGF0ZS1waWNrZXItaGVhZGVyLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2RhdGVfcGlja2VyX2hlYWRlcl9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2RhdGVfcGlja2VyX2hlYWRlcl9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQnRuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WQnRuICovIFwiLi9zcmMvY29tcG9uZW50cy9WQnRuL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVkljb24gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJY29uL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RoZW1lYWJsZSAqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvdXRpbC9pbmRleC5qc1wiKTtcbnZhciBfX3JlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fcmVhZCB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgICByLFxuICAgICAgICBhciA9IFtdLFxuICAgICAgICBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcblxuLy8gQ29tcG9uZW50c1xuXG5cbi8vIE1peGluc1xuXG5cbi8vIFV0aWxzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1kYXRlLXBpY2tlci1oZWFkZXInLFxuICAgIG1peGluczogW19taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGxvY2FsZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2VuLXVzJ1xuICAgICAgICB9LFxuICAgICAgICBtaW46IFN0cmluZyxcbiAgICAgICAgbWF4OiBTdHJpbmcsXG4gICAgICAgIG5leHRJY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMubmV4dCdcbiAgICAgICAgfSxcbiAgICAgICAgcHJldkljb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5wcmV2J1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1JldmVyc2luZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChTdHJpbmcodGhpcy52YWx1ZSkuc3BsaXQoJy0nKVsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QoX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImNyZWF0ZU5hdGl2ZUxvY2FsZUZvcm1hdHRlclwiXSkodGhpcy5sb2NhbGUsIHsgbW9udGg6ICdsb25nJywgeWVhcjogJ251bWVyaWMnLCB0aW1lWm9uZTogJ1VUQycgfSwgeyBsZW5ndGg6IDcgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QoX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImNyZWF0ZU5hdGl2ZUxvY2FsZUZvcm1hdHRlclwiXSkodGhpcy5sb2NhbGUsIHsgeWVhcjogJ251bWVyaWMnLCB0aW1lWm9uZTogJ1VUQycgfSwgeyBsZW5ndGg6IDQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICAgICAgdGhpcy5pc1JldmVyc2luZyA9IG5ld1ZhbCA8IG9sZFZhbDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZW5CdG46IGZ1bmN0aW9uIGdlbkJ0bihjaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSB0aGlzLmRpc2FibGVkIHx8IGNoYW5nZSA8IDAgJiYgdGhpcy5taW4gJiYgdGhpcy5jYWxjdWxhdGVDaGFuZ2UoY2hhbmdlKSA8IHRoaXMubWluIHx8IGNoYW5nZSA+IDAgJiYgdGhpcy5tYXggJiYgdGhpcy5jYWxjdWxhdGVDaGFuZ2UoY2hhbmdlKSA+IHRoaXMubWF4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZCdG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBkYXJrOiB0aGlzLmRhcmssXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgaWNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGlnaHQ6IHRoaXMubGlnaHRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5hdGl2ZU9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGVtaXQoJ2lucHV0JywgX3RoaXMuY2FsY3VsYXRlQ2hhbmdlKGNoYW5nZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW3RoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCBjaGFuZ2UgPCAwID09PSAhdGhpcy4kdnVldGlmeS5ydGwgPyB0aGlzLnByZXZJY29uIDogdGhpcy5uZXh0SWNvbildKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY3VsYXRlQ2hhbmdlOiBmdW5jdGlvbiBjYWxjdWxhdGVDaGFuZ2Uoc2lnbikge1xuICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKFN0cmluZyh0aGlzLnZhbHVlKS5zcGxpdCgnLScpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiAxICogdjtcbiAgICAgICAgICAgIH0pLCAyKSxcbiAgICAgICAgICAgICAgICB5ZWFyID0gX2FbMF0sXG4gICAgICAgICAgICAgICAgbW9udGggPSBfYVsxXTtcbiAgICAgICAgICAgIGlmIChtb250aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyAoeWVhciArIHNpZ24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0KF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJtb250aENoYW5nZVwiXSkoU3RyaW5nKHRoaXMudmFsdWUpLCBzaWduKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSGVhZGVyOiBmdW5jdGlvbiBnZW5IZWFkZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gIXRoaXMuZGlzYWJsZWQgJiYgKHRoaXMuY29sb3IgfHwgJ2FjY2VudCcpO1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3N0cm9uZycsIHRoaXMuc2V0VGV4dENvbG9yKGNvbG9yLCB7XG4gICAgICAgICAgICAgICAga2V5OiBTdHJpbmcodGhpcy52YWx1ZSksXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRlbWl0KCd0b2dnbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBbdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCB0aGlzLmZvcm1hdHRlcihTdHJpbmcodGhpcy52YWx1ZSkpXSk7XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RyYW5zaXRpb24nLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5pc1JldmVyc2luZyA9PT0gIXRoaXMuJHZ1ZXRpZnkucnRsID8gJ3RhYi1yZXZlcnNlLXRyYW5zaXRpb24nIDogJ3RhYi10cmFuc2l0aW9uJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtoZWFkZXJdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWRhdGUtcGlja2VyLWhlYWRlcl9fdmFsdWUnLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgICAgICd2LWRhdGUtcGlja2VyLWhlYWRlcl9fdmFsdWUtLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFt0cmFuc2l0aW9uXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWRhdGUtcGlja2VyLWhlYWRlcicsXG4gICAgICAgICAgICBjbGFzczogdGhpcy50aGVtZUNsYXNzZXNcbiAgICAgICAgfSwgW3RoaXMuZ2VuQnRuKC0xKSwgdGhpcy5nZW5IZWFkZXIoKSwgdGhpcy5nZW5CdG4oKzEpXSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvVkRhdGVQaWNrZXJNb250aFRhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvVkRhdGVQaWNrZXJNb250aFRhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfZGF0ZV9waWNrZXJfdGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL2RhdGUtcGlja2VyLXRhYmxlICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci9taXhpbnMvZGF0ZS1waWNrZXItdGFibGUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL3V0aWwvaW5kZXguanNcIik7XG4vLyBNaXhpbnNcblxuXG5cbi8vIFV0aWxzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1kYXRlLXBpY2tlci1tb250aC10YWJsZScsXG4gICAgbWl4aW5zOiBbX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfZGF0ZV9waWNrZXJfdGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdXSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCB8fCBPYmplY3QoX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImNyZWF0ZU5hdGl2ZUxvY2FsZUZvcm1hdHRlclwiXSkodGhpcy5sb2NhbGUsIHsgbW9udGg6ICdzaG9ydCcsIHRpbWVab25lOiAnVVRDJyB9LCB7IHN0YXJ0OiA1LCBsZW5ndGg6IDIgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgY2FsY3VsYXRlVGFibGVEYXRlOiBmdW5jdGlvbiBjYWxjdWxhdGVUYWJsZURhdGUoZGVsdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgKHBhcnNlSW50KHRoaXMudGFibGVEYXRlLCAxMCkgKyBNYXRoLnNpZ24oZGVsdGEgfHwgMSkpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5UQm9keTogZnVuY3Rpb24gZ2VuVEJvZHkoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICB2YXIgY29scyA9IEFycmF5KDMpLmZpbGwobnVsbCk7XG4gICAgICAgICAgICB2YXIgcm93cyA9IDEyIC8gY29scy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIF9sb29wXzEocm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRkcyA9IGNvbHMubWFwKGZ1bmN0aW9uIChfLCBjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gcm93ICogY29scy5sZW5ndGggKyBjb2w7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kY3JlYXRlRWxlbWVudCgndGQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IG1vbnRoXG4gICAgICAgICAgICAgICAgICAgIH0sIFtfdGhpcy5nZW5CdXR0b24oX3RoaXMuZGlzcGxheWVkWWVhciArIFwiLVwiICsgT2JqZWN0KF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJwYWRcIl0pKG1vbnRoICsgMSksIGZhbHNlKV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpc18xLiRjcmVhdGVFbGVtZW50KCd0cicsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiByb3dcbiAgICAgICAgICAgICAgICB9LCB0ZHMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHJvd3M7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3BfMShyb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3Rib2R5JywgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuVGFibGUoJ3YtZGF0ZS1waWNrZXItdGFibGUgdi1kYXRlLXBpY2tlci10YWJsZS0tbW9udGgnLCBbdGhpcy5nZW5UQm9keSgpXSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvVkRhdGVQaWNrZXJUaXRsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci9WRGF0ZVBpY2tlclRpdGxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19kYXRlX3BpY2tlcl90aXRsZV9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fZGF0ZS1waWNrZXItdGl0bGUuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19kYXRlLXBpY2tlci10aXRsZS5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19kYXRlX3BpY2tlcl90aXRsZV9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2RhdGVfcGlja2VyX3RpdGxlX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WSWNvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkljb24vaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19waWNrZXJfYnV0dG9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvcGlja2VyLWJ1dHRvbiAqLyBcIi4vc3JjL21peGlucy9waWNrZXItYnV0dG9uLmpzXCIpO1xuXG4vLyBDb21wb25lbnRzXG5cbi8vIE1peGluc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtZGF0ZS1waWNrZXItdGl0bGUnLFxuICAgIG1peGluczogW19taXhpbnNfcGlja2VyX2J1dHRvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZGF0ZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJydcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0aW5nWWVhcjogQm9vbGVhbixcbiAgICAgICAgeWVhcjoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIHllYXJJY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNSZXZlcnNpbmc6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjb21wdXRlZFRyYW5zaXRpb246IGZ1bmN0aW9uIGNvbXB1dGVkVHJhbnNpdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUmV2ZXJzaW5nID8gJ3BpY2tlci1yZXZlcnNlLXRyYW5zaXRpb24nIDogJ3BpY2tlci10cmFuc2l0aW9uJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHZhbCwgcHJldikge1xuICAgICAgICAgICAgdGhpcy5pc1JldmVyc2luZyA9IHZhbCA8IHByZXY7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuWWVhckljb246IGZ1bmN0aW9uIGdlblllYXJJY29uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGFyazogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMueWVhckljb24pO1xuICAgICAgICB9LFxuICAgICAgICBnZXRZZWFyQnRuOiBmdW5jdGlvbiBnZXRZZWFyQnRuKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuUGlja2VyQnV0dG9uKCdzZWxlY3RpbmdZZWFyJywgdHJ1ZSwgW3RoaXMueWVhciwgdGhpcy55ZWFySWNvbiA/IHRoaXMuZ2VuWWVhckljb24oKSA6IG51bGxdLCBmYWxzZSwgJ3YtZGF0ZS1waWNrZXItdGl0bGVfX3llYXInKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuVGl0bGVUZXh0OiBmdW5jdGlvbiBnZW5UaXRsZVRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndHJhbnNpdGlvbicsIHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmNvbXB1dGVkVHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFt0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgZG9tUHJvcHM6IHsgaW5uZXJIVE1MOiB0aGlzLmRhdGUgfHwgJyZuYnNwOycgfSxcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMudmFsdWVcbiAgICAgICAgICAgIH0pXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblRpdGxlRGF0ZTogZnVuY3Rpb24gZ2VuVGl0bGVEYXRlKHRpdGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5QaWNrZXJCdXR0b24oJ3NlbGVjdGluZ1llYXInLCBmYWxzZSwgdGhpcy5nZW5UaXRsZVRleHQodGl0bGUpLCBmYWxzZSwgJ3YtZGF0ZS1waWNrZXItdGl0bGVfX2RhdGUnKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWRhdGUtcGlja2VyLXRpdGxlJ1xuICAgICAgICB9LCBbdGhpcy5nZXRZZWFyQnRuKCksIHRoaXMuZ2VuVGl0bGVEYXRlKCldKTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci9WRGF0ZVBpY2tlclllYXJzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL1ZEYXRlUGlja2VyWWVhcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2RhdGVfcGlja2VyX3llYXJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19kYXRlLXBpY2tlci15ZWFycy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2RhdGUtcGlja2VyLXllYXJzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2RhdGVfcGlja2VyX3llYXJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfZGF0ZV9waWNrZXJfeWVhcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2NvbG9yYWJsZSAqLyBcIi4vc3JjL21peGlucy9jb2xvcmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvdXRpbC9pbmRleC5qc1wiKTtcblxuLy8gTWl4aW5zXG5cbi8vIFV0aWxzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1kYXRlLXBpY2tlci15ZWFycycsXG4gICAgbWl4aW5zOiBbX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGxvY2FsZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2VuLXVzJ1xuICAgICAgICB9LFxuICAgICAgICBtaW46IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIG1heDogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgdmFsdWU6IFtOdW1iZXIsIFN0cmluZ11cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWZhdWx0Q29sb3I6ICdwcmltYXJ5J1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQgfHwgT2JqZWN0KF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJjcmVhdGVOYXRpdmVMb2NhbGVGb3JtYXR0ZXJcIl0pKHRoaXMubG9jYWxlLCB7IHllYXI6ICdudW1lcmljJywgdGltZVpvbmU6ICdVVEMnIH0sIHsgbGVuZ3RoOiA0IH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICB2YXIgYWN0aXZlSXRlbSA9IHRoaXMuJGVsLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2FjdGl2ZScpWzBdO1xuICAgICAgICBpZiAoYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgdGhpcy4kZWwuc2Nyb2xsVG9wID0gYWN0aXZlSXRlbS5vZmZzZXRUb3AgLSB0aGlzLiRlbC5vZmZzZXRIZWlnaHQgLyAyICsgYWN0aXZlSXRlbS5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kZWwuc2Nyb2xsVG9wID0gdGhpcy4kZWwuc2Nyb2xsSGVpZ2h0IC8gMiAtIHRoaXMuJGVsLm9mZnNldEhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuWWVhckl0ZW06IGZ1bmN0aW9uIGdlblllYXJJdGVtKHllYXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXR0ZXIoXCJcIiArIHllYXIpO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IHBhcnNlSW50KHRoaXMudmFsdWUsIDEwKSA9PT0geWVhcjtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGFjdGl2ZSAmJiAodGhpcy5jb2xvciB8fCAncHJpbWFyeScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2xpJywgdGhpcy5zZXRUZXh0Q29sb3IoY29sb3IsIHtcbiAgICAgICAgICAgICAgICBrZXk6IHllYXIsXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogeyBhY3RpdmU6IGFjdGl2ZSB9LFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kZW1pdCgnaW5wdXQnLCB5ZWFyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBmb3JtYXR0ZWQpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5ZZWFySXRlbXM6IGZ1bmN0aW9uIGdlblllYXJJdGVtcygpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkWWVhciA9IHRoaXMudmFsdWUgPyBwYXJzZUludCh0aGlzLnZhbHVlLCAxMCkgOiBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICB2YXIgbWF4WWVhciA9IHRoaXMubWF4ID8gcGFyc2VJbnQodGhpcy5tYXgsIDEwKSA6IHNlbGVjdGVkWWVhciArIDEwMDtcbiAgICAgICAgICAgIHZhciBtaW5ZZWFyID0gTWF0aC5taW4obWF4WWVhciwgdGhpcy5taW4gPyBwYXJzZUludCh0aGlzLm1pbiwgMTApIDogc2VsZWN0ZWRZZWFyIC0gMTAwKTtcbiAgICAgICAgICAgIGZvciAodmFyIHllYXIgPSBtYXhZZWFyOyB5ZWFyID49IG1pblllYXI7IHllYXItLSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5nZW5ZZWFySXRlbSh5ZWFyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndWwnLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtZGF0ZS1waWNrZXIteWVhcnMnLFxuICAgICAgICAgICAgcmVmOiAneWVhcnMnXG4gICAgICAgIH0sIHRoaXMuZ2VuWWVhckl0ZW1zKCkpO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZEYXRlUGlja2VyLCBWRGF0ZVBpY2tlclRpdGxlLCBWRGF0ZVBpY2tlckhlYWRlciwgVkRhdGVQaWNrZXJEYXRlVGFibGUsIFZEYXRlUGlja2VyTW9udGhUYWJsZSwgVkRhdGVQaWNrZXJZZWFycywgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkRhdGVQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkRhdGVQaWNrZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL1ZEYXRlUGlja2VyLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkRhdGVQaWNrZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGVQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZEYXRlUGlja2VyVGl0bGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkRhdGVQaWNrZXJUaXRsZSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvVkRhdGVQaWNrZXJUaXRsZS5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZEYXRlUGlja2VyVGl0bGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGVQaWNrZXJUaXRsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkRhdGVQaWNrZXJIZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkRhdGVQaWNrZXJIZWFkZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL1ZEYXRlUGlja2VySGVhZGVyLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkRhdGVQaWNrZXJIZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGVQaWNrZXJIZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZEYXRlUGlja2VyRGF0ZVRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZEYXRlUGlja2VyRGF0ZVRhYmxlICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci9WRGF0ZVBpY2tlckRhdGVUYWJsZS5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZEYXRlUGlja2VyRGF0ZVRhYmxlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZEYXRlUGlja2VyRGF0ZVRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WRGF0ZVBpY2tlck1vbnRoVGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkRhdGVQaWNrZXJNb250aFRhYmxlICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci9WRGF0ZVBpY2tlck1vbnRoVGFibGUuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRGF0ZVBpY2tlck1vbnRoVGFibGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGVQaWNrZXJNb250aFRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WRGF0ZVBpY2tlclllYXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZEYXRlUGlja2VyWWVhcnMgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL1ZEYXRlUGlja2VyWWVhcnMuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRGF0ZVBpY2tlclllYXJzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZEYXRlUGlja2VyWWVhcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgICRfdnVldGlmeV9zdWJjb21wb25lbnRzOiB7XG4gICAgICAgIFZEYXRlUGlja2VyOiBfVkRhdGVQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZEYXRlUGlja2VyVGl0bGU6IF9WRGF0ZVBpY2tlclRpdGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWRGF0ZVBpY2tlckhlYWRlcjogX1ZEYXRlUGlja2VySGVhZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWRGF0ZVBpY2tlckRhdGVUYWJsZTogX1ZEYXRlUGlja2VyRGF0ZVRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWRGF0ZVBpY2tlck1vbnRoVGFibGU6IF9WRGF0ZVBpY2tlck1vbnRoVGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZEYXRlUGlja2VyWWVhcnM6IF9WRGF0ZVBpY2tlclllYXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdXG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvbWl4aW5zL2RhdGUtcGlja2VyLXRhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvbWl4aW5zL2RhdGUtcGlja2VyLXRhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2RhdGVfcGlja2VyX3RhYmxlX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19kYXRlLXBpY2tlci10YWJsZS5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2RhdGUtcGlja2VyLXRhYmxlLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2RhdGVfcGlja2VyX3RhYmxlX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfZGF0ZV9waWNrZXJfdGFibGVfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlyZWN0aXZlc190b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4vZGlyZWN0aXZlcy90b3VjaCAqLyBcIi4vc3JjL2RpcmVjdGl2ZXMvdG91Y2gudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaXNEYXRlQWxsb3dlZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi91dGlsL2lzRGF0ZUFsbG93ZWQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL3V0aWwvaXNEYXRlQWxsb3dlZC5qc1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLy8gRGlyZWN0aXZlc1xuXG4vLyBVdGlsc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgZGlyZWN0aXZlczogeyBUb3VjaDogX2RpcmVjdGl2ZXNfdG91Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0gfSxcbiAgICBwcm9wczoge1xuICAgICAgICBhbGxvd2VkRGF0ZXM6IEZ1bmN0aW9uLFxuICAgICAgICBjdXJyZW50OiBTdHJpbmcsXG4gICAgICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBsb2NhbGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdlbi11cydcbiAgICAgICAgfSxcbiAgICAgICAgbWluOiBTdHJpbmcsXG4gICAgICAgIG1heDogU3RyaW5nLFxuICAgICAgICBzY3JvbGxhYmxlOiBCb29sZWFuLFxuICAgICAgICB0YWJsZURhdGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBbU3RyaW5nLCBBcnJheV1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1JldmVyc2luZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNvbXB1dGVkVHJhbnNpdGlvbjogZnVuY3Rpb24gY29tcHV0ZWRUcmFuc2l0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNSZXZlcnNpbmcgPT09ICF0aGlzLiR2dWV0aWZ5LnJ0bCA/ICd0YWItcmV2ZXJzZS10cmFuc2l0aW9uJyA6ICd0YWItdHJhbnNpdGlvbic7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXllZE1vbnRoOiBmdW5jdGlvbiBkaXNwbGF5ZWRNb250aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYmxlRGF0ZS5zcGxpdCgnLScpWzFdIC0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheWVkWWVhcjogZnVuY3Rpb24gZGlzcGxheWVkWWVhcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYmxlRGF0ZS5zcGxpdCgnLScpWzBdICogMTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgdGFibGVEYXRlOiBmdW5jdGlvbiB0YWJsZURhdGUobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZXZlcnNpbmcgPSBuZXdWYWwgPCBvbGRWYWw7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuQnV0dG9uQ2xhc3NlczogZnVuY3Rpb24gZ2VuQnV0dG9uQ2xhc3Nlcyhpc0FsbG93ZWQsIGlzRmxvYXRpbmcsIGlzU2VsZWN0ZWQsIGlzQ3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHsgJ3YtYnRuLS1hY3RpdmUnOiBpc1NlbGVjdGVkLCAndi1idG4tLWZsYXQnOiAhaXNTZWxlY3RlZCwgJ3YtYnRuLS1pY29uJzogaXNTZWxlY3RlZCAmJiBpc0FsbG93ZWQgJiYgaXNGbG9hdGluZywgJ3YtYnRuLS1mbG9hdGluZyc6IGlzRmxvYXRpbmcsICd2LWJ0bi0tZGVwcmVzc2VkJzogIWlzRmxvYXRpbmcgJiYgaXNTZWxlY3RlZCwgJ3YtYnRuLS1kaXNhYmxlZCc6ICFpc0FsbG93ZWQgfHwgdGhpcy5kaXNhYmxlZCAmJiBpc1NlbGVjdGVkLCAndi1idG4tLW91dGxpbmUnOiBpc0N1cnJlbnQgJiYgIWlzU2VsZWN0ZWQgfSwgdGhpcy50aGVtZUNsYXNzZXMpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5CdXR0b246IGZ1bmN0aW9uIGdlbkJ1dHRvbih2YWx1ZSwgaXNGbG9hdGluZykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSBPYmplY3QoX3V0aWxfaXNEYXRlQWxsb3dlZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSkodmFsdWUsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5hbGxvd2VkRGF0ZXMpO1xuICAgICAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSB2YWx1ZSA9PT0gdGhpcy52YWx1ZSB8fCBBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpICYmIHRoaXMudmFsdWUuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgICAgICAgdmFyIGlzQ3VycmVudCA9IHZhbHVlID09PSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgc2V0Q29sb3IgPSBpc1NlbGVjdGVkID8gdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IgOiB0aGlzLnNldFRleHRDb2xvcjtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IChpc1NlbGVjdGVkIHx8IGlzQ3VycmVudCkgJiYgKHRoaXMuY29sb3IgfHwgJ2FjY2VudCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicsIHNldENvbG9yKGNvbG9yLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWJ0bicsXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy5nZW5CdXR0b25DbGFzc2VzKGlzQWxsb3dlZCwgaXNGbG9hdGluZywgaXNTZWxlY3RlZCwgaXNDdXJyZW50KSxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnV0dG9uJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZG9tUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICFpc0FsbG93ZWQsXG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTDogXCI8ZGl2IGNsYXNzPVxcXCJ2LWJ0bl9fY29udGVudFxcXCI+XCIgKyB0aGlzLmZvcm1hdHRlcih2YWx1ZSkgKyBcIjwvZGl2PlwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjogdGhpcy5kaXNhYmxlZCB8fCAhaXNBbGxvd2VkID8ge30gOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kZW1pdCgnaW5wdXQnLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHdoZWVsOiBmdW5jdGlvbiB3aGVlbChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd0YWJsZURhdGUnLCB0aGlzLmNhbGN1bGF0ZVRhYmxlRGF0ZShlLmRlbHRhWSkpO1xuICAgICAgICB9LFxuICAgICAgICB0b3VjaDogZnVuY3Rpb24gdG91Y2godmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3RhYmxlRGF0ZScsIHRoaXMuY2FsY3VsYXRlVGFibGVEYXRlKHZhbHVlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblRhYmxlOiBmdW5jdGlvbiBnZW5UYWJsZShzdGF0aWNDbGFzcywgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RyYW5zaXRpb24nLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHsgbmFtZTogdGhpcy5jb21wdXRlZFRyYW5zaXRpb24gfVxuICAgICAgICAgICAgfSwgW3RoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RhYmxlJywgeyBrZXk6IHRoaXMudGFibGVEYXRlIH0sIGNoaWxkcmVuKV0pO1xuICAgICAgICAgICAgdmFyIHRvdWNoRGlyZWN0aXZlID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZnVuY3Rpb24gbGVmdChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5vZmZzZXRYIDwgLTE1ICYmIF90aGlzLnRvdWNoKDEpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZnVuY3Rpb24gcmlnaHQoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUub2Zmc2V0WCA+IDE1ICYmIF90aGlzLnRvdWNoKC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBzdGF0aWNDbGFzcyxcbiAgICAgICAgICAgICAgICBjbGFzczogdGhpcy50aGVtZUNsYXNzZXMsXG4gICAgICAgICAgICAgICAgb246IHRoaXMuc2Nyb2xsYWJsZSA/IHsgd2hlZWw6IHRoaXMud2hlZWwgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbdG91Y2hEaXJlY3RpdmVdXG4gICAgICAgICAgICB9LCBbdHJhbnNpdGlvbl0pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvdXRpbC9jcmVhdGVOYXRpdmVMb2NhbGVGb3JtYXR0ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL3V0aWwvY3JlYXRlTmF0aXZlTG9jYWxlRm9ybWF0dGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGFkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BhZCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvdXRpbC9wYWQuanNcIik7XG52YXIgX19yZWFkID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3JlYWQgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSxcbiAgICAgICAgcixcbiAgICAgICAgYXIgPSBbXSxcbiAgICAgICAgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlKSB0aHJvdyBlLmVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoZnVuY3Rpb24gKGxvY2FsZSwgb3B0aW9ucywgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8geyBzdGFydDogMCwgbGVuZ3RoOiAwIH0gOiBfYSxcbiAgICAgICAgc3RhcnQgPSBfYi5zdGFydCxcbiAgICAgICAgbGVuZ3RoID0gX2IubGVuZ3RoO1xuICAgIHZhciBtYWtlSXNvU3RyaW5nID0gZnVuY3Rpb24gbWFrZUlzb1N0cmluZyhkYXRlU3RyaW5nKSB7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChkYXRlU3RyaW5nLnRyaW0oKS5zcGxpdCgnICcpWzBdLnNwbGl0KCctJyksIDMpLFxuICAgICAgICAgICAgeWVhciA9IF9hWzBdLFxuICAgICAgICAgICAgbW9udGggPSBfYVsxXSxcbiAgICAgICAgICAgIGRhdGUgPSBfYVsyXTtcbiAgICAgICAgcmV0dXJuIFt5ZWFyLCBPYmplY3QoX3BhZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSkobW9udGggfHwgMSksIE9iamVjdChfcGFkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKShkYXRlIHx8IDEpXS5qb2luKCctJyk7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgaW50bEZvcm1hdHRlcl8xID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlIHx8IHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZVN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGludGxGb3JtYXR0ZXJfMS5mb3JtYXQobmV3IERhdGUobWFrZUlzb1N0cmluZyhkYXRlU3RyaW5nKSArIFwiVDAwOjAwOjAwKzAwOjAwXCIpKTtcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdGFydCB8fCBsZW5ndGggPyBmdW5jdGlvbiAoZGF0ZVN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc29TdHJpbmcoZGF0ZVN0cmluZykuc3Vic3RyKHN0YXJ0LCBsZW5ndGgpO1xuICAgICAgICB9IDogbnVsbDtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci91dGlsL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL3V0aWwvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGNyZWF0ZU5hdGl2ZUxvY2FsZUZvcm1hdHRlciwgbW9udGhDaGFuZ2UsIHBhZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3JlYXRlTmF0aXZlTG9jYWxlRm9ybWF0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NyZWF0ZU5hdGl2ZUxvY2FsZUZvcm1hdHRlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvdXRpbC9jcmVhdGVOYXRpdmVMb2NhbGVGb3JtYXR0ZXIuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjcmVhdGVOYXRpdmVMb2NhbGVGb3JtYXR0ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfY3JlYXRlTmF0aXZlTG9jYWxlRm9ybWF0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tb250aENoYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb250aENoYW5nZSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvdXRpbC9tb250aENoYW5nZS5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1vbnRoQ2hhbmdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX21vbnRoQ2hhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wYWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGFkICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci91dGlsL3BhZC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBhZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9wYWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci91dGlsL2lzRGF0ZUFsbG93ZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci91dGlsL2lzRGF0ZUFsbG93ZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNEYXRlQWxsb3dlZDsgfSk7XG5mdW5jdGlvbiBpc0RhdGVBbGxvd2VkKGRhdGUsIG1pbiwgbWF4LCBhbGxvd2VkRm4pIHtcbiAgICByZXR1cm4gKCFhbGxvd2VkRm4gfHwgYWxsb3dlZEZuKGRhdGUpKSAmJiAoIW1pbiB8fCBkYXRlID49IG1pbikgJiYgKCFtYXggfHwgZGF0ZSA8PSBtYXgpO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL3V0aWwvbW9udGhDaGFuZ2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvdXRpbC9tb250aENoYW5nZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGFkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BhZCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvdXRpbC9wYWQuanNcIik7XG52YXIgX19yZWFkID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3JlYWQgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSxcbiAgICAgICAgcixcbiAgICAgICAgYXIgPSBbXSxcbiAgICAgICAgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlKSB0aHJvdyBlLmVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFlZWVktTU0gZm9ybWF0XG4gKiBAcGFyYW0ge051bWJlcn0gc2lnbiAtMSBvciArMVxuICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGZ1bmN0aW9uICh2YWx1ZSwgc2lnbikge1xuICAgIHZhciBfYSA9IF9fcmVhZCh2YWx1ZS5zcGxpdCgnLScpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gMSAqIHY7XG4gICAgfSksIDIpLFxuICAgICAgICB5ZWFyID0gX2FbMF0sXG4gICAgICAgIG1vbnRoID0gX2FbMV07XG4gICAgaWYgKG1vbnRoICsgc2lnbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4geWVhciAtIDEgKyBcIi0xMlwiO1xuICAgIH0gZWxzZSBpZiAobW9udGggKyBzaWduID09PSAxMykge1xuICAgICAgICByZXR1cm4geWVhciArIDEgKyBcIi0wMVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB5ZWFyICsgXCItXCIgKyBPYmplY3QoX3BhZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSkobW9udGggKyBzaWduKTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci91dGlsL3BhZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkRhdGVQaWNrZXIvdXRpbC9wYWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xudmFyIHBhZFN0YXJ0ID0gZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLCB0YXJnZXRMZW5ndGgsIHBhZFN0cmluZykge1xuICAgIHRhcmdldExlbmd0aCA9IHRhcmdldExlbmd0aCA+PiAwO1xuICAgIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpO1xuICAgIHBhZFN0cmluZyA9IFN0cmluZyhwYWRTdHJpbmcpO1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKTtcbiAgICB9XG4gICAgdGFyZ2V0TGVuZ3RoID0gdGFyZ2V0TGVuZ3RoIC0gc3RyaW5nLmxlbmd0aDtcbiAgICBpZiAodGFyZ2V0TGVuZ3RoID4gcGFkU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICBwYWRTdHJpbmcgKz0gcGFkU3RyaW5nLnJlcGVhdCh0YXJnZXRMZW5ndGggLyBwYWRTdHJpbmcubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZFN0cmluZy5zbGljZSgwLCB0YXJnZXRMZW5ndGgpICsgU3RyaW5nKHN0cmluZyk7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAobiwgbGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxlbmd0aCA9IDI7XG4gICAgfVxuICAgIHJldHVybiBwYWRTdGFydChuLCBsZW5ndGgsICcwJyk7XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WRGlhbG9nL1ZEaWFsb2cuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WRGlhbG9nL1ZEaWFsb2cuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfZGlhbG9nc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fZGlhbG9ncy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2RpYWxvZ3Muc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfZGlhbG9nc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2RpYWxvZ3Nfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2RlcGVuZGVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2RlcGVuZGVudCAqLyBcIi4vc3JjL21peGlucy9kZXBlbmRlbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19kZXRhY2hhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvZGV0YWNoYWJsZSAqLyBcIi4vc3JjL21peGlucy9kZXRhY2hhYmxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfb3ZlcmxheWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9vdmVybGF5YWJsZSAqLyBcIi4vc3JjL21peGlucy9vdmVybGF5YWJsZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3JldHVybmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9yZXR1cm5hYmxlICovIFwiLi9zcmMvbWl4aW5zL3JldHVybmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19zdGFja2FibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9zdGFja2FibGUgKi8gXCIuL3NyYy9taXhpbnMvc3RhY2thYmxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdG9nZ2xlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RvZ2dsZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdG9nZ2xlYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlyZWN0aXZlc19jbGlja19vdXRzaWRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUgKi8gXCIuL3NyYy9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX1RoZW1lUHJvdmlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvVGhlbWVQcm92aWRlciAqLyBcIi4vc3JjL3V0aWwvVGhlbWVQcm92aWRlci50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLy8gTWl4aW5zXG5cblxuXG5cblxuXG4vLyBEaXJlY3RpdmVzXG5cbi8vIEhlbHBlcnNcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtZGlhbG9nJyxcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICAgIENsaWNrT3V0c2lkZTogX2RpcmVjdGl2ZXNfY2xpY2tfb3V0c2lkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXVxuICAgIH0sXG4gICAgbWl4aW5zOiBbX21peGluc19kZXBlbmRlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfZGV0YWNoYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwgX21peGluc19vdmVybGF5YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSwgX21peGluc19yZXR1cm5hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3N0YWNrYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSwgX21peGluc190b2dnbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0XCJdXSxcbiAgICBwcm9wczoge1xuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgcGVyc2lzdGVudDogQm9vbGVhbixcbiAgICAgICAgZnVsbHNjcmVlbjogQm9vbGVhbixcbiAgICAgICAgZnVsbFdpZHRoOiBCb29sZWFuLFxuICAgICAgICBub0NsaWNrQW5pbWF0aW9uOiBCb29sZWFuLFxuICAgICAgICBsaWdodDogQm9vbGVhbixcbiAgICAgICAgZGFyazogQm9vbGVhbixcbiAgICAgICAgbWF4V2lkdGg6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgICAgICBkZWZhdWx0OiAnbm9uZSdcbiAgICAgICAgfSxcbiAgICAgICAgb3JpZ2luOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnY2VudGVyIGNlbnRlcidcbiAgICAgICAgfSxcbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICAgICAgICBkZWZhdWx0OiAnYXV0bydcbiAgICAgICAgfSxcbiAgICAgICAgc2Nyb2xsYWJsZTogQm9vbGVhbixcbiAgICAgICAgdHJhbnNpdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQm9vbGVhbl0sXG4gICAgICAgICAgICBkZWZhdWx0OiAnZGlhbG9nLXRyYW5zaXRpb24nXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGFuaW1hdGVUaW1lb3V0OiBudWxsLFxuICAgICAgICAgICAgc3RhY2tDbGFzczogJ3YtZGlhbG9nX19jb250ZW50LS1hY3RpdmUnLFxuICAgICAgICAgICAgc3RhY2tNaW5aSW5kZXg6IDIwMFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBfYSA9IHt9LCBfYVsoXCJ2LWRpYWxvZyBcIiArIHRoaXMuY29udGVudENsYXNzKS50cmltKCldID0gdHJ1ZSwgX2FbJ3YtZGlhbG9nLS1hY3RpdmUnXSA9IHRoaXMuaXNBY3RpdmUsIF9hWyd2LWRpYWxvZy0tcGVyc2lzdGVudCddID0gdGhpcy5wZXJzaXN0ZW50LCBfYVsndi1kaWFsb2ctLWZ1bGxzY3JlZW4nXSA9IHRoaXMuZnVsbHNjcmVlbiwgX2FbJ3YtZGlhbG9nLS1zY3JvbGxhYmxlJ10gPSB0aGlzLnNjcm9sbGFibGUsIF9hWyd2LWRpYWxvZy0tYW5pbWF0ZWQnXSA9IHRoaXMuYW5pbWF0ZSwgX2E7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRDbGFzc2VzOiBmdW5jdGlvbiBjb250ZW50Q2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3YtZGlhbG9nX19jb250ZW50JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndi1kaWFsb2dfX2NvbnRlbnQtLWFjdGl2ZSc6IHRoaXMuaXNBY3RpdmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZSh2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVPdmVybGF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVsbHNjcmVlbjogZnVuY3Rpb24gZnVsbHNjcmVlbih2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHRoaXMuaGlkZVNjcm9sbCgpO2Vsc2UgdGhpcy5zaG93U2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMuaXNCb290ZWQgPSB0aGlzLmlzQWN0aXZlO1xuICAgICAgICB0aGlzLmlzQWN0aXZlICYmIHRoaXMuc2hvdygpO1xuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB0aGlzLnVuYmluZCgpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBhbmltYXRlQ2xpY2s6IGZ1bmN0aW9uIGFuaW1hdGVDbGljaygpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIE5lZWRlZCBmb3Igd2hlbiBjbGlja2luZyB2ZXJ5IGZhc3RcbiAgICAgICAgICAgIC8vIG91dHNpZGUgb2YgdGhlIGRpYWxvZ1xuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5hbmltYXRlVGltZW91dCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCAxNTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlQ29uZGl0aW9uYWw6IGZ1bmN0aW9uIGNsb3NlQ29uZGl0aW9uYWwoZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRpYWxvZyBjb250ZW50IGNvbnRhaW5zXG4gICAgICAgICAgICAvLyB0aGUgY2xpY2sgZXZlbnQsIG9yIGlmIHRoZVxuICAgICAgICAgICAgLy8gZGlhbG9nIGlzIG5vdCBhY3RpdmVcbiAgICAgICAgICAgIGlmICh0aGlzLiRyZWZzLmNvbnRlbnQuY29udGFpbnMoZS50YXJnZXQpIHx8ICF0aGlzLmlzQWN0aXZlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBJZiB3ZSBtYWRlIGl0IGhlcmUsIHRoZSBjbGljayBpcyBvdXRzaWRlXG4gICAgICAgICAgICAvLyBhbmQgaXMgYWN0aXZlLiBJZiBwZXJzaXN0ZW50LCBhbmQgdGhlXG4gICAgICAgICAgICAvLyBjbGljayBpcyBvbiB0aGUgb3ZlcmxheSwgYW5pbWF0ZVxuICAgICAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVudCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5ub0NsaWNrQW5pbWF0aW9uICYmIHRoaXMub3ZlcmxheSA9PT0gZS50YXJnZXQpIHRoaXMuYW5pbWF0ZUNsaWNrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xvc2UgZGlhbG9nIGlmICFwZXJzaXN0ZW50LCBjbGlja2VkIG91dHNpZGUgYW5kIHdlJ3JlIHRoZSB0b3Btb3N0IGRpYWxvZy5cbiAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGluIGEgY2FwdHVyZSBldmVudCAoYm90dG9tIHVwKSwgd2Ugc2hvdWxkbid0IG5lZWQgdG8gc3RvcCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJnZXRaSW5kZXhcIl0pKHRoaXMuJHJlZnMuY29udGVudCkgPj0gdGhpcy5nZXRNYXhaSW5kZXgoKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGlkZVNjcm9sbDogZnVuY3Rpb24gaGlkZVNjcm9sbCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnb3ZlcmZsb3cteS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX21peGluc19vdmVybGF5YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXS5tZXRob2RzLmhpZGVTY3JvbGwuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgICAgICF0aGlzLmZ1bGxzY3JlZW4gJiYgIXRoaXMuaGlkZU92ZXJsYXkgJiYgdGhpcy5nZW5PdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLmZ1bGxzY3JlZW4gJiYgdGhpcy5oaWRlU2Nyb2xsKCk7XG4gICAgICAgICAgICB0aGlzLiRyZWZzLmNvbnRlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMuJGxpc3RlbmVycy5rZXlkb3duICYmIHRoaXMuYmluZCgpO1xuICAgICAgICB9LFxuICAgICAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5ZG93bik7XG4gICAgICAgIH0sXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5ZG93bik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5ZG93bjogZnVuY3Rpb24gb25LZXlkb3duKGUpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2tleWRvd24nLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAnY2xhc3MnOiB0aGlzLmNsYXNzZXMsXG4gICAgICAgICAgICByZWY6ICdkaWFsb2cnLFxuICAgICAgICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2xpY2stb3V0c2lkZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VDb25kaXRpb25hbDogdGhpcy5jbG9zZUNvbmRpdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiB0aGlzLmdldE9wZW5EZXBlbmRlbnRFbGVtZW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHsgbmFtZTogJ3Nob3cnLCB2YWx1ZTogdGhpcy5pc0FjdGl2ZSB9XSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5mdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICBkYXRhLnN0eWxlID0ge1xuICAgICAgICAgICAgICAgIG1heFdpZHRoOiB0aGlzLm1heFdpZHRoID09PSAnbm9uZScgPyB1bmRlZmluZWQgOiBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiY29udmVydFRvVW5pdFwiXSkodGhpcy5tYXhXaWR0aCksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGggPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJjb252ZXJ0VG9Vbml0XCJdKSh0aGlzLndpZHRoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kc2xvdHMuYWN0aXZhdG9yKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGgoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtZGlhbG9nX19hY3RpdmF0b3InLFxuICAgICAgICAgICAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3YtZGlhbG9nX19hY3RpdmF0b3ItLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmRpc2FibGVkKSBfdGhpcy5pc0FjdGl2ZSA9ICFfdGhpcy5pc0FjdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFt0aGlzLiRzbG90cy5hY3RpdmF0b3JdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpYWxvZyA9IGgoJ2RpdicsIGRhdGEsIHRoaXMuc2hvd0xhenlDb250ZW50KHRoaXMuJHNsb3RzLmRlZmF1bHQpKTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgZGlhbG9nID0gaCgndHJhbnNpdGlvbicsIHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLnRyYW5zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogdGhpcy5vcmlnaW5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbZGlhbG9nXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChoKCdkaXYnLCB7XG4gICAgICAgICAgICAnY2xhc3MnOiB0aGlzLmNvbnRlbnRDbGFzc2VzLFxuICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduKHsgdGFiSW5kZXg6ICctMScgfSwgdGhpcy5nZXRTY29wZUlkQXR0cnMoKSksXG4gICAgICAgICAgICBzdHlsZTogeyB6SW5kZXg6IHRoaXMuYWN0aXZlWkluZGV4IH0sXG4gICAgICAgICAgICByZWY6ICdjb250ZW50J1xuICAgICAgICB9LCBbdGhpcy4kY3JlYXRlRWxlbWVudChfdXRpbF9UaGVtZVByb3ZpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgbGlnaHQ6IHRoaXMubGlnaHQsXG4gICAgICAgICAgICAgICAgZGFyazogdGhpcy5kYXJrXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtkaWFsb2ddKV0pKTtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1kaWFsb2dfX2NvbnRhaW5lcicsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICF0aGlzLiRzbG90cy5hY3RpdmF0b3IgfHwgdGhpcy5mdWxsV2lkdGggPyAnYmxvY2snIDogJ2lubGluZS1ibG9jaydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEaWFsb2cvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkRpYWxvZy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVkRpYWxvZywgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkRpYWxvZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WRGlhbG9nICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGlhbG9nL1ZEaWFsb2cuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRGlhbG9nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZEaWFsb2dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkRpYWxvZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRpdmlkZXIvVkRpdmlkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZEaXZpZGVyL1ZEaXZpZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfZGl2aWRlcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2RpdmlkZXJzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZGl2aWRlcnMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfZGl2aWRlcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19kaXZpZGVyc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbi8vIFN0eWxlc1xuXG4vLyBNaXhpbnNcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LWRpdmlkZXInLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGluc2V0OiBCb29sZWFuLFxuICAgICAgICB2ZXJ0aWNhbDogQm9vbGVhblxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICByZXR1cm4gaCgnaHInLCB7XG4gICAgICAgICAgICBjbGFzczogX19hc3NpZ24oeyAndi1kaXZpZGVyJzogdHJ1ZSwgJ3YtZGl2aWRlci0taW5zZXQnOiB0aGlzLmluc2V0LCAndi1kaXZpZGVyLS12ZXJ0aWNhbCc6IHRoaXMudmVydGljYWwgfSwgdGhpcy50aGVtZUNsYXNzZXMpLFxuICAgICAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzLFxuICAgICAgICAgICAgb246IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgICB9KTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRpdmlkZXIvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZEaXZpZGVyL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVkRpdmlkZXIsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZEaXZpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZEaXZpZGVyICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGl2aWRlci9WRGl2aWRlci50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZEaXZpZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZEaXZpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX1ZEaXZpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WRXhwYW5zaW9uUGFuZWwvVkV4cGFuc2lvblBhbmVsLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZFeHBhbnNpb25QYW5lbC9WRXhwYW5zaW9uUGFuZWwudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2V4cGFuc2lvbl9wYW5lbF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fZXhwYW5zaW9uLXBhbmVsLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZXhwYW5zaW9uLXBhbmVsLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2V4cGFuc2lvbl9wYW5lbF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2V4cGFuc2lvbl9wYW5lbF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3JlZ2lzdHJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvcmVnaXN0cmFibGUgKi8gXCIuL3NyYy9taXhpbnMvcmVnaXN0cmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL21peGlucyAqLyBcIi4vc3JjL3V0aWwvbWl4aW5zLnRzXCIpO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5cblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKShfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgT2JqZWN0KF9taXhpbnNfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInByb3ZpZGVcIl0pKCdleHBhbnNpb25QYW5lbCcpKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LWV4cGFuc2lvbi1wYW5lbCcsXG4gICAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cGFuc2lvblBhbmVsOiB0aGlzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgcmVhZG9ubHk6IEJvb2xlYW4sXG4gICAgICAgIGV4cGFuZDogQm9vbGVhbixcbiAgICAgICAgZm9jdXNhYmxlOiBCb29sZWFuLFxuICAgICAgICBpbnNldDogQm9vbGVhbixcbiAgICAgICAgcG9wb3V0OiBCb29sZWFuLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgQXJyYXldLFxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgICBvcGVuOiBbXVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7ICd2LWV4cGFuc2lvbi1wYW5lbC0tZm9jdXNhYmxlJzogdGhpcy5mb2N1c2FibGUsICd2LWV4cGFuc2lvbi1wYW5lbC0tcG9wb3V0JzogdGhpcy5wb3BvdXQsICd2LWV4cGFuc2lvbi1wYW5lbC0taW5zZXQnOiB0aGlzLmluc2V0IH0sIHRoaXMudGhlbWVDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiBleHBhbmQodikge1xuICAgICAgICAgICAgdmFyIG9wZW5JbmRleCA9IC0xO1xuICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgYWxsIHBhbmVscyB1bmxlc3Mgb25seSBvbmUgaXMgb3BlblxuICAgICAgICAgICAgICAgIHZhciBvcGVuQ291bnQgPSB0aGlzLm9wZW4ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsID8gYWNjICsgMSA6IGFjYztcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB2YXIgb3BlbiA9IEFycmF5KHRoaXMuaXRlbXMubGVuZ3RoKS5maWxsKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAob3BlbkNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5JbmRleCA9IHRoaXMub3Blbi5pbmRleE9mKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3BlbkluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbltvcGVuSW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdiA/IHRoaXMub3BlbiA6IG9wZW5JbmRleCA+IC0xID8gb3BlbkluZGV4IDogbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh2KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZyb21WYWx1ZSh2KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy52YWx1ZSAhPT0gbnVsbCAmJiB0aGlzLnVwZGF0ZUZyb21WYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdXBkYXRlRnJvbVZhbHVlOiBmdW5jdGlvbiB1cGRhdGVGcm9tVmFsdWUodikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikgJiYgIXRoaXMuZXhwYW5kKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgb3BlbiA9IEFycmF5KHRoaXMuaXRlbXMubGVuZ3RoKS5maWxsKGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBvcGVuW3ZdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wZW4gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVQYW5lbHMob3Blbik7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVBhbmVsczogZnVuY3Rpb24gdXBkYXRlUGFuZWxzKG9wZW4pIHtcbiAgICAgICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlID0gb3BlbiAmJiBvcGVuW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0udG9nZ2xlKGFjdGl2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhbmVsQ2xpY2s6IGZ1bmN0aW9uIHBhbmVsQ2xpY2sodWlkKSB7XG4gICAgICAgICAgICB2YXIgb3BlbiA9IHRoaXMuZXhwYW5kID8gdGhpcy5vcGVuLnNsaWNlKCkgOiBBcnJheSh0aGlzLml0ZW1zLmxlbmd0aCkuZmlsbChmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtc1tpXS5fdWlkID09PSB1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbltpXSA9ICF0aGlzLm9wZW5baV07XG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmV4cGFuZCAmJiB0aGlzLiRlbWl0KCdpbnB1dCcsIG9wZW5baV0gPyBpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVQYW5lbHMob3Blbik7XG4gICAgICAgICAgICBpZiAodGhpcy5leHBhbmQpIHRoaXMuJGVtaXQoJ2lucHV0Jywgb3Blbik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLm9wZW4ucHVzaChmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uIHVucmVnaXN0ZXIoY29udGVudCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pdGVtcy5maW5kSW5kZXgoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5fdWlkID09PSBjb250ZW50Ll91aWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMub3Blbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHJldHVybiBoKCd1bCcsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1leHBhbnNpb24tcGFuZWwnLFxuICAgICAgICAgICAgY2xhc3M6IHRoaXMuY2xhc3Nlc1xuICAgICAgICB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkV4cGFuc2lvblBhbmVsL1ZFeHBhbnNpb25QYW5lbENvbnRlbnQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZFeHBhbnNpb25QYW5lbC9WRXhwYW5zaW9uUGFuZWxDb250ZW50LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3RyYW5zaXRpb25zICovIFwiLi9zcmMvY29tcG9uZW50cy90cmFuc2l0aW9ucy9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2Jvb3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvYm9vdGFibGUgKi8gXCIuL3NyYy9taXhpbnMvYm9vdGFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190b2dnbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdG9nZ2xlYWJsZSAqLyBcIi4vc3JjL21peGlucy90b2dnbGVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcmlwcGxlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3JpcHBsZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvcmlwcGxlYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3JlZ2lzdHJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvcmVnaXN0cmFibGUgKi8gXCIuL3NyYy9taXhpbnMvcmVnaXN0cmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WSWNvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkljb24vaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL21peGlucyAqLyBcIi4vc3JjL3V0aWwvbWl4aW5zLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvY29uc29sZSAqLyBcIi4vc3JjL3V0aWwvY29uc29sZS50c1wiKTtcbnZhciBfX3JlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fcmVhZCB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgICByLFxuICAgICAgICBhciA9IFtdLFxuICAgICAgICBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19zcHJlYWQgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICB9cmV0dXJuIGFyO1xufTtcblxuXG5cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE9iamVjdChfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0pKF9taXhpbnNfYm9vdGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdG9nZ2xlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwgX21peGluc19yaXBwbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLCBPYmplY3QoX21peGluc19yZWdpc3RyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiaW5qZWN0XCJdKSgnZXhwYW5zaW9uUGFuZWwnLCAndi1leHBhbnNpb24tcGFuZWwtY29udGVudCcsICd2LWV4cGFuc2lvbi1wYW5lbCcpXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LWV4cGFuc2lvbi1wYW5lbC1jb250ZW50JyxcbiAgICBwcm9wczoge1xuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgcmVhZG9ubHk6IEJvb2xlYW4sXG4gICAgICAgIGV4cGFuZEljb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5leHBhbmQnXG4gICAgICAgIH0sXG4gICAgICAgIGhpZGVBY3Rpb25zOiBCb29sZWFuLFxuICAgICAgICByaXBwbGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtCb29sZWFuLCBPYmplY3RdLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogJ2F1dG8nXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjb250YWluZXJDbGFzc2VzOiBmdW5jdGlvbiBjb250YWluZXJDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndi1leHBhbnNpb24tcGFuZWxfX2NvbnRhaW5lci0tYWN0aXZlJzogdGhpcy5pc0FjdGl2ZSxcbiAgICAgICAgICAgICAgICAndi1leHBhbnNpb24tcGFuZWxfX2NvbnRhaW5lci0tZGlzYWJsZWQnOiB0aGlzLmlzRGlzYWJsZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGlzYWJsZWQ6IGZ1bmN0aW9uIGlzRGlzYWJsZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbnNpb25QYW5lbC5kaXNhYmxlZCB8fCB0aGlzLmRpc2FibGVkO1xuICAgICAgICB9LFxuICAgICAgICBpc1JlYWRvbmx5OiBmdW5jdGlvbiBpc1JlYWRvbmx5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5zaW9uUGFuZWwucmVhZG9ubHkgfHwgdGhpcy5yZWFkb25seTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5leHBhbnNpb25QYW5lbC5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgLy8gQ2FuIGJlIHJlbW92ZWQgb25jZSBmdWxseSBkZXByZWNhdGVkXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJjb25zb2xlV2FyblwiXSkoJ3YtbW9kZWwgaGFzIGJlZW4gZGVwcmVjYXRlZCcsIHRoaXMpO1xuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5leHBhbnNpb25QYW5lbC51bnJlZ2lzdGVyKHRoaXMpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBvbktleWRvd246IGZ1bmN0aW9uIG9uS2V5ZG93bihlKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgZWxlbWVudCBpcyB0aGUgYWN0aXZlRWxlbWVudFxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMgJiYgdGhpcy4kZWwgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHRoaXMuZXhwYW5zaW9uUGFuZWwucGFuZWxDbGljayh0aGlzLl91aWQpO1xuICAgICAgICB9LFxuICAgICAgICBvbkhlYWRlckNsaWNrOiBmdW5jdGlvbiBvbkhlYWRlckNsaWNrKCkge1xuICAgICAgICAgICAgdGhpcy5pc1JlYWRvbmx5IHx8IHRoaXMuZXhwYW5zaW9uUGFuZWwucGFuZWxDbGljayh0aGlzLl91aWQpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5Cb2R5OiBmdW5jdGlvbiBnZW5Cb2R5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICByZWY6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBjbGFzczogJ3YtZXhwYW5zaW9uLXBhbmVsX19ib2R5JyxcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2hvdycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmlzQWN0aXZlXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sIHRoaXMuc2hvd0xhenlDb250ZW50KHRoaXMuJHNsb3RzLmRlZmF1bHQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSGVhZGVyOiBmdW5jdGlvbiBnZW5IZWFkZXIoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBfX3NwcmVhZCh0aGlzLiRzbG90cy5oZWFkZXIpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhpZGVBY3Rpb25zKSBjaGlsZHJlbi5wdXNoKHRoaXMuZ2VuSWNvbigpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWV4cGFuc2lvbi1wYW5lbF9faGVhZGVyJyxcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAncmlwcGxlJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMucmlwcGxlXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IHRoaXMub25IZWFkZXJDbGlja1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSWNvbjogZnVuY3Rpb24gZ2VuSWNvbigpIHtcbiAgICAgICAgICAgIHZhciBpY29uID0gdGhpcy4kc2xvdHMuYWN0aW9ucyB8fCBbdGhpcy4kY3JlYXRlRWxlbWVudChfVkljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0sIHRoaXMuZXhwYW5kSWNvbildO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RyYW5zaXRpb24nLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgbmFtZTogJ2ZhZGUtdHJhbnNpdGlvbicgfVxuICAgICAgICAgICAgfSwgW3RoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtZXhwYW5zaW9uLXBhbmVsX19oZWFkZXJfX2ljb24nLFxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzaG93JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICF0aGlzLmlzRGlzYWJsZWRcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSwgaWNvbildKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoYWN0aXZlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZSkgdGhpcy5pc0Jvb3RlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBXZSB0cmVhdCBib290YWJsZSBkaWZmZXJlbnRseVxuICAgICAgICAgICAgLy8gTmVlZHMgdGltZSB0byBjYWxjIGhlaWdodFxuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc0FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLiRzbG90cy5oZWFkZXIgJiYgY2hpbGRyZW4ucHVzaCh0aGlzLmdlbkhlYWRlcigpKTtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChoKF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiVkV4cGFuZFRyYW5zaXRpb25cIl0sIFt0aGlzLmdlbkJvZHkoKV0pKTtcbiAgICAgICAgcmV0dXJuIGgoJ2xpJywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWV4cGFuc2lvbi1wYW5lbF9fY29udGFpbmVyJyxcbiAgICAgICAgICAgIGNsYXNzOiB0aGlzLmNvbnRhaW5lckNsYXNzZXMsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIHRhYmluZGV4OiB0aGlzLmlzUmVhZG9ubHkgfHwgdGhpcy5pc0Rpc2FibGVkID8gbnVsbCA6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGtleWRvd246IHRoaXMub25LZXlkb3duXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkV4cGFuc2lvblBhbmVsL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkV4cGFuc2lvblBhbmVsL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZFeHBhbnNpb25QYW5lbCwgVkV4cGFuc2lvblBhbmVsQ29udGVudCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkV4cGFuc2lvblBhbmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZFeHBhbnNpb25QYW5lbCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkV4cGFuc2lvblBhbmVsL1ZFeHBhbnNpb25QYW5lbC50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZFeHBhbnNpb25QYW5lbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WRXhwYW5zaW9uUGFuZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZFeHBhbnNpb25QYW5lbENvbnRlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkV4cGFuc2lvblBhbmVsQ29udGVudCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkV4cGFuc2lvblBhbmVsL1ZFeHBhbnNpb25QYW5lbENvbnRlbnQudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRXhwYW5zaW9uUGFuZWxDb250ZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZFeHBhbnNpb25QYW5lbENvbnRlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICAkX3Z1ZXRpZnlfc3ViY29tcG9uZW50czoge1xuICAgICAgICBWRXhwYW5zaW9uUGFuZWw6IF9WRXhwYW5zaW9uUGFuZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZFeHBhbnNpb25QYW5lbENvbnRlbnQ6IF9WRXhwYW5zaW9uUGFuZWxDb250ZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdXG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkZvb3Rlci9WRm9vdGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkZvb3Rlci9WRm9vdGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2Zvb3Rlcl9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fZm9vdGVyLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZm9vdGVyLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2Zvb3Rlcl9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2Zvb3Rlcl9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfYXBwbGljYXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvYXBwbGljYXRpb25hYmxlICovIFwiLi9zcmMvbWl4aW5zL2FwcGxpY2F0aW9uYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2NvbG9yYWJsZSAqLyBcIi4vc3JjL21peGlucy9jb2xvcmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuLy8gU3R5bGVzXG5cbi8vIE1peGluc1xuXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LWZvb3RlcicsXG4gICAgbWl4aW5zOiBbT2JqZWN0KF9taXhpbnNfYXBwbGljYXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKShudWxsLCBbJ2hlaWdodCcsICdpbnNldCddKSwgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdXSxcbiAgICBwcm9wczoge1xuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IDMyLFxuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXVxuICAgICAgICB9LFxuICAgICAgICBpbnNldDogQm9vbGVhblxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYXBwbGljYXRpb25Qcm9wZXJ0eTogZnVuY3Rpb24gYXBwbGljYXRpb25Qcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc2V0ID8gJ2luc2V0Rm9vdGVyJyA6ICdmb290ZXInO1xuICAgICAgICB9LFxuICAgICAgICBjb21wdXRlZE1hcmdpbkJvdHRvbTogZnVuY3Rpb24gY29tcHV0ZWRNYXJnaW5Cb3R0b20oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXBwKSByZXR1cm47XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kdnVldGlmeS5hcHBsaWNhdGlvbi5ib3R0b207XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkUGFkZGluZ0xlZnQ6IGZ1bmN0aW9uIGNvbXB1dGVkUGFkZGluZ0xlZnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuYXBwIHx8ICF0aGlzLmluc2V0ID8gMCA6IHRoaXMuJHZ1ZXRpZnkuYXBwbGljYXRpb24ubGVmdDtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWRQYWRkaW5nUmlnaHQ6IGZ1bmN0aW9uIGNvbXB1dGVkUGFkZGluZ1JpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmFwcCA/IDAgOiB0aGlzLiR2dWV0aWZ5LmFwcGxpY2F0aW9uLnJpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZXM6IGZ1bmN0aW9uIHN0eWxlcygpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpc05hTih0aGlzLmhlaWdodCkgPyB0aGlzLmhlaWdodCA6IHRoaXMuaGVpZ2h0ICsgXCJweFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcHV0ZWRQYWRkaW5nTGVmdCkge1xuICAgICAgICAgICAgICAgIHN0eWxlcy5wYWRkaW5nTGVmdCA9IHRoaXMuY29tcHV0ZWRQYWRkaW5nTGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXB1dGVkUGFkZGluZ1JpZ2h0KSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnBhZGRpbmdSaWdodCA9IHRoaXMuY29tcHV0ZWRQYWRkaW5nUmlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wdXRlZE1hcmdpbkJvdHRvbSkge1xuICAgICAgICAgICAgICAgIHN0eWxlcy5tYXJnaW5Cb3R0b20gPSB0aGlzLmNvbXB1dGVkTWFyZ2luQm90dG9tICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBhcHBsaWNhdGlvbiBsYXlvdXRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlQXBwbGljYXRpb246IGZ1bmN0aW9uIHVwZGF0ZUFwcGxpY2F0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlSW50KHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBpc05hTihoZWlnaHQpID8gdGhpcy4kZWwgPyB0aGlzLiRlbC5jbGllbnRIZWlnaHQgOiAwIDogaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5jb2xvciwge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWZvb3RlcicsXG4gICAgICAgICAgICAnY2xhc3MnOiBfX2Fzc2lnbih7ICd2LWZvb3Rlci0tYWJzb2x1dGUnOiB0aGlzLmFic29sdXRlLCAndi1mb290ZXItLWZpeGVkJzogIXRoaXMuYWJzb2x1dGUgJiYgKHRoaXMuYXBwIHx8IHRoaXMuZml4ZWQpLCAndi1mb290ZXItLWluc2V0JzogdGhpcy5pbnNldCB9LCB0aGlzLnRoZW1lQ2xhc3NlcyksXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICByZWY6ICdjb250ZW50J1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGgoJ2Zvb3RlcicsIGRhdGEsIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZGb290ZXIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkZvb3Rlci9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVkZvb3RlciwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkZvb3Rlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WRm9vdGVyICovIFwiLi9zcmMvY29tcG9uZW50cy9WRm9vdGVyL1ZGb290ZXIuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRm9vdGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZGb290ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkZvb3Rlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkZvcm0vVkZvcm0uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZGb3JtL1ZGb3JtLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfZm9ybXNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2Zvcm1zLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZm9ybXMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfZm9ybXNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19mb3Jtc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9yZWdpc3RyYWJsZSAqLyBcIi4vc3JjL21peGlucy9yZWdpc3RyYWJsZS50c1wiKTtcbi8vIFN0eWxlc1xuXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1mb3JtJyxcbiAgICBtaXhpbnM6IFtPYmplY3QoX21peGluc19yZWdpc3RyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wicHJvdmlkZVwiXSkoJ2Zvcm0nKV0sXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgICBwcm9wczoge1xuICAgICAgICB2YWx1ZTogQm9vbGVhbixcbiAgICAgICAgbGF6eVZhbGlkYXRpb246IEJvb2xlYW5cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICAgICAgd2F0Y2hlcnM6IFtdLFxuICAgICAgICAgICAgZXJyb3JCYWc6IHt9XG4gICAgICAgIH07XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBlcnJvckJhZzoge1xuICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gT2JqZWN0LnZhbHVlcyh0aGlzLmVycm9yQmFnKS5pbmNsdWRlcyh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsICFlcnJvcnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZXA6IHRydWUsXG4gICAgICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICB3YXRjaElucHV0OiBmdW5jdGlvbiB3YXRjaElucHV0KGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHdhdGNoZXIgPSBmdW5jdGlvbiB3YXRjaGVyKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LiR3YXRjaCgnaGFzRXJyb3InLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLiRzZXQoX3RoaXMuZXJyb3JCYWcsIGlucHV0Ll91aWQsIHZhbCk7XG4gICAgICAgICAgICAgICAgfSwgeyBpbW1lZGlhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHdhdGNoZXJzID0ge1xuICAgICAgICAgICAgICAgIF91aWQ6IGlucHV0Ll91aWQsXG4gICAgICAgICAgICAgICAgdmFsaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzaG91bGRWYWxpZGF0ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMubGF6eVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHN0YXJ0IHdhdGNoaW5nIGlucHV0cyBpZiB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgICAgd2F0Y2hlcnMuc2hvdWxkVmFsaWRhdGUgPSBpbnB1dC4kd2F0Y2goJ3Nob3VsZFZhbGlkYXRlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHdhdGNoIGlmIHdlJ3JlIG5vdCBhbHJlYWR5IGRvaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5lcnJvckJhZy5oYXNPd25Qcm9wZXJ0eShpbnB1dC5fdWlkKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB3YXRjaGVycy52YWxpZCA9IHdhdGNoZXIoaW5wdXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXRjaGVycy52YWxpZCA9IHdhdGNoZXIoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdhdGNoZXJzO1xuICAgICAgICB9LFxuICAgICAgICAvKiogQHB1YmxpYyAqL1xuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gdGhpcy5pbnB1dHMuZmlsdGVyKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaW5wdXQudmFsaWRhdGUodHJ1ZSk7XG4gICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gIWVycm9ycztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEBwdWJsaWMgKi9cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmlucHV0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0c1tpXS5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGF6eVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciB0aW1lb3V0IGluIHZhbGlkYXRhYmxlXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVycm9yQmFnID0ge307XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAcHVibGljICovXG4gICAgICAgIHJlc2V0VmFsaWRhdGlvbjogZnVuY3Rpb24gcmVzZXRWYWxpZGF0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmlucHV0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0c1tpXS5yZXNldFZhbGlkYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxhenlWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgdGltZW91dCBpbiB2YWxpZGF0YWJsZVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lcnJvckJhZyA9IHt9O1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB1bndhdGNoID0gdGhpcy53YXRjaElucHV0KGlucHV0KTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgdGhpcy53YXRjaGVycy5wdXNoKHVud2F0Y2gpO1xuICAgICAgICB9LFxuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbiB1bnJlZ2lzdGVyKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSB0aGlzLmlucHV0cy5maW5kKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuX3VpZCA9PT0gaW5wdXQuX3VpZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFmb3VuZCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHVud2F0Y2ggPSB0aGlzLndhdGNoZXJzLmZpbmQoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5fdWlkID09PSBmb3VuZC5fdWlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1bndhdGNoLnZhbGlkICYmIHVud2F0Y2gudmFsaWQoKTtcbiAgICAgICAgICAgIHVud2F0Y2guc2hvdWxkVmFsaWRhdGUgJiYgdW53YXRjaC5zaG91bGRWYWxpZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy53YXRjaGVycyA9IHRoaXMud2F0Y2hlcnMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkuX3VpZCAhPT0gZm91bmQuX3VpZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5pbnB1dHMgPSB0aGlzLmlucHV0cy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaS5fdWlkICE9PSBmb3VuZC5fdWlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5lcnJvckJhZywgZm91bmQuX3VpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGgoJ2Zvcm0nLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtZm9ybScsXG4gICAgICAgICAgICBhdHRyczogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgbm92YWxpZGF0ZTogdHJ1ZVxuICAgICAgICAgICAgfSwgdGhpcy4kYXR0cnMpLFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBzdWJtaXQ6IGZ1bmN0aW9uIHN1Ym1pdChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy4kZW1pdCgnc3VibWl0JywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WRm9ybS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkZvcm0vaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWRm9ybSwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkZvcm0gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZGb3JtL1ZGb3JtLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkZvcm1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZHcmlkL1ZDb250YWluZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkdyaWQvVkNvbnRhaW5lci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfZ3JpZF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fZ3JpZC5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2dyaWQuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfZ3JpZF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2dyaWRfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ3JpZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ncmlkICovIFwiLi9zcmMvY29tcG9uZW50cy9WR3JpZC9ncmlkLmpzXCIpO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoT2JqZWN0KF9ncmlkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKSgnY29udGFpbmVyJykpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZHcmlkL1ZDb250ZW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WR3JpZC9WQ29udGVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2NvbnRlbnRfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2NvbnRlbnQuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19jb250ZW50LnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2NvbnRlbnRfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19jb250ZW50X3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19zc3JfYm9vdGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9zc3ItYm9vdGFibGUgKi8gXCIuL3NyYy9taXhpbnMvc3NyLWJvb3RhYmxlLnRzXCIpO1xuLy8gU3R5bGVzXG5cbi8vIE1peGluc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtY29udGVudCcsXG4gICAgbWl4aW5zOiBbX21peGluc19zc3JfYm9vdGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIHRhZzoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ21haW4nXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHN0eWxlczogZnVuY3Rpb24gc3R5bGVzKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy4kdnVldGlmeS5hcHBsaWNhdGlvbixcbiAgICAgICAgICAgICAgICBiYXIgPSBfYS5iYXIsXG4gICAgICAgICAgICAgICAgdG9wID0gX2EudG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gX2EucmlnaHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyID0gX2EuZm9vdGVyLFxuICAgICAgICAgICAgICAgIGluc2V0Rm9vdGVyID0gX2EuaW5zZXRGb290ZXIsXG4gICAgICAgICAgICAgICAgYm90dG9tID0gX2EuYm90dG9tLFxuICAgICAgICAgICAgICAgIGxlZnQgPSBfYS5sZWZ0O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wOiB0b3AgKyBiYXIgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiByaWdodCArIFwicHhcIixcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiBmb290ZXIgKyBpbnNldEZvb3RlciArIGJvdHRvbSArIFwicHhcIixcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdDogbGVmdCArIFwicHhcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1jb250ZW50JyxcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlcyxcbiAgICAgICAgICAgIHJlZjogJ2NvbnRlbnQnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBoKHRoaXMudGFnLCBkYXRhLCBbaCgnZGl2JywgeyBzdGF0aWNDbGFzczogJ3YtY29udGVudF9fd3JhcCcgfSwgdGhpcy4kc2xvdHMuZGVmYXVsdCldKTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WR3JpZC9WRmxleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkdyaWQvVkZsZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19ncmlkX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19ncmlkLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZ3JpZC5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19ncmlkX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfZ3JpZF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ncmlkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dyaWQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZHcmlkL2dyaWQuanNcIik7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChPYmplY3QoX2dyaWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pKCdmbGV4JykpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZHcmlkL1ZMYXlvdXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkdyaWQvVkxheW91dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfZ3JpZF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fZ3JpZC5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2dyaWQuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfZ3JpZF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2dyaWRfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZ3JpZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ncmlkICovIFwiLi9zcmMvY29tcG9uZW50cy9WR3JpZC9ncmlkLmpzXCIpO1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoT2JqZWN0KF9ncmlkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKSgnbGF5b3V0JykpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZHcmlkL2dyaWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkdyaWQvZ3JpZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gR3JpZDsgfSk7XG5mdW5jdGlvbiBHcmlkKG5hbWUpIHtcbiAgICAvKiBAdnVlL2NvbXBvbmVudCAqL1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IFwidi1cIiArIG5hbWUsXG4gICAgICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBpZDogU3RyaW5nLFxuICAgICAgICAgICAgdGFnOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9hKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBfYS5wcm9wcyxcbiAgICAgICAgICAgICAgICBkYXRhID0gX2EuZGF0YSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgICAgICAgICAgZGF0YS5zdGF0aWNDbGFzcyA9IChuYW1lICsgXCIgXCIgKyAoZGF0YS5zdGF0aWNDbGFzcyB8fCAnJykpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmF0dHJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBPYmplY3Qua2V5cyhkYXRhLmF0dHJzKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgb25jZSByZXNvbHZlZFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL2lzc3Vlcy83ODQxXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdzbG90JykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLmF0dHJzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjbGFzc2VzLmxlbmd0aCkgZGF0YS5zdGF0aWNDbGFzcyArPSBcIiBcIiArIGNsYXNzZXMuam9pbignICcpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BzLmlkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5kb21Qcm9wcyA9IGRhdGEuZG9tUHJvcHMgfHwge307XG4gICAgICAgICAgICAgICAgZGF0YS5kb21Qcm9wcy5pZCA9IHByb3BzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGgocHJvcHMudGFnLCBkYXRhLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZHcmlkL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WR3JpZC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZDb250YWluZXIsIFZDb250ZW50LCBWRmxleCwgVkxheW91dCwgVlNwYWNlciwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU3BhY2VyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVlNwYWNlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQ29udGFpbmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZDb250YWluZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZHcmlkL1ZDb250YWluZXIuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQ29udGFpbmVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZDb250YWluZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZDb250ZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZDb250ZW50ICovIFwiLi9zcmMvY29tcG9uZW50cy9WR3JpZC9WQ29udGVudC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZDb250ZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZDb250ZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WRmxleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WRmxleCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkdyaWQvVkZsZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRmxleFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WRmxleF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkxheW91dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WTGF5b3V0ICovIFwiLi9zcmMvY29tcG9uZW50cy9WR3JpZC9WTGF5b3V0LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkxheW91dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WTGF5b3V0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cblxuXG5cbnZhciBWU3BhY2VyID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZUZ1bmN0aW9uYWxcIl0pKCdzcGFjZXInLCAnZGl2JywgJ3Ytc3BhY2VyJyk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgICRfdnVldGlmeV9zdWJjb21wb25lbnRzOiB7XG4gICAgICAgIFZDb250YWluZXI6IF9WQ29udGFpbmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWQ29udGVudDogX1ZDb250ZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWRmxleDogX1ZGbGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWTGF5b3V0OiBfVkxheW91dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgVlNwYWNlcjogVlNwYWNlclxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZIb3Zlci9WSG92ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkhvdmVyL1ZIb3Zlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2RlbGF5YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2RlbGF5YWJsZSAqLyBcIi4vc3JjL21peGlucy9kZWxheWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190b2dnbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdG9nZ2xlYWJsZSAqLyBcIi4vc3JjL21peGlucy90b2dnbGVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9taXhpbnMgKi8gXCIuL3NyYy91dGlsL21peGlucy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG4vLyBNaXhpbnNcblxuXG4vLyBVdGlsaXRpZXNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE9iamVjdChfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0pKF9taXhpbnNfZGVsYXlhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RvZ2dsZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl1cbi8qIEB2dWUvY29tcG9uZW50ICovXG4pLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtaG92ZXInLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnJ1bkRlbGF5KCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlTGVhdmU6IGZ1bmN0aW9uIG9uTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnJ1bkRlbGF5KCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQgJiYgdGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiY29uc29sZVdhcm5cIl0pKCd2LWhvdmVyIGlzIG1pc3NpbmcgYSBkZWZhdWx0IHNjb3BlZFNsb3Qgb3IgYm91bmQgdmFsdWUnLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50O1xuICAgICAgICBpZiAodGhpcy4kc2NvcGVkU2xvdHMuZGVmYXVsdCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQoeyBob3ZlcjogdGhpcy5pc0FjdGl2ZSB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLiRzbG90cy5kZWZhdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuJHNsb3RzLmRlZmF1bHRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbGVtZW50IHx8IHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiY29uc29sZVdhcm5cIl0pKCd2LWhvdmVyIHNob3VsZCBvbmx5IGNvbnRhaW4gYSBzaW5nbGUgZWxlbWVudCcsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9nKGVsZW1lbnQuZGF0YSwge1xuICAgICAgICAgICAgICAgIG1vdXNlZW50ZXI6IHRoaXMub25Nb3VzZUVudGVyLFxuICAgICAgICAgICAgICAgIG1vdXNlbGVhdmU6IHRoaXMub25Nb3VzZUxlYXZlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkhvdmVyL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkhvdmVyL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZIb3ZlciwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkhvdmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZIb3ZlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkhvdmVyL1ZIb3Zlci50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZIb3ZlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WSG92ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkhvdmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WSWNvbi9WSWNvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkljb24vVkljb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19pY29uc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9faWNvbnMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19pY29ucy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19pY29uc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2ljb25zX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfc2l6ZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9zaXplYWJsZSAqLyBcIi4vc3JjL21peGlucy9zaXplYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RoZW1lYWJsZSAqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFwidnVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8vIE1peGluc1xuXG5cblxuLy8gVXRpbFxuXG4vLyBUeXBlc1xuXG5cbnZhciBTSVpFX01BUDtcbihmdW5jdGlvbiAoU0laRV9NQVApIHtcbiAgICBTSVpFX01BUFtcInNtYWxsXCJdID0gXCIxNnB4XCI7XG4gICAgU0laRV9NQVBbXCJkZWZhdWx0XCJdID0gXCIyNHB4XCI7XG4gICAgU0laRV9NQVBbXCJtZWRpdW1cIl0gPSBcIjI4cHhcIjtcbiAgICBTSVpFX01BUFtcImxhcmdlXCJdID0gXCIzNnB4XCI7XG4gICAgU0laRV9NQVBbXCJ4TGFyZ2VcIl0gPSBcIjQwcHhcIjtcbn0pKFNJWkVfTUFQIHx8IChTSVpFX01BUCA9IHt9KSk7XG5mdW5jdGlvbiBpc0ZvbnRBd2Vzb21lNShpY29uVHlwZSkge1xuICAgIHJldHVybiBbJ2ZhcycsICdmYXInLCAnZmFsJywgJ2ZhYiddLnNvbWUoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gaWNvblR5cGUuaW5jbHVkZXModmFsKTtcbiAgICB9KTtcbn1cbnZhciBWSWNvbiA9IE9iamVjdChfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0pKF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3NpemVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXVxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbikuZXh0ZW5kKHtcbiAgICBuYW1lOiAndi1pY29uJyxcbiAgICBwcm9wczoge1xuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgbGVmdDogQm9vbGVhbixcbiAgICAgICAgcmlnaHQ6IEJvb2xlYW5cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgc2l6ZXMgPSB7XG4gICAgICAgICAgICBzbWFsbDogdGhpcy5zbWFsbCxcbiAgICAgICAgICAgIG1lZGl1bTogdGhpcy5tZWRpdW0sXG4gICAgICAgICAgICBsYXJnZTogdGhpcy5sYXJnZSxcbiAgICAgICAgICAgIHhMYXJnZTogdGhpcy54TGFyZ2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGV4cGxpY2l0U2l6ZSA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJrZXlzXCJdKShzaXplcykuZmluZChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZXNba2V5XSAmJiAhIWtleTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IGV4cGxpY2l0U2l6ZSAmJiBTSVpFX01BUFtleHBsaWNpdFNpemVdIHx8IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJjb252ZXJ0VG9Vbml0XCJdKSh0aGlzLnNpemUpO1xuICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtaWNvbicsXG4gICAgICAgICAgICBhdHRyczogX19hc3NpZ24oeyAnYXJpYS1oaWRkZW4nOiB0cnVlIH0sIHRoaXMuJGF0dHJzKSxcbiAgICAgICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZvbnRTaXplKSBkYXRhLnN0eWxlID0geyBmb250U2l6ZTogZm9udFNpemUgfTtcbiAgICAgICAgdmFyIGljb25OYW1lID0gJyc7XG4gICAgICAgIGlmICh0aGlzLiRzbG90cy5kZWZhdWx0KSBpY29uTmFtZSA9IHRoaXMuJHNsb3RzLmRlZmF1bHRbMF0udGV4dDtcbiAgICAgICAgLy8gUmVtYXAgaW50ZXJuYWwgbmFtZXMgbGlrZSAnJHZ1ZXRpZnkuaWNvbnMuY2FuY2VsJyB0byB0aGUgY3VycmVudCBuYW1lIGZvciB0aGF0IGljb25cbiAgICAgICAgaWNvbk5hbWUgPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wicmVtYXBJbnRlcm5hbEljb25cIl0pKHRoaXMsIGljb25OYW1lKTtcbiAgICAgICAgdmFyIGljb25UeXBlID0gJ21hdGVyaWFsLWljb25zJztcbiAgICAgICAgLy8gTWF0ZXJpYWwgSWNvbiBkZWxpbWl0ZXIgaXMgX1xuICAgICAgICAvLyBodHRwczovL21hdGVyaWFsLmlvL2ljb25zL1xuICAgICAgICB2YXIgZGVsaW1pdGVySW5kZXggPSBpY29uTmFtZS5pbmRleE9mKCctJyk7XG4gICAgICAgIHZhciBpc0N1c3RvbUljb24gPSBkZWxpbWl0ZXJJbmRleCA+IC0xO1xuICAgICAgICBpZiAoaXNDdXN0b21JY29uKSB7XG4gICAgICAgICAgICBpY29uVHlwZSA9IGljb25OYW1lLnNsaWNlKDAsIGRlbGltaXRlckluZGV4KTtcbiAgICAgICAgICAgIGlmIChpc0ZvbnRBd2Vzb21lNShpY29uVHlwZSkpIGljb25UeXBlID0gJyc7XG4gICAgICAgICAgICAvLyBBc3N1bWUgaWYgbm90IGEgY3VzdG9tIGljb25cbiAgICAgICAgICAgIC8vIGlzIE1hdGVyaWFsIEljb24gZm9udFxuICAgICAgICB9IGVsc2UgbmV3Q2hpbGRyZW4ucHVzaChpY29uTmFtZSk7XG4gICAgICAgIGRhdGEuY2xhc3MgPSBfX2Fzc2lnbigoX2EgPSB7ICd2LWljb24tLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCwgJ3YtaWNvbi0tbGVmdCc6IHRoaXMubGVmdCwgJ3YtaWNvbi0tbGluayc6IHRoaXMuJGxpc3RlbmVycy5jbGljayB8fCB0aGlzLiRsaXN0ZW5lcnNbJyFjbGljayddLCAndi1pY29uLS1yaWdodCc6IHRoaXMucmlnaHQgfSwgX2FbaWNvblR5cGVdID0gdHJ1ZSwgX2FbaWNvbk5hbWVdID0gaXNDdXN0b21JY29uLCBfYSksIHRoaXMudGhlbWVDbGFzc2VzKTtcbiAgICAgICAgcmV0dXJuIGgoJ2knLCB0aGlzLnNldFRleHRDb2xvcih0aGlzLmNvbG9yLCBkYXRhKSwgbmV3Q2hpbGRyZW4pO1xuICAgIH1cbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0LmEuZXh0ZW5kKHtcbiAgICBuYW1lOiAndi1pY29uJyxcbiAgICAkX3dyYXBwZXJGb3I6IFZJY29uLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX2EpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfYS5kYXRhLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICAgICAgdmFyIGljb25OYW1lID0gJyc7XG4gICAgICAgIC8vIFN1cHBvcnQgdXNhZ2Ugb2Ygdi10ZXh0IGFuZCB2LWh0bWxcbiAgICAgICAgaWYgKGRhdGEuZG9tUHJvcHMpIHtcbiAgICAgICAgICAgIGljb25OYW1lID0gZGF0YS5kb21Qcm9wcy50ZXh0Q29udGVudCB8fCBkYXRhLmRvbVByb3BzLmlubmVySFRNTCB8fCBpY29uTmFtZTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBub2RlcyBzbyBpdCBkb2Vzbid0XG4gICAgICAgICAgICAvLyBvdmVyd3JpdGUgb3VyIGNoYW5nZXNcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmRvbVByb3BzLnRleHRDb250ZW50O1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEuZG9tUHJvcHMuaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoKFZJY29uLCBkYXRhLCBpY29uTmFtZSA/IFtpY29uTmFtZV0gOiBjaGlsZHJlbik7XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJY29uL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WSWNvbi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZJY29uLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WSWNvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkljb24vVkljb24udHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWSWNvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkltZy9WSW1nLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkltZy9WSW1nLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2ltYWdlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9faW1hZ2VzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9faW1hZ2VzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2ltYWdlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2ltYWdlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WUmVzcG9uc2l2ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVlJlc3BvbnNpdmUgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZSZXNwb25zaXZlL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvY29uc29sZSAqLyBcIi4vc3JjL3V0aWwvY29uc29sZS50c1wiKTtcblxuLy8gQ29tcG9uZW50c1xuXG4vLyBVdGlsc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVlJlc3BvbnNpdmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uZXh0ZW5kKHtcbiAgICBuYW1lOiAndi1pbWcnLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFsdDogU3RyaW5nLFxuICAgICAgICBjb250YWluOiBCb29sZWFuLFxuICAgICAgICBzcmM6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgICB9LFxuICAgICAgICBncmFkaWVudDogU3RyaW5nLFxuICAgICAgICBsYXp5U3JjOiBTdHJpbmcsXG4gICAgICAgIHNyY3NldDogU3RyaW5nLFxuICAgICAgICBzaXplczogU3RyaW5nLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2NlbnRlciBjZW50ZXInXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2ZhZGUtdHJhbnNpdGlvbidcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnRTcmM6ICcnLFxuICAgICAgICAgICAgaW1hZ2U6IG51bGwsXG4gICAgICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICBjYWxjdWxhdGVkQXNwZWN0UmF0aW86IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29tcHV0ZWRBc3BlY3RSYXRpbzogZnVuY3Rpb24gY29tcHV0ZWRBc3BlY3RSYXRpbygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGlzZWRTcmMuYXNwZWN0O1xuICAgICAgICB9LFxuICAgICAgICBub3JtYWxpc2VkU3JjOiBmdW5jdGlvbiBub3JtYWxpc2VkU3JjKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLnNyYyA9PT0gJ3N0cmluZycgPyB7XG4gICAgICAgICAgICAgICAgc3JjOiB0aGlzLnNyYyxcbiAgICAgICAgICAgICAgICBzcmNzZXQ6IHRoaXMuc3Jjc2V0LFxuICAgICAgICAgICAgICAgIGxhenlTcmM6IHRoaXMubGF6eVNyYyxcbiAgICAgICAgICAgICAgICBhc3BlY3Q6IE51bWJlcih0aGlzLmFzcGVjdFJhdGlvIHx8IHRoaXMuY2FsY3VsYXRlZEFzcGVjdFJhdGlvKVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBzcmM6IHRoaXMuc3JjLnNyYyxcbiAgICAgICAgICAgICAgICBzcmNzZXQ6IHRoaXMuc3Jjc2V0IHx8IHRoaXMuc3JjLnNyY3NldCxcbiAgICAgICAgICAgICAgICBsYXp5U3JjOiB0aGlzLmxhenlTcmMgfHwgdGhpcy5zcmMubGF6eVNyYyxcbiAgICAgICAgICAgICAgICBhc3BlY3Q6IE51bWJlcih0aGlzLmFzcGVjdFJhdGlvIHx8IHRoaXMuc3JjLmFzcGVjdCB8fCB0aGlzLmNhbGN1bGF0ZWRBc3BlY3RSYXRpbylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIF9fY2FjaGVkSW1hZ2U6IGZ1bmN0aW9uIF9fY2FjaGVkSW1hZ2UoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLm5vcm1hbGlzZWRTcmMuc3JjIHx8IHRoaXMubm9ybWFsaXNlZFNyYy5sYXp5U3JjKSkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgdmFyIGJhY2tncm91bmRJbWFnZSA9IFtdO1xuICAgICAgICAgICAgdmFyIHNyYyA9IHRoaXMuaXNMb2FkaW5nID8gdGhpcy5ub3JtYWxpc2VkU3JjLmxhenlTcmMgOiB0aGlzLmN1cnJlbnRTcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5ncmFkaWVudCkgYmFja2dyb3VuZEltYWdlLnB1c2goXCJsaW5lYXItZ3JhZGllbnQoXCIgKyB0aGlzLmdyYWRpZW50ICsgXCIpXCIpO1xuICAgICAgICAgICAgaWYgKHNyYykgYmFja2dyb3VuZEltYWdlLnB1c2goXCJ1cmwoXFxcIlwiICsgc3JjICsgXCJcXFwiKVwiKTtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtaW1hZ2VfX2ltYWdlJyxcbiAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAndi1pbWFnZV9faW1hZ2UtLXByZWxvYWQnOiB0aGlzLmlzTG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgJ3YtaW1hZ2VfX2ltYWdlLS1jb250YWluJzogdGhpcy5jb250YWluLFxuICAgICAgICAgICAgICAgICAgICAndi1pbWFnZV9faW1hZ2UtLWNvdmVyJzogIXRoaXMuY29udGFpblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiBiYWNrZ3JvdW5kSW1hZ2Uuam9pbignLCAnKSxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBrZXk6ICt0aGlzLmlzTG9hZGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhbnNpdGlvbikgcmV0dXJuIGltYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RyYW5zaXRpb24nLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy50cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiAnaW4tb3V0J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtpbWFnZV0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBzcmM6IGZ1bmN0aW9uIHNyYygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0xvYWRpbmcpIHRoaXMuaW5pdCgpO2Vsc2UgdGhpcy5sb2FkSW1hZ2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgJyR2dWV0aWZ5LmJyZWFrcG9pbnQud2lkdGgnOiAnZ2V0U3JjJ1xuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub3JtYWxpc2VkU3JjLmxhenlTcmMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF6eUltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgIGxhenlJbWcuc3JjID0gdGhpcy5ub3JtYWxpc2VkU3JjLmxhenlTcmM7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2xsRm9yU2l6ZShsYXp5SW1nLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodGhpcy5ub3JtYWxpc2VkU3JjLnNyYykgdGhpcy5sb2FkSW1hZ2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Mb2FkOiBmdW5jdGlvbiBvbkxvYWQoKSB7XG4gICAgICAgICAgICB0aGlzLmdldFNyYygpO1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2xvYWQnLCB0aGlzLnNyYyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIG9uRXJyb3IoKSB7XG4gICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiY29uc29sZUVycm9yXCJdKShcIkltYWdlIGxvYWQgZmFpbGVkXFxuXFxuXCIgKyAoXCJzcmM6IFwiICsgdGhpcy5ub3JtYWxpc2VkU3JjLnNyYyksIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZXJyb3InLCB0aGlzLnNyYyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNyYzogZnVuY3Rpb24gZ2V0U3JjKCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmltYWdlKSB0aGlzLmN1cnJlbnRTcmMgPSB0aGlzLmltYWdlLmN1cnJlbnRTcmMgfHwgdGhpcy5pbWFnZS5zcmM7XG4gICAgICAgIH0sXG4gICAgICAgIGxvYWRJbWFnZTogZnVuY3Rpb24gbG9hZEltYWdlKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZS5kZWNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UuZGVjb2RlKCkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImNvbnNvbGVXYXJuXCJdKShcIkZhaWxlZCB0byBkZWNvZGUgaW1hZ2UsIHRyeWluZyB0byByZW5kZXIgYW55d2F5XFxuXFxuXCIgKyAoXCJzcmM6IFwiICsgX3RoaXMubm9ybWFsaXNlZFNyYy5zcmMpICsgKGVyci5tZXNzYWdlID8gXCJcXG5PcmlnaW5hbCBlcnJvcjogXCIgKyBlcnIubWVzc2FnZSA6ICcnKSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKF90aGlzLm9uTG9hZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25Mb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlLm9uZXJyb3IgPSB0aGlzLm9uRXJyb3I7XG4gICAgICAgICAgICBpbWFnZS5zcmMgPSB0aGlzLm5vcm1hbGlzZWRTcmMuc3JjO1xuICAgICAgICAgICAgdGhpcy5zaXplcyAmJiAoaW1hZ2Uuc2l6ZXMgPSB0aGlzLnNpemVzKTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXNlZFNyYy5zcmNzZXQgJiYgKGltYWdlLnNyY3NldCA9IHRoaXMubm9ybWFsaXNlZFNyYy5zcmNzZXQpO1xuICAgICAgICAgICAgdGhpcy5hc3BlY3RSYXRpbyB8fCB0aGlzLnBvbGxGb3JTaXplKGltYWdlKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3JjKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbGxGb3JTaXplOiBmdW5jdGlvbiBwb2xsRm9yU2l6ZShpbWcsIHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb2xsID0gZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmF0dXJhbEhlaWdodCA9IGltZy5uYXR1cmFsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBuYXR1cmFsV2lkdGggPSBpbWcubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChuYXR1cmFsSGVpZ2h0IHx8IG5hdHVyYWxXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYWxjdWxhdGVkQXNwZWN0UmF0aW8gPSBuYXR1cmFsV2lkdGggLyBuYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgIT0gbnVsbCAmJiBzZXRUaW1lb3V0KHBvbGwsIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb2xsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIF9fZ2VuUGxhY2Vob2xkZXI6IGZ1bmN0aW9uIF9fZ2VuUGxhY2Vob2xkZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2xvdHMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSB0aGlzLmlzTG9hZGluZyA/IFt0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1pbWFnZV9fcGxhY2Vob2xkZXInXG4gICAgICAgICAgICAgICAgfSwgdGhpcy4kc2xvdHMucGxhY2Vob2xkZXIpXSA6IFtdO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50cmFuc2l0aW9uKSByZXR1cm4gcGxhY2Vob2xkZXJbMF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RyYW5zaXRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IG5hbWU6IHRoaXMudHJhbnNpdGlvbiB9XG4gICAgICAgICAgICAgICAgfSwgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBub2RlID0gX1ZSZXNwb25zaXZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLm9wdGlvbnMucmVuZGVyLmNhbGwodGhpcywgaCk7XG4gICAgICAgIG5vZGUuZGF0YS5zdGF0aWNDbGFzcyArPSAnIHYtaW1hZ2UnO1xuICAgICAgICBub2RlLmRhdGEuYXR0cnMgPSB7XG4gICAgICAgICAgICByb2xlOiB0aGlzLmFsdCA/ICdpbWcnIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLmFsdFxuICAgICAgICB9O1xuICAgICAgICBub2RlLmNoaWxkcmVuID0gW3RoaXMuX19jYWNoZWRTaXplciwgdGhpcy5fX2NhY2hlZEltYWdlLCB0aGlzLl9fZ2VuUGxhY2Vob2xkZXIoKSwgdGhpcy5nZW5Db250ZW50KCldO1xuICAgICAgICByZXR1cm4gaChub2RlLnRhZywgbm9kZS5kYXRhLCBub2RlLmNoaWxkcmVuKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkltZy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WSW1nL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWSW1nLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WSW1nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZJbWcgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJbWcvVkltZy50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZJbWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkltZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WSW1nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WSW5wdXQvVklucHV0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZJbnB1dC9WSW5wdXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2lucHV0c19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9faW5wdXRzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9faW5wdXRzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX2lucHV0c19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2lucHV0c19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVkljb24gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJY29uL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WTGFiZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZMYWJlbCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkxhYmVsL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WTWVzc2FnZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZNZXNzYWdlcyAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk1lc3NhZ2VzL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RoZW1lYWJsZSAqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc192YWxpZGF0YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3ZhbGlkYXRhYmxlICovIFwiLi9zcmMvbWl4aW5zL3ZhbGlkYXRhYmxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBTdHlsZXNcblxuLy8gQ29tcG9uZW50c1xuXG5cblxuLy8gTWl4aW5zXG5cblxuXG4vLyBVdGlsaXRpZXNcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtaW5wdXQnLFxuICAgIG1peGluczogW19taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSwgX21peGluc192YWxpZGF0YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYXBwZW5kSWNvbjogU3RyaW5nLFxuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgYXBwZW5kSWNvbkNiOiBGdW5jdGlvbixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIGhpZGVEZXRhaWxzOiBCb29sZWFuLFxuICAgICAgICBoaW50OiBTdHJpbmcsXG4gICAgICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgICAgIHBlcnNpc3RlbnRIaW50OiBCb29sZWFuLFxuICAgICAgICBwcmVwZW5kSWNvbjogU3RyaW5nLFxuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgcHJlcGVuZEljb25DYjogRnVuY3Rpb24sXG4gICAgICAgIHZhbHVlOiB7IHJlcXVpcmVkOiBmYWxzZSB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKHZtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXp5VmFsdWU6IHZtLnZhbHVlLFxuICAgICAgICAgICAgaGFzTW91c2VEb3duOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3Nlc0lucHV0OiBmdW5jdGlvbiBjbGFzc2VzSW5wdXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oe30sIHRoaXMuY2xhc3NlcywgeyAndi1pbnB1dC0taGFzLXN0YXRlJzogdGhpcy5oYXNTdGF0ZSwgJ3YtaW5wdXQtLWhpZGUtZGV0YWlscyc6IHRoaXMuaGlkZURldGFpbHMsICd2LWlucHV0LS1pcy1sYWJlbC1hY3RpdmUnOiB0aGlzLmlzTGFiZWxBY3RpdmUsICd2LWlucHV0LS1pcy1kaXJ0eSc6IHRoaXMuaXNEaXJ0eSwgJ3YtaW5wdXQtLWlzLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCwgJ3YtaW5wdXQtLWlzLWZvY3VzZWQnOiB0aGlzLmlzRm9jdXNlZCwgJ3YtaW5wdXQtLWlzLWxvYWRpbmcnOiB0aGlzLmxvYWRpbmcgIT09IGZhbHNlICYmIHRoaXMubG9hZGluZyAhPT0gdW5kZWZpbmVkLCAndi1pbnB1dC0taXMtcmVhZG9ubHknOiB0aGlzLnJlYWRvbmx5IH0sIHRoaXMudGhlbWVDbGFzc2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlyZWN0aXZlc0lucHV0OiBmdW5jdGlvbiBkaXJlY3RpdmVzSW5wdXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0hpbnQ6IGZ1bmN0aW9uIGhhc0hpbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuaGFzTWVzc2FnZXMgJiYgdGhpcy5oaW50ICYmICh0aGlzLnBlcnNpc3RlbnRIaW50IHx8IHRoaXMuaXNGb2N1c2VkKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzTGFiZWw6IGZ1bmN0aW9uIGhhc0xhYmVsKCkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy4kc2xvdHMubGFiZWwgfHwgdGhpcy5sYWJlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFByb3h5IGZvciBgbGF6eVZhbHVlYFxuICAgICAgICAvLyBUaGlzIGFsbG93cyBhbiBpbnB1dFxuICAgICAgICAvLyB0byBmdW5jdGlvbiB3aXRob3V0XG4gICAgICAgIC8vIGEgcHJvdmlkZWQgbW9kZWxcbiAgICAgICAgaW50ZXJuYWxWYWx1ZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF6eVZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF6eVZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQodGhpcy4kX21vZGVsRXZlbnQsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGlydHk6IGZ1bmN0aW9uIGlzRGlydHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmxhenlWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNEaXNhYmxlZDogZnVuY3Rpb24gaXNEaXNhYmxlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzTGFiZWxBY3RpdmU6IGZ1bmN0aW9uIGlzTGFiZWxBY3RpdmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0RpcnR5O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUodmFsKSB7XG4gICAgICAgICAgICB0aGlzLmxhenlWYWx1ZSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiBiZWZvcmVDcmVhdGUoKSB7XG4gICAgICAgIC8vIHYtcmFkaW8tZ3JvdXAgbmVlZHMgdG8gZW1pdCBhIGRpZmZlcmVudCBldmVudFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVldGlmeWpzL3Z1ZXRpZnkvaXNzdWVzLzQ3NTJcbiAgICAgICAgdGhpcy4kX21vZGVsRXZlbnQgPSB0aGlzLiRvcHRpb25zLm1vZGVsICYmIHRoaXMuJG9wdGlvbnMubW9kZWwuZXZlbnQgfHwgJ2lucHV0JztcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuQ29udGVudDogZnVuY3Rpb24gZ2VuQ29udGVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5nZW5QcmVwZW5kU2xvdCgpLCB0aGlzLmdlbkNvbnRyb2woKSwgdGhpcy5nZW5BcHBlbmRTbG90KCldO1xuICAgICAgICB9LFxuICAgICAgICBnZW5Db250cm9sOiBmdW5jdGlvbiBnZW5Db250cm9sKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtaW5wdXRfX2NvbnRyb2wnXG4gICAgICAgICAgICB9LCBbdGhpcy5nZW5JbnB1dFNsb3QoKSwgdGhpcy5nZW5NZXNzYWdlcygpXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkRlZmF1bHRTbG90OiBmdW5jdGlvbiBnZW5EZWZhdWx0U2xvdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5nZW5MYWJlbCgpLCB0aGlzLiRzbG90cy5kZWZhdWx0XTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHNob3VsZERlcHJlY2F0ZSAoMi4wKSwgdXNlZCBmb3IgY2xlYXJJY29uXG4gICAgICAgIGdlbkljb246IGZ1bmN0aW9uIGdlbkljb24odHlwZSwgY2IsIHNob3VsZERlcHJlY2F0ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzaG91bGREZXByZWNhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHNob3VsZERlcHJlY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWNvbiA9IHRoaXNbdHlwZSArIFwiSWNvblwiXTtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBcImNsaWNrOlwiICsgT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImtlYmFiQ2FzZVwiXSkodHlwZSk7XG4gICAgICAgICAgICBjYiA9IGNiIHx8IHRoaXNbdHlwZSArIFwiSWNvbkNiXCJdO1xuICAgICAgICAgICAgaWYgKHNob3VsZERlcHJlY2F0ZSAmJiB0eXBlICYmIGNiKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlcHJlY2F0ZVwiXSkoXCI6XCIgKyB0eXBlICsgXCItaWNvbi1jYlwiLCBcIkBcIiArIGV2ZW50TmFtZSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy52YWxpZGF0aW9uU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGRhcms6IHRoaXMuZGFyayxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0OiB0aGlzLmxpZ2h0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjogISh0aGlzLiRsaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBjYikgPyBudWxsIDoge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLiRlbWl0KGV2ZW50TmFtZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYihlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGFpbmVyIGhhcyBtb3VzZXVwIGV2ZW50IHRoYXQgd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIG1lbnUgb3BlbiBpZiBlbmNsb3NlZFxuICAgICAgICAgICAgICAgICAgICBtb3VzZXVwOiBmdW5jdGlvbiBtb3VzZXVwKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ2LWlucHV0X19pY29uIHYtaW5wdXRfX2ljb24tLVwiICsgT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImtlYmFiQ2FzZVwiXSkodHlwZSksXG4gICAgICAgICAgICAgICAga2V5OiBcIlwiICsgdHlwZSArIGljb25cbiAgICAgICAgICAgIH0sIFt0aGlzLiRjcmVhdGVFbGVtZW50KF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgZGF0YSwgaWNvbildKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSW5wdXRTbG90OiBmdW5jdGlvbiBnZW5JbnB1dFNsb3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2JywgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5iYWNrZ3JvdW5kQ29sb3IsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtaW5wdXRfX3Nsb3QnLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7IGhlaWdodDogT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImNvbnZlcnRUb1VuaXRcIl0pKHRoaXMuaGVpZ2h0KSB9LFxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IHRoaXMuZGlyZWN0aXZlc0lucHV0LFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiB0aGlzLm9uQ2xpY2ssXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlZG93bjogdGhpcy5vbk1vdXNlRG93bixcbiAgICAgICAgICAgICAgICAgICAgbW91c2V1cDogdGhpcy5vbk1vdXNlVXBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZjogJ2lucHV0LXNsb3QnXG4gICAgICAgICAgICB9KSwgW3RoaXMuZ2VuRGVmYXVsdFNsb3QoKV0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5MYWJlbDogZnVuY3Rpb24gZ2VuTGFiZWwoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzTGFiZWwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZMYWJlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLnZhbGlkYXRpb25TdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZGFyazogdGhpcy5kYXJrLFxuICAgICAgICAgICAgICAgICAgICBmb2N1c2VkOiB0aGlzLmhhc1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICBmb3I6IHRoaXMuJGF0dHJzLmlkLFxuICAgICAgICAgICAgICAgICAgICBsaWdodDogdGhpcy5saWdodFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMuJHNsb3RzLmxhYmVsIHx8IHRoaXMubGFiZWwpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5NZXNzYWdlczogZnVuY3Rpb24gZ2VuTWVzc2FnZXMoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWRlRGV0YWlscykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSB0aGlzLmhhc0hpbnQgPyBbdGhpcy5oaW50XSA6IHRoaXMudmFsaWRhdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVk1lc3NhZ2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuaGFzSGludCA/ICcnIDogdGhpcy52YWxpZGF0aW9uU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGRhcms6IHRoaXMuZGFyayxcbiAgICAgICAgICAgICAgICAgICAgbGlnaHQ6IHRoaXMubGlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmhhc01lc3NhZ2VzIHx8IHRoaXMuaGFzSGludCA/IG1lc3NhZ2VzIDogW11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuU2xvdDogZnVuY3Rpb24gZ2VuU2xvdCh0eXBlLCBsb2NhdGlvbiwgc2xvdCkge1xuICAgICAgICAgICAgaWYgKCFzbG90Lmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgcmVmID0gdHlwZSArIFwiLVwiICsgbG9jYXRpb247XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInYtaW5wdXRfX1wiICsgcmVmLFxuICAgICAgICAgICAgICAgIHJlZjogcmVmXG4gICAgICAgICAgICB9LCBzbG90KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuUHJlcGVuZFNsb3Q6IGZ1bmN0aW9uIGdlblByZXBlbmRTbG90KCkge1xuICAgICAgICAgICAgdmFyIHNsb3QgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzbG90c1sncHJlcGVuZCddKSB7XG4gICAgICAgICAgICAgICAgc2xvdC5wdXNoKHRoaXMuJHNsb3RzWydwcmVwZW5kJ10pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXBlbmRJY29uKSB7XG4gICAgICAgICAgICAgICAgc2xvdC5wdXNoKHRoaXMuZ2VuSWNvbigncHJlcGVuZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlblNsb3QoJ3ByZXBlbmQnLCAnb3V0ZXInLCBzbG90KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuQXBwZW5kU2xvdDogZnVuY3Rpb24gZ2VuQXBwZW5kU2xvdCgpIHtcbiAgICAgICAgICAgIHZhciBzbG90ID0gW107XG4gICAgICAgICAgICAvLyBBcHBlbmQgaWNvbiBmb3IgdGV4dCBmaWVsZCB3YXMgcmVhbGx5XG4gICAgICAgICAgICAvLyBhbiBhcHBlbmRlZCBpbm5lciBpY29uLCB2LXRleHQtZmllbGRcbiAgICAgICAgICAgIC8vIHdpbGwgb3ZlcndyaXRlIHRoaXMgbWV0aG9kIGluIG9yZGVyIHRvIG9idGFpblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdFxuICAgICAgICAgICAgaWYgKHRoaXMuJHNsb3RzWydhcHBlbmQnXSkge1xuICAgICAgICAgICAgICAgIHNsb3QucHVzaCh0aGlzLiRzbG90c1snYXBwZW5kJ10pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFwcGVuZEljb24pIHtcbiAgICAgICAgICAgICAgICBzbG90LnB1c2godGhpcy5nZW5JY29uKCdhcHBlbmQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5TbG90KCdhcHBlbmQnLCAnb3V0ZXInLCBzbG90KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjbGljaycsIGUpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgICAgICAgdGhpcy5oYXNNb3VzZURvd24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnbW91c2Vkb3duJywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VVcDogZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzTW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdtb3VzZXVwJywgZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHRoaXMuc2V0VGV4dENvbG9yKHRoaXMudmFsaWRhdGlvblN0YXRlLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtaW5wdXQnLFxuICAgICAgICAgICAgYXR0cnM6IHRoaXMuYXR0cnNJbnB1dCxcbiAgICAgICAgICAgICdjbGFzcyc6IHRoaXMuY2xhc3Nlc0lucHV0XG4gICAgICAgIH0pLCB0aGlzLmdlbkNvbnRlbnQoKSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVklucHV0L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVklucHV0L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZJbnB1dCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVklucHV0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZJbnB1dCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVklucHV0L1ZJbnB1dC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZJbnB1dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WSW5wdXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVklucHV0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WSXRlbUdyb3VwL1ZJdGVtLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZJdGVtR3JvdXAvVkl0ZW0udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19ncm91cGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9ncm91cGFibGUgKi8gXCIuL3NyYy9taXhpbnMvZ3JvdXBhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9taXhpbnMgKi8gXCIuL3NyYy91dGlsL21peGlucy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG4vLyBNaXhpbnNcblxuLy8gVXRpbGl0aWVzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKShPYmplY3QoX21peGluc19ncm91cGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImZhY3RvcnlcIl0pKCdpdGVtR3JvdXAnLCAndi1pdGVtJywgJ3YtaXRlbS1ncm91cCcpXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LWl0ZW0nLFxuICAgIHByb3BzOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0KSB7XG4gICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiY29uc29sZVdhcm5cIl0pKCd2LWl0ZW0gaXMgbWlzc2luZyBhIGRlZmF1bHQgc2NvcGVkU2xvdCcsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0KSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy4kc2NvcGVkU2xvdHMuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiB0aGlzLmlzQWN0aXZlLFxuICAgICAgICAgICAgICAgIHRvZ2dsZTogdGhpcy50b2dnbGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWxlbWVudCB8fCB0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICAgICAgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImNvbnNvbGVXYXJuXCJdKSgndi1pdGVtIHNob3VsZCBvbmx5IGNvbnRhaW4gYSBzaW5nbGUgZWxlbWVudCcsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5kYXRhID0gZWxlbWVudC5kYXRhIHx8IHt9O1xuICAgICAgICBlbGVtZW50LmRhdGEuY2xhc3MgPSBbZWxlbWVudC5kYXRhLmNsYXNzLCAoX2EgPSB7fSwgX2FbdGhpcy5hY3RpdmVDbGFzc10gPSB0aGlzLmlzQWN0aXZlLCBfYSldO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkl0ZW1Hcm91cC9WSXRlbUdyb3VwLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkl0ZW1Hcm91cC9WSXRlbUdyb3VwLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IEJhc2VJdGVtR3JvdXAsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiQmFzZUl0ZW1Hcm91cFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIEJhc2VJdGVtR3JvdXA7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19pdGVtX2dyb3VwX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19pdGVtLWdyb3VwLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9faXRlbS1ncm91cC5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19pdGVtX2dyb3VwX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfaXRlbV9ncm91cF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcHJveHlhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvcHJveHlhYmxlICovIFwiLi9zcmMvbWl4aW5zL3Byb3h5YWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RoZW1lYWJsZSAqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL21peGlucyAqLyBcIi4vc3JjL3V0aWwvbWl4aW5zLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvY29uc29sZSAqLyBcIi4vc3JjL3V0aWwvY29uc29sZS50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbi8vIFN0eWxlc1xuXG5cblxuLy8gVXRpbGl0aWVzXG5cblxudmFyIEJhc2VJdGVtR3JvdXAgPSBPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKShfbWl4aW5zX3Byb3h5YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0pLmV4dGVuZCh7XG4gICAgbmFtZTogJ2Jhc2UtaXRlbS1ncm91cCcsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWN0aXZlQ2xhc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICd2LWl0ZW0tLWFjdGl2ZSdcbiAgICAgICAgfSxcbiAgICAgICAgbWFuZGF0b3J5OiBCb29sZWFuLFxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIG11bHRpcGxlOiBCb29sZWFuXG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gQXMgbG9uZyBhcyBhIHZhbHVlIGlzIGRlZmluZWQsIHNob3cgaXRcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgaWYgbXVsdGlwbGVcbiAgICAgICAgICAgIC8vIHRvIGRldGVybWluZSB3aGljaCBkZWZhdWx0IHRvIHByb3ZpZGVcbiAgICAgICAgICAgIGludGVybmFsTGF6eVZhbHVlOiB0aGlzLnZhbHVlICE9PSB1bmRlZmluZWQgPyB0aGlzLnZhbHVlIDogdGhpcy5tdWx0aXBsZSA/IFtdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCB0aGlzLnRoZW1lQ2xhc3Nlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdGVkSXRlbXM6IGZ1bmN0aW9uIHNlbGVjdGVkSXRlbXMoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2dnbGVNZXRob2QoX3RoaXMuZ2V0VmFsdWUoaXRlbSwgaW5kZXgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RlZFZhbHVlczogZnVuY3Rpb24gc2VsZWN0ZWRWYWx1ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLmludGVybmFsVmFsdWUpID8gdGhpcy5pbnRlcm5hbFZhbHVlIDogW3RoaXMuaW50ZXJuYWxWYWx1ZV07XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZU1ldGhvZDogZnVuY3Rpb24gdG9nZ2xlTWV0aG9kKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaW50ZXJuYWxWYWx1ZSA9PT0gdjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGludGVybmFsVmFsdWUgPSB0aGlzLmludGVybmFsVmFsdWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnRlcm5hbFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxWYWx1ZS5pbmNsdWRlcyh2KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBpbnRlcm5hbFZhbHVlOiBmdW5jdGlvbiBpbnRlcm5hbFZhbHVlKCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZXRpZnlqcy92dWV0aWZ5L2lzc3Vlcy81MzUyXG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayh0aGlzLnVwZGF0ZUl0ZW1zU3RhdGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLmludGVybmFsVmFsdWUpKSB7XG4gICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiY29uc29sZVdhcm5cIl0pKCdNb2RlbCBtdXN0IGJlIGJvdW5kIHRvIGFuIGFycmF5IGlmIHRoZSBtdWx0aXBsZSBwcm9wZXJ0eSBpcyB0cnVlLicsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShpdGVtLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS52YWx1ZSA9PSBudWxsIHx8IGl0ZW0udmFsdWUgPT09ICcnID8gaSA6IGl0ZW0udmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW50ZXJuYWxWYWx1ZSh0aGlzLmdldFZhbHVlKGl0ZW0sIGluZGV4KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihpdGVtKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pdGVtcy5wdXNoKGl0ZW0pIC0gMTtcbiAgICAgICAgICAgIGl0ZW0uJG9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9uQ2xpY2soaXRlbSwgaW5kZXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiBubyB2YWx1ZSBwcm92aWRlZCBhbmQgbWFuZGF0b3J5LFxuICAgICAgICAgICAgLy8gYXNzaWduIGZpcnN0IHJlZ2lzdGVyZWQgaXRlbVxuICAgICAgICAgICAgaWYgKHRoaXMubWFuZGF0b3J5ICYmIHRoaXMuaW50ZXJuYWxMYXp5VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWFuZGF0b3J5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW0oaXRlbSwgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbiB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZShpdGVtLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB2YXIgdmFsdWVJbmRleCA9IHRoaXMuc2VsZWN0ZWRWYWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICAvLyBJdGVtcyBpcyBub3Qgc2VsZWN0ZWQsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIGlmICh2YWx1ZUluZGV4IDwgMCkgcmV0dXJuO1xuICAgICAgICAgICAgLy8gSWYgbm90IG1hbmRhdG9yeSwgdXNlIHJlZ3VsYXIgdXBkYXRlIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICghdGhpcy5tYW5kYXRvcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVJbnRlcm5hbFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdmFsdWVcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmIEFycmF5LmlzQXJyYXkodGhpcy5pbnRlcm5hbFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9IHRoaXMuaW50ZXJuYWxWYWx1ZS5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYgIT09IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBtYW5kYXRvcnkgYW5kIHdlIGhhdmUgbm8gc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyBhZGQgdGhlIGxhc3QgaXRlbSBhcyB2YWx1ZVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWFuZGF0b3J5KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVJdGVtOiBmdW5jdGlvbiB1cGRhdGVJdGVtKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGl0ZW0sIGluZGV4KTtcbiAgICAgICAgICAgIGl0ZW0uaXNBY3RpdmUgPSB0aGlzLnRvZ2dsZU1ldGhvZCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUl0ZW1zU3RhdGU6IGZ1bmN0aW9uIHVwZGF0ZUl0ZW1zU3RhdGUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYW5kYXRvcnkgJiYgIXRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVNYW5kYXRvcnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IE1ha2UgdGhpcyBzbWFydGVyIHNvIGl0XG4gICAgICAgICAgICAvLyBkb2Vzbid0IGhhdmUgdG8gaXRlcmF0ZSBldmVyeVxuICAgICAgICAgICAgLy8gY2hpbGQgaW4gYW4gdXBkYXRlXG4gICAgICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2godGhpcy51cGRhdGVJdGVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlSW50ZXJuYWxWYWx1ZTogZnVuY3Rpb24gdXBkYXRlSW50ZXJuYWxWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5tdWx0aXBsZSA/IHRoaXMudXBkYXRlTXVsdGlwbGUodmFsdWUpIDogdGhpcy51cGRhdGVTaW5nbGUodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVNYW5kYXRvcnk6IGZ1bmN0aW9uIHVwZGF0ZU1hbmRhdG9yeShsYXN0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsYXN0ID8gdGhpcy5pdGVtcy5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW50ZXJuYWxWYWx1ZSh0aGlzLmdldFZhbHVlKHRoaXMuaXRlbXNbaW5kZXhdLCBpbmRleCkpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVNdWx0aXBsZTogZnVuY3Rpb24gdXBkYXRlTXVsdGlwbGUodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBBcnJheS5pc0FycmF5KHRoaXMuaW50ZXJuYWxWYWx1ZSkgPyB0aGlzLmludGVybmFsVmFsdWUgOiBbXTtcbiAgICAgICAgICAgIHZhciBpbnRlcm5hbFZhbHVlID0gZGVmYXVsdFZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbnRlcm5hbFZhbHVlLmZpbmRJbmRleChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hbmRhdG9yeSAmJlxuICAgICAgICAgICAgLy8gSXRlbSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgaW5kZXggPiAtMSAmJlxuICAgICAgICAgICAgLy8gdmFsdWUgd291bGQgYmUgcmVkdWNlZCBiZWxvdyBtaW5cbiAgICAgICAgICAgIGludGVybmFsVmFsdWUubGVuZ3RoIC0gMSA8IDEpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIE1heCBpcyBzZXRcbiAgICAgICAgICAgIHRoaXMubWF4ICE9IG51bGwgJiZcbiAgICAgICAgICAgIC8vIEl0ZW0gZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgaW5kZXggPCAwICYmXG4gICAgICAgICAgICAvLyB2YWx1ZSB3b3VkbCBiZSBpbmNyZWFzZWQgYWJvdmUgbWF4XG4gICAgICAgICAgICBpbnRlcm5hbFZhbHVlLmxlbmd0aCArIDEgPiB0aGlzLm1heCkgcmV0dXJuO1xuICAgICAgICAgICAgaW5kZXggPiAtMSA/IGludGVybmFsVmFsdWUuc3BsaWNlKGluZGV4LCAxKSA6IGludGVybmFsVmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSBpbnRlcm5hbFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVTaW5nbGU6IGZ1bmN0aW9uIHVwZGF0ZVNpbmdsZSh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGlzU2FtZSA9IHZhbHVlID09PSB0aGlzLmludGVybmFsVmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5tYW5kYXRvcnkgJiYgaXNTYW1lKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSBpc1NhbWUgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWl0ZW0tZ3JvdXAnLFxuICAgICAgICAgICAgY2xhc3M6IHRoaXMuY2xhc3Nlc1xuICAgICAgICB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB9XG59KTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQmFzZUl0ZW1Hcm91cC5leHRlbmQoe1xuICAgIG5hbWU6ICd2LWl0ZW0tZ3JvdXAnLFxuICAgIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpdGVtR3JvdXA6IHRoaXNcbiAgICAgICAgfTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkl0ZW1Hcm91cC9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WSXRlbUdyb3VwL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWSXRlbSwgVkl0ZW1Hcm91cCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkl0ZW1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkl0ZW0gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJdGVtR3JvdXAvVkl0ZW0udHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWSXRlbVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WSXRlbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkl0ZW1Hcm91cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WSXRlbUdyb3VwICovIFwiLi9zcmMvY29tcG9uZW50cy9WSXRlbUdyb3VwL1ZJdGVtR3JvdXAudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWSXRlbUdyb3VwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZJdGVtR3JvdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICAkX3Z1ZXRpZnlfc3ViY29tcG9uZW50czoge1xuICAgICAgICBWSXRlbTogX1ZJdGVtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWSXRlbUdyb3VwOiBfVkl0ZW1Hcm91cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZKdW1ib3Ryb24vVkp1bWJvdHJvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZKdW1ib3Ryb24vVkp1bWJvdHJvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19qdW1ib3Ryb25zX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19qdW1ib3Ryb25zLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fanVtYm90cm9ucy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19qdW1ib3Ryb25zX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfanVtYm90cm9uc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3JvdXRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvcm91dGFibGUgKi8gXCIuL3NyYy9taXhpbnMvcm91dGFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvY29uc29sZSAqLyBcIi4vc3JjL3V0aWwvY29uc29sZS50c1wiKTtcblxuLy8gTWl4aW5zXG5cblxuXG4vLyBVdGlsc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtanVtYm90cm9uJyxcbiAgICBtaXhpbnM6IFtfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgX21peGluc19yb3V0YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGdyYWRpZW50OiBTdHJpbmcsXG4gICAgICAgIGhlaWdodDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICc0MDBweCdcbiAgICAgICAgfSxcbiAgICAgICAgc3JjOiBTdHJpbmcsXG4gICAgICAgIHRhZzoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYmFja2dyb3VuZFN0eWxlczogZnVuY3Rpb24gYmFja2dyb3VuZFN0eWxlcygpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzLmJhY2tncm91bmQgPSBcImxpbmVhci1ncmFkaWVudChcIiArIHRoaXMuZ3JhZGllbnQgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aGVtZUNsYXNzZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlczogZnVuY3Rpb24gc3R5bGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVwcmVjYXRlXCJdKSgndi1qdW1ib3Ryb24nLCB0aGlzLnNyYyA/ICd2LWltZycgOiAndi1yZXNwb25zaXZlJywgdGhpcyk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlbkJhY2tncm91bmQ6IGZ1bmN0aW9uIGdlbkJhY2tncm91bmQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2JywgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5jb2xvciwge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1qdW1ib3Ryb25fX2JhY2tncm91bmQnLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLmJhY2tncm91bmRTdHlsZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuQ29udGVudDogZnVuY3Rpb24gZ2VuQ29udGVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWp1bWJvdHJvbl9fY29udGVudCdcbiAgICAgICAgICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5JbWFnZTogZnVuY3Rpb24gZ2VuSW1hZ2UoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3JjKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzbG90cy5pbWcpIHJldHVybiB0aGlzLiRzbG90cy5pbWcoeyBzcmM6IHRoaXMuc3JjIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2ltZycsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtanVtYm90cm9uX19pbWFnZScsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgc3JjOiB0aGlzLnNyYyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuV3JhcHBlcjogZnVuY3Rpb24gZ2VuV3JhcHBlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWp1bWJvdHJvbl9fd3JhcHBlcidcbiAgICAgICAgICAgIH0sIFt0aGlzLmdlbkltYWdlKCksIHRoaXMuZ2VuQmFja2dyb3VuZCgpLCB0aGlzLmdlbkNvbnRlbnQoKV0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2VuZXJhdGVSb3V0ZUxpbmsodGhpcy5jbGFzc2VzKSxcbiAgICAgICAgICAgIHRhZyA9IF9hLnRhZyxcbiAgICAgICAgICAgIGRhdGEgPSBfYS5kYXRhO1xuICAgICAgICBkYXRhLnN0YXRpY0NsYXNzID0gJ3YtanVtYm90cm9uJztcbiAgICAgICAgZGF0YS5zdHlsZSA9IHRoaXMuc3R5bGVzO1xuICAgICAgICByZXR1cm4gaCh0YWcsIGRhdGEsIFt0aGlzLmdlbldyYXBwZXIoKV0pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZKdW1ib3Ryb24vaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkp1bWJvdHJvbi9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVkp1bWJvdHJvbiwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkp1bWJvdHJvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WSnVtYm90cm9uICovIFwiLi9zcmMvY29tcG9uZW50cy9WSnVtYm90cm9uL1ZKdW1ib3Ryb24uanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWSnVtYm90cm9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZKdW1ib3Ryb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkp1bWJvdHJvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkxhYmVsL1ZMYWJlbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WTGFiZWwvVkxhYmVsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19sYWJlbHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2xhYmVscy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2xhYmVscy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19sYWJlbHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19sYWJlbHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2NvbG9yYWJsZSAqLyBcIi4vc3JjL21peGlucy9jb2xvcmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbi8vIFN0eWxlc1xuXG4vLyBNaXhpbnNcblxuXG4vLyBIZWxwZXJzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1sYWJlbCcsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBtaXhpbnM6IFtfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWJzb2x1dGU6IEJvb2xlYW4sXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5J1xuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgZm9jdXNlZDogQm9vbGVhbixcbiAgICAgICAgZm9yOiBTdHJpbmcsXG4gICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0OiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2F1dG8nXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBCb29sZWFuXG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBjdHgpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gY3R4LmNoaWxkcmVuLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gY3R4Lmxpc3RlbmVycyxcbiAgICAgICAgICAgIHByb3BzID0gY3R4LnByb3BzO1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1sYWJlbCcsXG4gICAgICAgICAgICAnY2xhc3MnOiBfX2Fzc2lnbih7ICd2LWxhYmVsLS1hY3RpdmUnOiBwcm9wcy52YWx1ZSwgJ3YtbGFiZWwtLWlzLWRpc2FibGVkJzogcHJvcHMuZGlzYWJsZWQgfSwgT2JqZWN0KF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJmdW5jdGlvbmFsVGhlbWVDbGFzc2VzXCJdKShjdHgpKSxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgZm9yOiBwcm9wcy5mb3IsXG4gICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogIXByb3BzLmZvclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uOiBsaXN0ZW5lcnMsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGxlZnQ6IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJjb252ZXJ0VG9Vbml0XCJdKShwcm9wcy5sZWZ0KSxcbiAgICAgICAgICAgICAgICByaWdodDogT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImNvbnZlcnRUb1VuaXRcIl0pKHByb3BzLnJpZ2h0KSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcHJvcHMuYWJzb2x1dGUgPyAnYWJzb2x1dGUnIDogJ3JlbGF0aXZlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaCgnbGFiZWwnLCBfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5vcHRpb25zLm1ldGhvZHMuc2V0VGV4dENvbG9yKHByb3BzLmZvY3VzZWQgJiYgcHJvcHMuY29sb3IsIGRhdGEpLCBjaGlsZHJlbik7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkxhYmVsL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkxhYmVsL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZMYWJlbCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkxhYmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZMYWJlbCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkxhYmVsL1ZMYWJlbC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZMYWJlbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WTGFiZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkxhYmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WTGlzdC9WTGlzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVkxpc3QvVkxpc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19saXN0c19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fbGlzdHMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19saXN0cy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19saXN0c19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2xpc3RzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9yZWdpc3RyYWJsZSAqLyBcIi4vc3JjL21peGlucy9yZWdpc3RyYWJsZS50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbi8vIFN0eWxlc1xuXG4vLyBNaXhpbnNcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtbGlzdCcsXG4gICAgbWl4aW5zOiBbT2JqZWN0KF9taXhpbnNfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInByb3ZpZGVcIl0pKCdsaXN0JyksIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdXSxcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2xpc3RDbGljayc6IHRoaXMubGlzdENsaWNrXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBkZW5zZTogQm9vbGVhbixcbiAgICAgICAgZXhwYW5kOiBCb29sZWFuLFxuICAgICAgICBzdWJoZWFkZXI6IEJvb2xlYW4sXG4gICAgICAgIHRocmVlTGluZTogQm9vbGVhbixcbiAgICAgICAgdHdvTGluZTogQm9vbGVhblxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwczogW11cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oeyAndi1saXN0LS1kZW5zZSc6IHRoaXMuZGVuc2UsICd2LWxpc3QtLXN1YmhlYWRlcic6IHRoaXMuc3ViaGVhZGVyLCAndi1saXN0LS10d28tbGluZSc6IHRoaXMudHdvTGluZSwgJ3YtbGlzdC0tdGhyZWUtbGluZSc6IHRoaXMudGhyZWVMaW5lIH0sIHRoaXMudGhlbWVDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIodWlkLCBjYikge1xuICAgICAgICAgICAgdGhpcy5ncm91cHMucHVzaCh7IHVpZDogdWlkLCBjYjogY2IgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uIHVucmVnaXN0ZXIodWlkKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdyb3Vwcy5maW5kSW5kZXgoZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZy51aWQgPT09IHVpZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsaXN0Q2xpY2s6IGZ1bmN0aW9uIGxpc3RDbGljayh1aWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4cGFuZCkgcmV0dXJuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZ3JvdXBzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2ldLmNiKHVpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtbGlzdCcsXG4gICAgICAgICAgICAnY2xhc3MnOiB0aGlzLmNsYXNzZXNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIGRhdGEsIFt0aGlzLiRzbG90cy5kZWZhdWx0XSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkxpc3QvVkxpc3RHcm91cC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WTGlzdC9WTGlzdEdyb3VwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21wb25lbnRzX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9jb21wb25lbnRzL1ZJY29uICovIFwiLi9zcmMvY29tcG9uZW50cy9WSWNvbi9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2Jvb3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvYm9vdGFibGUgKi8gXCIuL3NyYy9taXhpbnMvYm9vdGFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190b2dnbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdG9nZ2xlYWJsZSAqLyBcIi4vc3JjL21peGlucy90b2dnbGVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9yZWdpc3RyYWJsZSAqLyBcIi4vc3JjL21peGlucy9yZWdpc3RyYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3RyYW5zaXRpb25zICovIFwiLi9zcmMvY29tcG9uZW50cy90cmFuc2l0aW9ucy9pbmRleC5qc1wiKTtcbi8vIENvbXBvbmVudHNcblxuLy8gTWl4aW5zXG5cblxuXG4vLyBUcmFuc2l0aW9uc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtbGlzdC1ncm91cCcsXG4gICAgbWl4aW5zOiBbX21peGluc19ib290YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgT2JqZWN0KF9taXhpbnNfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImluamVjdFwiXSkoJ2xpc3QnLCAndi1saXN0LWdyb3VwJywgJ3YtbGlzdCcpLCBfbWl4aW5zX3RvZ2dsZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl1dLFxuICAgIGluamVjdDogWydsaXN0Q2xpY2snXSxcbiAgICBwcm9wczoge1xuICAgICAgICBhY3RpdmVDbGFzczoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3ByaW1hcnktLXRleHQnXG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEljb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5leHBhbmQnXG4gICAgICAgIH0sXG4gICAgICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgICAgICBncm91cDogU3RyaW5nLFxuICAgICAgICBub0FjdGlvbjogQm9vbGVhbixcbiAgICAgICAgcHJlcGVuZEljb246IFN0cmluZyxcbiAgICAgICAgc3ViR3JvdXA6IEJvb2xlYW5cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cHM6IFtdXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBncm91cENsYXNzZXM6IGZ1bmN0aW9uIGdyb3VwQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3YtbGlzdF9fZ3JvdXAtLWFjdGl2ZSc6IHRoaXMuaXNBY3RpdmUsXG4gICAgICAgICAgICAgICAgJ3YtbGlzdF9fZ3JvdXAtLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyQ2xhc3NlczogZnVuY3Rpb24gaGVhZGVyQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3YtbGlzdF9fZ3JvdXBfX2hlYWRlci0tYWN0aXZlJzogdGhpcy5pc0FjdGl2ZSxcbiAgICAgICAgICAgICAgICAndi1saXN0X19ncm91cF9faGVhZGVyLS1zdWItZ3JvdXAnOiB0aGlzLnN1Ykdyb3VwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBpdGVtc0NsYXNzZXM6IGZ1bmN0aW9uIGl0ZW1zQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3YtbGlzdF9fZ3JvdXBfX2l0ZW1zLS1uby1hY3Rpb24nOiB0aGlzLm5vQWN0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUodmFsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3ViR3JvdXAgJiYgdmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Q2xpY2sodGhpcy5fdWlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJHJvdXRlOiBmdW5jdGlvbiAkcm91dGUodG8pIHtcbiAgICAgICAgICAgIHZhciBpc0FjdGl2ZSA9IHRoaXMubWF0Y2hSb3V0ZSh0by5wYXRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlICYmIHRoaXMuaXNBY3RpdmUgIT09IGlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdENsaWNrKHRoaXMuX3VpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBpc0FjdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5saXN0LnJlZ2lzdGVyKHRoaXMuX3VpZCwgdGhpcy50b2dnbGUpO1xuICAgICAgICBpZiAodGhpcy5ncm91cCAmJiB0aGlzLiRyb3V0ZSAmJiB0aGlzLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0aGlzLm1hdGNoUm91dGUodGhpcy4kcm91dGUucGF0aCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubGlzdC51bnJlZ2lzdGVyKHRoaXMuX3VpZCk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljaygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gIXRoaXMuaXNBY3RpdmU7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkljb246IGZ1bmN0aW9uIGdlbkljb24oaWNvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX2NvbXBvbmVudHNfVkljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0sIGljb24pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5BcHBlbmRJY29uOiBmdW5jdGlvbiBnZW5BcHBlbmRJY29uKCkge1xuICAgICAgICAgICAgdmFyIGljb24gPSAhdGhpcy5zdWJHcm91cCA/IHRoaXMuYXBwZW5kSWNvbiA6IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpY29uICYmICF0aGlzLiRzbG90cy5hcHBlbmRJY29uKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWxpc3RfX2dyb3VwX19oZWFkZXJfX2FwcGVuZC1pY29uJ1xuICAgICAgICAgICAgfSwgW3RoaXMuJHNsb3RzLmFwcGVuZEljb24gfHwgdGhpcy5nZW5JY29uKGljb24pXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkdyb3VwOiBmdW5jdGlvbiBnZW5Hcm91cCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWxpc3RfX2dyb3VwX19oZWFkZXInLFxuICAgICAgICAgICAgICAgICdjbGFzcyc6IHRoaXMuaGVhZGVyQ2xhc3NlcyxcbiAgICAgICAgICAgICAgICBvbjogT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogdGhpcy5jbGlja1xuICAgICAgICAgICAgICAgIH0sIHRoaXMuJGxpc3RlbmVycyksXG4gICAgICAgICAgICAgICAgcmVmOiAnaXRlbSdcbiAgICAgICAgICAgIH0sIFt0aGlzLmdlblByZXBlbmRJY29uKCksIHRoaXMuJHNsb3RzLmFjdGl2YXRvciwgdGhpcy5nZW5BcHBlbmRJY29uKCldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSXRlbXM6IGZ1bmN0aW9uIGdlbkl0ZW1zKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtbGlzdF9fZ3JvdXBfX2l0ZW1zJyxcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiB0aGlzLml0ZW1zQ2xhc3NlcyxcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnc2hvdycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmlzQWN0aXZlXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgcmVmOiAnZ3JvdXAnXG4gICAgICAgICAgICB9LCB0aGlzLnNob3dMYXp5Q29udGVudCh0aGlzLiRzbG90cy5kZWZhdWx0KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblByZXBlbmRJY29uOiBmdW5jdGlvbiBnZW5QcmVwZW5kSWNvbigpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBpY29uID0gdGhpcy5wcmVwZW5kSWNvbiA/IHRoaXMucHJlcGVuZEljb24gOiB0aGlzLnN1Ykdyb3VwID8gJyR2dWV0aWZ5Lmljb25zLnN1Ymdyb3VwJyA6IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpY29uICYmICF0aGlzLiRzbG90cy5wcmVwZW5kSWNvbikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1saXN0X19ncm91cF9faGVhZGVyX19wcmVwZW5kLWljb24nLFxuICAgICAgICAgICAgICAgICdjbGFzcyc6IChfYSA9IHt9LCBfYVt0aGlzLmFjdGl2ZUNsYXNzXSA9IHRoaXMuaXNBY3RpdmUsIF9hKVxuICAgICAgICAgICAgfSwgW3RoaXMuJHNsb3RzLnByZXBlbmRJY29uIHx8IHRoaXMuZ2VuSWNvbihpY29uKV0pO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSh1aWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0aGlzLl91aWQgPT09IHVpZDtcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hSb3V0ZTogZnVuY3Rpb24gbWF0Y2hSb3V0ZSh0bykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdyb3VwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdG8ubWF0Y2godGhpcy5ncm91cCkgIT09IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1saXN0X19ncm91cCcsXG4gICAgICAgICAgICAnY2xhc3MnOiB0aGlzLmdyb3VwQ2xhc3Nlc1xuICAgICAgICB9LCBbdGhpcy5nZW5Hcm91cCgpLCBoKF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiVkV4cGFuZFRyYW5zaXRpb25cIl0sIFt0aGlzLmdlbkl0ZW1zKCldKV0pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZMaXN0L1ZMaXN0VGlsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZMaXN0L1ZMaXN0VGlsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3JvdXRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvcm91dGFibGUgKi8gXCIuL3NyYy9taXhpbnMvcm91dGFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190b2dnbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdG9nZ2xlYWJsZSAqLyBcIi4vc3JjL21peGlucy90b2dnbGVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlyZWN0aXZlc19yaXBwbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RpcmVjdGl2ZXMvcmlwcGxlICovIFwiLi9zcmMvZGlyZWN0aXZlcy9yaXBwbGUudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBNaXhpbnNcblxuXG5cblxuLy8gRGlyZWN0aXZlc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtbGlzdC10aWxlJyxcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICAgIFJpcHBsZTogX2RpcmVjdGl2ZXNfcmlwcGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdXG4gICAgfSxcbiAgICBtaXhpbnM6IFtfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSwgX21peGluc19yb3V0YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgX21peGluc190b2dnbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXV0sXG4gICAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgICBwcm9wczoge1xuICAgICAgICBhY3RpdmVDbGFzczoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3ByaW1hcnktLXRleHQnXG4gICAgICAgIH0sXG4gICAgICAgIGF2YXRhcjogQm9vbGVhbixcbiAgICAgICAgaW5hY3RpdmU6IEJvb2xlYW4sXG4gICAgICAgIHRhZzogU3RyaW5nXG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJveHlDbGFzczogJ3YtbGlzdF9fdGlsZS0tYWN0aXZlJ1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgbGlzdENsYXNzZXM6IGZ1bmN0aW9uIGxpc3RDbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyB7ICd2LWxpc3QtLWRpc2FibGVkJzogdHJ1ZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHsgJ3YtbGlzdF9fdGlsZSc6IHRydWUsICd2LWxpc3RfX3RpbGUtLWxpbmsnOiB0aGlzLmlzTGluayAmJiAhdGhpcy5pbmFjdGl2ZSwgJ3YtbGlzdF9fdGlsZS0tYXZhdGFyJzogdGhpcy5hdmF0YXIsICd2LWxpc3RfX3RpbGUtLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCwgJ3YtbGlzdF9fdGlsZS0tYWN0aXZlJzogIXRoaXMudG8gJiYgdGhpcy5pc0FjdGl2ZSB9LCB0aGlzLnRoZW1lQ2xhc3NlcywgKF9hID0ge30sIF9hW3RoaXMuYWN0aXZlQ2xhc3NdID0gdGhpcy5pc0FjdGl2ZSwgX2EpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNMaW5rOiBmdW5jdGlvbiBpc0xpbmsoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ocmVmIHx8IHRoaXMudG8gfHwgdGhpcy4kbGlzdGVuZXJzICYmICh0aGlzLiRsaXN0ZW5lcnMuY2xpY2sgfHwgdGhpcy4kbGlzdGVuZXJzWychY2xpY2snXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIGlzUm91dGVMaW5rID0gIXRoaXMuaW5hY3RpdmUgJiYgdGhpcy5pc0xpbms7XG4gICAgICAgIHZhciBfYSA9IGlzUm91dGVMaW5rID8gdGhpcy5nZW5lcmF0ZVJvdXRlTGluayh0aGlzLmNsYXNzZXMpIDoge1xuICAgICAgICAgICAgdGFnOiB0aGlzLnRhZyB8fCAnZGl2JyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBjbGFzczogdGhpcy5jbGFzc2VzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICAgICB0YWcgPSBfYS50YWcsXG4gICAgICAgICAgICBkYXRhID0gX2EuZGF0YTtcbiAgICAgICAgZGF0YS5hdHRycyA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEuYXR0cnMsIHRoaXMuJGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHRoaXMuc2V0VGV4dENvbG9yKCF0aGlzLmRpc2FibGVkICYmIHRoaXMuY29sb3IsIHtcbiAgICAgICAgICAgIGNsYXNzOiB0aGlzLmxpc3RDbGFzc2VzLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uOiBfX2Fzc2lnbih7fSwgdGhpcy4kbGlzdGVuZXJzKVxuICAgICAgICB9KSwgW2godGFnLCBkYXRhLCB0aGlzLiRzbG90cy5kZWZhdWx0KV0pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZMaXN0L1ZMaXN0VGlsZUFjdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZMaXN0L1ZMaXN0VGlsZUFjdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LWxpc3QtdGlsZS1hY3Rpb24nLFxuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX2EpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfYS5kYXRhLFxuICAgICAgICAgICAgX2IgPSBfYS5jaGlsZHJlbixcbiAgICAgICAgICAgIGNoaWxkcmVuID0gX2IgPT09IHZvaWQgMCA/IFtdIDogX2I7XG4gICAgICAgIGRhdGEuc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzID8gXCJ2LWxpc3RfX3RpbGVfX2FjdGlvbiBcIiArIGRhdGEuc3RhdGljQ2xhc3MgOiAndi1saXN0X190aWxlX19hY3Rpb24nO1xuICAgICAgICB2YXIgZmlsdGVyZWRDaGlsZCA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoVk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBWTm9kZS5pc0NvbW1lbnQgPT09IGZhbHNlICYmIFZOb2RlLnRleHQgIT09ICcgJztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWx0ZXJlZENoaWxkLmxlbmd0aCA+IDEpIGRhdGEuc3RhdGljQ2xhc3MgKz0gJyB2LWxpc3RfX3RpbGVfX2FjdGlvbi0tc3RhY2snO1xuICAgICAgICByZXR1cm4gaCgnZGl2JywgZGF0YSwgY2hpbGRyZW4pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZMaXN0L1ZMaXN0VGlsZUF2YXRhci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZMaXN0L1ZMaXN0VGlsZUF2YXRhci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQXZhdGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WQXZhdGFyICovIFwiLi9zcmMvY29tcG9uZW50cy9WQXZhdGFyL2luZGV4LnRzXCIpO1xuLy8gQ29tcG9uZW50c1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtbGlzdC10aWxlLWF2YXRhcicsXG4gICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICBwcm9wczoge1xuICAgICAgICBjb2xvcjogU3RyaW5nLFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogNDBcbiAgICAgICAgfSxcbiAgICAgICAgdGlsZTogQm9vbGVhblxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX2EpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfYS5kYXRhLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbixcbiAgICAgICAgICAgIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIGRhdGEuc3RhdGljQ2xhc3MgPSAoXCJ2LWxpc3RfX3RpbGVfX2F2YXRhciBcIiArIChkYXRhLnN0YXRpY0NsYXNzIHx8ICcnKSkudHJpbSgpO1xuICAgICAgICB2YXIgYXZhdGFyID0gaChfVkF2YXRhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogcHJvcHMuY29sb3IsXG4gICAgICAgICAgICAgICAgc2l6ZTogcHJvcHMuc2l6ZSxcbiAgICAgICAgICAgICAgICB0aWxlOiBwcm9wcy50aWxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtjaGlsZHJlbl0pO1xuICAgICAgICByZXR1cm4gaCgnZGl2JywgZGF0YSwgW2F2YXRhcl0pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZMaXN0L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WTGlzdC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZMaXN0LCBWTGlzdEdyb3VwLCBWTGlzdFRpbGUsIFZMaXN0VGlsZUFjdGlvbiwgVkxpc3RUaWxlQXZhdGFyLCBWTGlzdFRpbGVBY3Rpb25UZXh0LCBWTGlzdFRpbGVDb250ZW50LCBWTGlzdFRpbGVUaXRsZSwgVkxpc3RUaWxlU3ViVGl0bGUsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkxpc3RUaWxlQWN0aW9uVGV4dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZMaXN0VGlsZUFjdGlvblRleHQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZMaXN0VGlsZUNvbnRlbnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWTGlzdFRpbGVDb250ZW50OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWTGlzdFRpbGVUaXRsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZMaXN0VGlsZVRpdGxlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWTGlzdFRpbGVTdWJUaXRsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZMaXN0VGlsZVN1YlRpdGxlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZMaXN0ICovIFwiLi9zcmMvY29tcG9uZW50cy9WTGlzdC9WTGlzdC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZMaXN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WTGlzdEdyb3VwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZMaXN0R3JvdXAgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZMaXN0L1ZMaXN0R3JvdXAuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWTGlzdEdyb3VwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZMaXN0R3JvdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZMaXN0VGlsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WTGlzdFRpbGUgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZMaXN0L1ZMaXN0VGlsZS5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZMaXN0VGlsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WTGlzdFRpbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZMaXN0VGlsZUFjdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WTGlzdFRpbGVBY3Rpb24gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZMaXN0L1ZMaXN0VGlsZUFjdGlvbi5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZMaXN0VGlsZUFjdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WTGlzdFRpbGVBY3Rpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZMaXN0VGlsZUF2YXRhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WTGlzdFRpbGVBdmF0YXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZMaXN0L1ZMaXN0VGlsZUF2YXRhci5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZMaXN0VGlsZUF2YXRhclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WTGlzdFRpbGVBdmF0YXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG5cblxuXG5cbnZhciBWTGlzdFRpbGVBY3Rpb25UZXh0ID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZUZ1bmN0aW9uYWxcIl0pKCd2LWxpc3RfX3RpbGVfX2FjdGlvbi10ZXh0JywgJ3NwYW4nKTtcbnZhciBWTGlzdFRpbGVDb250ZW50ID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZUZ1bmN0aW9uYWxcIl0pKCd2LWxpc3RfX3RpbGVfX2NvbnRlbnQnLCAnZGl2Jyk7XG52YXIgVkxpc3RUaWxlVGl0bGUgPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY3JlYXRlU2ltcGxlRnVuY3Rpb25hbFwiXSkoJ3YtbGlzdF9fdGlsZV9fdGl0bGUnLCAnZGl2Jyk7XG52YXIgVkxpc3RUaWxlU3ViVGl0bGUgPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY3JlYXRlU2ltcGxlRnVuY3Rpb25hbFwiXSkoJ3YtbGlzdF9fdGlsZV9fc3ViLXRpdGxlJywgJ2RpdicpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgJF92dWV0aWZ5X3N1YmNvbXBvbmVudHM6IHtcbiAgICAgICAgVkxpc3Q6IF9WTGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgVkxpc3RHcm91cDogX1ZMaXN0R3JvdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZMaXN0VGlsZTogX1ZMaXN0VGlsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgVkxpc3RUaWxlQWN0aW9uOiBfVkxpc3RUaWxlQWN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWTGlzdFRpbGVBY3Rpb25UZXh0OiBWTGlzdFRpbGVBY3Rpb25UZXh0LFxuICAgICAgICBWTGlzdFRpbGVBdmF0YXI6IF9WTGlzdFRpbGVBdmF0YXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZMaXN0VGlsZUNvbnRlbnQ6IFZMaXN0VGlsZUNvbnRlbnQsXG4gICAgICAgIFZMaXN0VGlsZVN1YlRpdGxlOiBWTGlzdFRpbGVTdWJUaXRsZSxcbiAgICAgICAgVkxpc3RUaWxlVGl0bGU6IFZMaXN0VGlsZVRpdGxlXG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk1lbnUvVk1lbnUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZNZW51L1ZNZW51LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfbWVudXNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX21lbnVzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fbWVudXMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfbWVudXNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19tZW51c19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFwidnVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2RlbGF5YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2RlbGF5YWJsZSAqLyBcIi4vc3JjL21peGlucy9kZWxheWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19kZXBlbmRlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9kZXBlbmRlbnQgKi8gXCIuL3NyYy9taXhpbnMvZGVwZW5kZW50LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfZGV0YWNoYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2RldGFjaGFibGUgKi8gXCIuL3NyYy9taXhpbnMvZGV0YWNoYWJsZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX21lbnVhYmxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvbWVudWFibGUuanMgKi8gXCIuL3NyYy9taXhpbnMvbWVudWFibGUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19yZXR1cm5hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvcmV0dXJuYWJsZSAqLyBcIi4vc3JjL21peGlucy9yZXR1cm5hYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdG9nZ2xlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RvZ2dsZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdG9nZ2xlYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RoZW1lYWJsZSAqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19tZW51X2FjdGl2YXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9taXhpbnMvbWVudS1hY3RpdmF0b3IgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZNZW51L21peGlucy9tZW51LWFjdGl2YXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX21lbnVfZ2VuZXJhdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL21lbnUtZ2VuZXJhdG9ycyAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk1lbnUvbWl4aW5zL21lbnUtZ2VuZXJhdG9ycy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX21lbnVfa2V5YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL21lbnUta2V5YWJsZSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk1lbnUvbWl4aW5zL21lbnUta2V5YWJsZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX21lbnVfcG9zaXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21peGlucy9tZW51LXBvc2l0aW9uICovIFwiLi9zcmMvY29tcG9uZW50cy9WTWVudS9taXhpbnMvbWVudS1wb3NpdGlvbi5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlyZWN0aXZlc19jbGlja19vdXRzaWRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlICovIFwiLi9zcmMvZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXJlY3RpdmVzX3Jlc2l6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplICovIFwiLi9zcmMvZGlyZWN0aXZlcy9yZXNpemUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9UaGVtZVByb3ZpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9UaGVtZVByb3ZpZGVyICovIFwiLi9zcmMvdXRpbC9UaGVtZVByb3ZpZGVyLnRzXCIpO1xuXG5cbi8vIE1peGluc1xuXG5cblxuXG5cblxuXG4vLyBDb21wb25lbnQgbGV2ZWwgbWl4aW5zXG5cblxuXG5cbi8vIERpcmVjdGl2ZXNcblxuXG4vLyBIZWxwZXJzXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdC5hLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtbWVudScsXG4gICAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIFBhc3MgdGhlbWUgdGhyb3VnaCB0byBkZWZhdWx0IHNsb3RcbiAgICAgICAgICAgIHRoZW1lOiB0aGlzLnRoZW1lXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICAgIENsaWNrT3V0c2lkZTogX2RpcmVjdGl2ZXNfY2xpY2tfb3V0c2lkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFJlc2l6ZTogX2RpcmVjdGl2ZXNfcmVzaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fW1wiZGVmYXVsdFwiXVxuICAgIH0sXG4gICAgbWl4aW5zOiBbX21peGluc19tZW51X2FjdGl2YXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wiZGVmYXVsdFwiXSwgX21peGluc19kZXBlbmRlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfZGVsYXlhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX2RldGFjaGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfbWVudV9nZW5lcmF0b3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiZGVmYXVsdFwiXSwgX21peGluc19tZW51X2tleWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX21lbnVhYmxlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX21lbnVfcG9zaXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3JldHVybmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdG9nZ2xlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXSwgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGF1dG86IEJvb2xlYW4sXG4gICAgICAgIGNsb3NlT25DbGljazoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2VPbkNvbnRlbnRDbGljazoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIGZ1bGxXaWR0aDogQm9vbGVhbixcbiAgICAgICAgbWF4SGVpZ2h0OiB7IGRlZmF1bHQ6ICdhdXRvJyB9LFxuICAgICAgICBvZmZzZXRYOiBCb29sZWFuLFxuICAgICAgICBvZmZzZXRZOiBCb29sZWFuLFxuICAgICAgICBvcGVuT25DbGljazoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgb3Blbk9uSG92ZXI6IEJvb2xlYW4sXG4gICAgICAgIG9yaWdpbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3RvcCBsZWZ0J1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2l0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICd2LW1lbnUtdHJhbnNpdGlvbidcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlZmF1bHRPZmZzZXQ6IDgsXG4gICAgICAgICAgICBtYXhIZWlnaHRBdXRvRGVmYXVsdDogJzIwMHB4JyxcbiAgICAgICAgICAgIHN0YXJ0SW5kZXg6IDMsXG4gICAgICAgICAgICBzdG9wSW5kZXg6IDAsXG4gICAgICAgICAgICBoYXNKdXN0Rm9jdXNlZDogZmFsc2UsXG4gICAgICAgICAgICByZXNpemVUaW1lb3V0OiBudWxsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjYWxjdWxhdGVkTGVmdDogZnVuY3Rpb24gY2FsY3VsYXRlZExlZnQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXV0bykgcmV0dXJuIHRoaXMuY2FsY0xlZnQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNYT3ZlcmZsb3codGhpcy5jYWxjTGVmdEF1dG8oKSkgKyBcInB4XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGN1bGF0ZWRNYXhIZWlnaHQ6IGZ1bmN0aW9uIGNhbGN1bGF0ZWRNYXhIZWlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRvID8gJzIwMHB4JyA6IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fW1wiY29udmVydFRvVW5pdFwiXSkodGhpcy5tYXhIZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjdWxhdGVkTWF4V2lkdGg6IGZ1bmN0aW9uIGNhbGN1bGF0ZWRNYXhXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc05hTih0aGlzLm1heFdpZHRoKSA/IHRoaXMubWF4V2lkdGggOiB0aGlzLm1heFdpZHRoICsgXCJweFwiO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjdWxhdGVkTWluV2lkdGg6IGZ1bmN0aW9uIGNhbGN1bGF0ZWRNaW5XaWR0aCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHRoaXMubWluV2lkdGgpID8gdGhpcy5taW5XaWR0aCA6IHRoaXMubWluV2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluV2lkdGggPSB0aGlzLmRpbWVuc2lvbnMuYWN0aXZhdG9yLndpZHRoICsgdGhpcy5udWRnZVdpZHRoICsgKHRoaXMuYXV0byA/IDE2IDogMCk7XG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZE1heFdpZHRoID0gaXNOYU4ocGFyc2VJbnQodGhpcy5jYWxjdWxhdGVkTWF4V2lkdGgpKSA/IG1pbldpZHRoIDogcGFyc2VJbnQodGhpcy5jYWxjdWxhdGVkTWF4V2lkdGgpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKGNhbGN1bGF0ZWRNYXhXaWR0aCwgbWluV2lkdGgpICsgXCJweFwiO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjdWxhdGVkVG9wOiBmdW5jdGlvbiBjYWxjdWxhdGVkVG9wKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF1dG8gfHwgdGhpcy5pc0F0dGFjaGVkKSByZXR1cm4gdGhpcy5jYWxjVG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjWU92ZXJmbG93KHRoaXMuY2FsY1RvcEF1dG8oKSkgKyBcInB4XCI7XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlczogZnVuY3Rpb24gc3R5bGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IHRoaXMuY2FsY3VsYXRlZE1heEhlaWdodCxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogdGhpcy5jYWxjdWxhdGVkTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6IHRoaXMuY2FsY3VsYXRlZE1heFdpZHRoLFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5jYWxjdWxhdGVkVG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuY2FsY3VsYXRlZExlZnQsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiB0aGlzLm9yaWdpbixcbiAgICAgICAgICAgICAgICB6SW5kZXg6IHRoaXMuekluZGV4IHx8IHRoaXMuYWN0aXZlWkluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB0aWxlSGVpZ2h0OiBmdW5jdGlvbiB0aWxlSGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVuc2UgPyAzNiA6IDQ4O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBhY3RpdmF0b3I6IGZ1bmN0aW9uIGFjdGl2YXRvcihuZXdBY3RpdmF0b3IsIG9sZEFjdGl2YXRvcikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmF0b3JFdmVudHMob2xkQWN0aXZhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQWN0aXZhdG9yRXZlbnRzKG5ld0FjdGl2YXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGlzQ29udGVudEFjdGl2ZTogZnVuY3Rpb24gaXNDb250ZW50QWN0aXZlKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5oYXNKdXN0Rm9jdXNlZCA9IHZhbDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24gYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGV4aXN0cyBwcmltYXJpbHkgZm9yIHYtc2VsZWN0XG4gICAgICAgICAgICAvLyBoZWxwcyBkZXRlcm1pbmUgd2hpY2ggdGlsZXMgdG8gYWN0aXZhdGVcbiAgICAgICAgICAgIHRoaXMuZ2V0VGlsZXMoKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucyBvZiBtZW51XG4gICAgICAgICAgICAvLyBhbmQgaXRzIGFjdGl2YXRvclxuICAgICAgICAgICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdHJhbnNpdGlvblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RhcnRUcmFuc2l0aW9uKTtcbiAgICAgICAgICAgIC8vIE9uY2UgdHJhbnNpdGlvbmluZywgY2FsY3VsYXRlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLmNhbGN1bGF0ZVNjcm9sbCwgNTApO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZUNvbmRpdGlvbmFsOiBmdW5jdGlvbiBjbG9zZUNvbmRpdGlvbmFsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBY3RpdmUgJiYgdGhpcy5jbG9zZU9uQ2xpY2s7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVzaXplOiBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQWNjb3VudCBmb3Igc2NyZWVuIHJlc2l6ZVxuICAgICAgICAgICAgLy8gYW5kIG9yaWVudGF0aW9uIGNoYW5nZVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgICAgICAgdGhpcy4kcmVmcy5jb250ZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICAvLyBXaGVuIHJlc2l6aW5nIHRvIGEgc21hbGxlciB3aWR0aFxuICAgICAgICAgICAgLy8gY29udGVudCB3aWR0aCBpcyBldmFsdWF0ZWQgYmVmb3JlXG4gICAgICAgICAgICAvLyB0aGUgbmV3IGFjdGl2YXRvciB3aWR0aCBoYXMgYmVlblxuICAgICAgICAgICAgLy8gc2V0LCBjYXVzaW5nIGl0IHRvIG5vdCBzaXplIHByb3Blcmx5XG4gICAgICAgICAgICAvLyBoYWNreSBidXQgd2lsbCByZXZpc2l0IGluIHRoZSBmdXR1cmVcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnVwZGF0ZURpbWVuc2lvbnMsIDEwMCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtbWVudScsXG4gICAgICAgICAgICBjbGFzczogeyAndi1tZW51LS1pbmxpbmUnOiAhdGhpcy5mdWxsV2lkdGggJiYgdGhpcy4kc2xvdHMuYWN0aXZhdG9yIH0sXG4gICAgICAgICAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgICAgICAgICAgIGFyZzogNTAwLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdyZXNpemUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLm9uUmVzaXplXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAga2V5ZG93bjogdGhpcy5vbktleURvd25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIGRhdGEsIFt0aGlzLmdlbkFjdGl2YXRvcigpLCB0aGlzLiRjcmVhdGVFbGVtZW50KF91dGlsX1RoZW1lUHJvdmlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIHJvb3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgbGlnaHQ6IHRoaXMubGlnaHQsXG4gICAgICAgICAgICAgICAgZGFyazogdGhpcy5kYXJrXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0aGlzLmdlblRyYW5zaXRpb24oKV0pXSk7XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZNZW51L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WTWVudS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZNZW51LCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WTWVudV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WTWVudSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk1lbnUvVk1lbnUuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWTWVudVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WTWVudV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WTWVudV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk1lbnUvbWl4aW5zL21lbnUtYWN0aXZhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVk1lbnUvbWl4aW5zL21lbnUtYWN0aXZhdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKipcbiAqIE1lbnUgYWN0aXZhdG9yXG4gKlxuICogQG1peGluXG4gKlxuICogSGFuZGxlcyB0aGUgY2xpY2sgYW5kIGhvdmVyIGFjdGl2YXRpb25cbiAqIFN1cHBvcnRzIHNsb3R0ZWQgYW5kIGRldGFjaGVkIGFjdGl2YXRvcnNcbiAqL1xuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYWN0aXZhdG9yQ2xpY2tIYW5kbGVyOiBmdW5jdGlvbiBhY3RpdmF0b3JDbGlja0hhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wZW5PbkNsaWNrICYmICF0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBY3RpdmF0b3IoKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJzb2x1dGVYID0gZS5jbGllbnRYO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJzb2x1dGVZID0gZS5jbGllbnRZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNsb3NlT25DbGljayAmJiB0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBY3RpdmF0b3IoKS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZUVudGVySGFuZGxlcjogZnVuY3Rpb24gbW91c2VFbnRlckhhbmRsZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5ydW5EZWxheSgnb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaGFzSnVzdEZvY3VzZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYXNKdXN0Rm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlTGVhdmVIYW5kbGVyOiBmdW5jdGlvbiBtb3VzZUxlYXZlSGFuZGxlcihlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gUHJldmVudCBhY2NpZGVudGFsIHJlLWFjdGl2YXRpb25cbiAgICAgICAgICAgIHRoaXMucnVuRGVsYXkoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy4kcmVmcy5jb250ZW50LmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYWxsRGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEFjdGl2YXRvckV2ZW50czogZnVuY3Rpb24gYWRkQWN0aXZhdG9yRXZlbnRzKGFjdGl2YXRvcikge1xuICAgICAgICAgICAgaWYgKGFjdGl2YXRvciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdG9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWN0aXZhdG9yKSByZXR1cm47XG4gICAgICAgICAgICBhY3RpdmF0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmFjdGl2YXRvckNsaWNrSGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUFjdGl2YXRvckV2ZW50czogZnVuY3Rpb24gcmVtb3ZlQWN0aXZhdG9yRXZlbnRzKGFjdGl2YXRvcikge1xuICAgICAgICAgICAgaWYgKGFjdGl2YXRvciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZhdG9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWN0aXZhdG9yKSByZXR1cm47XG4gICAgICAgICAgICBhY3RpdmF0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmFjdGl2YXRvckNsaWNrSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WTWVudS9taXhpbnMvbWVudS1nZW5lcmF0b3JzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZNZW51L21peGlucy9tZW51LWdlbmVyYXRvcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZWFkID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3JlYWQgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSxcbiAgICAgICAgcixcbiAgICAgICAgYXIgPSBbXSxcbiAgICAgICAgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlKSB0aHJvdyBlLmVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fc3ByZWFkIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gICAgfXJldHVybiBhcjtcbn07XG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZW5BY3RpdmF0b3I6IGZ1bmN0aW9uIGdlbkFjdGl2YXRvcigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kc2xvdHMuYWN0aXZhdG9yKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1tZW51X19hY3RpdmF0b3InLFxuICAgICAgICAgICAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3YtbWVudV9fYWN0aXZhdG9yLS1hY3RpdmUnOiB0aGlzLmhhc0p1c3RGb2N1c2VkIHx8IHRoaXMuaXNBY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgICd2LW1lbnVfX2FjdGl2YXRvci0tZGlzYWJsZWQnOiB0aGlzLmRpc2FibGVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWY6ICdhY3RpdmF0b3InLFxuICAgICAgICAgICAgICAgIG9uOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wZW5PbkhvdmVyKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblsnbW91c2VlbnRlciddID0gdGhpcy5tb3VzZUVudGVySGFuZGxlcjtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uWydtb3VzZWxlYXZlJ10gPSB0aGlzLm1vdXNlTGVhdmVIYW5kbGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wZW5PbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblsnY2xpY2snXSA9IHRoaXMuYWN0aXZhdG9yQ2xpY2tIYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIG9wdGlvbnMsIHRoaXMuJHNsb3RzLmFjdGl2YXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblRyYW5zaXRpb246IGZ1bmN0aW9uIGdlblRyYW5zaXRpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhbnNpdGlvbikgcmV0dXJuIHRoaXMuZ2VuQ29udGVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RyYW5zaXRpb24nLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy50cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW3RoaXMuZ2VuQ29udGVudCgpXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkRpcmVjdGl2ZXM6IGZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gRG8gbm90IGFkZCBjbGljayBvdXRzaWRlIGZvciBob3ZlciBtZW51XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlcyA9ICF0aGlzLm9wZW5PbkhvdmVyICYmIHRoaXMuY2xvc2VPbkNsaWNrID8gW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2xpY2stb3V0c2lkZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VDb25kaXRpb25hbDogdGhpcy5jbG9zZUNvbmRpdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkKFtfdGhpcy4kZWxdLCBfdGhpcy5nZXRPcGVuRGVwZW5kZW50RWxlbWVudHMoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSA6IFtdO1xuICAgICAgICAgICAgZGlyZWN0aXZlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2hvdycsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaXNDb250ZW50QWN0aXZlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkaXJlY3RpdmVzO1xuICAgICAgICB9LFxuICAgICAgICBnZW5Db250ZW50OiBmdW5jdGlvbiBnZW5Db250ZW50KCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB0aGlzLmdldFNjb3BlSWRBdHRycygpLFxuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1tZW51X19jb250ZW50JyxcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiBfX2Fzc2lnbih7fSwgdGhpcy5yb290VGhlbWVDbGFzc2VzLCAoX2EgPSB7ICd2LW1lbnVfX2NvbnRlbnQtLWF1dG8nOiB0aGlzLmF1dG8sICdtZW51YWJsZV9fY29udGVudF9fYWN0aXZlJzogdGhpcy5pc0FjdGl2ZSB9LCBfYVt0aGlzLmNvbnRlbnRDbGFzcy50cmltKCldID0gdHJ1ZSwgX2EpKSxcbiAgICAgICAgICAgICAgICBzdHlsZTogdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5nZW5EaXJlY3RpdmVzKCksXG4gICAgICAgICAgICAgICAgcmVmOiAnY29udGVudCcsXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2xvc2VPbkNvbnRlbnRDbGljaykgX3RoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAhdGhpcy5kaXNhYmxlZCAmJiB0aGlzLm9wZW5PbkhvdmVyICYmIChvcHRpb25zLm9uLm1vdXNlZW50ZXIgPSB0aGlzLm1vdXNlRW50ZXJIYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMub3Blbk9uSG92ZXIgJiYgKG9wdGlvbnMub24ubW91c2VsZWF2ZSA9IHRoaXMubW91c2VMZWF2ZUhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIG9wdGlvbnMsIHRoaXMuc2hvd0xhenlDb250ZW50KHRoaXMuJHNsb3RzLmRlZmF1bHQpKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZNZW51L21peGlucy9tZW51LWtleWFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVk1lbnUvbWl4aW5zL21lbnUta2V5YWJsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG4vKipcbiAqIE1lbnUga2V5YWJsZVxuICpcbiAqIEBtaXhpblxuICpcbiAqIFByaW1hcmlseSB1c2VkIHRvIHN1cHBvcnQgVlNlbGVjdFxuICogSGFuZGxlcyBvcGVuaW5nIGFuZCBjbG9zaW5nIG9mIFZNZW51IGZyb20ga2V5c3Ryb2tlc1xuICogV2lsbCBjb25kaXRpb25hbGx5IGhpZ2hsaWdodCBWTGlzdFRpbGVzIGZvciBWU2VsZWN0XG4gKi9cbi8vIFV0aWxzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGlzdEluZGV4OiAtMSxcbiAgICAgICAgICAgIHRpbGVzOiBbXVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKHZhbCkge1xuICAgICAgICAgICAgaWYgKCF2YWwpIHRoaXMubGlzdEluZGV4ID0gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RJbmRleDogZnVuY3Rpb24gbGlzdEluZGV4KG5leHQsIHByZXYpIHtcbiAgICAgICAgICAgIGlmIChuZXh0IGluIHRoaXMudGlsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMudGlsZXNbbmV4dF07XG4gICAgICAgICAgICAgICAgdGlsZS5jbGFzc0xpc3QuYWRkKCd2LWxpc3RfX3RpbGUtLWhpZ2hsaWdodGVkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcmVmcy5jb250ZW50LnNjcm9sbFRvcCA9IHRpbGUub2Zmc2V0VG9wIC0gdGlsZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2IGluIHRoaXMudGlsZXMgJiYgdGhpcy50aWxlc1twcmV2XS5jbGFzc0xpc3QucmVtb3ZlKCd2LWxpc3RfX3RpbGUtLWhpZ2hsaWdodGVkJyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgb25LZXlEb3duOiBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgICAgICAgICAgaWYgKFtfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJrZXlDb2Rlc1wiXS5kb3duLCBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJrZXlDb2Rlc1wiXS51cCwgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wia2V5Q29kZXNcIl0uZW50ZXJdLmluY2x1ZGVzKGUua2V5Q29kZSkpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChbX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wia2V5Q29kZXNcIl0uZXNjLCBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJrZXlDb2Rlc1wiXS50YWJdLmluY2x1ZGVzKGUua2V5Q29kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VMaXN0SW5kZXgoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZUxpc3RJbmRleDogZnVuY3Rpb24gY2hhbmdlTGlzdEluZGV4KGUpIHtcbiAgICAgICAgICAgIC8vIEZvciBpbmZpbml0ZSBzY3JvbGwgYW5kIGF1dG9jb21wbGV0ZSwgcmUtZXZhbHVhdGUgY2hpbGRyZW5cbiAgICAgICAgICAgIHRoaXMuZ2V0VGlsZXMoKTtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImtleUNvZGVzXCJdLmRvd24gJiYgdGhpcy5saXN0SW5kZXggPCB0aGlzLnRpbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RJbmRleCsrO1xuICAgICAgICAgICAgICAgIC8vIEFsbG93IHVzZXIgdG8gc2V0IGxpc3RJbmRleCB0byAtMSBzb1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhlIGxpc3QgY2FuIGJlIHVuLWhpZ2hsaWdodGVkXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wia2V5Q29kZXNcIl0udXAgJiYgdGhpcy5saXN0SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdEluZGV4LS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wia2V5Q29kZXNcIl0uZW50ZXIgJiYgdGhpcy5saXN0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aWxlc1t0aGlzLmxpc3RJbmRleF0uY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VGlsZXM6IGZ1bmN0aW9uIGdldFRpbGVzKCkge1xuICAgICAgICAgICAgdGhpcy50aWxlcyA9IHRoaXMuJHJlZnMuY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCcudi1saXN0X190aWxlJyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WTWVudS9taXhpbnMvbWVudS1wb3NpdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVk1lbnUvbWl4aW5zL21lbnUtcG9zaXRpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyoqXG4gKiBNZW51IHBvc2l0aW9uXG4gKlxuICogQG1peGluXG4gKlxuICogVXNlZCBmb3IgY2FsY3VsYXRpbmcgYW4gYXV0b21hdGljIHBvc2l0aW9uICh1c2VkIGZvciBWU2VsZWN0KVxuICogV2lsbCBwb3NpdGlvbiB0aGUgVk1lbnUgY29udGVudCBwcm9wZXJseSBvdmVyIHRoZSBWU2VsZWN0XG4gKi9cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIC8vIFJldmlzaXQgdGhpc1xuICAgICAgICBjYWxjdWxhdGVTY3JvbGw6IGZ1bmN0aW9uIGNhbGN1bGF0ZVNjcm9sbCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA+PSB0aGlzLnN0b3BJbmRleCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9IHRoaXMuJHJlZnMuY29udGVudC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA+IHRoaXMuc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbFRvcCA9XG4gICAgICAgICAgICAgICAgLy8gVG9wIHBvc2l0aW9uIG9mIHNlbGVjdGVkIGl0ZW1cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggKiB0aGlzLnRpbGVIZWlnaHQgK1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBoYWxmIG9mIGEgdGlsZSdzIGhlaWdodFxuICAgICAgICAgICAgICAgIHRoaXMudGlsZUhlaWdodCAvIDIgK1xuICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIHBhZGRpbmcgb2Zmc2V0IG9uIGxpc3RzXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0T2Zmc2V0IC8gMiAtXG4gICAgICAgICAgICAgICAgLy8gSGFsZiBvZiB0aGUgYXV0byBjb250ZW50J3MgaGVpZ2h0XG4gICAgICAgICAgICAgICAgMTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuJHJlZnMuY29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMuY29udGVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGNMZWZ0QXV0bzogZnVuY3Rpb24gY2FsY0xlZnRBdXRvKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkgcmV0dXJuIDA7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5kaW1lbnNpb25zLmFjdGl2YXRvci5sZWZ0IC0gdGhpcy5kZWZhdWx0T2Zmc2V0ICogMik7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGNUb3BBdXRvOiBmdW5jdGlvbiBjYWxjVG9wQXV0bygpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gQXJyYXkuZnJvbSh0aGlzLnRpbGVzKS5maW5kSW5kZXgoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi5jbGFzc0xpc3QuY29udGFpbnMoJ3YtbGlzdF9fdGlsZS0tYWN0aXZlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgdGhpcy5zdG9wSW5kZXggPSB0aGlzLnRpbGVzLmxlbmd0aCA+IDQgPyB0aGlzLnRpbGVzLmxlbmd0aCAtIDQgOiB0aGlzLnRpbGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBhZGRpdGlvbmFsT2Zmc2V0ID0gdGhpcy5kZWZhdWx0T2Zmc2V0O1xuICAgICAgICAgICAgdmFyIG9mZnNldFBhZGRpbmc7XG4gICAgICAgICAgICAvLyBNZW51IHNob3VsZCBiZSBjZW50ZXJlZFxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggPiB0aGlzLnN0YXJ0SW5kZXggJiYgc2VsZWN0ZWRJbmRleCA8IHRoaXMuc3RvcEluZGV4KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0UGFkZGluZyA9IDEuNSAqIHRoaXMudGlsZUhlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBNZW51IHNob3VsZCBiZSBvZmZzZXQgdG9wXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkSW5kZXggPj0gdGhpcy5zdG9wSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBCZWluZyBvZmZzZXQgdG9wIG1lYW5zXG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBhY2NvdW50IGZvciB0b3BcbiAgICAgICAgICAgICAgICAvLyBhbmQgYm90dG9tIGxpc3QgcGFkZGluZ1xuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPZmZzZXQgKj0gMjtcbiAgICAgICAgICAgICAgICBvZmZzZXRQYWRkaW5nID0gKHNlbGVjdGVkSW5kZXggLSB0aGlzLnN0b3BJbmRleCkgKiB0aGlzLnRpbGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gTWVudSBzaG91bGQgYmUgb2Zmc2V0IGJvdHRvbVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRQYWRkaW5nID0gc2VsZWN0ZWRJbmRleCAqIHRoaXMudGlsZUhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkVG9wICsgYWRkaXRpb25hbE9mZnNldCAtIG9mZnNldFBhZGRpbmcgLSB0aGlzLnRpbGVIZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk1lc3NhZ2VzL1ZNZXNzYWdlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WTWVzc2FnZXMvVk1lc3NhZ2VzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19tZXNzYWdlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fbWVzc2FnZXMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19tZXNzYWdlcy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19tZXNzYWdlc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX21lc3NhZ2VzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbi8vIFN0eWxlc1xuXG4vLyBNaXhpbnNcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtbWVzc2FnZXMnLFxuICAgIG1peGluczogW19taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlbkNoaWxkcmVuOiBmdW5jdGlvbiBnZW5DaGlsZHJlbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0cmFuc2l0aW9uLWdyb3VwJywge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1tZXNzYWdlc19fd3JhcHBlcicsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21lc3NhZ2UtdHJhbnNpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHRhZzogJ2RpdidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLnZhbHVlLm1hcCh0aGlzLmdlbk1lc3NhZ2UpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuTWVzc2FnZTogZnVuY3Rpb24gZ2VuTWVzc2FnZShtZXNzYWdlLCBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LW1lc3NhZ2VzX19tZXNzYWdlJyxcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICBkb21Qcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUw6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICByZXR1cm4gaCgnZGl2JywgdGhpcy5zZXRUZXh0Q29sb3IodGhpcy5jb2xvciwge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LW1lc3NhZ2VzJyxcbiAgICAgICAgICAgIGNsYXNzOiB0aGlzLnRoZW1lQ2xhc3Nlc1xuICAgICAgICB9KSwgW3RoaXMuZ2VuQ2hpbGRyZW4oKV0pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZNZXNzYWdlcy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZNZXNzYWdlcy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWTWVzc2FnZXMsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZNZXNzYWdlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WTWVzc2FnZXMgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZNZXNzYWdlcy9WTWVzc2FnZXMuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWTWVzc2FnZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVk1lc3NhZ2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX1ZNZXNzYWdlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk5hdmlnYXRpb25EcmF3ZXIvVk5hdmlnYXRpb25EcmF3ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZOYXZpZ2F0aW9uRHJhd2VyL1ZOYXZpZ2F0aW9uRHJhd2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfbmF2aWdhdGlvbl9kcmF3ZXJfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX25hdmlnYXRpb24tZHJhd2VyLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fbmF2aWdhdGlvbi1kcmF3ZXIuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfbmF2aWdhdGlvbl9kcmF3ZXJfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19uYXZpZ2F0aW9uX2RyYXdlcl9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfYXBwbGljYXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvYXBwbGljYXRpb25hYmxlICovIFwiLi9zcmMvbWl4aW5zL2FwcGxpY2F0aW9uYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2RlcGVuZGVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2RlcGVuZGVudCAqLyBcIi4vc3JjL21peGlucy9kZXBlbmRlbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19vdmVybGF5YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL292ZXJsYXlhYmxlICovIFwiLi9zcmMvbWl4aW5zL292ZXJsYXlhYmxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfc3NyX2Jvb3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvc3NyLWJvb3RhYmxlICovIFwiLi9zcmMvbWl4aW5zL3Nzci1ib290YWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RoZW1lYWJsZSAqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RpcmVjdGl2ZXNfY2xpY2tfb3V0c2lkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlICovIFwiLi9zcmMvZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXJlY3RpdmVzX3Jlc2l6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUgKi8gXCIuL3NyYy9kaXJlY3RpdmVzL3Jlc2l6ZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlyZWN0aXZlc190b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGlyZWN0aXZlcy90b3VjaCAqLyBcIi4vc3JjL2RpcmVjdGl2ZXMvdG91Y2gudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vLyBNaXhpbnNcblxuXG5cblxuXG4vLyBEaXJlY3RpdmVzXG5cblxuXG4vLyBIZWxwZXJzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1uYXZpZ2F0aW9uLWRyYXdlcicsXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgICBDbGlja091dHNpZGU6IF9kaXJlY3RpdmVzX2NsaWNrX291dHNpZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFJlc2l6ZTogX2RpcmVjdGl2ZXNfcmVzaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBUb3VjaDogX2RpcmVjdGl2ZXNfdG91Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlZmF1bHRcIl1cbiAgICB9LFxuICAgIG1peGluczogW09iamVjdChfbWl4aW5zX2FwcGxpY2F0aW9uYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSkobnVsbCwgWydtaW5pVmFyaWFudCcsICdyaWdodCcsICd3aWR0aCddKSwgX21peGluc19kZXBlbmRlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfb3ZlcmxheWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfc3NyX2Jvb3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY2xpcHBlZDogQm9vbGVhbixcbiAgICAgICAgZGlzYWJsZVJvdXRlV2F0Y2hlcjogQm9vbGVhbixcbiAgICAgICAgZGlzYWJsZVJlc2l6ZVdhdGNoZXI6IEJvb2xlYW4sXG4gICAgICAgIGhlaWdodDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICcxMDAlJ1xuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZzogQm9vbGVhbixcbiAgICAgICAgbWluaVZhcmlhbnQ6IEJvb2xlYW4sXG4gICAgICAgIG1pbmlWYXJpYW50V2lkdGg6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiA4MFxuICAgICAgICB9LFxuICAgICAgICBtb2JpbGVCcmVha1BvaW50OiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogMTI2NFxuICAgICAgICB9LFxuICAgICAgICBwZXJtYW5lbnQ6IEJvb2xlYW4sXG4gICAgICAgIHJpZ2h0OiBCb29sZWFuLFxuICAgICAgICBzdGF0ZWxlc3M6IEJvb2xlYW4sXG4gICAgICAgIHRlbXBvcmFyeTogQm9vbGVhbixcbiAgICAgICAgdG91Y2hsZXNzOiBCb29sZWFuLFxuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDMwMFxuICAgICAgICB9LFxuICAgICAgICB2YWx1ZTogeyByZXF1aXJlZDogZmFsc2UgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIHRvdWNoQXJlYToge1xuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGZvciBzZXR0aW5nIGFuIGFwcFxuICAgICAgICAgKiB2YWx1ZSBmcm9tIGEgZHluYW1pY1xuICAgICAgICAgKiBwcm9wZXJ0eS4gQ2FsbGVkIGZyb21cbiAgICAgICAgICogYXBwbGljYXRpb25hYmxlLmpzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGFwcGxpY2F0aW9uUHJvcGVydHk6IGZ1bmN0aW9uIGFwcGxpY2F0aW9uUHJvcGVydHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGN1bGF0ZWRUcmFuc2Zvcm06IGZ1bmN0aW9uIGNhbGN1bGF0ZWRUcmFuc2Zvcm0oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkgcmV0dXJuIDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodCA/IHRoaXMuY2FsY3VsYXRlZFdpZHRoIDogLXRoaXMuY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjdWxhdGVkV2lkdGg6IGZ1bmN0aW9uIGNhbGN1bGF0ZWRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbmlWYXJpYW50ID8gdGhpcy5taW5pVmFyaWFudFdpZHRoIDogdGhpcy53aWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7ICd2LW5hdmlnYXRpb24tZHJhd2VyJzogdHJ1ZSwgJ3YtbmF2aWdhdGlvbi1kcmF3ZXItLWFic29sdXRlJzogdGhpcy5hYnNvbHV0ZSwgJ3YtbmF2aWdhdGlvbi1kcmF3ZXItLWNsaXBwZWQnOiB0aGlzLmNsaXBwZWQsICd2LW5hdmlnYXRpb24tZHJhd2VyLS1jbG9zZSc6ICF0aGlzLmlzQWN0aXZlLCAndi1uYXZpZ2F0aW9uLWRyYXdlci0tZml4ZWQnOiAhdGhpcy5hYnNvbHV0ZSAmJiAodGhpcy5hcHAgfHwgdGhpcy5maXhlZCksICd2LW5hdmlnYXRpb24tZHJhd2VyLS1mbG9hdGluZyc6IHRoaXMuZmxvYXRpbmcsICd2LW5hdmlnYXRpb24tZHJhd2VyLS1pcy1tb2JpbGUnOiB0aGlzLmlzTW9iaWxlLCAndi1uYXZpZ2F0aW9uLWRyYXdlci0tbWluaS12YXJpYW50JzogdGhpcy5taW5pVmFyaWFudCwgJ3YtbmF2aWdhdGlvbi1kcmF3ZXItLW9wZW4nOiB0aGlzLmlzQWN0aXZlLCAndi1uYXZpZ2F0aW9uLWRyYXdlci0tcmlnaHQnOiB0aGlzLnJpZ2h0LCAndi1uYXZpZ2F0aW9uLWRyYXdlci0tdGVtcG9yYXJ5JzogdGhpcy50ZW1wb3JhcnkgfSwgdGhpcy50aGVtZUNsYXNzZXMpO1xuICAgICAgICB9LFxuICAgICAgICBoYXNBcHA6IGZ1bmN0aW9uIGhhc0FwcCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcCAmJiAhdGhpcy5pc01vYmlsZSAmJiAhdGhpcy50ZW1wb3Jhcnk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzTW9iaWxlOiBmdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5zdGF0ZWxlc3MgJiYgIXRoaXMucGVybWFuZW50ICYmICF0aGlzLnRlbXBvcmFyeSAmJiB0aGlzLiR2dWV0aWZ5LmJyZWFrcG9pbnQud2lkdGggPCBwYXJzZUludCh0aGlzLm1vYmlsZUJyZWFrUG9pbnQsIDEwKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFyZ2luVG9wOiBmdW5jdGlvbiBtYXJnaW5Ub3AoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzQXBwKSByZXR1cm4gMDtcbiAgICAgICAgICAgIHZhciBtYXJnaW5Ub3AgPSB0aGlzLiR2dWV0aWZ5LmFwcGxpY2F0aW9uLmJhcjtcbiAgICAgICAgICAgIG1hcmdpblRvcCArPSB0aGlzLmNsaXBwZWQgPyB0aGlzLiR2dWV0aWZ5LmFwcGxpY2F0aW9uLnRvcCA6IDA7XG4gICAgICAgICAgICByZXR1cm4gbWFyZ2luVG9wO1xuICAgICAgICB9LFxuICAgICAgICBtYXhIZWlnaHQ6IGZ1bmN0aW9uIG1heEhlaWdodCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNBcHApIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIG1heEhlaWdodCA9IHRoaXMuJHZ1ZXRpZnkuYXBwbGljYXRpb24uYm90dG9tICsgdGhpcy4kdnVldGlmeS5hcHBsaWNhdGlvbi5mb290ZXIgKyB0aGlzLiR2dWV0aWZ5LmFwcGxpY2F0aW9uLmJhcjtcbiAgICAgICAgICAgIGlmICghdGhpcy5jbGlwcGVkKSByZXR1cm4gbWF4SGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIG1heEhlaWdodCArIHRoaXMuJHZ1ZXRpZnkuYXBwbGljYXRpb24udG9wO1xuICAgICAgICB9LFxuICAgICAgICByZWFjdHNUb0NsaWNrOiBmdW5jdGlvbiByZWFjdHNUb0NsaWNrKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLnN0YXRlbGVzcyAmJiAhdGhpcy5wZXJtYW5lbnQgJiYgKHRoaXMuaXNNb2JpbGUgfHwgdGhpcy50ZW1wb3JhcnkpO1xuICAgICAgICB9LFxuICAgICAgICByZWFjdHNUb01vYmlsZTogZnVuY3Rpb24gcmVhY3RzVG9Nb2JpbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuZGlzYWJsZVJlc2l6ZVdhdGNoZXIgJiYgIXRoaXMuc3RhdGVsZXNzICYmICF0aGlzLnBlcm1hbmVudCAmJiAhdGhpcy50ZW1wb3Jhcnk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWN0c1RvUm91dGU6IGZ1bmN0aW9uIHJlYWN0c1RvUm91dGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuZGlzYWJsZVJvdXRlV2F0Y2hlciAmJiAhdGhpcy5zdGF0ZWxlc3MgJiYgKHRoaXMudGVtcG9yYXJ5IHx8IHRoaXMuaXNNb2JpbGUpO1xuICAgICAgICB9LFxuICAgICAgICByZXNpemVJc0Rpc2FibGVkOiBmdW5jdGlvbiByZXNpemVJc0Rpc2FibGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZVJlc2l6ZVdhdGNoZXIgfHwgdGhpcy5zdGF0ZWxlc3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dPdmVybGF5OiBmdW5jdGlvbiBzaG93T3ZlcmxheSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQWN0aXZlICYmICh0aGlzLmlzTW9iaWxlIHx8IHRoaXMudGVtcG9yYXJ5KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGVzOiBmdW5jdGlvbiBzdHlsZXMoKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImNvbnZlcnRUb1VuaXRcIl0pKHRoaXMuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IHRoaXMubWFyZ2luVG9wICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIG1heEhlaWdodDogXCJjYWxjKDEwMCUgLSBcIiArICt0aGlzLm1heEhlaWdodCArIFwicHgpXCIsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoXCIgKyB0aGlzLmNhbGN1bGF0ZWRUcmFuc2Zvcm0gKyBcInB4KVwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmNhbGN1bGF0ZWRXaWR0aCArIFwicHhcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgICRyb3V0ZTogZnVuY3Rpb24gJHJvdXRlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhY3RzVG9Sb3V0ZSAmJiB0aGlzLmNsb3NlQ29uZGl0aW9uYWwoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKHZhbCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB2YWwpO1xuICAgICAgICAgICAgdGhpcy5jYWxsVXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIG1vYmlsZSBjaGFuZ2VzLCBhZGp1c3RcbiAgICAgICAgICogdGhlIGFjdGl2ZSBzdGF0ZSBvbmx5IHdoZW5cbiAgICAgICAgICogdGhlcmUgaGFzIGJlZW4gYSBwcmV2aW91c1xuICAgICAgICAgKiB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgaXNNb2JpbGU6IGZ1bmN0aW9uIGlzTW9iaWxlKHZhbCwgcHJldikge1xuICAgICAgICAgICAgIXZhbCAmJiB0aGlzLmlzQWN0aXZlICYmICF0aGlzLnRlbXBvcmFyeSAmJiB0aGlzLnJlbW92ZU92ZXJsYXkoKTtcbiAgICAgICAgICAgIGlmIChwcmV2ID09IG51bGwgfHwgdGhpcy5yZXNpemVJc0Rpc2FibGVkIHx8ICF0aGlzLnJlYWN0c1RvTW9iaWxlKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gIXZhbDtcbiAgICAgICAgICAgIHRoaXMuY2FsbFVwZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBwZXJtYW5lbnQ6IGZ1bmN0aW9uIHBlcm1hbmVudCh2YWwpIHtcbiAgICAgICAgICAgIC8vIElmIGVuYWJsaW5nIHByb3BcbiAgICAgICAgICAgIC8vIGVuYWJsZSB0aGUgZHJhd2VyXG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbGxVcGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd092ZXJsYXk6IGZ1bmN0aW9uIHNob3dPdmVybGF5KHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCkgdGhpcy5nZW5PdmVybGF5KCk7ZWxzZSB0aGlzLnJlbW92ZU92ZXJsYXkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGVtcG9yYXJ5OiBmdW5jdGlvbiB0ZW1wb3JhcnkoKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxVcGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHZhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVybWFuZW50KSByZXR1cm47XG4gICAgICAgICAgICBpZiAodmFsID09IG51bGwpIHJldHVybiB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHRoaXMuaXNBY3RpdmUpIHRoaXMuaXNBY3RpdmUgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGNhbGN1bGF0ZVRvdWNoQXJlYTogZnVuY3Rpb24gY2FsY3VsYXRlVG91Y2hBcmVhKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiRlbC5wYXJlbnROb2RlKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgcGFyZW50UmVjdCA9IHRoaXMuJGVsLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnRvdWNoQXJlYSA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBwYXJlbnRSZWN0LmxlZnQgKyA1MCxcbiAgICAgICAgICAgICAgICByaWdodDogcGFyZW50UmVjdC5yaWdodCAtIDUwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZUNvbmRpdGlvbmFsOiBmdW5jdGlvbiBjbG9zZUNvbmRpdGlvbmFsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBY3RpdmUgJiYgdGhpcy5yZWFjdHNUb0NsaWNrO1xuICAgICAgICB9LFxuICAgICAgICBnZW5EaXJlY3RpdmVzOiBmdW5jdGlvbiBnZW5EaXJlY3RpdmVzKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVzID0gW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2xpY2stb3V0c2lkZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VDb25kaXRpb25hbDogdGhpcy5jbG9zZUNvbmRpdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlOiB0aGlzLmdldE9wZW5EZXBlbmRlbnRFbGVtZW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgIXRoaXMudG91Y2hsZXNzICYmIGRpcmVjdGl2ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuc3dpcGVMZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5zd2lwZVJpZ2h0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgc3RhdGUgYmVmb3JlIG1vdW50IHRvIGF2b2lkXG4gICAgICAgICAqIGVudHJ5IHRyYW5zaXRpb25zIGluIFNTUlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcm1hbmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlbGVzcyB8fCB0aGlzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMudGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9ICF0aGlzLmlzTW9iaWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzd2lwZVJpZ2h0OiBmdW5jdGlvbiBzd2lwZVJpZ2h0KGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlICYmICF0aGlzLnJpZ2h0KSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVRvdWNoQXJlYSgpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGUudG91Y2hlbmRYIC0gZS50b3VjaHN0YXJ0WCkgPCAxMDApIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdGhpcy5yaWdodCAmJiBlLnRvdWNoc3RhcnRYIDw9IHRoaXMudG91Y2hBcmVhLmxlZnQpIHRoaXMuaXNBY3RpdmUgPSB0cnVlO2Vsc2UgaWYgKHRoaXMucmlnaHQgJiYgdGhpcy5pc0FjdGl2ZSkgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBzd2lwZUxlZnQ6IGZ1bmN0aW9uIHN3aXBlTGVmdChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSAmJiB0aGlzLnJpZ2h0KSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVRvdWNoQXJlYSgpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGUudG91Y2hlbmRYIC0gZS50b3VjaHN0YXJ0WCkgPCAxMDApIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICYmIGUudG91Y2hzdGFydFggPj0gdGhpcy50b3VjaEFyZWEucmlnaHQpIHRoaXMuaXNBY3RpdmUgPSB0cnVlO2Vsc2UgaWYgKCF0aGlzLnJpZ2h0ICYmIHRoaXMuaXNBY3RpdmUpIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgYXBwbGljYXRpb24gbGF5b3V0XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUFwcGxpY2F0aW9uOiBmdW5jdGlvbiB1cGRhdGVBcHBsaWNhdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5pc0FjdGl2ZSB8fCB0aGlzLnRlbXBvcmFyeSB8fCB0aGlzLmlzTW9iaWxlID8gMCA6IHRoaXMuY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy5jbGFzc2VzLFxuICAgICAgICAgICAgc3R5bGU6IHRoaXMuc3R5bGVzLFxuICAgICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5nZW5EaXJlY3RpdmVzKCksXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5taW5pVmFyaWFudCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kZW1pdCgndXBkYXRlOm1pbmlWYXJpYW50JywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbmVuZDogZnVuY3Rpb24gdHJhbnNpdGlvbmVuZChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLiRlbWl0KCd0cmFuc2l0aW9uZW5kJywgZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBuZXcgRXZlbnQoJ3Jlc2l6ZScpXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNpemVFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdVSUV2ZW50cycpO1xuICAgICAgICAgICAgICAgICAgICByZXNpemVFdmVudC5pbml0VUlFdmVudCgncmVzaXplJywgdHJ1ZSwgZmFsc2UsIHdpbmRvdywgMCk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KHJlc2l6ZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBoKCdhc2lkZScsIGRhdGEsIFt0aGlzLiRzbG90cy5kZWZhdWx0LCBoKCdkaXYnLCB7ICdjbGFzcyc6ICd2LW5hdmlnYXRpb24tZHJhd2VyX19ib3JkZXInIH0pXSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk5hdmlnYXRpb25EcmF3ZXIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZOYXZpZ2F0aW9uRHJhd2VyL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVk5hdmlnYXRpb25EcmF3ZXIsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZOYXZpZ2F0aW9uRHJhd2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZOYXZpZ2F0aW9uRHJhd2VyICovIFwiLi9zcmMvY29tcG9uZW50cy9WTmF2aWdhdGlvbkRyYXdlci9WTmF2aWdhdGlvbkRyYXdlci5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZOYXZpZ2F0aW9uRHJhd2VyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZOYXZpZ2F0aW9uRHJhd2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX1ZOYXZpZ2F0aW9uRHJhd2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WT3ZlcmZsb3dCdG4vVk92ZXJmbG93QnRuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZPdmVyZmxvd0J0bi9WT3ZlcmZsb3dCdG4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX292ZXJmbG93X2J1dHRvbnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX292ZXJmbG93LWJ1dHRvbnMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19vdmVyZmxvdy1idXR0b25zLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX292ZXJmbG93X2J1dHRvbnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19vdmVyZmxvd19idXR0b25zX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZTZWxlY3RfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVlNlbGVjdC9WU2VsZWN0ICovIFwiLi9zcmMvY29tcG9uZW50cy9WU2VsZWN0L1ZTZWxlY3QuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZBdXRvY29tcGxldGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZBdXRvY29tcGxldGUgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZBdXRvY29tcGxldGUvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUZXh0RmllbGRfVlRleHRGaWVsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVlRleHRGaWVsZC9WVGV4dEZpZWxkICovIFwiLi9zcmMvY29tcG9uZW50cy9WVGV4dEZpZWxkL1ZUZXh0RmllbGQuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZCdG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZCdG4gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZCdG4vaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9jb25zb2xlICovIFwiLi9zcmMvdXRpbC9jb25zb2xlLnRzXCIpO1xuLy8gU3R5bGVzXG5cbi8vIEV4dGVuc2lvbnNcblxuXG5cblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3Ytb3ZlcmZsb3ctYnRuJyxcbiAgICBleHRlbmRzOiBfVkF1dG9jb21wbGV0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSxcbiAgICBwcm9wczoge1xuICAgICAgICBzZWdtZW50ZWQ6IEJvb2xlYW4sXG4gICAgICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgICAgICB0cmFuc2l0aW9uOiBfVlNlbGVjdF9WU2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLnByb3BzLnRyYW5zaXRpb25cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihfVkF1dG9jb21wbGV0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5jb21wdXRlZC5jbGFzc2VzLmNhbGwodGhpcyksIHtcbiAgICAgICAgICAgICAgICAndi1vdmVyZmxvdy1idG4nOiB0cnVlLFxuICAgICAgICAgICAgICAgICd2LW92ZXJmbG93LWJ0bi0tc2VnbWVudGVkJzogdGhpcy5zZWdtZW50ZWQsXG4gICAgICAgICAgICAgICAgJ3Ytb3ZlcmZsb3ctYnRuLS1lZGl0YWJsZSc6IHRoaXMuZWRpdGFibGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBpc0FueVZhbHVlQWxsb3dlZDogZnVuY3Rpb24gaXNBbnlWYWx1ZUFsbG93ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0YWJsZSB8fCBfVkF1dG9jb21wbGV0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5jb21wdXRlZC5pc0FueVZhbHVlQWxsb3dlZC5jYWxsKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBpc1NpbmdsZTogZnVuY3Rpb24gaXNTaW5nbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWRJdGVtczogZnVuY3Rpb24gY29tcHV0ZWRJdGVtcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRlZCA/IHRoaXMuYWxsSXRlbXMgOiB0aGlzLmZpbHRlcmVkSXRlbXM7XG4gICAgICAgIH0sXG4gICAgICAgICRfbWVudVByb3BzOiBmdW5jdGlvbiAkX21lbnVQcm9wcygpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IF9WQXV0b2NvbXBsZXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLmNvbXB1dGVkLiRfbWVudVByb3BzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBwcm9wcy50cmFuc2l0aW9uID0gcHJvcHMudHJhbnNpdGlvbiB8fCAndi1tZW51LXRyYW5zaXRpb24nO1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlblNlbGVjdGlvbnM6IGZ1bmN0aW9uIGdlblNlbGVjdGlvbnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0YWJsZSA/IF9WQXV0b2NvbXBsZXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLm1ldGhvZHMuZ2VuU2VsZWN0aW9ucy5jYWxsKHRoaXMpIDogX1ZTZWxlY3RfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLmdlblNlbGVjdGlvbnMuY2FsbCh0aGlzKTsgLy8gT3ZlcnJpZGUgdi1hdXRvY29tcGxldGUncyBvdmVycmlkZVxuICAgICAgICB9LFxuICAgICAgICBnZW5Db21tYVNlbGVjdGlvbjogZnVuY3Rpb24gZ2VuQ29tbWFTZWxlY3Rpb24oaXRlbSwgaW5kZXgsIGxhc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRlZCA/IHRoaXMuZ2VuU2VnbWVudGVkQnRuKGl0ZW0pIDogX1ZTZWxlY3RfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLmdlbkNvbW1hU2VsZWN0aW9uLmNhbGwodGhpcywgaXRlbSwgaW5kZXgsIGxhc3QpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5JbnB1dDogZnVuY3Rpb24gZ2VuSW5wdXQoKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBfVlRleHRGaWVsZF9WVGV4dEZpZWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLm1ldGhvZHMuZ2VuSW5wdXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlucHV0LmRhdGEuZG9tUHJvcHMudmFsdWUgPSB0aGlzLmVkaXRhYmxlID8gdGhpcy5pbnRlcm5hbFNlYXJjaCA6ICcnO1xuICAgICAgICAgICAgaW5wdXQuZGF0YS5hdHRycy5yZWFkb25seSA9ICF0aGlzLmlzQW55VmFsdWVBbGxvd2VkO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9LFxuICAgICAgICBnZW5MYWJlbDogZnVuY3Rpb24gZ2VuTGFiZWwoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0YWJsZSAmJiB0aGlzLmlzRm9jdXNlZCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBfVlRleHRGaWVsZF9WVGV4dEZpZWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLm1ldGhvZHMuZ2VuTGFiZWwuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICghbGFiZWwpIHJldHVybiBsYWJlbDtcbiAgICAgICAgICAgIC8vIFJlc2V0IHByZXZpb3VzbHkgc2V0IHN0eWxlcyBmcm9tIHBhcmVudFxuICAgICAgICAgICAgbGFiZWwuZGF0YS5zdHlsZSA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICB9LFxuICAgICAgICBnZW5TZWdtZW50ZWRCdG46IGZ1bmN0aW9uIGdlblNlZ21lbnRlZEJ0bihpdGVtKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGl0ZW1WYWx1ZSA9IHRoaXMuZ2V0VmFsdWUoaXRlbSk7XG4gICAgICAgICAgICB2YXIgaXRlbU9iaiA9IHRoaXMuY29tcHV0ZWRJdGVtcy5maW5kKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFZhbHVlKGkpID09PSBpdGVtVmFsdWU7XG4gICAgICAgICAgICB9KSB8fCBpdGVtO1xuICAgICAgICAgICAgaWYgKCFpdGVtT2JqLnRleHQgfHwgIWl0ZW1PYmouY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiY29uc29sZVdhcm5cIl0pKCdXaGVuIHVzaW5nIFxcJ3NlZ21lbnRlZFxcJyBwcm9wIHdpdGhvdXQgYSBzZWxlY3Rpb24gc2xvdCwgaXRlbXMgbXVzdCBjb250YWluIGJvdGggYSB0ZXh0IGFuZCBjYWxsYmFjayBwcm9wZXJ0eScsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZCdG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICAgICAgICBwcm9wczogeyBmbGF0OiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtT2JqLmNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW2l0ZW1PYmoudGV4dF0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRTZWxlY3RlZEl0ZW1zOiBmdW5jdGlvbiBzZXRTZWxlY3RlZEl0ZW1zKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtcyA9IFt0aGlzLmludGVybmFsVmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk92ZXJmbG93QnRuL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVk92ZXJmbG93QnRuL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZPdmVyZmxvd0J0biwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVk92ZXJmbG93QnRuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZPdmVyZmxvd0J0biAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk92ZXJmbG93QnRuL1ZPdmVyZmxvd0J0bi5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZPdmVyZmxvd0J0blwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WT3ZlcmZsb3dCdG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVk92ZXJmbG93QnRuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WUGFnaW5hdGlvbi9WUGFnaW5hdGlvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlBhZ2luYXRpb24vVlBhZ2luYXRpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19wYWdpbmF0aW9uX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19wYWdpbmF0aW9uLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fcGFnaW5hdGlvbi5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19wYWdpbmF0aW9uX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfcGFnaW5hdGlvbl9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVkljb24gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJY29uL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXJlY3RpdmVzX3Jlc2l6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUgKi8gXCIuL3NyYy9kaXJlY3RpdmVzL3Jlc2l6ZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3JlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fcmVhZCB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgICByLFxuICAgICAgICBhciA9IFtdLFxuICAgICAgICBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19zcHJlYWQgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICB9cmV0dXJuIGFyO1xufTtcblxuXG4vLyBEaXJlY3RpdmVzXG5cbi8vIE1peGluc1xuXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoT2JqZWN0KF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSkoX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LXBhZ2luYXRpb24nLFxuICAgIGRpcmVjdGl2ZXM6IHsgUmVzaXplOiBfZGlyZWN0aXZlc19yZXNpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0gfSxcbiAgICBwcm9wczoge1xuICAgICAgICBjaXJjbGU6IEJvb2xlYW4sXG4gICAgICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsICUgMSA9PT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG90YWxWaXNpYmxlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBuZXh0SWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5Lmljb25zLm5leHQnXG4gICAgICAgIH0sXG4gICAgICAgIHByZXZJY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMucHJldidcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1heEJ1dHRvbnM6IDAsXG4gICAgICAgICAgICBzZWxlY3RlZDogbnVsbFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7ICd2LXBhZ2luYXRpb24nOiB0cnVlLCAndi1wYWdpbmF0aW9uLS1jaXJjbGUnOiB0aGlzLmNpcmNsZSwgJ3YtcGFnaW5hdGlvbi0tZGlzYWJsZWQnOiB0aGlzLmRpc2FibGVkIH0sIHRoaXMudGhlbWVDbGFzc2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbXM6IGZ1bmN0aW9uIGl0ZW1zKCkge1xuICAgICAgICAgICAgdmFyIG1heExlbmd0aCA9IHBhcnNlSW50KHRoaXMudG90YWxWaXNpYmxlLCAxMCkgfHwgdGhpcy5tYXhCdXR0b25zO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDw9IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlKDEsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVuID0gbWF4TGVuZ3RoICUgMiA9PT0gMCA/IDEgOiAwO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBNYXRoLmZsb29yKG1heExlbmd0aCAvIDIpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5sZW5ndGggLSBsZWZ0ICsgMSArIGV2ZW47XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA+IGxlZnQgJiYgdGhpcy52YWx1ZSA8IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy52YWx1ZSAtIGxlZnQgKyAyO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLnZhbHVlICsgbGVmdCAtIDIgLSBldmVuO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZChbMSwgJy4uLiddLCB0aGlzLnJhbmdlKHN0YXJ0LCBlbmQpLCBbJy4uLicsIHRoaXMubGVuZ3RoXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgPT09IGxlZnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy52YWx1ZSArIGxlZnQgLSAxIC0gZXZlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWQodGhpcy5yYW5nZSgxLCBlbmQpLCBbJy4uLicsIHRoaXMubGVuZ3RoXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgPT09IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy52YWx1ZSAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZChbMSwgJy4uLiddLCB0aGlzLnJhbmdlKHN0YXJ0LCB0aGlzLmxlbmd0aCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWQodGhpcy5yYW5nZSgxLCBsZWZ0KSwgWycuLi4nXSwgdGhpcy5yYW5nZShyaWdodCwgdGhpcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2sodGhpcy5vblJlc2l6ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBDaGFuZ2UgdGhpcyAoZjc1ZGVlM2EsIGNiZGY3Y2FhKVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlbGVjdGVkID0gX3RoaXMudmFsdWU7XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9LFxuICAgICAgICBvblJlc2l6ZTogZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLiRlbCAmJiB0aGlzLiRlbC5wYXJlbnRFbGVtZW50ID8gdGhpcy4kZWwucGFyZW50RWxlbWVudC5jbGllbnRXaWR0aCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgdGhpcy5tYXhCdXR0b25zID0gTWF0aC5mbG9vcigod2lkdGggLSA5NikgLyA0Mik7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLnZhbHVlICsgMSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCduZXh0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cyhlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHRoaXMudmFsdWUgLSAxKTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3ByZXZpb3VzJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJhbmdlOiBmdW5jdGlvbiByYW5nZShmcm9tLCB0bykge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gW107XG4gICAgICAgICAgICBmcm9tID0gZnJvbSA+IDAgPyBmcm9tIDogMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDw9IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICByYW5nZS5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9LFxuICAgICAgICBnZW5JY29uOiBmdW5jdGlvbiBnZW5JY29uKGgsIGljb24sIGRpc2FibGVkLCBmbikge1xuICAgICAgICAgICAgcmV0dXJuIGgoJ2xpJywgW2goJ2J1dHRvbicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtcGFnaW5hdGlvbl9fbmF2aWdhdGlvbicsXG4gICAgICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3YtcGFnaW5hdGlvbl9fbmF2aWdhdGlvbi0tZGlzYWJsZWQnOiBkaXNhYmxlZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2J1dHRvbidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uOiBkaXNhYmxlZCA/IHt9IDogeyBjbGljazogZm4gfVxuICAgICAgICAgICAgfSwgW2goX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCBbaWNvbl0pXSldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSXRlbTogZnVuY3Rpb24gZ2VuSXRlbShoLCBpKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gaSA9PT0gdGhpcy52YWx1ZSAmJiAodGhpcy5jb2xvciB8fCAncHJpbWFyeScpO1xuICAgICAgICAgICAgcmV0dXJuIGgoJ2J1dHRvbicsIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKGNvbG9yLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXBhZ2luYXRpb25fX2l0ZW0nLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgICAgICd2LXBhZ2luYXRpb25fX2l0ZW0tLWFjdGl2ZSc6IGkgPT09IHRoaXMudmFsdWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdidXR0b24nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJGVtaXQoJ2lucHV0JywgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgW2kudG9TdHJpbmcoKV0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5JdGVtczogZnVuY3Rpb24gZ2VuSXRlbXMoaCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLm1hcChmdW5jdGlvbiAoaSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaCgnbGknLCB7IGtleTogaW5kZXggfSwgW2lzTmFOKE51bWJlcihpKSkgPyBoKCdzcGFuJywgeyBjbGFzczogJ3YtcGFnaW5hdGlvbl9fbW9yZScgfSwgW2kudG9TdHJpbmcoKV0pIDogX3RoaXMuZ2VuSXRlbShoLCBpKV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW3RoaXMuZ2VuSWNvbihoLCB0aGlzLiR2dWV0aWZ5LnJ0bCA/IHRoaXMubmV4dEljb24gOiB0aGlzLnByZXZJY29uLCB0aGlzLnZhbHVlIDw9IDEsIHRoaXMucHJldmlvdXMpLCB0aGlzLmdlbkl0ZW1zKGgpLCB0aGlzLmdlbkljb24oaCwgdGhpcy4kdnVldGlmeS5ydGwgPyB0aGlzLnByZXZJY29uIDogdGhpcy5uZXh0SWNvbiwgdGhpcy52YWx1ZSA+PSB0aGlzLmxlbmd0aCwgdGhpcy5uZXh0KV07XG4gICAgICAgIHJldHVybiBoKCd1bCcsIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzOiB7IHF1aWV0OiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgbmFtZTogJ3Jlc2l6ZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMub25SZXNpemVcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgY2xhc3M6IHRoaXMuY2xhc3Nlc1xuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZQYWdpbmF0aW9uL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WUGFnaW5hdGlvbi9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZQYWdpbmF0aW9uLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WUGFnaW5hdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WUGFnaW5hdGlvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlBhZ2luYXRpb24vVlBhZ2luYXRpb24udHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWUGFnaW5hdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WUGFnaW5hdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WUGFnaW5hdGlvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlBhcmFsbGF4L1ZQYXJhbGxheC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WUGFyYWxsYXgvVlBhcmFsbGF4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19wYXJhbGxheF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fcGFyYWxsYXguc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19wYXJhbGxheC5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19wYXJhbGxheF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX3BhcmFsbGF4X3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190cmFuc2xhdGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90cmFuc2xhdGFibGUgKi8gXCIuL3NyYy9taXhpbnMvdHJhbnNsYXRhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9taXhpbnMgKi8gXCIuL3NyYy91dGlsL21peGlucy50c1wiKTtcbi8vIFN0eWxlXG5cbi8vIE1peGluc1xuXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE9iamVjdChfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0pKF9taXhpbnNfdHJhbnNsYXRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LXBhcmFsbGF4JyxcbiAgICBwcm9wczoge1xuICAgICAgICBhbHQ6IFN0cmluZyxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgICAgICAgZGVmYXVsdDogNTAwXG4gICAgICAgIH0sXG4gICAgICAgIHNyYzogU3RyaW5nXG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNCb290ZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBzdHlsZXM6IGZ1bmN0aW9uIHN0eWxlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLmlzQm9vdGVkID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlLCBcIiArIHRoaXMucGFyYWxsYXggKyBcInB4KVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBwYXJhbGxheDogZnVuY3Rpb24gcGFyYWxsYXgoKSB7XG4gICAgICAgICAgICB0aGlzLmlzQm9vdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGltZyA9IHRoaXMuJHJlZnMuaW1nO1xuICAgICAgICAgICAgaWYgKCFpbWcpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChpbWcuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvYmpIZWlnaHQ6IGZ1bmN0aW9uIG9iakhlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmltZy5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBpbWdEYXRhID0ge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXBhcmFsbGF4X19pbWFnZScsXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIHNyYzogdGhpcy5zcmNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWY6ICdpbWcnXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmFsdCkgaW1nRGF0YS5hdHRycy5hbHQgPSB0aGlzLmFsdDtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGgoJ2RpdicsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1wYXJhbGxheF9faW1hZ2UtY29udGFpbmVyJ1xuICAgICAgICB9LCBbaCgnaW1nJywgaW1nRGF0YSldKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBoKCdkaXYnLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtcGFyYWxsYXhfX2NvbnRlbnQnXG4gICAgICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXBhcmFsbGF4JyxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCArIFwicHhcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgICAgfSwgW2NvbnRhaW5lciwgY29udGVudF0pO1xuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WUGFyYWxsYXgvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WUGFyYWxsYXgvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlBhcmFsbGF4LCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WUGFyYWxsYXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlBhcmFsbGF4ICovIFwiLi9zcmMvY29tcG9uZW50cy9WUGFyYWxsYXgvVlBhcmFsbGF4LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlBhcmFsbGF4XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZQYXJhbGxheF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WUGFyYWxsYXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZQaWNrZXIvVlBpY2tlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZQaWNrZXIvVlBpY2tlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19waWNrZXJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19waWNrZXJzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fcGlja2Vycy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19waWNrZXJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfcGlja2Vyc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19jYXJkc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fY2FyZHMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19jYXJkcy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19jYXJkc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX2NhcmRzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cblxuLy8gTWl4aW5zXG5cblxuLy8gSGVscGVyc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtcGlja2VyJyxcbiAgICBtaXhpbnM6IFtfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGZ1bGxXaWR0aDogQm9vbGVhbixcbiAgICAgICAgbGFuZHNjYXBlOiBCb29sZWFuLFxuICAgICAgICB0cmFuc2l0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnZmFkZS10cmFuc2l0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDI5MFxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjb21wdXRlZFRpdGxlQ29sb3I6IGZ1bmN0aW9uIGNvbXB1dGVkVGl0bGVDb2xvcigpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VGl0bGVDb2xvciA9IHRoaXMuaXNEYXJrID8gbnVsbCA6IHRoaXMuY29sb3IgfHwgJ3ByaW1hcnknO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sb3IgfHwgZGVmYXVsdFRpdGxlQ29sb3I7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuVGl0bGU6IGZ1bmN0aW9uIGdlblRpdGxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMuY29tcHV0ZWRUaXRsZUNvbG9yLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXBpY2tlcl9fdGl0bGUnLFxuICAgICAgICAgICAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3YtcGlja2VyX190aXRsZS0tbGFuZHNjYXBlJzogdGhpcy5sYW5kc2NhcGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgdGhpcy4kc2xvdHMudGl0bGUpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5Cb2R5VHJhbnNpdGlvbjogZnVuY3Rpb24gZ2VuQm9keVRyYW5zaXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndHJhbnNpdGlvbicsIHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLnRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuQm9keTogZnVuY3Rpb24gZ2VuQm9keSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXBpY2tlcl9fYm9keScsXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy50aGVtZUNsYXNzZXMsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHRoaXMuZnVsbFdpZHRoID8gdW5kZWZpbmVkIDoge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImNvbnZlcnRUb1VuaXRcIl0pKHRoaXMud2lkdGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW3RoaXMuZ2VuQm9keVRyYW5zaXRpb24oKV0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5BY3Rpb25zOiBmdW5jdGlvbiBnZW5BY3Rpb25zKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtcGlja2VyX19hY3Rpb25zIHYtY2FyZF9fYWN0aW9ucydcbiAgICAgICAgICAgIH0sIHRoaXMuJHNsb3RzLmFjdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtcGlja2VyIHYtY2FyZCcsXG4gICAgICAgICAgICAnY2xhc3MnOiBfX2Fzc2lnbih7ICd2LXBpY2tlci0tbGFuZHNjYXBlJzogdGhpcy5sYW5kc2NhcGUsICd2LXBpY2tlci0tZnVsbC13aWR0aCc6IHRoaXMuZnVsbFdpZHRoIH0sIHRoaXMudGhlbWVDbGFzc2VzKVxuICAgICAgICB9LCBbdGhpcy4kc2xvdHMudGl0bGUgPyB0aGlzLmdlblRpdGxlKCkgOiBudWxsLCB0aGlzLmdlbkJvZHkoKSwgdGhpcy4kc2xvdHMuYWN0aW9ucyA/IHRoaXMuZ2VuQWN0aW9ucygpIDogbnVsbF0pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZQaWNrZXIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlBpY2tlci9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlBpY2tlciwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlBpY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WUGlja2VyICovIFwiLi9zcmMvY29tcG9uZW50cy9WUGlja2VyL1ZQaWNrZXIuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWUGlja2VyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVlBpY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlByb2dyZXNzQ2lyY3VsYXIvVlByb2dyZXNzQ2lyY3VsYXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZQcm9ncmVzc0NpcmN1bGFyL1ZQcm9ncmVzc0NpcmN1bGFyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfcHJvZ3Jlc3NfY2lyY3VsYXJfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3Byb2dyZXNzLWNpcmN1bGFyLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fcHJvZ3Jlc3MtY2lyY3VsYXIuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfcHJvZ3Jlc3NfY2lyY3VsYXJfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19wcm9ncmVzc19jaXJjdWxhcl9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG5cbi8vIE1peGluc1xuXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE9iamVjdChfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0pKF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LXByb2dyZXNzLWNpcmN1bGFyJyxcbiAgICBwcm9wczoge1xuICAgICAgICBidXR0b246IEJvb2xlYW4sXG4gICAgICAgIGluZGV0ZXJtaW5hdGU6IEJvb2xlYW4sXG4gICAgICAgIHJvdGF0ZToge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogMzJcbiAgICAgICAgfSxcbiAgICAgICAgd2lkdGg6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IDRcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNhbGN1bGF0ZWRTaXplOiBmdW5jdGlvbiBjYWxjdWxhdGVkU2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5zaXplKSArICh0aGlzLmJ1dHRvbiA/IDggOiAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2lyY3VtZmVyZW5jZTogZnVuY3Rpb24gY2lyY3VtZmVyZW5jZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAyICogTWF0aC5QSSAqIHRoaXMucmFkaXVzO1xuICAgICAgICB9LFxuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndi1wcm9ncmVzcy1jaXJjdWxhci0taW5kZXRlcm1pbmF0ZSc6IHRoaXMuaW5kZXRlcm1pbmF0ZSxcbiAgICAgICAgICAgICAgICAndi1wcm9ncmVzcy1jaXJjdWxhci0tYnV0dG9uJzogdGhpcy5idXR0b25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplZFZhbHVlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA+IDEwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy52YWx1ZSwgMTApO1xuICAgICAgICB9LFxuICAgICAgICByYWRpdXM6IGZ1bmN0aW9uIHJhZGl1cygpIHtcbiAgICAgICAgICAgIHJldHVybiAyMDtcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiBmdW5jdGlvbiBzdHJva2VEYXNoQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLmNpcmN1bWZlcmVuY2UgKiAxMDAwKSAvIDEwMDA7XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIHN0cm9rZURhc2hPZmZzZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gKDEwMCAtIHRoaXMubm9ybWFsaXplZFZhbHVlKSAvIDEwMCAqIHRoaXMuY2lyY3VtZmVyZW5jZSArICdweCc7XG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiBmdW5jdGlvbiBzdHJva2VXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoIC8gK3RoaXMuc2l6ZSAqIHRoaXMudmlld0JveFNpemUgKiAyO1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZXM6IGZ1bmN0aW9uIHN0eWxlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmNhbGN1bGF0ZWRTaXplICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmNhbGN1bGF0ZWRTaXplICsgXCJweFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzdmdTdHlsZXM6IGZ1bmN0aW9uIHN2Z1N0eWxlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZShcIiArIHRoaXMucm90YXRlICsgXCJkZWcpXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHZpZXdCb3hTaXplOiBmdW5jdGlvbiB2aWV3Qm94U2l6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhZGl1cyAvICgxIC0gdGhpcy53aWR0aCAvICt0aGlzLnNpemUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlbkNpcmNsZTogZnVuY3Rpb24gZ2VuQ2lyY2xlKGgsIG5hbWUsIG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoJ2NpcmNsZScsIHtcbiAgICAgICAgICAgICAgICBjbGFzczogXCJ2LXByb2dyZXNzLWNpcmN1bGFyX19cIiArIG5hbWUsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICAgICAgY3g6IDIgKiB0aGlzLnZpZXdCb3hTaXplLFxuICAgICAgICAgICAgICAgICAgICBjeTogMiAqIHRoaXMudmlld0JveFNpemUsXG4gICAgICAgICAgICAgICAgICAgIHI6IHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiB0aGlzLnN0cm9rZURhc2hBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0Jzogb2Zmc2V0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblN2ZzogZnVuY3Rpb24gZ2VuU3ZnKGgpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFt0aGlzLmluZGV0ZXJtaW5hdGUgfHwgdGhpcy5nZW5DaXJjbGUoaCwgJ3VuZGVybGF5JywgMCksIHRoaXMuZ2VuQ2lyY2xlKGgsICdvdmVybGF5JywgdGhpcy5zdHJva2VEYXNoT2Zmc2V0KV07XG4gICAgICAgICAgICByZXR1cm4gaCgnc3ZnJywge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLnN2Z1N0eWxlcyxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICB4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICAgICAgICAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94U2l6ZSArIFwiIFwiICsgdGhpcy52aWV3Qm94U2l6ZSArIFwiIFwiICsgMiAqIHRoaXMudmlld0JveFNpemUgKyBcIiBcIiArIDIgKiB0aGlzLnZpZXdCb3hTaXplXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBpbmZvID0gaCgnZGl2JywgeyBzdGF0aWNDbGFzczogJ3YtcHJvZ3Jlc3MtY2lyY3VsYXJfX2luZm8nIH0sIFt0aGlzLiRzbG90cy5kZWZhdWx0XSk7XG4gICAgICAgIHZhciBzdmcgPSB0aGlzLmdlblN2ZyhoKTtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHRoaXMuc2V0VGV4dENvbG9yKHRoaXMuY29sb3IsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1wcm9ncmVzcy1jaXJjdWxhcicsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcbiAgICAgICAgICAgICAgICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICAgICAgICAgICAgICAgJ2FyaWEtdmFsdWVtYXgnOiAxMDAsXG4gICAgICAgICAgICAgICAgJ2FyaWEtdmFsdWVub3cnOiB0aGlzLmluZGV0ZXJtaW5hdGUgPyB1bmRlZmluZWQgOiB0aGlzLm5vcm1hbGl6ZWRWYWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB0aGlzLmNsYXNzZXMsXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICBvbjogdGhpcy4kbGlzdGVuZXJzXG4gICAgICAgIH0pLCBbc3ZnLCBpbmZvXSk7XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZQcm9ncmVzc0NpcmN1bGFyL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WUHJvZ3Jlc3NDaXJjdWxhci9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZQcm9ncmVzc0NpcmN1bGFyLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WUHJvZ3Jlc3NDaXJjdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WUHJvZ3Jlc3NDaXJjdWxhciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlByb2dyZXNzQ2lyY3VsYXIvVlByb2dyZXNzQ2lyY3VsYXIudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWUHJvZ3Jlc3NDaXJjdWxhclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WUHJvZ3Jlc3NDaXJjdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WUHJvZ3Jlc3NDaXJjdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlByb2dyZXNzTGluZWFyL1ZQcm9ncmVzc0xpbmVhci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WUHJvZ3Jlc3NMaW5lYXIvVlByb2dyZXNzTGluZWFyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19wcm9ncmVzc19saW5lYXJfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3Byb2dyZXNzLWxpbmVhci5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3Byb2dyZXNzLWxpbmVhci5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19wcm9ncmVzc19saW5lYXJfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19wcm9ncmVzc19saW5lYXJfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2NvbG9yYWJsZSAqLyBcIi4vc3JjL21peGlucy9jb2xvcmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9taXhpbnMgKi8gXCIuL3NyYy91dGlsL21peGlucy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3RyYW5zaXRpb25zICovIFwiLi9zcmMvY29tcG9uZW50cy90cmFuc2l0aW9ucy9pbmRleC5qc1wiKTtcblxuLy8gTWl4aW5zXG5cbi8vIEhlbHBlcnNcblxuXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE9iamVjdChfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0pKF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LXByb2dyZXNzLWxpbmVhcicsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgYmFja2dyb3VuZE9wYWNpdHk6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGJ1ZmZlclZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogMTAwXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAncHJpbWFyeSdcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogN1xuICAgICAgICB9LFxuICAgICAgICBpbmRldGVybWluYXRlOiBCb29sZWFuLFxuICAgICAgICBxdWVyeTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGJhY2tncm91bmRTdHlsZTogZnVuY3Rpb24gYmFja2dyb3VuZFN0eWxlKCkge1xuICAgICAgICAgICAgdmFyIGJhY2tncm91bmRPcGFjaXR5ID0gdGhpcy5iYWNrZ3JvdW5kT3BhY2l0eSA9PSBudWxsID8gdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPyAxIDogMC4zIDogcGFyc2VGbG9hdCh0aGlzLmJhY2tncm91bmRPcGFjaXR5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmFjdGl2ZSA/IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJjb252ZXJ0VG9Vbml0XCJdKSh0aGlzLmhlaWdodCkgOiAwLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IGJhY2tncm91bmRPcGFjaXR5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLm5vcm1hbGl6ZWRCdWZlciArIFwiJVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlZmZlY3RpdmVXaWR0aDogZnVuY3Rpb24gZWZmZWN0aXZlV2lkdGgoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9ybWFsaXplZEJ1ZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMubm9ybWFsaXplZFZhbHVlICogMTAwIC8gK3RoaXMubm9ybWFsaXplZEJ1ZmVyO1xuICAgICAgICB9LFxuICAgICAgICBub3JtYWxpemVkQnVmZXI6IGZ1bmN0aW9uIG5vcm1hbGl6ZWRCdWZlcigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlclZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyVmFsdWUgPiAxMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuYnVmZmVyVmFsdWUsIDEwKTtcbiAgICAgICAgfSxcbiAgICAgICAgbm9ybWFsaXplZFZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemVkVmFsdWUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLnZhbHVlLCAxMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlczogZnVuY3Rpb24gc3R5bGVzKCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmluZGV0ZXJtaW5hdGUgJiYgcGFyc2VJbnQodGhpcy5ub3JtYWxpemVkQnVmZXIsIDEwKSAhPT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzLndpZHRoID0gdGhpcy5ub3JtYWxpemVkQnVmZXIgKyBcIiVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuRGV0ZXJtaW5hdGU6IGZ1bmN0aW9uIGdlbkRldGVybWluYXRlKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCdkaXYnLCB0aGlzLnNldEJhY2tncm91bmRDb2xvcih0aGlzLmNvbG9yLCB7XG4gICAgICAgICAgICAgICAgcmVmOiAnZnJvbnQnLFxuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInYtcHJvZ3Jlc3MtbGluZWFyX19iYXJfX2RldGVybWluYXRlXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuZWZmZWN0aXZlV2lkdGggKyBcIiVcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuQmFyOiBmdW5jdGlvbiBnZW5CYXIoaCwgbmFtZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMuY29sb3IsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtcHJvZ3Jlc3MtbGluZWFyX19iYXJfX2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICAgICAgICAgIGNsYXNzOiAoX2EgPSB7fSwgX2FbbmFtZV0gPSB0cnVlLCBfYSlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSW5kZXRlcm1pbmF0ZTogZnVuY3Rpb24gZ2VuSW5kZXRlcm1pbmF0ZShoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIHJlZjogJ2Zyb250JyxcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtcHJvZ3Jlc3MtbGluZWFyX19iYXJfX2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgICAgICd2LXByb2dyZXNzLWxpbmVhcl9fYmFyX19pbmRldGVybWluYXRlLS1hY3RpdmUnOiB0aGlzLmFjdGl2ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFt0aGlzLmdlbkJhcihoLCAnbG9uZycpLCB0aGlzLmdlbkJhcihoLCAnc2hvcnQnKV0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBmYWRlID0gaChfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIlZGYWRlVHJhbnNpdGlvblwiXSwgdGhpcy5pbmRldGVybWluYXRlID8gW3RoaXMuZ2VuSW5kZXRlcm1pbmF0ZShoKV0gOiBbXSk7XG4gICAgICAgIHZhciBzbGlkZSA9IGgoX3RyYW5zaXRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJWU2xpZGVYVHJhbnNpdGlvblwiXSwgdGhpcy5pbmRldGVybWluYXRlID8gW10gOiBbdGhpcy5nZW5EZXRlcm1pbmF0ZShoKV0pO1xuICAgICAgICB2YXIgYmFyID0gaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXByb2dyZXNzLWxpbmVhcl9fYmFyJyxcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlc1xuICAgICAgICB9LCBbZmFkZSwgc2xpZGVdKTtcbiAgICAgICAgdmFyIGJhY2tncm91bmQgPSBoKCdkaXYnLCB0aGlzLnNldEJhY2tncm91bmRDb2xvcih0aGlzLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLmNvbG9yLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtcHJvZ3Jlc3MtbGluZWFyX19iYWNrZ3JvdW5kJyxcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLmJhY2tncm91bmRTdHlsZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtcHJvZ3Jlc3MtbGluZWFyJyxcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAncHJvZ3Jlc3NiYXInLFxuICAgICAgICAgICAgICAgICdhcmlhLXZhbHVlbWluJzogMCxcbiAgICAgICAgICAgICAgICAnYXJpYS12YWx1ZW1heCc6IHRoaXMubm9ybWFsaXplZEJ1ZmVyLFxuICAgICAgICAgICAgICAgICdhcmlhLXZhbHVlbm93JzogdGhpcy5pbmRldGVybWluYXRlID8gdW5kZWZpbmVkIDogdGhpcy5ub3JtYWxpemVkVmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICd2LXByb2dyZXNzLWxpbmVhci0tcXVlcnknOiB0aGlzLnF1ZXJ5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJjb252ZXJ0VG9Vbml0XCJdKSh0aGlzLmhlaWdodClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbjogdGhpcy4kbGlzdGVuZXJzXG4gICAgICAgIH0sIFtiYWNrZ3JvdW5kLCBiYXJdKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlByb2dyZXNzTGluZWFyL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlByb2dyZXNzTGluZWFyL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZQcm9ncmVzc0xpbmVhciwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlByb2dyZXNzTGluZWFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZQcm9ncmVzc0xpbmVhciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlByb2dyZXNzTGluZWFyL1ZQcm9ncmVzc0xpbmVhci50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZQcm9ncmVzc0xpbmVhclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WUHJvZ3Jlc3NMaW5lYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVlByb2dyZXNzTGluZWFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WUmFkaW9Hcm91cC9WUmFkaW8uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WUmFkaW9Hcm91cC9WUmFkaW8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfcmFkaW9zX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19yYWRpb3Muc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19yYWRpb3Muc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfcmFkaW9zX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfcmFkaW9zX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WSWNvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkljb24vaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZMYWJlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVkxhYmVsICovIFwiLi9zcmMvY29tcG9uZW50cy9WTGFiZWwvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcmlwcGxlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3JpcHBsZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvcmlwcGxlYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RoZW1lYWJsZSAqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19zZWxlY3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvc2VsZWN0YWJsZSAqLyBcIi4vc3JjL21peGlucy9zZWxlY3RhYmxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9yZWdpc3RyYWJsZSAqLyBcIi4vc3JjL21peGlucy9yZWdpc3RyYWJsZS50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3JlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fcmVhZCB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgICByLFxuICAgICAgICBhciA9IFtdLFxuICAgICAgICBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19zcHJlYWQgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICB9cmV0dXJuIGFyO1xufTtcbi8vIFN0eWxlc1xuXG4vLyBDb21wb25lbnRzXG5cblxuLy8gTWl4aW5zXG5cblxuXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LXJhZGlvJyxcbiAgICBtaXhpbnM6IFtfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSwgX21peGluc19yaXBwbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLCBPYmplY3QoX21peGluc19yZWdpc3RyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiaW5qZWN0XCJdKSgncmFkaW8nLCAndi1yYWRpbycsICd2LXJhZGlvLWdyb3VwJyksIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdXSxcbiAgICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnYWNjZW50J1xuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgbGFiZWw6IFN0cmluZyxcbiAgICAgICAgb25JY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMucmFkaW9PbidcbiAgICAgICAgfSxcbiAgICAgICAgb2ZmSWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5Lmljb25zLnJhZGlvT2ZmJ1xuICAgICAgICB9LFxuICAgICAgICByZWFkb25seTogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBpc0ZvY3VzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcGFyZW50RXJyb3I6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjb21wdXRlZERhdGE6IGZ1bmN0aW9uIGNvbXB1dGVkRGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFRleHRDb2xvcighdGhpcy5wYXJlbnRFcnJvciAmJiB0aGlzLmlzQWN0aXZlICYmIHRoaXMuY29sb3IsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtcmFkaW8nLFxuICAgICAgICAgICAgICAgICdjbGFzcyc6IF9fYXNzaWduKHsgJ3YtcmFkaW8tLWlzLWRpc2FibGVkJzogdGhpcy5pc0Rpc2FibGVkLCAndi1yYWRpby0taXMtZm9jdXNlZCc6IHRoaXMuaXNGb2N1c2VkIH0sIHRoaXMudGhlbWVDbGFzc2VzKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkQ29sb3I6IGZ1bmN0aW9uIGNvbXB1dGVkQ29sb3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0FjdGl2ZSA/IHRoaXMuY29sb3IgOiB0aGlzLnJhZGlvLnZhbGlkYXRpb25TdGF0ZSB8fCBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWRJY29uOiBmdW5jdGlvbiBjb21wdXRlZEljb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0FjdGl2ZSA/IHRoaXMub25JY29uIDogdGhpcy5vZmZJY29uO1xuICAgICAgICB9LFxuICAgICAgICBoYXNTdGF0ZTogZnVuY3Rpb24gaGFzU3RhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0FjdGl2ZSB8fCAhIXRoaXMucmFkaW8udmFsaWRhdGlvblN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBpc0Rpc2FibGVkOiBmdW5jdGlvbiBpc0Rpc2FibGVkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgISF0aGlzLnJhZGlvLmRpc2FibGVkO1xuICAgICAgICB9LFxuICAgICAgICBpc1JlYWRvbmx5OiBmdW5jdGlvbiBpc1JlYWRvbmx5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZG9ubHkgfHwgISF0aGlzLnJhZGlvLnJlYWRvbmx5O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLnJhZGlvLnJlZ2lzdGVyKHRoaXMpO1xuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yYWRpby51bnJlZ2lzdGVyKHRoaXMpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZW5JbnB1dDogZnVuY3Rpb24gZ2VuSW5wdXQoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBXZSBjYW4ndCBhY3R1YWxseSB1c2UgdGhlIG1peGluIGRpcmVjdGx5IGJlY2F1c2VcbiAgICAgICAgICAgIC8vIGl0J3MgbWFkZSBmb3Igc3RhbmRhbG9uZSBjb21wb25lbnRzLCBidXQgaXRzXG4gICAgICAgICAgICAvLyBnZW5JbnB1dCBtZXRob2QgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWRcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBfbWl4aW5zX3NlbGVjdGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0ubWV0aG9kcy5nZW5JbnB1dCkuY2FsbC5hcHBseShfYSwgX19zcHJlYWQoW3RoaXNdLCBhcmdzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkxhYmVsOiBmdW5jdGlvbiBnZW5MYWJlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WTGFiZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICAgICAgICBvbjogeyBjbGljazogdGhpcy5vbkNoYW5nZSB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGZvcjogdGhpcy5pZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMucmFkaW8udmFsaWRhdGlvblN0YXRlIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkYXJrOiB0aGlzLmRhcmssXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWQ6IHRoaXMuaGFzU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0OiB0aGlzLmxpZ2h0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy4kc2xvdHMubGFiZWwgfHwgdGhpcy5sYWJlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblJhZGlvOiBmdW5jdGlvbiBnZW5SYWRpbygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWlucHV0LS1zZWxlY3Rpb24tY29udHJvbHNfX2lucHV0J1xuICAgICAgICAgICAgfSwgW3RoaXMuZ2VuSW5wdXQoJ3JhZGlvJywgX19hc3NpZ24oeyBuYW1lOiB0aGlzLnJhZGlvLm5hbWUgfHwgKHRoaXMucmFkaW8uX3VpZCA/ICd2LXJhZGlvLScgKyB0aGlzLnJhZGlvLl91aWQgOiBmYWxzZSksIHZhbHVlOiB0aGlzLnZhbHVlIH0sIHRoaXMuJGF0dHJzKSksICF0aGlzLmlzRGlzYWJsZWQgJiYgdGhpcy5nZW5SaXBwbGUodGhpcy5zZXRUZXh0Q29sb3IodGhpcy5jb21wdXRlZENvbG9yKSksIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCB0aGlzLnNldFRleHRDb2xvcih0aGlzLmNvbXB1dGVkQ29sb3IsIHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBkYXJrOiB0aGlzLmRhcmssXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0OiB0aGlzLmxpZ2h0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIHRoaXMuY29tcHV0ZWRJY29uKV0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzOiBmdW5jdGlvbiBvbkZvY3VzKCkge1xuICAgICAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cihlKSB7XG4gICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnYmx1cicsIGUpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Rpc2FibGVkIHx8IHRoaXMuaXNSZWFkb25seSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQgJiYgKCF0aGlzLmlzQWN0aXZlIHx8ICF0aGlzLnJhZGlvLm1hbmRhdG9yeSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25LZXlkb3duOiBmdW5jdGlvbiBvbktleWRvd24oKSB7fVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICByZXR1cm4gaCgnZGl2JywgdGhpcy5jb21wdXRlZERhdGEsIFt0aGlzLmdlblJhZGlvKCksIHRoaXMuZ2VuTGFiZWwoKV0pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZSYWRpb0dyb3VwL1ZSYWRpb0dyb3VwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WUmFkaW9Hcm91cC9WUmFkaW9Hcm91cC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3NlbGVjdGlvbl9jb250cm9sc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fc2VsZWN0aW9uLWNvbnRyb2xzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc2VsZWN0aW9uLWNvbnRyb2xzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3NlbGVjdGlvbl9jb250cm9sc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX3NlbGVjdGlvbl9jb250cm9sc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19yYWRpb19ncm91cF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fcmFkaW8tZ3JvdXAuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19yYWRpby1ncm91cC5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19yYWRpb19ncm91cF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX3JhZGlvX2dyb3VwX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJbnB1dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVklucHV0ICovIFwiLi9zcmMvY29tcG9uZW50cy9WSW5wdXQvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb21wYXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29tcGFyYWJsZSAqLyBcIi4vc3JjL21peGlucy9jb21wYXJhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9yZWdpc3RyYWJsZSAqLyBcIi4vc3JjL21peGlucy9yZWdpc3RyYWJsZS50c1wiKTtcbi8vIFN0eWxlc1xuXG5cbi8vIENvbXBvbmVudHNcblxuLy8gTWl4aW5zXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LXJhZGlvLWdyb3VwJyxcbiAgICBleHRlbmRzOiBfVklucHV0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLFxuICAgIG1peGluczogW19taXhpbnNfY29tcGFyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSwgT2JqZWN0KF9taXhpbnNfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcInByb3ZpZGVcIl0pKCdyYWRpbycpXSxcbiAgICBtb2RlbDoge1xuICAgICAgICBwcm9wOiAndmFsdWUnLFxuICAgICAgICBldmVudDogJ2NoYW5nZSdcbiAgICB9LFxuICAgIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYWRpbzogdGhpc1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sdW1uOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAnYXV0bydcbiAgICAgICAgfSxcbiAgICAgICAgbWFuZGF0b3J5OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiBTdHJpbmcsXG4gICAgICAgIHJvdzogQm9vbGVhbixcbiAgICAgICAgLy8gSWYgbm8gdmFsdWUgc2V0IG9uIFZSYWRpb1xuICAgICAgICAvLyB3aWxsIG1hdGNoIHZhbHVlQ29tcGFyYXRvclxuICAgICAgICAvLyBmb3JjZSBkZWZhdWx0IHRvIG51bGxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVybmFsVGFiSW5kZXg6IC0xLFxuICAgICAgICAgICAgcmFkaW9zOiBbXVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3YtaW5wdXQtLXNlbGVjdGlvbi1jb250cm9scyB2LWlucHV0LS1yYWRpby1ncm91cCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3YtaW5wdXQtLXJhZGlvLWdyb3VwLS1jb2x1bW4nOiB0aGlzLmNvbHVtbiAmJiAhdGhpcy5yb3csXG4gICAgICAgICAgICAgICAgJ3YtaW5wdXQtLXJhZGlvLWdyb3VwLS1yb3cnOiB0aGlzLnJvd1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgaGFzRXJyb3I6ICdzZXRFcnJvclN0YXRlJyxcbiAgICAgICAgaW50ZXJuYWxWYWx1ZTogJ3NldEFjdGl2ZVJhZGlvJ1xuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5zZXRFcnJvclN0YXRlKHRoaXMuaGFzRXJyb3IpO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZVJhZGlvKCk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlbkRlZmF1bHRTbG90OiBmdW5jdGlvbiBnZW5EZWZhdWx0U2xvdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWlucHV0LS1yYWRpby1ncm91cF9faW5wdXQnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICdyYWRpb2dyb3VwJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9WSW5wdXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0ubWV0aG9kcy5nZW5EZWZhdWx0U2xvdC5jYWxsKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25SYWRpb0NoYW5nZTogZnVuY3Rpb24gb25SYWRpb0NoYW5nZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaGFzSW5wdXQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVJhZGlvKCk7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayh0aGlzLnZhbGlkYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25SYWRpb0JsdXI6IGZ1bmN0aW9uIG9uUmFkaW9CbHVyKGUpIHtcbiAgICAgICAgICAgIGlmICghZS5yZWxhdGVkVGFyZ2V0IHx8ICFlLnJlbGF0ZWRUYXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd2LXJhZGlvJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0lucHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdibHVyJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihyYWRpbykge1xuICAgICAgICAgICAgcmFkaW8uaXNBY3RpdmUgPSB0aGlzLnZhbHVlQ29tcGFyYXRvcih0aGlzLmludGVybmFsVmFsdWUsIHJhZGlvLnZhbHVlKTtcbiAgICAgICAgICAgIHJhZGlvLiRvbignY2hhbmdlJywgdGhpcy5vblJhZGlvQ2hhbmdlKTtcbiAgICAgICAgICAgIHJhZGlvLiRvbignYmx1cicsIHRoaXMub25SYWRpb0JsdXIpO1xuICAgICAgICAgICAgdGhpcy5yYWRpb3MucHVzaChyYWRpbyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEVycm9yU3RhdGU6IGZ1bmN0aW9uIHNldEVycm9yU3RhdGUodmFsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IHRoaXMucmFkaW9zLmxlbmd0aDsgLS1pbmRleCA+PSAwOykge1xuICAgICAgICAgICAgICAgIHRoaXMucmFkaW9zW2luZGV4XS5wYXJlbnRFcnJvciA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0QWN0aXZlUmFkaW86IGZ1bmN0aW9uIHNldEFjdGl2ZVJhZGlvKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSB0aGlzLnJhZGlvcy5sZW5ndGg7IC0taW5kZXggPj0gMDspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaW8gPSB0aGlzLnJhZGlvc1tpbmRleF07XG4gICAgICAgICAgICAgICAgcmFkaW8uaXNBY3RpdmUgPSB0aGlzLnZhbHVlQ29tcGFyYXRvcih0aGlzLmludGVybmFsVmFsdWUsIHJhZGlvLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gdW5yZWdpc3RlcihyYWRpbykge1xuICAgICAgICAgICAgcmFkaW8uJG9mZignY2hhbmdlJywgdGhpcy5vblJhZGlvQ2hhbmdlKTtcbiAgICAgICAgICAgIHJhZGlvLiRvZmYoJ2JsdXInLCB0aGlzLm9uUmFkaW9CbHVyKTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMucmFkaW9zLmZpbmRJbmRleChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiByID09PSByYWRpbztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB0aGlzLnJhZGlvcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlJhZGlvR3JvdXAvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZSYWRpb0dyb3VwL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlJhZGlvR3JvdXAsIFZSYWRpbywgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlJhZGlvR3JvdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlJhZGlvR3JvdXAgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZSYWRpb0dyb3VwL1ZSYWRpb0dyb3VwLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlJhZGlvR3JvdXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlJhZGlvR3JvdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZSYWRpb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WUmFkaW8gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZSYWRpb0dyb3VwL1ZSYWRpby5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZSYWRpb1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WUmFkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICAkX3Z1ZXRpZnlfc3ViY29tcG9uZW50czoge1xuICAgICAgICBWUmFkaW9Hcm91cDogX1ZSYWRpb0dyb3VwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWUmFkaW86IF9WUmFkaW9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WUmFuZ2VTbGlkZXIvVlJhbmdlU2xpZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZSYW5nZVNsaWRlci9WUmFuZ2VTbGlkZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3JhbmdlX3NsaWRlcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3JhbmdlLXNsaWRlcnMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19yYW5nZS1zbGlkZXJzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3JhbmdlX3NsaWRlcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19yYW5nZV9zbGlkZXJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZTbGlkZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTbGlkZXIvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLy8gU3R5bGVzXG5cbi8vIEV4dGVuc2lvbnNcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtcmFuZ2Utc2xpZGVyJyxcbiAgICBleHRlbmRzOiBfVlNsaWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSxcbiAgICBwcm9wczoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEodm0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGl2ZVRodW1iOiBudWxsLFxuICAgICAgICAgICAgbGF6eVZhbHVlOiAhdm0udmFsdWUubGVuZ3RoID8gWzAsIDBdIDogdm0udmFsdWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgICd2LWlucHV0LS1yYW5nZS1zbGlkZXInOiB0cnVlXG4gICAgICAgICAgICB9LCBfVlNsaWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5jb21wdXRlZC5jbGFzc2VzLmNhbGwodGhpcykpO1xuICAgICAgICB9LFxuICAgICAgICBpbnRlcm5hbFZhbHVlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXp5VmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBfYS5taW4sXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IF9hLm1heDtcbiAgICAgICAgICAgICAgICAvLyBSb3VuZCB2YWx1ZSB0byBlbnN1cmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gZW50aXJlIHNsaWRlciByYW5nZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBiZSBzZWxlY3RlZCB3aXRoIHN0ZXBcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWwubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yb3VuZFZhbHVlKE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFN3aXRjaCB2YWx1ZXMgaWYgcmFuZ2UgYW5kIHdyb25nIG9yZGVyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID4gdmFsdWVbMV0gfHwgdmFsdWVbMV0gPCB2YWx1ZVswXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUaHVtYiAhPT0gbnVsbCkgdGhpcy5hY3RpdmVUaHVtYiA9IHRoaXMuYWN0aXZlVGh1bWIgPT09IDEgPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVbMV0sIHZhbHVlWzBdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sYXp5VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWVwRXF1YWxcIl0pKHZhbHVlLCB0aGlzLnZhbHVlKSkgdGhpcy4kZW1pdCgnaW5wdXQnLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnB1dFdpZHRoOiBmdW5jdGlvbiBpbnB1dFdpZHRoKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsVmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfdGhpcy5yb3VuZFZhbHVlKHYpIC0gX3RoaXMubWluKSAvIChfdGhpcy5tYXggLSBfdGhpcy5taW4pICogMTAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGlydHk6IGZ1bmN0aW9uIGlzRGlydHkoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxWYWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgIT09IF90aGlzLm1pbjtcbiAgICAgICAgICAgIH0pIHx8IHRoaXMuYWx3YXlzRGlydHk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYWNrRmlsbFN0eWxlczogZnVuY3Rpb24gdHJhY2tGaWxsU3R5bGVzKCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IF9WU2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLmNvbXB1dGVkLnRyYWNrRmlsbFN0eWxlcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGZpbGxQZXJjZW50ID0gTWF0aC5hYnModGhpcy5pbnB1dFdpZHRoWzBdIC0gdGhpcy5pbnB1dFdpZHRoWzFdKTtcbiAgICAgICAgICAgIHN0eWxlcy53aWR0aCA9IFwiY2FsYyhcIiArIGZpbGxQZXJjZW50ICsgXCIlIC0gXCIgKyB0aGlzLnRyYWNrUGFkZGluZyArIFwicHgpXCI7XG4gICAgICAgICAgICBzdHlsZXNbdGhpcy4kdnVldGlmeS5ydGwgPyAncmlnaHQnIDogJ2xlZnQnXSA9IHRoaXMuaW5wdXRXaWR0aFswXSArIFwiJVwiO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2tQYWRkaW5nOiBmdW5jdGlvbiB0cmFja1BhZGRpbmcoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RpcnR5IHx8IHRoaXMuaW50ZXJuYWxWYWx1ZVswXSkgcmV0dXJuIDA7XG4gICAgICAgICAgICByZXR1cm4gX1ZTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uY29tcHV0ZWQudHJhY2tQYWRkaW5nLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2V0SW5kZXhPZkNsb3Nlc3RWYWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXhPZkNsb3Nlc3RWYWx1ZShhcnIsIHYpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhhcnJbMF0gLSB2KSA8IE1hdGguYWJzKGFyclsxXSAtIHYpKSByZXR1cm4gMDtlbHNlIHJldHVybiAxO1xuICAgICAgICB9LFxuICAgICAgICBnZW5JbnB1dDogZnVuY3Rpb24gZ2VuSW5wdXQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJjcmVhdGVSYW5nZVwiXSkoMikubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gX1ZTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0ubWV0aG9kcy5nZW5JbnB1dC5jYWxsKF90aGlzKTtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhLmF0dHJzLnZhbHVlID0gX3RoaXMuaW50ZXJuYWxWYWx1ZVtpXTtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhLm9uLmZvY3VzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlVGh1bWIgPSBpO1xuICAgICAgICAgICAgICAgICAgICBfVlNsaWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLm9uRm9jdXMuY2FsbChfdGhpcywgZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuQ2hpbGRyZW46IGZ1bmN0aW9uIGdlbkNoaWxkcmVuKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5nZW5JbnB1dCgpLCB0aGlzLmdlblRyYWNrQ29udGFpbmVyKCksIHRoaXMuZ2VuU3RlcHMoKSwgT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImNyZWF0ZVJhbmdlXCJdKSgyKS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy5pbnRlcm5hbFZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIHZhciBvbkRyYWcgPSBmdW5jdGlvbiBvbkRyYWcoZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZVRodW1iID0gaTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25UaHVtYk1vdXNlRG93bihlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZVdpZHRoID0gX3RoaXMuaW5wdXRXaWR0aFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgaXNBY3RpdmUgPSAoX3RoaXMuaXNGb2N1c2VkIHx8IF90aGlzLmlzQWN0aXZlKSAmJiBfdGhpcy5hY3RpdmVUaHVtYiA9PT0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2VuVGh1bWJDb250YWluZXIodmFsdWUsIHZhbHVlV2lkdGgsIGlzQWN0aXZlLCBvbkRyYWcpO1xuICAgICAgICAgICAgfSldO1xuICAgICAgICB9LFxuICAgICAgICBvblNsaWRlckNsaWNrOiBmdW5jdGlvbiBvblNsaWRlckNsaWNrKGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VNb3ZlKGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuaW50ZXJuYWxWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZShlLCB0cmFja0NsaWNrKSB7XG4gICAgICAgICAgICBpZiAodHJhY2tDbGljayA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tDbGljayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5wYXJzZU1vdXNlTW92ZShlKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF9hLnZhbHVlLFxuICAgICAgICAgICAgICAgIGlzSW5zaWRlVHJhY2sgPSBfYS5pc0luc2lkZVRyYWNrO1xuICAgICAgICAgICAgaWYgKGlzSW5zaWRlVHJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tDbGljaykgdGhpcy5hY3RpdmVUaHVtYiA9IHRoaXMuZ2V0SW5kZXhPZkNsb3Nlc3RWYWx1ZSh0aGlzLmludGVybmFsVmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEludGVybmFsVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBhcnNlS2V5RG93bihlLCB0aGlzLmludGVybmFsVmFsdWVbdGhpcy5hY3RpdmVUaHVtYl0pO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVybmFsVmFsdWU6IGZ1bmN0aW9uIHNldEludGVybmFsVmFsdWUodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSB0aGlzLmludGVybmFsVmFsdWUubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IF90aGlzLmFjdGl2ZVRodW1iKSByZXR1cm4gdmFsdWU7ZWxzZSByZXR1cm4gTnVtYmVyKHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WUmFuZ2VTbGlkZXIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WUmFuZ2VTbGlkZXIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlJhbmdlU2xpZGVyLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WUmFuZ2VTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlJhbmdlU2xpZGVyICovIFwiLi9zcmMvY29tcG9uZW50cy9WUmFuZ2VTbGlkZXIvVlJhbmdlU2xpZGVyLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlJhbmdlU2xpZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZSYW5nZVNsaWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WUmFuZ2VTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZSYXRpbmcvVlJhdGluZy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZSYXRpbmcvVlJhdGluZy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19yYXRpbmdfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3JhdGluZy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3JhdGluZy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19yYXRpbmdfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19yYXRpbmdfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZJY29uICovIFwiLi9zcmMvY29tcG9uZW50cy9WSWNvbi9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2NvbG9yYWJsZSAqLyBcIi4vc3JjL21peGlucy9jb2xvcmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19kZWxheWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9kZWxheWFibGUgKi8gXCIuL3NyYy9taXhpbnMvZGVsYXlhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfc2l6ZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9zaXplYWJsZSAqLyBcIi4vc3JjL21peGlucy9zaXplYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3JpcHBsZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9yaXBwbGVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3JpcHBsZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG4vLyBTdHlsZXNcblxuLy8gQ29tcG9uZW50c1xuXG4vLyBNaXhpbnNcblxuXG5cblxuXG4vLyBVdGlsaXRpZXNcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJkZWZhdWx0XCJdKShfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwgX21peGluc19kZWxheWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfcmlwcGxlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSwgX21peGluc19zaXplYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSwgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0pLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtcmF0aW5nJyxcbiAgICBwcm9wczoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhY2NlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAncHJpbWFyeSdcbiAgICAgICAgfSxcbiAgICAgICAgZGVuc2U6IEJvb2xlYW4sXG4gICAgICAgIGVtcHR5SWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5Lmljb25zLnJhdGluZ0VtcHR5J1xuICAgICAgICB9LFxuICAgICAgICBmdWxsSWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5Lmljb25zLnJhdGluZ0Z1bGwnXG4gICAgICAgIH0sXG4gICAgICAgIGhhbGZJY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMucmF0aW5nSGFsZidcbiAgICAgICAgfSxcbiAgICAgICAgaGFsZkluY3JlbWVudHM6IEJvb2xlYW4sXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDVcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJhYmxlOiBCb29sZWFuLFxuICAgICAgICByZWFkb25seTogQm9vbGVhbixcbiAgICAgICAgaG92ZXI6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBob3ZlckluZGV4OiAtMSxcbiAgICAgICAgICAgIGludGVybmFsVmFsdWU6IHRoaXMudmFsdWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGRpcmVjdGl2ZXM6IGZ1bmN0aW9uIGRpcmVjdGl2ZXMoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkb25seSB8fCAhdGhpcy5yaXBwbGUpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdyaXBwbGUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7IGNpcmNsZTogdHJ1ZSB9XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfSxcbiAgICAgICAgaWNvblByb3BzOiBmdW5jdGlvbiBpY29uUHJvcHMoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLiRwcm9wcyxcbiAgICAgICAgICAgICAgICBkYXJrID0gX2EuZGFyayxcbiAgICAgICAgICAgICAgICBtZWRpdW0gPSBfYS5tZWRpdW0sXG4gICAgICAgICAgICAgICAgbGFyZ2UgPSBfYS5sYXJnZSxcbiAgICAgICAgICAgICAgICBsaWdodCA9IF9hLmxpZ2h0LFxuICAgICAgICAgICAgICAgIHNtYWxsID0gX2Euc21hbGwsXG4gICAgICAgICAgICAgICAgc2l6ZSA9IF9hLnNpemUsXG4gICAgICAgICAgICAgICAgeExhcmdlID0gX2EueExhcmdlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXJrOiBkYXJrLFxuICAgICAgICAgICAgICAgIG1lZGl1bTogbWVkaXVtLFxuICAgICAgICAgICAgICAgIGxhcmdlOiBsYXJnZSxcbiAgICAgICAgICAgICAgICBsaWdodDogbGlnaHQsXG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICBzbWFsbDogc21hbGwsXG4gICAgICAgICAgICAgICAgeExhcmdlOiB4TGFyZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGlzSG92ZXJpbmc6IGZ1bmN0aW9uIGlzSG92ZXJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ob3ZlciAmJiB0aGlzLmhvdmVySW5kZXggPj0gMDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgaW50ZXJuYWxWYWx1ZTogZnVuY3Rpb24gaW50ZXJuYWxWYWx1ZSh2YWwpIHtcbiAgICAgICAgICAgIHZhbCAhPT0gdGhpcy52YWx1ZSAmJiB0aGlzLiRlbWl0KCdpbnB1dCcsIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBjcmVhdGVDbGlja0ZuOiBmdW5jdGlvbiBjcmVhdGVDbGlja0ZuKGkpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVhZG9ubHkpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBfdGhpcy5nZW5Ib3ZlckluZGV4KGUsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jbGVhcmFibGUgJiYgX3RoaXMuaW50ZXJuYWxWYWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW50ZXJuYWxWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW50ZXJuYWxWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZVByb3BzOiBmdW5jdGlvbiBjcmVhdGVQcm9wcyhpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaW50ZXJuYWxWYWx1ZSxcbiAgICAgICAgICAgICAgICBjbGljazogdGhpcy5jcmVhdGVDbGlja0ZuKGkpLFxuICAgICAgICAgICAgICAgIGlzRmlsbGVkOiBNYXRoLmZsb29yKHRoaXMuaW50ZXJuYWxWYWx1ZSkgPiBpLFxuICAgICAgICAgICAgICAgIGlzSG92ZXJlZDogTWF0aC5mbG9vcih0aGlzLmhvdmVySW5kZXgpID4gaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhbGZJbmNyZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuaXNIYWxmSG92ZXJlZCA9ICFwcm9wcy5pc0hvdmVyZWQgJiYgKHRoaXMuaG92ZXJJbmRleCAtIGkpICUgMSA+IDA7XG4gICAgICAgICAgICAgICAgcHJvcHMuaXNIYWxmRmlsbGVkID0gIXByb3BzLmlzRmlsbGVkICYmICh0aGlzLmludGVybmFsVmFsdWUgLSBpKSAlIDEgPiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBnZW5Ib3ZlckluZGV4OiBmdW5jdGlvbiBnZW5Ib3ZlckluZGV4KGUsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpICsgKHRoaXMuaXNIYWxmRXZlbnQoZSkgPyAwLjUgOiAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SWNvbk5hbWU6IGZ1bmN0aW9uIGdldEljb25OYW1lKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgaXNGdWxsID0gdGhpcy5pc0hvdmVyaW5nID8gcHJvcHMuaXNIb3ZlcmVkIDogcHJvcHMuaXNGaWxsZWQ7XG4gICAgICAgICAgICB2YXIgaXNIYWxmID0gdGhpcy5pc0hvdmVyaW5nID8gcHJvcHMuaXNIYWxmSG92ZXJlZCA6IHByb3BzLmlzSGFsZkZpbGxlZDtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bGwgPyB0aGlzLmZ1bGxJY29uIDogaXNIYWxmID8gdGhpcy5oYWxmSWNvbiA6IHRoaXMuZW1wdHlJY29uO1xuICAgICAgICB9LFxuICAgICAgICBnZXRDb2xvcjogZnVuY3Rpb24gZ2V0Q29sb3IocHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSG92ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuaXNIb3ZlcmVkIHx8IHByb3BzLmlzSGFsZkhvdmVyZWQpIHJldHVybiB0aGlzLmNvbG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuaXNGaWxsZWQgfHwgcHJvcHMuaXNIYWxmRmlsbGVkKSByZXR1cm4gdGhpcy5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgaXNIYWxmRXZlbnQ6IGZ1bmN0aW9uIGlzSGFsZkV2ZW50KGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhbGZJbmNyZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBlLnRhcmdldCAmJiBlLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjdCAmJiBlLnBhZ2VYIC0gcmVjdC5sZWZ0IDwgcmVjdC53aWR0aCAvIDIpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcihlLCBpKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5ydW5EZWxheSgnb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ob3ZlckluZGV4ID0gX3RoaXMuZ2VuSG92ZXJJbmRleChlLCBpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlTGVhdmU6IGZ1bmN0aW9uIG9uTW91c2VMZWF2ZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnJ1bkRlbGF5KCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaG92ZXJJbmRleCA9IC0xO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkl0ZW06IGZ1bmN0aW9uIGdlbkl0ZW0oaSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoaXMuY3JlYXRlUHJvcHMoaSk7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2NvcGVkU2xvdHMuaXRlbSkgcmV0dXJuIHRoaXMuJHNjb3BlZFNsb3RzLml0ZW0ocHJvcHMpO1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgICAgICBjbGljazogcHJvcHMuY2xpY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5ob3Zlcikge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5tb3VzZWVudGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9uTW91c2VFbnRlcihlLCBpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5tb3VzZWxlYXZlID0gdGhpcy5vbk1vdXNlTGVhdmU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFsZkluY3JlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub25Nb3VzZUVudGVyKGUsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgdGhpcy5zZXRUZXh0Q29sb3IodGhpcy5nZXRDb2xvcihwcm9wcyksIHtcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHRoaXMuaWNvblByb3BzLFxuICAgICAgICAgICAgICAgIG9uOiBsaXN0ZW5lcnNcbiAgICAgICAgICAgIH0pLCBbdGhpcy5nZXRJY29uTmFtZShwcm9wcyldKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiY3JlYXRlUmFuZ2VcIl0pKE51bWJlcih0aGlzLmxlbmd0aCkpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdlbkl0ZW0oaSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXJhdGluZycsXG4gICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICd2LXJhdGluZy0tcmVhZG9ubHknOiB0aGlzLnJlYWRvbmx5LFxuICAgICAgICAgICAgICAgICd2LXJhdGluZy0tZGVuc2UnOiB0aGlzLmRlbnNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlJhdGluZy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WUmF0aW5nL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWUmF0aW5nLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WUmF0aW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZSYXRpbmcgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZSYXRpbmcvVlJhdGluZy50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZSYXRpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlJhdGluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WUmF0aW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WUmVzcG9uc2l2ZS9WUmVzcG9uc2l2ZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlJlc3BvbnNpdmUvVlJlc3BvbnNpdmUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19yZXNwb25zaXZlX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19yZXNwb25zaXZlLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fcmVzcG9uc2l2ZS5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19yZXNwb25zaXZlX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfcmVzcG9uc2l2ZV9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfbWVhc3VyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL21lYXN1cmFibGUgKi8gXCIuL3NyYy9taXhpbnMvbWVhc3VyYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuXG4vLyBNaXhpbnNcblxuLy8gVXRpbHNcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdKShfbWl4aW5zX21lYXN1cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtcmVzcG9uc2l2ZScsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYXNwZWN0UmF0aW86IFtTdHJpbmcsIE51bWJlcl1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNvbXB1dGVkQXNwZWN0UmF0aW86IGZ1bmN0aW9uIGNvbXB1dGVkQXNwZWN0UmF0aW8oKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMuYXNwZWN0UmF0aW8pO1xuICAgICAgICB9LFxuICAgICAgICBhc3BlY3RTdHlsZTogZnVuY3Rpb24gYXNwZWN0U3R5bGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZEFzcGVjdFJhdGlvID8geyBwYWRkaW5nQm90dG9tOiAxIC8gdGhpcy5jb21wdXRlZEFzcGVjdFJhdGlvICogMTAwICsgJyUnIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIF9fY2FjaGVkU2l6ZXI6IGZ1bmN0aW9uIF9fY2FjaGVkU2l6ZXIoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXNwZWN0U3R5bGUpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHRoaXMuYXNwZWN0U3R5bGUsXG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXJlc3BvbnNpdmVfX3NpemVyJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuQ29udGVudDogZnVuY3Rpb24gZ2VuQ29udGVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXJlc3BvbnNpdmVfX2NvbnRlbnQnXG4gICAgICAgICAgICB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXJlc3BvbnNpdmUnLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJjb252ZXJ0VG9Vbml0XCJdKSh0aGlzLmhlaWdodCksXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0OiBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiY29udmVydFRvVW5pdFwiXSkodGhpcy5tYXhIZWlnaHQpLFxuICAgICAgICAgICAgICAgIG1heFdpZHRoOiBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiY29udmVydFRvVW5pdFwiXSkodGhpcy5tYXhXaWR0aCksXG4gICAgICAgICAgICAgICAgd2lkdGg6IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJjb252ZXJ0VG9Vbml0XCJdKSh0aGlzLndpZHRoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgICAgfSwgW3RoaXMuX19jYWNoZWRTaXplciwgdGhpcy5nZW5Db250ZW50KCldKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlJlc3BvbnNpdmUvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZSZXNwb25zaXZlL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlJlc3BvbnNpdmUsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZSZXNwb25zaXZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZSZXNwb25zaXZlICovIFwiLi9zcmMvY29tcG9uZW50cy9WUmVzcG9uc2l2ZS9WUmVzcG9uc2l2ZS50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZSZXNwb25zaXZlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZSZXNwb25zaXZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX1ZSZXNwb25zaXZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WU2VsZWN0L1ZTZWxlY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WU2VsZWN0L1ZTZWxlY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdE1lbnVQcm9wcywgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0TWVudVByb3BzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVmYXVsdE1lbnVQcm9wczsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3RleHRfZmllbGRzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL190ZXh0LWZpZWxkcy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3RleHQtZmllbGRzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3RleHRfZmllbGRzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfdGV4dF9maWVsZHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc2VsZWN0X3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19zZWxlY3Quc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19zZWxlY3Quc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc2VsZWN0X3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfc2VsZWN0X3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZDaGlwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WQ2hpcCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkNoaXAvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZNZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WTWVudSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk1lbnUvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZTZWxlY3RMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZTZWxlY3RMaXN0ICovIFwiLi9zcmMvY29tcG9uZW50cy9WU2VsZWN0L1ZTZWxlY3RMaXN0LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WVGV4dEZpZWxkX1ZUZXh0RmllbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZUZXh0RmllbGQvVlRleHRGaWVsZCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRleHRGaWVsZC9WVGV4dEZpZWxkLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29tcGFyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2NvbXBhcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29tcGFyYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2ZpbHRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9maWx0ZXJhYmxlICovIFwiLi9zcmMvbWl4aW5zL2ZpbHRlcmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RpcmVjdGl2ZXNfY2xpY2tfb3V0c2lkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlICovIFwiLi9zcmMvZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9jb25zb2xlICovIFwiLi9zcmMvdXRpbC9jb25zb2xlLnRzXCIpO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fdmFsdWVzID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3ZhbHVlcyB8fCBmdW5jdGlvbiAobykge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSxcbiAgICAgICAgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xufTtcbi8vIFN0eWxlc1xuXG5cbi8vIENvbXBvbmVudHNcblxuXG5cbi8vIEV4dGVuc2lvbnNcblxuLy8gTWl4aW5zXG5cblxuLy8gRGlyZWN0aXZlc1xuXG4vLyBIZWxwZXJzXG5cblxudmFyIGRlZmF1bHRNZW51UHJvcHMgPSB7XG4gICAgY2xvc2VPbkNsaWNrOiBmYWxzZSxcbiAgICBjbG9zZU9uQ29udGVudENsaWNrOiBmYWxzZSxcbiAgICBvcGVuT25DbGljazogZmFsc2UsXG4gICAgbWF4SGVpZ2h0OiAzMDBcbn07XG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3Ytc2VsZWN0JyxcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICAgIENsaWNrT3V0c2lkZTogX2RpcmVjdGl2ZXNfY2xpY2tfb3V0c2lkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiZGVmYXVsdFwiXVxuICAgIH0sXG4gICAgZXh0ZW5kczogX1ZUZXh0RmllbGRfVlRleHRGaWVsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSxcbiAgICBtaXhpbnM6IFtfbWl4aW5zX2NvbXBhcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfZmlsdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYXBwZW5kSWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5Lmljb25zLmRyb3Bkb3duJ1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRJY29uQ2I6IEZ1bmN0aW9uLFxuICAgICAgICBhdHRhY2g6IHtcbiAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBicm93c2VyQXV0b2NvbXBsZXRlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnb24nXG4gICAgICAgIH0sXG4gICAgICAgIGNhY2hlSXRlbXM6IEJvb2xlYW4sXG4gICAgICAgIGNoaXBzOiBCb29sZWFuLFxuICAgICAgICBjbGVhcmFibGU6IEJvb2xlYW4sXG4gICAgICAgIGRlbGV0YWJsZUNoaXBzOiBCb29sZWFuLFxuICAgICAgICBkZW5zZTogQm9vbGVhbixcbiAgICAgICAgaGlkZVNlbGVjdGVkOiBCb29sZWFuLFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGl0ZW1BdmF0YXI6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBGdW5jdGlvbl0sXG4gICAgICAgICAgICBkZWZhdWx0OiAnYXZhdGFyJ1xuICAgICAgICB9LFxuICAgICAgICBpdGVtRGlzYWJsZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBGdW5jdGlvbl0sXG4gICAgICAgICAgICBkZWZhdWx0OiAnZGlzYWJsZWQnXG4gICAgICAgIH0sXG4gICAgICAgIGl0ZW1UZXh0OiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgRnVuY3Rpb25dLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICAgIH0sXG4gICAgICAgIGl0ZW1WYWx1ZToge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIEZ1bmN0aW9uXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICd2YWx1ZSdcbiAgICAgICAgfSxcbiAgICAgICAgbWVudVByb3BzOiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0TWVudVByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtdWx0aXBsZTogQm9vbGVhbixcbiAgICAgICAgb3Blbk9uQ2xlYXI6IEJvb2xlYW4sXG4gICAgICAgIHJldHVybk9iamVjdDogQm9vbGVhbixcbiAgICAgICAgc2VhcmNoSW5wdXQ6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgc21hbGxDaGlwczogQm9vbGVhblxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSh2bSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cnNJbnB1dDogeyByb2xlOiAnY29tYm9ib3gnIH0sXG4gICAgICAgICAgICBjYWNoZWRJdGVtczogdm0uY2FjaGVJdGVtcyA/IHZtLml0ZW1zIDogW10sXG4gICAgICAgICAgICBjb250ZW50OiBudWxsLFxuICAgICAgICAgICAgaXNCb290ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNNZW51QWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGxhc3RJdGVtOiAyMCxcbiAgICAgICAgICAgIC8vIEFzIGxvbmcgYXMgYSB2YWx1ZSBpcyBkZWZpbmVkLCBzaG93IGl0XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGNoZWNrIGlmIG11bHRpcGxlXG4gICAgICAgICAgICAvLyB0byBkZXRlcm1pbmUgd2hpY2ggZGVmYXVsdCB0byBwcm92aWRlXG4gICAgICAgICAgICBsYXp5VmFsdWU6IHZtLnZhbHVlICE9PSB1bmRlZmluZWQgPyB2bS52YWx1ZSA6IHZtLm11bHRpcGxlID8gW10gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4OiAtMSxcbiAgICAgICAgICAgIHNlbGVjdGVkSXRlbXM6IFtdXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICAvKiBBbGwgaXRlbXMgdGhhdCB0aGUgc2VsZWN0IGhhcyAqL1xuICAgICAgICBhbGxJdGVtczogZnVuY3Rpb24gYWxsSXRlbXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJEdXBsaWNhdGVzKHRoaXMuY2FjaGVkSXRlbXMuY29uY2F0KHRoaXMuaXRlbXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBfVlRleHRGaWVsZF9WVGV4dEZpZWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLmNvbXB1dGVkLmNsYXNzZXMuY2FsbCh0aGlzKSwge1xuICAgICAgICAgICAgICAgICd2LXNlbGVjdCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3Ytc2VsZWN0LS1jaGlwcyc6IHRoaXMuaGFzQ2hpcHMsXG4gICAgICAgICAgICAgICAgJ3Ytc2VsZWN0LS1jaGlwcy0tc21hbGwnOiB0aGlzLnNtYWxsQ2hpcHMsXG4gICAgICAgICAgICAgICAgJ3Ytc2VsZWN0LS1pcy1tZW51LWFjdGl2ZSc6IHRoaXMuaXNNZW51QWN0aXZlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyogVXNlZCBieSBvdGhlciBjb21wb25lbnRzIHRvIG92ZXJ3cml0ZSAqL1xuICAgICAgICBjb21wdXRlZEl0ZW1zOiBmdW5jdGlvbiBjb21wdXRlZEl0ZW1zKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxsSXRlbXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNvdW50ZXJWYWx1ZTogZnVuY3Rpb24gY291bnRlclZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGUgPyB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoIDogKHRoaXMuZ2V0VGV4dCh0aGlzLnNlbGVjdGVkSXRlbXNbMF0pIHx8ICcnKS50b1N0cmluZygpLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZGlyZWN0aXZlczogZnVuY3Rpb24gZGlyZWN0aXZlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRm9jdXNlZCA/IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2NsaWNrLW91dHNpZGUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmJsdXIsXG4gICAgICAgICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZUNvbmRpdGlvbmFsOiB0aGlzLmNsb3NlQ29uZGl0aW9uYWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgZHluYW1pY0hlaWdodDogZnVuY3Rpb24gZHluYW1pY0hlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiAnYXV0byc7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0NoaXBzOiBmdW5jdGlvbiBoYXNDaGlwcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaXBzIHx8IHRoaXMuc21hbGxDaGlwcztcbiAgICAgICAgfSxcbiAgICAgICAgaGFzU2xvdDogZnVuY3Rpb24gaGFzU2xvdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaGFzQ2hpcHMgfHwgdGhpcy4kc2NvcGVkU2xvdHMuc2VsZWN0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNEaXJ0eTogZnVuY3Rpb24gaXNEaXJ0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdERhdGE6IGZ1bmN0aW9uIGxpc3REYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMubXVsdGlwbGUgJiYgIXRoaXMuaXNIaWRpbmdTZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGRlbnNlOiB0aGlzLmRlbnNlLFxuICAgICAgICAgICAgICAgICAgICBoaWRlU2VsZWN0ZWQ6IHRoaXMuaGlkZVNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogdGhpcy52aXJ0dWFsaXplZEl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBub0RhdGFUZXh0OiB0aGlzLiR2dWV0aWZ5LnQodGhpcy5ub0RhdGFUZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJdGVtczogdGhpcy5zZWxlY3RlZEl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBpdGVtQXZhdGFyOiB0aGlzLml0ZW1BdmF0YXIsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1EaXNhYmxlZDogdGhpcy5pdGVtRGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1WYWx1ZTogdGhpcy5pdGVtVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1UZXh0OiB0aGlzLml0ZW1UZXh0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6IHRoaXMuc2VsZWN0SXRlbVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2NvcGVkU2xvdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogdGhpcy4kc2NvcGVkU2xvdHMuaXRlbVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXRpY0xpc3Q6IGZ1bmN0aW9uIHN0YXRpY0xpc3QoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kc2xvdHNbJ25vLWRhdGEnXSB8fCB0aGlzLiRzbG90c1sncHJlcGVuZC1pdGVtJ10gfHwgdGhpcy4kc2xvdHNbJ2FwcGVuZC1pdGVtJ10pIHtcbiAgICAgICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcImNvbnNvbGVFcnJvclwiXSkoJ2Fzc2VydDogc3RhdGljTGlzdCBzaG91bGQgbm90IGJlIGNhbGxlZCBpZiBzbG90cyBhcmUgdXNlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZTZWxlY3RMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLCB0aGlzLmxpc3REYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmlydHVhbGl6ZWRJdGVtczogZnVuY3Rpb24gdmlydHVhbGl6ZWRJdGVtcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfbWVudVByb3BzLmF1dG8gPyB0aGlzLmNvbXB1dGVkSXRlbXMgOiB0aGlzLmNvbXB1dGVkSXRlbXMuc2xpY2UoMCwgdGhpcy5sYXN0SXRlbSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lbnVDYW5TaG93OiBmdW5jdGlvbiBtZW51Q2FuU2hvdygpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAkX21lbnVQcm9wczogZnVuY3Rpb24gJF9tZW51UHJvcHMoKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXNlZFByb3BzO1xuICAgICAgICAgICAgbm9ybWFsaXNlZFByb3BzID0gdHlwZW9mIHRoaXMubWVudVByb3BzID09PSAnc3RyaW5nJyA/IHRoaXMubWVudVByb3BzLnNwbGl0KCcsJykgOiB0aGlzLm1lbnVQcm9wcztcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vcm1hbGlzZWRQcm9wcykpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpc2VkUHJvcHMgPSBub3JtYWxpc2VkUHJvcHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHApIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW3AudHJpbSgpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCBkZWZhdWx0TWVudVByb3BzLCB7IHZhbHVlOiB0aGlzLm1lbnVDYW5TaG93ICYmIHRoaXMuaXNNZW51QWN0aXZlLCBudWRnZUJvdHRvbTogdGhpcy5udWRnZUJvdHRvbSA/IHRoaXMubnVkZ2VCb3R0b20gOiBub3JtYWxpc2VkUHJvcHMub2Zmc2V0WSA/IDEgOiAwIH0sIG5vcm1hbGlzZWRQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIGludGVybmFsVmFsdWU6IGZ1bmN0aW9uIGludGVybmFsVmFsdWUodmFsKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJdGVtcygpO1xuICAgICAgICB9LFxuICAgICAgICBpc0Jvb3RlZDogZnVuY3Rpb24gaXNCb290ZWQoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb250ZW50ICYmIF90aGlzLmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF90aGlzLm9uU2Nyb2xsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzTWVudUFjdGl2ZTogZnVuY3Rpb24gaXNNZW51QWN0aXZlKHZhbCkge1xuICAgICAgICAgICAgaWYgKCF2YWwpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNCb290ZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcih2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWNoZUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkSXRlbXMgPSB0aGlzLmZpbHRlckR1cGxpY2F0ZXModGhpcy5jYWNoZWRJdGVtcy5jb25jYXQodmFsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJdGVtcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLiRyZWZzLm1lbnUgJiYgdGhpcy4kcmVmcy5tZW51LiRyZWZzLmNvbnRlbnQ7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIC8qKiBAcHVibGljICovXG4gICAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgICAgICAgICB0aGlzLmlzTWVudUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5ibHVyKCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEBwdWJsaWMgKi9cbiAgICAgICAgYWN0aXZhdGVNZW51OiBmdW5jdGlvbiBhY3RpdmF0ZU1lbnUoKSB7XG4gICAgICAgICAgICB0aGlzLmlzTWVudUFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyYWJsZUNhbGxiYWNrOiBmdW5jdGlvbiBjbGVhcmFibGVDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMubXVsdGlwbGUgPyBbXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLiRyZWZzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wZW5PbkNsZWFyKSB0aGlzLmlzTWVudUFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlQ29uZGl0aW9uYWw6IGZ1bmN0aW9uIGNsb3NlQ29uZGl0aW9uYWwoZSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAvLyBDbGljayBvcmlnaW5hdGVzIGZyb20gb3V0c2lkZSB0aGUgbWVudSBjb250ZW50XG4gICAgICAgICAgICAgICAgISF0aGlzLmNvbnRlbnQgJiYgIXRoaXMuY29udGVudC5jb250YWlucyhlLnRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAvLyBDbGljayBvcmlnaW5hdGVzIGZyb20gb3V0c2lkZSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICEhdGhpcy4kZWwgJiYgIXRoaXMuJGVsLmNvbnRhaW5zKGUudGFyZ2V0KSAmJiBlLnRhcmdldCAhPT0gdGhpcy4kZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlckR1cGxpY2F0ZXM6IGZ1bmN0aW9uIGZpbHRlckR1cGxpY2F0ZXMoYXJyKSB7XG4gICAgICAgICAgICB2YXIgdW5pcXVlVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGFyci5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGFycltpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuZ2V0VmFsdWUoaXRlbSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY29tcGFyYXRvclxuICAgICAgICAgICAgICAgICF1bmlxdWVWYWx1ZXMuaGFzKHZhbCkgJiYgdW5pcXVlVmFsdWVzLnNldCh2YWwsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odW5pcXVlVmFsdWVzLnZhbHVlcygpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZEV4aXN0aW5nSW5kZXg6IGZ1bmN0aW9uIGZpbmRFeGlzdGluZ0luZGV4KGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaXRlbVZhbHVlID0gdGhpcy5nZXRWYWx1ZShpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pbnRlcm5hbFZhbHVlIHx8IFtdKS5maW5kSW5kZXgoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudmFsdWVDb21wYXJhdG9yKF90aGlzLmdldFZhbHVlKGkpLCBpdGVtVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkNoaXBTZWxlY3Rpb246IGZ1bmN0aW9uIGdlbkNoaXBTZWxlY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5yZWFkb25seSB8fCB0aGlzLmdldERpc2FibGVkKGl0ZW0pO1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gZnVuY3Rpb24gZm9jdXMoZSwgY2IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMub25Gb2N1cygpO1xuICAgICAgICAgICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZDaGlwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWNoaXAtLXNlbGVjdC1tdWx0aScsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2U6IHRoaXMuZGVsZXRhYmxlQ2hpcHMgJiYgIWlzRGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogaW5kZXggPT09IHRoaXMuc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgc21hbGw6IHRoaXMuc21hbGxDaGlwc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzKGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24gaW5wdXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub25DaGlwSW5wdXQoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5nZXRWYWx1ZShpdGVtKVxuICAgICAgICAgICAgfSwgdGhpcy5nZXRUZXh0KGl0ZW0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuQ29tbWFTZWxlY3Rpb246IGZ1bmN0aW9uIGdlbkNvbW1hU2VsZWN0aW9uKGl0ZW0sIGluZGV4LCBsYXN0KSB7XG4gICAgICAgICAgICAvLyBJdGVtIG1heSBiZSBhbiBvYmplY3RcbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSBKU09OLnN0cmluZ2lmeVxuICAgICAgICAgICAgdmFyIGtleSA9IEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0VmFsdWUoaXRlbSkpO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gaW5kZXggPT09IHRoaXMuc2VsZWN0ZWRJbmRleCAmJiB0aGlzLmNvbG9yO1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSB0aGlzLmRpc2FibGVkIHx8IHRoaXMuZ2V0RGlzYWJsZWQoaXRlbSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2JywgdGhpcy5zZXRUZXh0Q29sb3IoY29sb3IsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3Ytc2VsZWN0X19zZWxlY3Rpb24gdi1zZWxlY3RfX3NlbGVjdGlvbi0tY29tbWEnLFxuICAgICAgICAgICAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Ytc2VsZWN0X19zZWxlY3Rpb24tLWRpc2FibGVkJzogaXNEaXNhYmxlZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgICAgIH0pLCBcIlwiICsgdGhpcy5nZXRUZXh0KGl0ZW0pICsgKGxhc3QgPyAnJyA6ICcsICcpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuRGVmYXVsdFNsb3Q6IGZ1bmN0aW9uIGdlbkRlZmF1bHRTbG90KCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdlblNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuZ2VuSW5wdXQoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gaXMgYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIC8vIHB1c2ggdGhlIGlucHV0XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnMucHVzaChpbnB1dCk7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHB1c2ggaXQgaW50byBjaGlsZHJlblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zLmNoaWxkcmVuID0gc2VsZWN0aW9ucy5jaGlsZHJlbiB8fCBbXTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zLmNoaWxkcmVuLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXNlbGVjdF9fc2xvdCcsXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5kaXJlY3RpdmVzXG4gICAgICAgICAgICB9LCBbdGhpcy5nZW5MYWJlbCgpLCB0aGlzLnByZWZpeCA/IHRoaXMuZ2VuQWZmaXgoJ3ByZWZpeCcpIDogbnVsbCwgc2VsZWN0aW9ucywgdGhpcy5zdWZmaXggPyB0aGlzLmdlbkFmZml4KCdzdWZmaXgnKSA6IG51bGwsIHRoaXMuZ2VuQ2xlYXJJY29uKCksIHRoaXMuZ2VuSWNvblNsb3QoKV0pLCB0aGlzLmdlbk1lbnUoKSwgdGhpcy5nZW5Qcm9ncmVzcygpXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSW5wdXQ6IGZ1bmN0aW9uIGdlbklucHV0KCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gX1ZUZXh0RmllbGRfVlRleHRGaWVsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLmdlbklucHV0LmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpbnB1dC5kYXRhLmRvbVByb3BzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGlucHV0LmRhdGEuYXR0cnMucmVhZG9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXQuZGF0YS5hdHRyc1snYXJpYS1yZWFkb25seSddID0gU3RyaW5nKHRoaXMucmVhZG9ubHkpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9LFxuICAgICAgICBnZW5MaXN0OiBmdW5jdGlvbiBnZW5MaXN0KCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBzbG90cywgd2UgY2FuIHVzZSBhIGNhY2hlZCBWTm9kZSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICBpZiAodGhpcy4kc2xvdHNbJ25vLWRhdGEnXSB8fCB0aGlzLiRzbG90c1sncHJlcGVuZC1pdGVtJ10gfHwgdGhpcy4kc2xvdHNbJ2FwcGVuZC1pdGVtJ10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5MaXN0V2l0aFNsb3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGljTGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VuTGlzdFdpdGhTbG90OiBmdW5jdGlvbiBnZW5MaXN0V2l0aFNsb3QoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNsb3RzID0gWydwcmVwZW5kLWl0ZW0nLCAnbm8tZGF0YScsICdhcHBlbmQtaXRlbSddLmZpbHRlcihmdW5jdGlvbiAoc2xvdE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJHNsb3RzW3Nsb3ROYW1lXTtcbiAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoc2xvdE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywge1xuICAgICAgICAgICAgICAgICAgICBzbG90OiBzbG90TmFtZVxuICAgICAgICAgICAgICAgIH0sIF90aGlzLiRzbG90c1tzbG90TmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBSZXF1aXJlcyBkZXN0cnVjdHVyaW5nIGR1ZSB0byBWdWVcbiAgICAgICAgICAgIC8vIG1vZGlmeWluZyB0aGUgYG9uYCBwcm9wZXJ0eSB3aGVuIHBhc3NlZFxuICAgICAgICAgICAgLy8gYXMgYSByZWZlcmVuY2VkIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZTZWxlY3RMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdLCBfX2Fzc2lnbih7fSwgdGhpcy5saXN0RGF0YSksIHNsb3RzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuTWVudTogZnVuY3Rpb24gZ2VuTWVudSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoaXMuJF9tZW51UHJvcHM7XG4gICAgICAgICAgICBwcm9wcy5hY3RpdmF0b3IgPSB0aGlzLiRyZWZzWydpbnB1dC1zbG90J107XG4gICAgICAgICAgICAvLyBEZXByZWNhdGUgdXNpbmcgbWVudSBwcm9wcyBkaXJlY3RseVxuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlICgyLjApXG4gICAgICAgICAgICB2YXIgaW5oZXJpdGVkUHJvcHMgPSBPYmplY3Qua2V5cyhfVk1lbnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0ub3B0aW9ucy5wcm9wcyk7XG4gICAgICAgICAgICB2YXIgZGVwcmVjYXRlZFByb3BzID0gT2JqZWN0LmtleXModGhpcy4kYXR0cnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaGVyaXRlZFByb3BzLmluY2x1ZGVzKE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJjYW1lbGl6ZVwiXSkoYXR0cikpKSBhY2MucHVzaChhdHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkZXByZWNhdGVkUHJvcHNfMSA9IF9fdmFsdWVzKGRlcHJlY2F0ZWRQcm9wcyksIGRlcHJlY2F0ZWRQcm9wc18xXzEgPSBkZXByZWNhdGVkUHJvcHNfMS5uZXh0KCk7ICFkZXByZWNhdGVkUHJvcHNfMV8xLmRvbmU7IGRlcHJlY2F0ZWRQcm9wc18xXzEgPSBkZXByZWNhdGVkUHJvcHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBkZXByZWNhdGVkUHJvcHNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wiY2FtZWxpemVcIl0pKHByb3ApXSA9IHRoaXMuJGF0dHJzW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHJlY2F0ZWRQcm9wc18xXzEgJiYgIWRlcHJlY2F0ZWRQcm9wc18xXzEuZG9uZSAmJiAoX2EgPSBkZXByZWNhdGVkUHJvcHNfMS5yZXR1cm4pKSBfYS5jYWxsKGRlcHJlY2F0ZWRQcm9wc18xKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwcmVjYXRlZFByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGUgPSBkZXByZWNhdGVkUHJvcHMubGVuZ3RoID4gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50XzEgPSBkZXByZWNhdGVkUHJvcHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1tPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wiY2FtZWxpemVcIl0pKHApXSA9IF90aGlzLiRhdHRyc1twXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzXzEgPSBkZXByZWNhdGVkUHJvcHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCInXCIgKyBwICsgXCInXCI7XG4gICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBtdWx0aXBsZSA/ICdcXG4nIDogJ1xcJyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbmx5Qm9vbHMgPSBPYmplY3Qua2V5cyhyZXBsYWNlbWVudF8xKS5ldmVyeShmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BUeXBlID0gX1ZNZW51X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLm9wdGlvbnMucHJvcHNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByZXBsYWNlbWVudF8xW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IChwcm9wVHlwZS50eXBlIHx8IHByb3BUeXBlKSA9PT0gQm9vbGVhbiAmJiB2YWx1ZSA9PT0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25seUJvb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudF8xID0gT2JqZWN0LmtleXMocmVwbGFjZW1lbnRfMSkuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50XzEgPSBKU09OLnN0cmluZ2lmeShyZXBsYWNlbWVudF8xLCBudWxsLCBtdWx0aXBsZSA/IDIgOiAwKS5yZXBsYWNlKC9cIihbXihcIilcIl0rKVwiOi9nLCAnJDE6JykucmVwbGFjZSgvXCIvZywgJ1xcJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiY29uc29sZVdhcm5cIl0pKHByb3BzXzEgKyBcIiBcIiArIChtdWx0aXBsZSA/ICdhcmUnIDogJ2lzJykgKyBcIiBkZXByZWNhdGVkLCB1c2UgXCIgKyBzZXBhcmF0b3IgKyBcIjptZW51LXByb3BzPVxcXCJcIiArIHJlcGxhY2VtZW50XzEgKyBcIlxcXCJcIiArIHNlcGFyYXRvciArIFwiIGluc3RlYWRcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXR0YWNoIHRvIHJvb3QgZWwgc28gdGhhdFxuICAgICAgICAgICAgLy8gbWVudSBjb3ZlcnMgcHJlcGVuZC9hcHBlbmQgaWNvbnNcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgdGhpcyBhIGNvbXB1dGVkIHByb3BlcnR5IG9yIGhlbHBlciBvciBzb21ldGhpbmdcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoID09PSAnJyB8fCAvLyBJZiB1c2VkIGFzIGEgYm9vbGVhbiBwcm9wICg8di1tZW51IGF0dGFjaD4pXG4gICAgICAgICAgICB0aGlzLmF0dGFjaCA9PT0gdHJ1ZSB8fCAvLyBJZiBib3VuZCB0byBhIGJvb2xlYW4gKDx2LW1lbnUgOmF0dGFjaD1cInRydWVcIj4pXG4gICAgICAgICAgICB0aGlzLmF0dGFjaCA9PT0gJ2F0dGFjaCcgLy8gSWYgYm91bmQgYXMgYm9vbGVhbiBwcm9wIGluIHB1ZyAodi1tZW51KGF0dGFjaCkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuYXR0YWNoID0gdGhpcy4kZWw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5hdHRhY2ggPSB0aGlzLmF0dGFjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WTWVudV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24gaW5wdXQodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc01lbnVBY3RpdmUgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0ZvY3VzZWQgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZjogJ21lbnUnXG4gICAgICAgICAgICB9LCBbdGhpcy5nZW5MaXN0KCldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuU2VsZWN0aW9uczogZnVuY3Rpb24gZ2VuU2VsZWN0aW9ucygpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgZ2VuU2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNjb3BlZFNsb3RzLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGdlblNlbGVjdGlvbiA9IHRoaXMuZ2VuU2xvdFNlbGVjdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNDaGlwcykge1xuICAgICAgICAgICAgICAgIGdlblNlbGVjdGlvbiA9IHRoaXMuZ2VuQ2hpcFNlbGVjdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuU2VsZWN0aW9uID0gdGhpcy5nZW5Db21tYVNlbGVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2xlbmd0aF0gPSBnZW5TZWxlY3Rpb24odGhpcy5zZWxlY3RlZEl0ZW1zW2xlbmd0aF0sIGxlbmd0aCwgbGVuZ3RoID09PSBjaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXNlbGVjdF9fc2VsZWN0aW9ucydcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuU2xvdFNlbGVjdGlvbjogZnVuY3Rpb24gZ2VuU2xvdFNlbGVjdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNjb3BlZFNsb3RzLnNlbGVjdGlvbih7XG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBpbmRleCA9PT0gdGhpcy5zZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXRNZW51SW5kZXg6IGZ1bmN0aW9uIGdldE1lbnVJbmRleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLm1lbnUgPyB0aGlzLiRyZWZzLm1lbnUubGlzdEluZGV4IDogLTE7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERpc2FibGVkOiBmdW5jdGlvbiBnZXREaXNhYmxlZChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImdldFByb3BlcnR5RnJvbUl0ZW1cIl0pKGl0ZW0sIHRoaXMuaXRlbURpc2FibGVkLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFRleHQ6IGZ1bmN0aW9uIGdldFRleHQoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJnZXRQcm9wZXJ0eUZyb21JdGVtXCJdKShpdGVtLCB0aGlzLml0ZW1UZXh0LCBpdGVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wiZ2V0UHJvcGVydHlGcm9tSXRlbVwiXSkoaXRlbSwgdGhpcy5pdGVtVmFsdWUsIHRoaXMuZ2V0VGV4dChpdGVtKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmx1cjogZnVuY3Rpb24gb25CbHVyKGUpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2JsdXInLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DaGlwSW5wdXQ6IGZ1bmN0aW9uIG9uQ2hpcElucHV0KGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB0aGlzLnNlbGVjdEl0ZW0oaXRlbSk7ZWxzZSB0aGlzLnNldFZhbHVlKG51bGwpO1xuICAgICAgICAgICAgLy8gSWYgYWxsIGl0ZW1zIGhhdmUgYmVlbiBkZWxldGVkLFxuICAgICAgICAgICAgLy8gb3BlbiBgdi1tZW51YFxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTWVudUFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlzYWJsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNNZW51QWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZm9jdXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlckRvd246IGZ1bmN0aW9uIG9uRW50ZXJEb3duKCkge1xuICAgICAgICAgICAgdGhpcy5vbkJsdXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Fc2NEb3duOiBmdW5jdGlvbiBvbkVzY0Rvd24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5pc01lbnVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25LZXlEb3duOiBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgICAgICAgICAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgICAgICAvLyBJZiBlbnRlciwgc3BhY2UsIHVwLCBvciBkb3duIGlzIHByZXNzZWQsIG9wZW4gbWVudVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlYWRvbmx5ICYmICF0aGlzLmlzTWVudUFjdGl2ZSAmJiBbX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wia2V5Q29kZXNcIl0uZW50ZXIsIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImtleUNvZGVzXCJdLnNwYWNlLCBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJrZXlDb2Rlc1wiXS51cCwgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wia2V5Q29kZXNcIl0uZG93bl0uaW5jbHVkZXMoa2V5Q29kZSkpIHRoaXMuYWN0aXZhdGVNZW51KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc01lbnVBY3RpdmUgJiYgdGhpcy4kcmVmcy5tZW51KSB0aGlzLiRyZWZzLm1lbnUuY2hhbmdlTGlzdEluZGV4KGUpO1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgZG8gc29tZXRoaW5nIGRpZmZlcmVudFxuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1tcImtleUNvZGVzXCJdLmVudGVyKSByZXR1cm4gdGhpcy5vbkVudGVyRG93bihlKTtcbiAgICAgICAgICAgIC8vIElmIGVzY2FwZSBkZWFjdGl2YXRlIHRoZSBtZW51XG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wia2V5Q29kZXNcIl0uZXNjKSByZXR1cm4gdGhpcy5vbkVzY0Rvd24oZSk7XG4gICAgICAgICAgICAvLyBJZiB0YWIgLSBzZWxlY3QgaXRlbSBvciBjbG9zZSBtZW51XG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wia2V5Q29kZXNcIl0udGFiKSByZXR1cm4gdGhpcy5vblRhYkRvd24oZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VVcDogZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXBwZW5kSW5uZXIgPSB0aGlzLiRyZWZzWydhcHBlbmQtaW5uZXInXTtcbiAgICAgICAgICAgIC8vIElmIGFwcGVuZCBpbm5lciBpcyBwcmVzZW50XG4gICAgICAgICAgICAvLyBhbmQgdGhlIHRhcmdldCBpcyBpdHNlbGZcbiAgICAgICAgICAgIC8vIG9yIGluc2lkZSwgdG9nZ2xlIG1lbnVcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTWVudUFjdGl2ZSAmJiBhcHBlbmRJbm5lciAmJiAoYXBwZW5kSW5uZXIgPT09IGUudGFyZ2V0IHx8IGFwcGVuZElubmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc01lbnVBY3RpdmUgPSAhX3RoaXMuaXNNZW51QWN0aXZlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIElmIHVzZXIgaXMgY2xpY2tpbmcgaW4gdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC8vIGFuZCBmaWVsZCBpcyBlbmNsb3NlZCwgYWN0aXZhdGUgaXRcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0VuY2xvc2VkICYmICF0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTWVudUFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfVlRleHRGaWVsZF9WVGV4dEZpZWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLm1ldGhvZHMub25Nb3VzZVVwLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2Nyb2xsOiBmdW5jdGlvbiBvblNjcm9sbCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNZW51QWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbnRlbnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdEl0ZW0gPj0gdGhpcy5jb21wdXRlZEl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBzaG93TW9yZUl0ZW1zID0gdGhpcy5jb250ZW50LnNjcm9sbEhlaWdodCAtICh0aGlzLmNvbnRlbnQuc2Nyb2xsVG9wICsgdGhpcy5jb250ZW50LmNsaWVudEhlaWdodCkgPCAyMDA7XG4gICAgICAgICAgICAgICAgaWYgKHNob3dNb3JlSXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0SXRlbSArPSAyMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGFiRG93bjogZnVuY3Rpb24gb25UYWJEb3duKGUpIHtcbiAgICAgICAgICAgIHZhciBtZW51SW5kZXggPSB0aGlzLmdldE1lbnVJbmRleCgpO1xuICAgICAgICAgICAgdmFyIGxpc3RUaWxlID0gdGhpcy4kcmVmcy5tZW51LnRpbGVzW21lbnVJbmRleF07XG4gICAgICAgICAgICAvLyBBbiBpdGVtIHRoYXQgaXMgc2VsZWN0ZWQgYnlcbiAgICAgICAgICAgIC8vIG1lbnUtaW5kZXggc2hvdWxkIHRvZ2dsZWRcbiAgICAgICAgICAgIGlmIChsaXN0VGlsZSAmJiBsaXN0VGlsZS5jbGFzc05hbWUuaW5kZXhPZigndi1saXN0X190aWxlLS1oaWdobGlnaHRlZCcpID4gLTEgJiYgdGhpcy5pc01lbnVBY3RpdmUgJiYgbWVudUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBsaXN0VGlsZS5jbGljaygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBtYWtlIGl0IGhlcmUsXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVzZXIgaGFzIG5vIHNlbGVjdGVkIGluZGV4ZXNcbiAgICAgICAgICAgICAgICAvLyBhbmQgaXMgcHJvYmFibHkgdGFiYmluZyBvdXRcbiAgICAgICAgICAgICAgICBfVlRleHRGaWVsZF9WVGV4dEZpZWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdLm1ldGhvZHMub25CbHVyLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdEl0ZW06IGZ1bmN0aW9uIHNlbGVjdEl0ZW0oaXRlbSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5yZXR1cm5PYmplY3QgPyBpdGVtIDogdGhpcy5nZXRWYWx1ZShpdGVtKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc01lbnVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGludGVybmFsVmFsdWUgPSAodGhpcy5pbnRlcm5hbFZhbHVlIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5maW5kRXhpc3RpbmdJbmRleChpdGVtKTtcbiAgICAgICAgICAgICAgICBpICE9PSAtMSA/IGludGVybmFsVmFsdWUuc3BsaWNlKGksIDEpIDogaW50ZXJuYWxWYWx1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoaW50ZXJuYWxWYWx1ZS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJldHVybk9iamVjdCA/IGkgOiBfdGhpcy5nZXRWYWx1ZShpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzZWxlY3RpbmcgbXVsdGlwbGVcbiAgICAgICAgICAgICAgICAvLyBhZGp1c3QgbWVudSBhZnRlciBlYWNoXG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kcmVmcy5tZW51ICYmIF90aGlzLiRyZWZzLm1lbnUudXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRNZW51SW5kZXg6IGZ1bmN0aW9uIHNldE1lbnVJbmRleChpbmRleCkge1xuICAgICAgICAgICAgdGhpcy4kcmVmcy5tZW51ICYmICh0aGlzLiRyZWZzLm1lbnUubGlzdEluZGV4ID0gaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRTZWxlY3RlZEl0ZW1zOiBmdW5jdGlvbiBzZXRTZWxlY3RlZEl0ZW1zKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkSXRlbXMgPSBbXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSAhdGhpcy5tdWx0aXBsZSB8fCAhQXJyYXkuaXNBcnJheSh0aGlzLmludGVybmFsVmFsdWUpID8gW3RoaXMuaW50ZXJuYWxWYWx1ZV0gOiB0aGlzLmludGVybmFsVmFsdWU7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIF9sb29wXzEodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzXzEuYWxsSXRlbXMuZmluZEluZGV4KGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy52YWx1ZUNvbXBhcmF0b3IoX3RoaXMuZ2V0VmFsdWUodiksIF90aGlzLmdldFZhbHVlKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJdGVtcy5wdXNoKHRoaXNfMS5hbGxJdGVtc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdmFsdWVzXzEgPSBfX3ZhbHVlcyh2YWx1ZXMpLCB2YWx1ZXNfMV8xID0gdmFsdWVzXzEubmV4dCgpOyAhdmFsdWVzXzFfMS5kb25lOyB2YWx1ZXNfMV8xID0gdmFsdWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9sb29wXzEodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgICAgICAgICAgICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlc18xXzEgJiYgIXZhbHVlc18xXzEuZG9uZSAmJiAoX2EgPSB2YWx1ZXNfMS5yZXR1cm4pKSBfYS5jYWxsKHZhbHVlc18xKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1zID0gc2VsZWN0ZWRJdGVtcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTZWxlY3QvVlNlbGVjdExpc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlNlbGVjdC9WU2VsZWN0TGlzdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfY2FyZHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX2NhcmRzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fY2FyZHMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfY2FyZHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19jYXJkc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQ2hlY2tib3hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZDaGVja2JveCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkNoZWNrYm94L2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WRGl2aWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVkRpdmlkZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEaXZpZGVyL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WU3ViaGVhZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WU3ViaGVhZGVyICovIFwiLi9zcmMvY29tcG9uZW50cy9WU3ViaGVhZGVyL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WTGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVkxpc3QgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZMaXN0L2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RoZW1lYWJsZSAqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xudmFyIF9fdmFsdWVzID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3ZhbHVlcyB8fCBmdW5jdGlvbiAobykge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSxcbiAgICAgICAgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLy8gQ29tcG9uZW50c1xuXG5cblxuXG4vLyBNaXhpbnNcblxuXG4vLyBIZWxwZXJzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1zZWxlY3QtbGlzdCcsXG4gICAgbWl4aW5zOiBbX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0XCJdXSxcbiAgICBwcm9wczoge1xuICAgICAgICBhY3Rpb246IEJvb2xlYW4sXG4gICAgICAgIGRlbnNlOiBCb29sZWFuLFxuICAgICAgICBoaWRlU2VsZWN0ZWQ6IEJvb2xlYW4sXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXRlbUF2YXRhcjoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIEZ1bmN0aW9uXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhdmF0YXInXG4gICAgICAgIH0sXG4gICAgICAgIGl0ZW1EaXNhYmxlZDoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXksIEZ1bmN0aW9uXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdkaXNhYmxlZCdcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbVRleHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5LCBGdW5jdGlvbl0sXG4gICAgICAgICAgICBkZWZhdWx0OiAndGV4dCdcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbVZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheSwgRnVuY3Rpb25dLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3ZhbHVlJ1xuICAgICAgICB9LFxuICAgICAgICBub0RhdGFUZXh0OiBTdHJpbmcsXG4gICAgICAgIG5vRmlsdGVyOiBCb29sZWFuLFxuICAgICAgICBzZWFyY2hJbnB1dDoge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RlZEl0ZW1zOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgcGFyc2VkSXRlbXM6IGZ1bmN0aW9uIHBhcnNlZEl0ZW1zKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFZhbHVlKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRpbGVBY3RpdmVDbGFzczogZnVuY3Rpb24gdGlsZUFjdGl2ZUNsYXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0VGV4dENvbG9yKHRoaXMuY29sb3IpLmNsYXNzIHx8IHt9KS5qb2luKCcgJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXRpY05vRGF0YVRpbGU6IGZ1bmN0aW9uIHN0YXRpY05vRGF0YVRpbGUoKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHtcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIFByZXZlbnQgb25CbHVyIGZyb20gYmVpbmcgY2FsbGVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WTGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiVkxpc3RUaWxlXCJdLCB0aWxlLCBbdGhpcy5nZW5UaWxlQ29udGVudCh0aGlzLm5vRGF0YVRleHQpXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuQWN0aW9uOiBmdW5jdGlvbiBnZW5BY3Rpb24oaXRlbSwgaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuJGVtaXQoJ3NlbGVjdCcsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WTGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiVkxpc3RUaWxlQWN0aW9uXCJdLCBkYXRhLCBbdGhpcy4kY3JlYXRlRWxlbWVudChfVkNoZWNrYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KV0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5EaXZpZGVyOiBmdW5jdGlvbiBnZW5EaXZpZGVyKHByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVkRpdmlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sIHsgcHJvcHM6IHByb3BzIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5GaWx0ZXJlZFRleHQ6IGZ1bmN0aW9uIGdlbkZpbHRlcmVkVGV4dCh0ZXh0KSB7XG4gICAgICAgICAgICB0ZXh0ID0gKHRleHQgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VhcmNoSW5wdXQgfHwgdGhpcy5ub0ZpbHRlcikgcmV0dXJuIE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJlc2NhcGVIVE1MXCJdKSh0ZXh0KTtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0TWFza2VkQ2hhcmFjdGVycyh0ZXh0KSxcbiAgICAgICAgICAgICAgICBzdGFydCA9IF9hLnN0YXJ0LFxuICAgICAgICAgICAgICAgIG1pZGRsZSA9IF9hLm1pZGRsZSxcbiAgICAgICAgICAgICAgICBlbmQgPSBfYS5lbmQ7XG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJlc2NhcGVIVE1MXCJdKShzdGFydCkgKyB0aGlzLmdlbkhpZ2hsaWdodChtaWRkbGUpICsgT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImVzY2FwZUhUTUxcIl0pKGVuZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkhlYWRlcjogZnVuY3Rpb24gZ2VuSGVhZGVyKHByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVlN1YmhlYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSwgeyBwcm9wczogcHJvcHMgfSwgcHJvcHMuaGVhZGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSGlnaGxpZ2h0OiBmdW5jdGlvbiBnZW5IaWdobGlnaHQodGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiPHNwYW4gY2xhc3M9XFxcInYtbGlzdF9fdGlsZV9fbWFza1xcXCI+XCIgKyBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZXNjYXBlSFRNTFwiXSkodGV4dCkgKyBcIjwvc3Bhbj5cIjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TWFza2VkQ2hhcmFjdGVyczogZnVuY3Rpb24gZ2V0TWFza2VkQ2hhcmFjdGVycyh0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgc2VhcmNoSW5wdXQgPSAodGhpcy5zZWFyY2hJbnB1dCB8fCAnJykudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGV4dC50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoSW5wdXQpO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIHsgc3RhcnQ6ICcnLCBtaWRkbGU6IHRleHQsIGVuZDogJycgfTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRleHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIG1pZGRsZSA9IHRleHQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0ZXh0LnNsaWNlKGluZGV4ICsgc2VhcmNoSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgbWlkZGxlOiBtaWRkbGUsIGVuZDogZW5kIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdlblRpbGU6IGZ1bmN0aW9uIGdlblRpbGUoaXRlbSwgZGlzYWJsZWQsIGF2YXRhciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGRpc2FibGVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdmF0YXIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGF2YXRhciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaGFzSXRlbShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtID09PSBPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBhdmF0YXIgPSB0aGlzLmdldEF2YXRhcihpdGVtKTtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IGRpc2FibGVkICE9PSBudWxsID8gZGlzYWJsZWQgOiB0aGlzLmdldERpc2FibGVkKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRpbGUgPSB7XG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbiBtb3VzZWRvd24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBvbkJsdXIgZnJvbSBiZWluZyBjYWxsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpc2FibGVkIHx8IF90aGlzLiRlbWl0KCdzZWxlY3QnLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ2xhc3M6IHRoaXMudGlsZUFjdGl2ZUNsYXNzLFxuICAgICAgICAgICAgICAgICAgICBhdmF0YXI6IGF2YXRhcixcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICByaXBwbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuJHNjb3BlZFNsb3RzLml0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVkxpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIlZMaXN0VGlsZVwiXSwgdGlsZSwgW3RoaXMuYWN0aW9uICYmICF0aGlzLmhpZGVTZWxlY3RlZCAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDAgPyB0aGlzLmdlbkFjdGlvbihpdGVtLCB2YWx1ZSkgOiBudWxsLCB0aGlzLmdlblRpbGVDb250ZW50KGl0ZW0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzY29wZWRTbG90ID0gdGhpcy4kc2NvcGVkU2xvdHMuaXRlbSh7IHBhcmVudDogcGFyZW50LCBpdGVtOiBpdGVtLCB0aWxlOiB0aWxlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVlZHNUaWxlKHNjb3BlZFNsb3QpID8gdGhpcy4kY3JlYXRlRWxlbWVudChfVkxpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIlZMaXN0VGlsZVwiXSwgdGlsZSwgW3Njb3BlZFNsb3RdKSA6IHNjb3BlZFNsb3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblRpbGVDb250ZW50OiBmdW5jdGlvbiBnZW5UaWxlQ29udGVudChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJIVE1MID0gdGhpcy5nZW5GaWx0ZXJlZFRleHQodGhpcy5nZXRUZXh0KGl0ZW0pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WTGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiVkxpc3RUaWxlQ29udGVudFwiXSwgW3RoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJWTGlzdFRpbGVUaXRsZVwiXSwge1xuICAgICAgICAgICAgICAgIGRvbVByb3BzOiB7IGlubmVySFRNTDogaW5uZXJIVE1MIH1cbiAgICAgICAgICAgIH0pXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0l0ZW06IGZ1bmN0aW9uIGhhc0l0ZW0oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkSXRlbXMuaW5kZXhPZih0aGlzLmdldFZhbHVlKGl0ZW0pKSA+IC0xO1xuICAgICAgICB9LFxuICAgICAgICBuZWVkc1RpbGU6IGZ1bmN0aW9uIG5lZWRzVGlsZSh0aWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGlsZS5jb21wb25lbnRPcHRpb25zID09IG51bGwgfHwgdGlsZS5jb21wb25lbnRPcHRpb25zLkN0b3Iub3B0aW9ucy5uYW1lICE9PSAndi1saXN0LXRpbGUnO1xuICAgICAgICB9LFxuICAgICAgICBnZXRBdmF0YXI6IGZ1bmN0aW9uIGdldEF2YXRhcihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZ2V0UHJvcGVydHlGcm9tSXRlbVwiXSkoaXRlbSwgdGhpcy5pdGVtQXZhdGFyLCBmYWxzZSkpO1xuICAgICAgICB9LFxuICAgICAgICBnZXREaXNhYmxlZDogZnVuY3Rpb24gZ2V0RGlzYWJsZWQoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImdldFByb3BlcnR5RnJvbUl0ZW1cIl0pKGl0ZW0sIHRoaXMuaXRlbURpc2FibGVkLCBmYWxzZSkpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRUZXh0OiBmdW5jdGlvbiBnZXRUZXh0KGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImdldFByb3BlcnR5RnJvbUl0ZW1cIl0pKGl0ZW0sIHRoaXMuaXRlbVRleHQsIGl0ZW0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZ2V0UHJvcGVydHlGcm9tSXRlbVwiXSkoaXRlbSwgdGhpcy5pdGVtVmFsdWUsIHRoaXMuZ2V0VGV4dChpdGVtKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuaXRlbXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWRlU2VsZWN0ZWQgJiYgdGhpcy5oYXNJdGVtKGl0ZW0pKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PSBudWxsKSBjaGlsZHJlbi5wdXNoKHRoaXMuZ2VuVGlsZShpdGVtKSk7ZWxzZSBpZiAoaXRlbS5oZWFkZXIpIGNoaWxkcmVuLnB1c2godGhpcy5nZW5IZWFkZXIoaXRlbSkpO2Vsc2UgaWYgKGl0ZW0uZGl2aWRlcikgY2hpbGRyZW4ucHVzaCh0aGlzLmdlbkRpdmlkZXIoaXRlbSkpO2Vsc2UgY2hpbGRyZW4ucHVzaCh0aGlzLmdlblRpbGUoaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuLnB1c2godGhpcy4kc2xvdHNbJ25vLWRhdGEnXSB8fCB0aGlzLnN0YXRpY05vRGF0YVRpbGUpO1xuICAgICAgICB0aGlzLiRzbG90c1sncHJlcGVuZC1pdGVtJ10gJiYgY2hpbGRyZW4udW5zaGlmdCh0aGlzLiRzbG90c1sncHJlcGVuZC1pdGVtJ10pO1xuICAgICAgICB0aGlzLiRzbG90c1snYXBwZW5kLWl0ZW0nXSAmJiBjaGlsZHJlbi5wdXNoKHRoaXMuJHNsb3RzWydhcHBlbmQtaXRlbSddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1zZWxlY3QtbGlzdCB2LWNhcmQnLFxuICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy50aGVtZUNsYXNzZXNcbiAgICAgICAgfSwgW3RoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJWTGlzdFwiXSwge1xuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBkZW5zZTogdGhpcy5kZW5zZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjaGlsZHJlbildKTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WU2VsZWN0L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZTZWxlY3QvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZTZWxlY3QsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNlbGVjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHdyYXBwZXI7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WU2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZTZWxlY3QgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTZWxlY3QvVlNlbGVjdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVk92ZXJmbG93QnRuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WT3ZlcmZsb3dCdG4gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZPdmVyZmxvd0J0bi9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkF1dG9jb21wbGV0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVkF1dG9jb21wbGV0ZSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkF1dG9jb21wbGV0ZS9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkNvbWJvYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WQ29tYm9ib3ggKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDb21ib2JveC9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9yZWJ1aWxkRnVuY3Rpb25hbFNsb3RzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL3JlYnVpbGRGdW5jdGlvbmFsU2xvdHMgKi8gXCIuL3NyYy91dGlsL3JlYnVpbGRGdW5jdGlvbmFsU2xvdHMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZGVkdXBlTW9kZWxMaXN0ZW5lcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvZGVkdXBlTW9kZWxMaXN0ZW5lcnMgKi8gXCIuL3NyYy91dGlsL2RlZHVwZU1vZGVsTGlzdGVuZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvY29uc29sZSAqLyBcIi4vc3JjL3V0aWwvY29uc29sZS50c1wiKTtcblxuXG5cblxuXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbnZhciB3cmFwcGVyID0ge1xuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgJF93cmFwcGVyRm9yOiBfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSxcbiAgICBwcm9wczoge1xuICAgICAgICAvLyBWQXV0b0NvbXBsZXRlXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBhdXRvY29tcGxldGU6IEJvb2xlYW4sXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBjb21ib2JveDogQm9vbGVhbixcbiAgICAgICAgbXVsdGlwbGU6IEJvb2xlYW4sXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICB0YWdzOiBCb29sZWFuLFxuICAgICAgICAvLyBWT3ZlcmZsb3dCdG5cbiAgICAgICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgb3ZlcmZsb3c6IEJvb2xlYW4sXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBzZWdtZW50ZWQ6IEJvb2xlYW5cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9hKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IF9hLnByb3BzLFxuICAgICAgICAgICAgZGF0YSA9IF9hLmRhdGEsXG4gICAgICAgICAgICBzbG90cyA9IF9hLnNsb3RzLFxuICAgICAgICAgICAgcGFyZW50ID0gX2EucGFyZW50O1xuICAgICAgICBPYmplY3QoX3V0aWxfZGVkdXBlTW9kZWxMaXN0ZW5lcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0pKGRhdGEpO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBPYmplY3QoX3V0aWxfcmVidWlsZEZ1bmN0aW9uYWxTbG90c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSkoc2xvdHMoKSwgaCk7XG4gICAgICAgIGlmIChwcm9wcy5hdXRvY29tcGxldGUpIHtcbiAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZXByZWNhdGVcIl0pKCc8di1zZWxlY3QgYXV0b2NvbXBsZXRlPicsICc8di1hdXRvY29tcGxldGU+Jywgd3JhcHBlciwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuY29tYm9ib3gpIHtcbiAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZXByZWNhdGVcIl0pKCc8di1zZWxlY3QgY29tYm9ib3g+JywgJzx2LWNvbWJvYm94PicsIHdyYXBwZXIsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLnRhZ3MpIHtcbiAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZXByZWNhdGVcIl0pKCc8di1zZWxlY3QgdGFncz4nLCAnPHYtY29tYm9ib3ggbXVsdGlwbGU+Jywgd3JhcHBlciwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMub3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZXByZWNhdGVcIl0pKCc8di1zZWxlY3Qgb3ZlcmZsb3c+JywgJzx2LW92ZXJmbG93LWJ0bj4nLCB3cmFwcGVyLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5zZWdtZW50ZWQpIHtcbiAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZXByZWNhdGVcIl0pKCc8di1zZWxlY3Qgc2VnbWVudGVkPicsICc8di1vdmVyZmxvdy1idG4gc2VnbWVudGVkPicsIHdyYXBwZXIsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZGVwcmVjYXRlXCJdKSgnPHYtc2VsZWN0IGVkaXRhYmxlPicsICc8di1vdmVyZmxvdy1idG4gZWRpdGFibGU+Jywgd3JhcHBlciwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuY29tYm9ib3ggfHwgcHJvcHMudGFncykge1xuICAgICAgICAgICAgZGF0YS5hdHRycy5tdWx0aXBsZSA9IHByb3BzLnRhZ3M7XG4gICAgICAgICAgICByZXR1cm4gaChfVkNvbWJvYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLCBkYXRhLCBjaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMuYXV0b2NvbXBsZXRlKSB7XG4gICAgICAgICAgICBkYXRhLmF0dHJzLm11bHRpcGxlID0gcHJvcHMubXVsdGlwbGU7XG4gICAgICAgICAgICByZXR1cm4gaChfVkF1dG9jb21wbGV0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwgZGF0YSwgY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLm92ZXJmbG93IHx8IHByb3BzLnNlZ21lbnRlZCB8fCBwcm9wcy5lZGl0YWJsZSkge1xuICAgICAgICAgICAgZGF0YS5hdHRycy5zZWdtZW50ZWQgPSBwcm9wcy5zZWdtZW50ZWQ7XG4gICAgICAgICAgICBkYXRhLmF0dHJzLmVkaXRhYmxlID0gcHJvcHMuZWRpdGFibGU7XG4gICAgICAgICAgICByZXR1cm4gaChfVk92ZXJmbG93QnRuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCBkYXRhLCBjaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLmF0dHJzLm11bHRpcGxlID0gcHJvcHMubXVsdGlwbGU7XG4gICAgICAgICAgICByZXR1cm4gaChfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSwgZGF0YSwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh3cmFwcGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WU2xpZGVyL1ZTbGlkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WU2xpZGVyL1ZTbGlkZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc2xpZGVyc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fc2xpZGVycy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3NsaWRlcnMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc2xpZGVyc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX3NsaWRlcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3RyYW5zaXRpb25zICovIFwiLi9zcmMvY29tcG9uZW50cy90cmFuc2l0aW9ucy9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVklucHV0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WSW5wdXQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJbnB1dC9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlyZWN0aXZlc19jbGlja19vdXRzaWRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUgKi8gXCIuL3NyYy9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvY29uc29sZSAqLyBcIi4vc3JjL3V0aWwvY29uc29sZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2xvYWRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvbG9hZGFibGUgKi8gXCIuL3NyYy9taXhpbnMvbG9hZGFibGUudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBTdHlsZXNcblxuLy8gQ29tcG9uZW50c1xuXG4vLyBFeHRlbnNpb25zXG5cbi8vIERpcmVjdGl2ZXNcblxuLy8gVXRpbGl0aWVzXG5cblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3Ytc2xpZGVyJyxcbiAgICBkaXJlY3RpdmVzOiB7IENsaWNrT3V0c2lkZTogX2RpcmVjdGl2ZXNfY2xpY2tfb3V0c2lkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSB9LFxuICAgIGV4dGVuZHM6IF9WSW5wdXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sXG4gICAgbWl4aW5zOiBbX21peGluc19sb2FkYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWx3YXlzRGlydHk6IEJvb2xlYW4sXG4gICAgICAgIGludmVyc2VMYWJlbDogQm9vbGVhbixcbiAgICAgICAgbGFiZWw6IFN0cmluZyxcbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICB9LFxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAxMDBcbiAgICAgICAgfSxcbiAgICAgICAgcmFuZ2U6IEJvb2xlYW4sXG4gICAgICAgIHN0ZXA6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3Iodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nIHx8IHYgPT09ICdhbHdheXMnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aWNrTGFiZWxzOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGlja1NpemU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIHRodW1iQ29sb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdGh1bWJMYWJlbDoge1xuICAgICAgICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3Iodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nIHx8IHYgPT09ICdhbHdheXMnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aHVtYlNpemU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAzMlxuICAgICAgICB9LFxuICAgICAgICB0cmFja0NvbG9yOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBbTnVtYmVyLCBTdHJpbmddXG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKHZtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcHA6IHt9LFxuICAgICAgICAgICAgaXNBY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAga2V5UHJlc3NlZDogMCxcbiAgICAgICAgICAgIGxhenlWYWx1ZTogdHlwZW9mIHZtLnZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZtLnZhbHVlIDogTnVtYmVyKHZtLm1pbiksXG4gICAgICAgICAgICBvbGRWYWx1ZTogbnVsbFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3YtaW5wdXQtLXNsaWRlcic6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3YtaW5wdXQtLXNsaWRlci0tdGlja3MnOiB0aGlzLnNob3dUaWNrcyxcbiAgICAgICAgICAgICAgICAndi1pbnB1dC0tc2xpZGVyLS1pbnZlcnNlLWxhYmVsJzogdGhpcy5pbnZlcnNlTGFiZWwsXG4gICAgICAgICAgICAgICAgJ3YtaW5wdXQtLXNsaWRlci0tdGlja3MtbGFiZWxzJzogdGhpcy50aWNrTGFiZWxzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgJ3YtaW5wdXQtLXNsaWRlci0tdGh1bWItbGFiZWwnOiB0aGlzLnRodW1iTGFiZWwgfHwgdGhpcy4kc2NvcGVkU2xvdHMudGh1bWJMYWJlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd1RpY2tzOiBmdW5jdGlvbiBzaG93VGlja3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aWNrTGFiZWxzLmxlbmd0aCA+IDAgfHwgIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5zdGVwTnVtZXJpYyAmJiAhIXRoaXMudGlja3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dUaHVtYkxhYmVsOiBmdW5jdGlvbiBzaG93VGh1bWJMYWJlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZCAmJiAoISF0aGlzLnRodW1iTGFiZWwgfHwgdGhpcy50aHVtYkxhYmVsID09PSAnJyB8fCB0aGlzLiRzY29wZWRTbG90c1sndGh1bWItbGFiZWwnXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkQ29sb3I6IGZ1bmN0aW9uIGNvbXB1dGVkQ29sb3IoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0aW9uU3RhdGUgfHwgdGhpcy5jb2xvciB8fCAncHJpbWFyeSc7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkVHJhY2tDb2xvcjogZnVuY3Rpb24gY29tcHV0ZWRUcmFja0NvbG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyBudWxsIDogdGhpcy50cmFja0NvbG9yIHx8IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkVGh1bWJDb2xvcjogZnVuY3Rpb24gY29tcHV0ZWRUaHVtYkNvbG9yKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMuaXNEaXJ0eSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0aW9uU3RhdGUgfHwgdGhpcy50aHVtYkNvbG9yIHx8IHRoaXMuY29sb3IgfHwgJ3ByaW1hcnknO1xuICAgICAgICB9LFxuICAgICAgICBpbnRlcm5hbFZhbHVlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXp5VmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbWluID0gX2EubWluLFxuICAgICAgICAgICAgICAgICAgICBtYXggPSBfYS5tYXg7XG4gICAgICAgICAgICAgICAgLy8gUm91bmQgdmFsdWUgdG8gZW5zdXJlIHRoZVxuICAgICAgICAgICAgICAgIC8vIGVudGlyZSBzbGlkZXIgcmFuZ2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gYmUgc2VsZWN0ZWQgd2l0aCBzdGVwXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5yb3VuZFZhbHVlKE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLmxhenlWYWx1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMubGF6eVZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdGVwTnVtZXJpYzogZnVuY3Rpb24gc3RlcE51bWVyaWMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwID4gMCA/IHBhcnNlRmxvYXQodGhpcy5zdGVwKSA6IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYWNrRmlsbFN0eWxlczogZnVuY3Rpb24gdHJhY2tGaWxsU3R5bGVzKCkge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLiR2dWV0aWZ5LnJ0bCA/ICdhdXRvJyA6IDA7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLiR2dWV0aWZ5LnJ0bCA/IDAgOiAnYXV0byc7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmlucHV0V2lkdGggKyBcIiVcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB3aWR0aCA9IFwiY2FsYyhcIiArIHRoaXMuaW5wdXRXaWR0aCArIFwiJSAtIDhweClcIjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy50cmFja1RyYW5zaXRpb24sXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB0cmFja1BhZGRpbmc6IGZ1bmN0aW9uIHRyYWNrUGFkZGluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQWN0aXZlIHx8IHRoaXMuaW5wdXRXaWR0aCA+IDAgfHwgdGhpcy5kaXNhYmxlZCA/IDAgOiA3O1xuICAgICAgICB9LFxuICAgICAgICB0cmFja1N0eWxlczogZnVuY3Rpb24gdHJhY2tTdHlsZXMoKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tQYWRkaW5nID0gdGhpcy5kaXNhYmxlZCA/IFwiY2FsYyhcIiArIHRoaXMuaW5wdXRXaWR0aCArIFwiJSArIDhweClcIiA6IHRoaXMudHJhY2tQYWRkaW5nICsgXCJweFwiO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLiR2dWV0aWZ5LnJ0bCA/ICdhdXRvJyA6IHRyYWNrUGFkZGluZztcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMuJHZ1ZXRpZnkucnRsID8gdHJhY2tQYWRkaW5nIDogJ2F1dG8nO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5kaXNhYmxlZCA/IFwiY2FsYyhcIiArICgxMDAgLSB0aGlzLmlucHV0V2lkdGgpICsgXCIlIC0gOHB4KVwiIDogJzEwMCUnO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLnRyYWNrVHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tTdHlsZXM6IGZ1bmN0aW9uIHRpY2tTdHlsZXMoKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE51bWJlcih0aGlzLnRpY2tTaXplKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2JvcmRlci13aWR0aCc6IHNpemUgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiBzaXplID4gMSA/ICc1MCUnIDogbnVsbCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNpemUgPiAxID8gXCJ0cmFuc2xhdGVYKC1cIiArIHNpemUgKyBcInB4KSB0cmFuc2xhdGVZKC1cIiArIChzaXplIC0gMSkgKyBcInB4KVwiIDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhY2tUcmFuc2l0aW9uOiBmdW5jdGlvbiB0cmFja1RyYW5zaXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlQcmVzc2VkID49IDIgPyAnbm9uZScgOiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbnVtVGlja3M6IGZ1bmN0aW9uIG51bVRpY2tzKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCgodGhpcy5tYXggLSB0aGlzLm1pbikgLyB0aGlzLnN0ZXBOdW1lcmljKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXRXaWR0aDogZnVuY3Rpb24gaW5wdXRXaWR0aCgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5yb3VuZFZhbHVlKHRoaXMuaW50ZXJuYWxWYWx1ZSkgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikgKiAxMDA7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGlydHk6IGZ1bmN0aW9uIGlzRGlydHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFZhbHVlID4gdGhpcy5taW4gfHwgdGhpcy5hbHdheXNEaXJ0eTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgbWluOiBmdW5jdGlvbiBtaW4odmFsKSB7XG4gICAgICAgICAgICB2YWwgPiB0aGlzLmludGVybmFsVmFsdWUgJiYgdGhpcy4kZW1pdCgnaW5wdXQnLCBwYXJzZUZsb2F0KHZhbCkpO1xuICAgICAgICB9LFxuICAgICAgICBtYXg6IGZ1bmN0aW9uIG1heCh2YWwpIHtcbiAgICAgICAgICAgIHZhbCA8IHRoaXMuaW50ZXJuYWxWYWx1ZSAmJiB0aGlzLiRlbWl0KCdpbnB1dCcsIHBhcnNlRmxvYXQodmFsKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgICAgLy8gV2l0aG91dCBhIHYtYXBwLCBpT1MgZG9lcyBub3Qgd29yayB3aXRoIGJvZHkgc2VsZWN0b3JzXG4gICAgICAgIHRoaXMuYXBwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtYXBwXScpIHx8IE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJjb25zb2xlV2FyblwiXSkoJ01pc3Npbmcgdi1hcHAgb3IgYSBub24tYm9keSB3cmFwcGluZyBlbGVtZW50IHdpdGggdGhlIFtkYXRhLWFwcF0gYXR0cmlidXRlJywgdGhpcyk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlbkRlZmF1bHRTbG90OiBmdW5jdGlvbiBnZW5EZWZhdWx0U2xvdCgpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFt0aGlzLmdlbkxhYmVsKCldO1xuICAgICAgICAgICAgdmFyIHNsaWRlciA9IHRoaXMuZ2VuU2xpZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmludmVyc2VMYWJlbCA/IGNoaWxkcmVuLnVuc2hpZnQoc2xpZGVyKSA6IGNoaWxkcmVuLnB1c2goc2xpZGVyKTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5nZW5Qcm9ncmVzcygpKTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuTGlzdGVuZXJzOiBmdW5jdGlvbiBnZW5MaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJsdXI6IHRoaXMub25CbHVyLFxuICAgICAgICAgICAgICAgIGNsaWNrOiB0aGlzLm9uU2xpZGVyQ2xpY2ssXG4gICAgICAgICAgICAgICAgZm9jdXM6IHRoaXMub25Gb2N1cyxcbiAgICAgICAgICAgICAgICBrZXlkb3duOiB0aGlzLm9uS2V5RG93bixcbiAgICAgICAgICAgICAgICBrZXl1cDogdGhpcy5vbktleVVwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBnZW5JbnB1dDogZnVuY3Rpb24gZ2VuSW5wdXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduKHsgJ2FyaWEtbGFiZWwnOiB0aGlzLmxhYmVsLCBuYW1lOiB0aGlzLm5hbWUsIHJvbGU6ICdzbGlkZXInLCB0YWJpbmRleDogdGhpcy5kaXNhYmxlZCA/IC0xIDogdGhpcy4kYXR0cnMudGFiaW5kZXgsIHZhbHVlOiB0aGlzLmludGVybmFsVmFsdWUsIHJlYWRvbmx5OiB0cnVlLCAnYXJpYS1yZWFkb25seSc6IFN0cmluZyh0aGlzLnJlYWRvbmx5KSwgJ2FyaWEtdmFsdWVtaW4nOiB0aGlzLm1pbiwgJ2FyaWEtdmFsdWVtYXgnOiB0aGlzLm1heCwgJ2FyaWEtdmFsdWVub3cnOiB0aGlzLmludGVybmFsVmFsdWUgfSwgdGhpcy4kYXR0cnMpLFxuICAgICAgICAgICAgICAgIG9uOiB0aGlzLmdlbkxpc3RlbmVycygpLFxuICAgICAgICAgICAgICAgIHJlZjogJ2lucHV0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblNsaWRlcjogZnVuY3Rpb24gZ2VuU2xpZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3Ytc2xpZGVyJyxcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiB7XG4gICAgICAgICAgICAgICAgICAgICd2LXNsaWRlci0taXMtYWN0aXZlJzogdGhpcy5pc0FjdGl2ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NsaWNrLW91dHNpZGUnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5vbkJsdXJcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSwgdGhpcy5nZW5DaGlsZHJlbigpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuQ2hpbGRyZW46IGZ1bmN0aW9uIGdlbkNoaWxkcmVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmdlbklucHV0KCksIHRoaXMuZ2VuVHJhY2tDb250YWluZXIoKSwgdGhpcy5nZW5TdGVwcygpLCB0aGlzLmdlblRodW1iQ29udGFpbmVyKHRoaXMuaW50ZXJuYWxWYWx1ZSwgdGhpcy5pbnB1dFdpZHRoLCB0aGlzLmlzRm9jdXNlZCB8fCB0aGlzLmlzQWN0aXZlLCB0aGlzLm9uVGh1bWJNb3VzZURvd24pXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuU3RlcHM6IGZ1bmN0aW9uIGdlblN0ZXBzKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGVwIHx8ICF0aGlzLnNob3dUaWNrcykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgdGlja3MgPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiY3JlYXRlUmFuZ2VcIl0pKHRoaXMubnVtVGlja3MgKyAxKS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudGlja0xhYmVsc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKF90aGlzLiRjcmVhdGVFbGVtZW50KCdzcGFuJywgX3RoaXMudGlja0xhYmVsc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXNsaWRlcl9fdGlja3MnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3Ytc2xpZGVyX190aWNrcy0tYWx3YXlzLXNob3cnOiBfdGhpcy50aWNrcyA9PT0gJ2Fsd2F5cycgfHwgX3RoaXMudGlja0xhYmVscy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiBfX2Fzc2lnbih7fSwgX3RoaXMudGlja1N0eWxlcywgeyBsZWZ0OiBpICogKDEwMCAvIF90aGlzLm51bVRpY2tzKSArIFwiJVwiIH0pXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1zbGlkZXJfX3RpY2tzLWNvbnRhaW5lcidcbiAgICAgICAgICAgIH0sIHRpY2tzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuVGh1bWI6IGZ1bmN0aW9uIGdlblRodW1iKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMuY29tcHV0ZWRUaHVtYkNvbG9yLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXNsaWRlcl9fdGh1bWInXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblRodW1iQ29udGFpbmVyOiBmdW5jdGlvbiBnZW5UaHVtYkNvbnRhaW5lcih2YWx1ZSwgdmFsdWVXaWR0aCwgaXNBY3RpdmUsIG9uRHJhZykge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW3RoaXMuZ2VuVGh1bWIoKV07XG4gICAgICAgICAgICB2YXIgdGh1bWJMYWJlbENvbnRlbnQgPSB0aGlzLmdldExhYmVsKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1RodW1iTGFiZWwgJiYgY2hpbGRyZW4ucHVzaCh0aGlzLmdlblRodW1iTGFiZWwodGh1bWJMYWJlbENvbnRlbnQpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB0aGlzLnNldFRleHRDb2xvcih0aGlzLmNvbXB1dGVkVGh1bWJDb2xvciwge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1zbGlkZXJfX3RodW1iLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzoge1xuICAgICAgICAgICAgICAgICAgICAndi1zbGlkZXJfX3RodW1iLWNvbnRhaW5lci0taXMtYWN0aXZlJzogaXNBY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgICd2LXNsaWRlcl9fdGh1bWItY29udGFpbmVyLS1zaG93LWxhYmVsJzogdGhpcy5zaG93VGh1bWJMYWJlbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy50cmFja1RyYW5zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICh0aGlzLiR2dWV0aWZ5LnJ0bCA/IDEwMCAtIHZhbHVlV2lkdGggOiB2YWx1ZVdpZHRoKSArIFwiJVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaHN0YXJ0OiBvbkRyYWcsXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlZG93bjogb25EcmFnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIGNoaWxkcmVuKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuVGh1bWJMYWJlbDogZnVuY3Rpb24gZ2VuVGh1bWJMYWJlbChjb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJjb252ZXJ0VG9Vbml0XCJdKSh0aGlzLnRodW1iU2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlZTY2FsZVRyYW5zaXRpb25cIl0sIHtcbiAgICAgICAgICAgICAgICBwcm9wczogeyBvcmlnaW46ICdib3R0b20gY2VudGVyJyB9XG4gICAgICAgICAgICB9LCBbdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1zbGlkZXJfX3RodW1iLWxhYmVsX19jb250YWluZXInLFxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzaG93JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaXNGb2N1c2VkIHx8IHRoaXMuaXNBY3RpdmUgfHwgdGhpcy50aHVtYkxhYmVsID09PSAnYWx3YXlzJ1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LCBbdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2JywgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5jb21wdXRlZFRodW1iQ29sb3IsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3Ytc2xpZGVyX190aHVtYi1sYWJlbCcsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2l6ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBbY29udGVudF0pXSldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuVHJhY2tDb250YWluZXI6IGZ1bmN0aW9uIGdlblRyYWNrQ29udGFpbmVyKCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW3RoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMuY29tcHV0ZWRUcmFja0NvbG9yLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXNsaWRlcl9fdHJhY2snLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLnRyYWNrU3R5bGVzXG4gICAgICAgICAgICB9KSksIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMuY29tcHV0ZWRDb2xvciwge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1zbGlkZXJfX3RyYWNrLWZpbGwnLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLnRyYWNrRmlsbFN0eWxlc1xuICAgICAgICAgICAgfSkpXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXNsaWRlcl9fdHJhY2tfX2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgcmVmOiAndHJhY2snXG4gICAgICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldExhYmVsOiBmdW5jdGlvbiBnZXRMYWJlbCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNjb3BlZFNsb3RzWyd0aHVtYi1sYWJlbCddID8gdGhpcy4kc2NvcGVkU2xvdHNbJ3RodW1iLWxhYmVsJ10oeyB2YWx1ZTogdmFsdWUgfSkgOiB0aGlzLiRjcmVhdGVFbGVtZW50KCdzcGFuJywgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cihlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5rZXlQcmVzc2VkID09PSAyKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnYmx1cicsIGUpO1xuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzOiBmdW5jdGlvbiBvbkZvY3VzKGUpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2ZvY3VzJywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGh1bWJNb3VzZURvd246IGZ1bmN0aW9uIG9uVGh1bWJNb3VzZURvd24oZSkge1xuICAgICAgICAgICAgdGhpcy5vbGRWYWx1ZSA9IHRoaXMuaW50ZXJuYWxWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMua2V5UHJlc3NlZCA9IDI7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCd0b3VjaGVzJyBpbiBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHAuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vbk1vdXNlTW92ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImFkZE9uY2VFdmVudExpc3RlbmVyXCJdKSh0aGlzLmFwcCwgJ3RvdWNoZW5kJywgdGhpcy5vblNsaWRlck1vdXNlVXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiYWRkT25jZUV2ZW50TGlzdGVuZXJcIl0pKHRoaXMuYXBwLCAnbW91c2V1cCcsIHRoaXMub25TbGlkZXJNb3VzZVVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3N0YXJ0JywgdGhpcy5pbnRlcm5hbFZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TbGlkZXJNb3VzZVVwOiBmdW5jdGlvbiBvblNsaWRlck1vdXNlVXAoKSB7XG4gICAgICAgICAgICB0aGlzLmtleVByZXNzZWQgPSAwO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFwcC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnZW5kJywgdGhpcy5pbnRlcm5hbFZhbHVlKTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZXBFcXVhbFwiXSkodGhpcy5vbGRWYWx1ZSwgdGhpcy5pbnRlcm5hbFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMuaW50ZXJuYWxWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbiBvbk1vdXNlTW92ZShlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLnBhcnNlTW91c2VNb3ZlKGUpLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gX2EudmFsdWUsXG4gICAgICAgICAgICAgICAgaXNJbnNpZGVUcmFjayA9IF9hLmlzSW5zaWRlVHJhY2s7XG4gICAgICAgICAgICBpZiAoaXNJbnNpZGVUcmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMucmVhZG9ubHkpIHJldHVybjtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VLZXlEb3duKGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJuYWxWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5VXA6IGZ1bmN0aW9uIG9uS2V5VXAoKSB7XG4gICAgICAgICAgICB0aGlzLmtleVByZXNzZWQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBvblNsaWRlckNsaWNrOiBmdW5jdGlvbiBvblNsaWRlckNsaWNrKGUpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZSk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLmludGVybmFsVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZU1vdXNlTW92ZTogZnVuY3Rpb24gcGFyc2VNb3VzZU1vdmUoZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy4kcmVmcy50cmFjay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0ID0gX2EubGVmdCxcbiAgICAgICAgICAgICAgICB0cmFja1dpZHRoID0gX2Eud2lkdGg7XG4gICAgICAgICAgICB2YXIgY2xpZW50WCA9ICd0b3VjaGVzJyBpbiBlID8gZS50b3VjaGVzWzBdLmNsaWVudFggOiBlLmNsaWVudFg7XG4gICAgICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgbGVmdCB0byBiZSBOYU4sIGZvcmNlIHRvIG51bWJlclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBNYXRoLm1pbihNYXRoLm1heCgoY2xpZW50WCAtIG9mZnNldExlZnQpIC8gdHJhY2tXaWR0aCwgMCksIDEpIHx8IDA7XG4gICAgICAgICAgICBpZiAodGhpcy4kdnVldGlmeS5ydGwpIGxlZnQgPSAxIC0gbGVmdDtcbiAgICAgICAgICAgIHZhciBpc0luc2lkZVRyYWNrID0gY2xpZW50WCA+PSBvZmZzZXRMZWZ0IC0gOCAmJiBjbGllbnRYIDw9IG9mZnNldExlZnQgKyB0cmFja1dpZHRoICsgODtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5taW4pICsgbGVmdCAqICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgaXNJbnNpZGVUcmFjazogaXNJbnNpZGVUcmFjayB9O1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZUtleURvd246IGZ1bmN0aW9uIHBhcnNlS2V5RG93bihlLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW50ZXJuYWxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgcGFnZXVwID0gX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wia2V5Q29kZXNcIl0ucGFnZXVwLFxuICAgICAgICAgICAgICAgIHBhZ2Vkb3duID0gX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wia2V5Q29kZXNcIl0ucGFnZWRvd24sXG4gICAgICAgICAgICAgICAgZW5kID0gX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wia2V5Q29kZXNcIl0uZW5kLFxuICAgICAgICAgICAgICAgIGhvbWUgPSBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJrZXlDb2Rlc1wiXS5ob21lLFxuICAgICAgICAgICAgICAgIGxlZnQgPSBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJrZXlDb2Rlc1wiXS5sZWZ0LFxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wia2V5Q29kZXNcIl0ucmlnaHQsXG4gICAgICAgICAgICAgICAgZG93biA9IF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImtleUNvZGVzXCJdLmRvd24sXG4gICAgICAgICAgICAgICAgdXAgPSBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJrZXlDb2Rlc1wiXS51cDtcbiAgICAgICAgICAgIGlmICghW3BhZ2V1cCwgcGFnZWRvd24sIGVuZCwgaG9tZSwgbGVmdCwgcmlnaHQsIGRvd24sIHVwXS5pbmNsdWRlcyhlLmtleUNvZGUpKSByZXR1cm47XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IHRoaXMuc3RlcE51bWVyaWMgfHwgMTtcbiAgICAgICAgICAgIHZhciBzdGVwcyA9ICh0aGlzLm1heCAtIHRoaXMubWluKSAvIHN0ZXA7XG4gICAgICAgICAgICBpZiAoW2xlZnQsIHJpZ2h0LCBkb3duLCB1cF0uaW5jbHVkZXMoZS5rZXlDb2RlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5UHJlc3NlZCArPSAxO1xuICAgICAgICAgICAgICAgIHZhciBpbmNyZWFzZSA9IHRoaXMuJHZ1ZXRpZnkucnRsID8gW2xlZnQsIHVwXSA6IFtyaWdodCwgdXBdO1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBpbmNyZWFzZS5pbmNsdWRlcyhlLmtleUNvZGUpID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gZS5zaGlmdEtleSA/IDMgOiBlLmN0cmxLZXkgPyAyIDogMTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgZGlyZWN0aW9uICogc3RlcCAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gaG9tZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLm1pbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMubWF4KTtcbiAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAoZS5rZXlDb2RlID09PSBrZXlDb2Rlcy5wYWdldXAgfHwgZS5rZXlDb2RlID09PSBwYWdlZG93bikgKi97XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhZ2UgdXAvZG93blxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZS5rZXlDb2RlID09PSBwYWdlZG93biA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAtIGRpcmVjdGlvbiAqIHN0ZXAgKiAoc3RlcHMgPiAxMDAgPyBzdGVwcyAvIDEwIDogMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcm91bmRWYWx1ZTogZnVuY3Rpb24gcm91bmRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0ZXBOdW1lcmljKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyBGb3JtYXQgaW5wdXQgdmFsdWUgdXNpbmcgdGhlIHNhbWUgbnVtYmVyXG4gICAgICAgICAgICAvLyBvZiBkZWNpbWFscyBwbGFjZXMgYXMgaW4gdGhlIHN0ZXAgcHJvcFxuICAgICAgICAgICAgdmFyIHRyaW1tZWRTdGVwID0gdGhpcy5zdGVwLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICAgICAgdmFyIGRlY2ltYWxzID0gdHJpbW1lZFN0ZXAuaW5kZXhPZignLicpID4gLTEgPyB0cmltbWVkU3RlcC5sZW5ndGggLSB0cmltbWVkU3RlcC5pbmRleE9mKCcuJykgLSAxIDogMDtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm1pbiAlIHRoaXMuc3RlcE51bWVyaWM7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBNYXRoLnJvdW5kKCh2YWx1ZSAtIG9mZnNldCkgLyB0aGlzLnN0ZXBOdW1lcmljKSAqIHRoaXMuc3RlcE51bWVyaWMgKyBvZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChNYXRoLm1pbihuZXdWYWx1ZSwgdGhpcy5tYXgpLnRvRml4ZWQoZGVjaW1hbHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW50ZXJuYWxWYWx1ZTogZnVuY3Rpb24gc2V0SW50ZXJuYWxWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WU2xpZGVyL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZTbGlkZXIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZTbGlkZXIsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlNsaWRlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlNsaWRlci9WU2xpZGVyLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNsaWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WU2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX1ZTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTbmFja2Jhci9WU25hY2tiYXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlNuYWNrYmFyL1ZTbmFja2Jhci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc25hY2tiYXJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19zbmFja2JhcnMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19zbmFja2JhcnMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc25hY2tiYXJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfc25hY2tiYXJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdG9nZ2xlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RvZ2dsZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdG9nZ2xlYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3Bvc2l0aW9uYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3Bvc2l0aW9uYWJsZSAqLyBcIi4vc3JjL21peGlucy9wb3NpdGlvbmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL21peGlucyAqLyBcIi4vc3JjL3V0aWwvbWl4aW5zLnRzXCIpO1xuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoT2JqZWN0KF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSkoX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdG9nZ2xlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwgT2JqZWN0KF9taXhpbnNfcG9zaXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJmYWN0b3J5XCJdKShbJ2Fic29sdXRlJywgJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCddKVxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbikuZXh0ZW5kKHtcbiAgICBuYW1lOiAndi1zbmFja2JhcicsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYXV0b0hlaWdodDogQm9vbGVhbixcbiAgICAgICAgbXVsdGlMaW5lOiBCb29sZWFuLFxuICAgICAgICAvLyBUT0RPOiBjaGFuZ2UgdGhpcyB0byBjbG9zZURlbGF5IHRvIG1hdGNoIG90aGVyIEFQSSBpbiBkZWxheWFibGUuanNcbiAgICAgICAgdGltZW91dDoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogNjAwMFxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbDogQm9vbGVhblxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGl2ZVRpbWVvdXQ6IC0xXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndi1zbmFjay0tYWN0aXZlJzogdGhpcy5pc0FjdGl2ZSxcbiAgICAgICAgICAgICAgICAndi1zbmFjay0tYWJzb2x1dGUnOiB0aGlzLmFic29sdXRlLFxuICAgICAgICAgICAgICAgICd2LXNuYWNrLS1hdXRvLWhlaWdodCc6IHRoaXMuYXV0b0hlaWdodCxcbiAgICAgICAgICAgICAgICAndi1zbmFjay0tYm90dG9tJzogdGhpcy5ib3R0b20gfHwgIXRoaXMudG9wLFxuICAgICAgICAgICAgICAgICd2LXNuYWNrLS1sZWZ0JzogdGhpcy5sZWZ0LFxuICAgICAgICAgICAgICAgICd2LXNuYWNrLS1tdWx0aS1saW5lJzogdGhpcy5tdWx0aUxpbmUgJiYgIXRoaXMudmVydGljYWwsXG4gICAgICAgICAgICAgICAgJ3Ytc25hY2stLXJpZ2h0JzogdGhpcy5yaWdodCxcbiAgICAgICAgICAgICAgICAndi1zbmFjay0tdG9wJzogdGhpcy50b3AsXG4gICAgICAgICAgICAgICAgJ3Ytc25hY2stLXZlcnRpY2FsJzogdGhpcy52ZXJ0aWNhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMuc2V0VGltZW91dCgpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBzZXRUaW1lb3V0OiBmdW5jdGlvbiBzZXRUaW1lb3V0KCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5hY3RpdmVUaW1lb3V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlICYmIHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChoKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXNuYWNrJyxcbiAgICAgICAgICAgICAgICBjbGFzczogdGhpcy5jbGFzc2VzLFxuICAgICAgICAgICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgICAgICAgIH0sIFtoKCdkaXYnLCB0aGlzLnNldEJhY2tncm91bmRDb2xvcih0aGlzLmNvbG9yLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXNuYWNrX193cmFwcGVyJ1xuICAgICAgICAgICAgfSksIFtoKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXNuYWNrX19jb250ZW50J1xuICAgICAgICAgICAgfSwgdGhpcy4kc2xvdHMuZGVmYXVsdCldKV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaCgndHJhbnNpdGlvbicsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7IG5hbWU6ICd2LXNuYWNrLXRyYW5zaXRpb24nIH1cbiAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WU25hY2tiYXIvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WU25hY2tiYXIvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlNuYWNrYmFyLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WU25hY2tiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlNuYWNrYmFyICovIFwiLi9zcmMvY29tcG9uZW50cy9WU25hY2tiYXIvVlNuYWNrYmFyLnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNuYWNrYmFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZTbmFja2Jhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WU25hY2tiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTcGVlZERpYWwvVlNwZWVkRGlhbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZTcGVlZERpYWwvVlNwZWVkRGlhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19zcGVlZF9kaWFsX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19zcGVlZC1kaWFsLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc3BlZWQtZGlhbC5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19zcGVlZF9kaWFsX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfc3BlZWRfZGlhbF9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdG9nZ2xlYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RvZ2dsZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdG9nZ2xlYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3Bvc2l0aW9uYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3Bvc2l0aW9uYWJsZSAqLyBcIi4vc3JjL21peGlucy9wb3NpdGlvbmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190cmFuc2l0aW9uYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RyYW5zaXRpb25hYmxlICovIFwiLi9zcmMvbWl4aW5zL3RyYW5zaXRpb25hYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXJlY3RpdmVzX2NsaWNrX291dHNpZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RpcmVjdGl2ZXMvY2xpY2stb3V0c2lkZSAqLyBcIi4vc3JjL2RpcmVjdGl2ZXMvY2xpY2stb3V0c2lkZS50c1wiKTtcblxuXG5cblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3Ytc3BlZWQtZGlhbCcsXG4gICAgZGlyZWN0aXZlczogeyBDbGlja091dHNpZGU6IF9kaXJlY3RpdmVzX2NsaWNrX291dHNpZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0gfSxcbiAgICBtaXhpbnM6IFtfbWl4aW5zX3Bvc2l0aW9uYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwgX21peGluc190b2dnbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RyYW5zaXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdXSxcbiAgICBwcm9wczoge1xuICAgICAgICBkaXJlY3Rpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICd0b3AnLFxuICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3IodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5jbHVkZXModmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3Blbk9uSG92ZXI6IEJvb2xlYW4sXG4gICAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdzY2FsZS10cmFuc2l0aW9uJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIF9hID0ge1xuICAgICAgICAgICAgICAgICd2LXNwZWVkLWRpYWwnOiB0cnVlLFxuICAgICAgICAgICAgICAgICd2LXNwZWVkLWRpYWwtLXRvcCc6IHRoaXMudG9wLFxuICAgICAgICAgICAgICAgICd2LXNwZWVkLWRpYWwtLXJpZ2h0JzogdGhpcy5yaWdodCxcbiAgICAgICAgICAgICAgICAndi1zcGVlZC1kaWFsLS1ib3R0b20nOiB0aGlzLmJvdHRvbSxcbiAgICAgICAgICAgICAgICAndi1zcGVlZC1kaWFsLS1sZWZ0JzogdGhpcy5sZWZ0LFxuICAgICAgICAgICAgICAgICd2LXNwZWVkLWRpYWwtLWFic29sdXRlJzogdGhpcy5hYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICAndi1zcGVlZC1kaWFsLS1maXhlZCc6IHRoaXMuZml4ZWRcbiAgICAgICAgICAgIH0sIF9hW1widi1zcGVlZC1kaWFsLS1kaXJlY3Rpb24tXCIgKyB0aGlzLmRpcmVjdGlvbl0gPSB0cnVlLCBfYTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAnY2xhc3MnOiB0aGlzLmNsYXNzZXMsXG4gICAgICAgICAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjbGljay1vdXRzaWRlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc0FjdGl2ZSA9ICFfdGhpcy5pc0FjdGl2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wZW5PbkhvdmVyKSB7XG4gICAgICAgICAgICBkYXRhLm9uLm1vdXNlZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhLm9uLm1vdXNlbGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9ICh0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdKS5tYXAoZnVuY3Rpb24gKGIsIGkpIHtcbiAgICAgICAgICAgICAgICBiLmtleSA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdCA9IGgoJ3RyYW5zaXRpb24tZ3JvdXAnLCB7XG4gICAgICAgICAgICAnY2xhc3MnOiAndi1zcGVlZC1kaWFsX19saXN0JyxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy50cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IHRoaXMub3JpZ2luLFxuICAgICAgICAgICAgICAgIHRhZzogJ2RpdidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gaCgnZGl2JywgZGF0YSwgW3RoaXMuJHNsb3RzLmFjdGl2YXRvciwgbGlzdF0pO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTcGVlZERpYWwvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlNwZWVkRGlhbC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlNwZWVkRGlhbCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlNwZWVkRGlhbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WU3BlZWREaWFsICovIFwiLi9zcmMvY29tcG9uZW50cy9WU3BlZWREaWFsL1ZTcGVlZERpYWwuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU3BlZWREaWFsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZTcGVlZERpYWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVlNwZWVkRGlhbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlN0ZXBwZXIvVlN0ZXBwZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZTdGVwcGVyL1ZTdGVwcGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc3RlcHBlcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3N0ZXBwZXJzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc3RlcHBlcnMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc3RlcHBlcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19zdGVwcGVyc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9yZWdpc3RyYWJsZSAqLyBcIi4vc3JjL21peGlucy9yZWdpc3RyYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RoZW1lYWJsZSAqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBTdHlsZXNcblxuLy8gTWl4aW5zXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LXN0ZXBwZXInLFxuICAgIG1peGluczogW09iamVjdChfbWl4aW5zX3JlZ2lzdHJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJwcm92aWRlXCJdKSgnc3RlcHBlcicpLCBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0ZXBDbGljazogdGhpcy5zdGVwQ2xpY2ssXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0aGlzLnZlcnRpY2FsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBub25MaW5lYXI6IEJvb2xlYW4sXG4gICAgICAgIGFsdExhYmVsczogQm9vbGVhbixcbiAgICAgICAgdmVydGljYWw6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBbTnVtYmVyLCBTdHJpbmddXG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgIGlzQm9vdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0ZXBzOiBbXSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtdLFxuICAgICAgICAgICAgaXNSZXZlcnNlOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7ICd2LXN0ZXBwZXInOiB0cnVlLCAndi1zdGVwcGVyLS1pcy1ib290ZWQnOiB0aGlzLmlzQm9vdGVkLCAndi1zdGVwcGVyLS12ZXJ0aWNhbCc6IHRoaXMudmVydGljYWwsICd2LXN0ZXBwZXItLWFsdC1sYWJlbHMnOiB0aGlzLmFsdExhYmVscywgJ3Ytc3RlcHBlci0tbm9uLWxpbmVhcic6IHRoaXMubm9uTGluZWFyIH0sIHRoaXMudGhlbWVDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgaW5wdXRWYWx1ZTogZnVuY3Rpb24gaW5wdXRWYWx1ZSh2YWwsIHByZXYpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZXZlcnNlID0gTnVtYmVyKHZhbCkgPCBOdW1iZXIocHJldik7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IHRoaXMuc3RlcHMubGVuZ3RoOyAtLWluZGV4ID49IDA7KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwc1tpbmRleF0udG9nZ2xlKHRoaXMuaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IHRoaXMuY29udGVudC5sZW5ndGg7IC0taW5kZXggPj0gMDspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbaW5kZXhdLnRvZ2dsZSh0aGlzLmlucHV0VmFsdWUsIHRoaXMuaXNSZXZlcnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy5pbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIHByZXYgJiYgKHRoaXMuaXNCb290ZWQgPSB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaW5wdXRWYWx1ZSA9IF90aGlzLnZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IHRoaXMudmFsdWUgfHwgdGhpcy5zdGVwc1swXS5zdGVwIHx8IDE7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS4kb3B0aW9ucy5uYW1lID09PSAndi1zdGVwcGVyLXN0ZXAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLiRvcHRpb25zLm5hbWUgPT09ICd2LXN0ZXBwZXItY29udGVudCcpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmlzVmVydGljYWwgPSB0aGlzLnZlcnRpY2FsO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbiB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpdGVtLiRvcHRpb25zLm5hbWUgPT09ICd2LXN0ZXBwZXItc3RlcCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBzID0gdGhpcy5zdGVwcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgIT09IGl0ZW07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uJG9wdGlvbnMubmFtZSA9PT0gJ3Ytc3RlcHBlci1jb250ZW50Jykge1xuICAgICAgICAgICAgICAgIGl0ZW0uaXNWZXJ0aWNhbCA9IHRoaXMudmVydGljYWw7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5jb250ZW50LmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAhPT0gaXRlbTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RlcENsaWNrOiBmdW5jdGlvbiBzdGVwQ2xpY2soc3RlcCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaW5wdXRWYWx1ZSA9IHN0ZXA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy5jbGFzc2VzXG4gICAgICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTdGVwcGVyL1ZTdGVwcGVyQ29udGVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZTdGVwcGVyL1ZTdGVwcGVyQ29udGVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdHJhbnNpdGlvbnMgKi8gXCIuL3NyYy9jb21wb25lbnRzL3RyYW5zaXRpb25zL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9yZWdpc3RyYWJsZSAqLyBcIi4vc3JjL21peGlucy9yZWdpc3RyYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG4vLyBDb21wb25lbnRzXG5cbi8vIE1peGluc1xuXG4vLyBIZWxwZXJzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi1zdGVwcGVyLWNvbnRlbnQnLFxuICAgIG1peGluczogW09iamVjdChfbWl4aW5zX3JlZ2lzdHJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJpbmplY3RcIl0pKCdzdGVwcGVyJywgJ3Ytc3RlcHBlci1jb250ZW50JywgJ3Ytc3RlcHBlcicpXSxcbiAgICBpbmplY3Q6IHtcbiAgICAgICAgaXNWZXJ0aWNhbFByb3ZpZGVkOiB7XG4gICAgICAgICAgICBmcm9tOiAnaXNWZXJ0aWNhbCdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgc3RlcDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAvLyBNdXN0IGJlIG51bGwgdG8gYWxsb3dcbiAgICAgICAgICAgIC8vIHByZXZpb3VzIGNvbXBhcmlzb25cbiAgICAgICAgICAgIGlzQWN0aXZlOiBudWxsLFxuICAgICAgICAgICAgaXNSZXZlcnNlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRoaXMuaXNWZXJ0aWNhbFByb3ZpZGVkXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndi1zdGVwcGVyX19jb250ZW50JzogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWRUcmFuc2l0aW9uOiBmdW5jdGlvbiBjb21wdXRlZFRyYW5zaXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1JldmVyc2UgPyBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIlZUYWJSZXZlcnNlVHJhbnNpdGlvblwiXSA6IF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiVlRhYlRyYW5zaXRpb25cIl07XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlczogZnVuY3Rpb24gc3R5bGVzKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmVydGljYWwpIHJldHVybiB7fTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiY29udmVydFRvVW5pdFwiXSkodGhpcy5oZWlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB3cmFwcGVyQ2xhc3NlczogZnVuY3Rpb24gd3JhcHBlckNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICd2LXN0ZXBwZXJfX3dyYXBwZXInOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUoY3VycmVudCwgcHJldmlvdXMpIHtcbiAgICAgICAgICAgIC8vIElmIGFjdGl2ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlXG4gICAgICAgICAgICAvLyB3YXMgbnVsbCwgaXMganVzdCBib290aW5nIHVwXG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBwcmV2aW91cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmVydGljYWwpIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB0aGlzLmVudGVyKCk7ZWxzZSB0aGlzLmxlYXZlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMuJHJlZnMud3JhcHBlci5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb24sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zdGVwcGVyICYmIHRoaXMuc3RlcHBlci5yZWdpc3Rlcih0aGlzKTtcbiAgICB9LFxuICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJHJlZnMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb24sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zdGVwcGVyICYmIHRoaXMuc3RlcHBlci51bnJlZ2lzdGVyKHRoaXMpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBvblRyYW5zaXRpb246IGZ1bmN0aW9uIG9uVHJhbnNpdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgZS5wcm9wZXJ0eU5hbWUgIT09ICdoZWlnaHQnKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgfSxcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzY3JvbGxIZWlnaHQgPSAwO1xuICAgICAgICAgICAgLy8gUmVuZGVyIGJ1ZyB3aXRoIGhlaWdodFxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSBfdGhpcy4kcmVmcy53cmFwcGVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgLy8gR2l2ZSB0aGUgY29sbGFwc2luZyBlbGVtZW50IHRpbWUgdG8gY29sbGFwc2VcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc0FjdGl2ZSAmJiAoX3RoaXMuaGVpZ2h0ID0gc2Nyb2xsSGVpZ2h0IHx8ICdhdXRvJyk7XG4gICAgICAgICAgICB9LCA0NTApO1xuICAgICAgICB9LFxuICAgICAgICBsZWF2ZTogZnVuY3Rpb24gbGVhdmUoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLiRyZWZzLndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmhlaWdodCA9IDA7XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKHN0ZXAsIHJldmVyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBzdGVwLnRvU3RyaW5nKCkgPT09IHRoaXMuc3RlcC50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5pc1JldmVyc2UgPSByZXZlcnNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBjb250ZW50RGF0YSA9IHtcbiAgICAgICAgICAgICdjbGFzcyc6IHRoaXMuY2xhc3Nlc1xuICAgICAgICB9O1xuICAgICAgICB2YXIgd3JhcHBlckRhdGEgPSB7XG4gICAgICAgICAgICAnY2xhc3MnOiB0aGlzLndyYXBwZXJDbGFzc2VzLFxuICAgICAgICAgICAgc3R5bGU6IHRoaXMuc3R5bGVzLFxuICAgICAgICAgICAgcmVmOiAnd3JhcHBlcidcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIGNvbnRlbnREYXRhLmRpcmVjdGl2ZXMgPSBbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzaG93JyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5pc0FjdGl2ZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBwZXIgPSBoKCdkaXYnLCB3cmFwcGVyRGF0YSwgW3RoaXMuJHNsb3RzLmRlZmF1bHRdKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBoKCdkaXYnLCBjb250ZW50RGF0YSwgW3dyYXBwZXJdKTtcbiAgICAgICAgcmV0dXJuIGgodGhpcy5jb21wdXRlZFRyYW5zaXRpb24sIHtcbiAgICAgICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgICAgfSwgW2NvbnRlbnRdKTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WU3RlcHBlci9WU3RlcHBlclN0ZXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WU3RlcHBlci9WU3RlcHBlclN0ZXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZJY29uICovIFwiLi9zcmMvY29tcG9uZW50cy9WSWNvbi9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2NvbG9yYWJsZSAqLyBcIi4vc3JjL21peGlucy9jb2xvcmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19yZWdpc3RyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3JlZ2lzdHJhYmxlICovIFwiLi9zcmMvbWl4aW5zL3JlZ2lzdHJhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXJlY3RpdmVzX3JpcHBsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGlyZWN0aXZlcy9yaXBwbGUgKi8gXCIuL3NyYy9kaXJlY3RpdmVzL3JpcHBsZS50c1wiKTtcbi8vIENvbXBvbmVudHNcblxuLy8gTWl4aW5zXG5cblxuLy8gRGlyZWN0aXZlc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3Ytc3RlcHBlci1zdGVwJyxcbiAgICBkaXJlY3RpdmVzOiB7IFJpcHBsZTogX2RpcmVjdGl2ZXNfcmlwcGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdIH0sXG4gICAgbWl4aW5zOiBbX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIE9iamVjdChfbWl4aW5zX3JlZ2lzdHJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJpbmplY3RcIl0pKCdzdGVwcGVyJywgJ3Ytc3RlcHBlci1zdGVwJywgJ3Ytc3RlcHBlcicpXSxcbiAgICBpbmplY3Q6IFsnc3RlcENsaWNrJ10sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5J1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogQm9vbGVhbixcbiAgICAgICAgY29tcGxldGVJY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMuY29tcGxldGUnXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRJY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMuZWRpdCdcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3JJY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMuZXJyb3InXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgICAgICBydWxlczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0ZXA6IFtOdW1iZXIsIFN0cmluZ11cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBpc0luYWN0aXZlOiB0cnVlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAndi1zdGVwcGVyX19zdGVwJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndi1zdGVwcGVyX19zdGVwLS1hY3RpdmUnOiB0aGlzLmlzQWN0aXZlLFxuICAgICAgICAgICAgICAgICd2LXN0ZXBwZXJfX3N0ZXAtLWVkaXRhYmxlJzogdGhpcy5lZGl0YWJsZSxcbiAgICAgICAgICAgICAgICAndi1zdGVwcGVyX19zdGVwLS1pbmFjdGl2ZSc6IHRoaXMuaXNJbmFjdGl2ZSxcbiAgICAgICAgICAgICAgICAndi1zdGVwcGVyX19zdGVwLS1lcnJvcic6IHRoaXMuaGFzRXJyb3IsXG4gICAgICAgICAgICAgICAgJ3Ytc3RlcHBlcl9fc3RlcC0tY29tcGxldGUnOiB0aGlzLmNvbXBsZXRlLFxuICAgICAgICAgICAgICAgICdlcnJvci0tdGV4dCc6IHRoaXMuaGFzRXJyb3JcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0Vycm9yOiBmdW5jdGlvbiBoYXNFcnJvcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGVzLnNvbWUoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSgpICE9PSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMuc3RlcHBlciAmJiB0aGlzLnN0ZXBwZXIucmVnaXN0ZXIodGhpcyk7XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN0ZXBwZXIgJiYgdGhpcy5zdGVwcGVyLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhlKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBDbGljayh0aGlzLnN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZShzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gc3RlcC50b1N0cmluZygpID09PSB0aGlzLnN0ZXAudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuaXNJbmFjdGl2ZSA9IE51bWJlcihzdGVwKSA8IE51bWJlcih0aGlzLnN0ZXApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy5jbGFzc2VzLFxuICAgICAgICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAncmlwcGxlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5lZGl0YWJsZVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBvbjogeyBjbGljazogdGhpcy5jbGljayB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGVwQ29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIHN0ZXBDb250ZW50ID0gW2goX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLCB7fSwgdGhpcy5lcnJvckljb24pXTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHN0ZXBDb250ZW50ID0gW2goX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLCB7fSwgdGhpcy5lZGl0SWNvbildO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGVwQ29udGVudCA9IFtoKF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSwge30sIHRoaXMuY29tcGxldGVJY29uKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGVwQ29udGVudCA9IHRoaXMuc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sb3IgPSAhdGhpcy5oYXNFcnJvciAmJiAodGhpcy5jb21wbGV0ZSB8fCB0aGlzLmlzQWN0aXZlKSA/IHRoaXMuY29sb3IgOiBmYWxzZTtcbiAgICAgICAgdmFyIHN0ZXAgPSBoKCdzcGFuJywgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3IsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1zdGVwcGVyX19zdGVwX19zdGVwJ1xuICAgICAgICB9KSwgc3RlcENvbnRlbnQpO1xuICAgICAgICB2YXIgbGFiZWwgPSBoKCdkaXYnLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3Ytc3RlcHBlcl9fbGFiZWwnXG4gICAgICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgICByZXR1cm4gaCgnZGl2JywgZGF0YSwgW3N0ZXAsIGxhYmVsXSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlN0ZXBwZXIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZTdGVwcGVyL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlN0ZXBwZXIsIFZTdGVwcGVyQ29udGVudCwgVlN0ZXBwZXJTdGVwLCBWU3RlcHBlckhlYWRlciwgVlN0ZXBwZXJJdGVtcywgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU3RlcHBlckhlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZTdGVwcGVySGVhZGVyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU3RlcHBlckl0ZW1zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVlN0ZXBwZXJJdGVtczsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WU3RlcHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WU3RlcHBlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlN0ZXBwZXIvVlN0ZXBwZXIuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU3RlcHBlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WU3RlcHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlN0ZXBwZXJTdGVwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZTdGVwcGVyU3RlcCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlN0ZXBwZXIvVlN0ZXBwZXJTdGVwLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlN0ZXBwZXJTdGVwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZTdGVwcGVyU3RlcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlN0ZXBwZXJDb250ZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZTdGVwcGVyQ29udGVudCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlN0ZXBwZXIvVlN0ZXBwZXJDb250ZW50LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlN0ZXBwZXJDb250ZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZTdGVwcGVyQ29udGVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG5cblxudmFyIFZTdGVwcGVySGVhZGVyID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZUZ1bmN0aW9uYWxcIl0pKCd2LXN0ZXBwZXJfX2hlYWRlcicpO1xudmFyIFZTdGVwcGVySXRlbXMgPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY3JlYXRlU2ltcGxlRnVuY3Rpb25hbFwiXSkoJ3Ytc3RlcHBlcl9faXRlbXMnKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgJF92dWV0aWZ5X3N1YmNvbXBvbmVudHM6IHtcbiAgICAgICAgVlN0ZXBwZXI6IF9WU3RlcHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgVlN0ZXBwZXJDb250ZW50OiBfVlN0ZXBwZXJDb250ZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWU3RlcHBlclN0ZXA6IF9WU3RlcHBlclN0ZXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZTdGVwcGVySGVhZGVyOiBWU3RlcHBlckhlYWRlcixcbiAgICAgICAgVlN0ZXBwZXJJdGVtczogVlN0ZXBwZXJJdGVtc1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTdWJoZWFkZXIvVlN1YmhlYWRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZTdWJoZWFkZXIvVlN1YmhlYWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19zdWJoZWFkZXJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19zdWJoZWFkZXJzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc3ViaGVhZGVycy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19zdWJoZWFkZXJzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfc3ViaGVhZGVyc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3Ytc3ViaGVhZGVyJyxcbiAgICBtaXhpbnM6IFtfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgaW5zZXQ6IEJvb2xlYW5cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi1zdWJoZWFkZXInLFxuICAgICAgICAgICAgY2xhc3M6IF9fYXNzaWduKHsgJ3Ytc3ViaGVhZGVyLS1pbnNldCc6IHRoaXMuaW5zZXQgfSwgdGhpcy50aGVtZUNsYXNzZXMpLFxuICAgICAgICAgICAgYXR0cnM6IHRoaXMuJGF0dHJzLFxuICAgICAgICAgICAgb246IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgICB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WU3ViaGVhZGVyL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZTdWJoZWFkZXIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZTdWJoZWFkZXIsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZTdWJoZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlN1YmhlYWRlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlN1YmhlYWRlci9WU3ViaGVhZGVyLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlN1YmhlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WU3ViaGVhZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX1ZTdWJoZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTd2l0Y2gvVlN3aXRjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZTd2l0Y2gvVlN3aXRjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19zZWxlY3Rpb25fY29udHJvbHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3NlbGVjdGlvbi1jb250cm9scy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3NlbGVjdGlvbi1jb250cm9scy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19zZWxlY3Rpb25fY29udHJvbHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19zZWxlY3Rpb25fY29udHJvbHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc3dpdGNoX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL19zd2l0Y2guc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19zd2l0Y2guc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc3dpdGNoX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfc3dpdGNoX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19zZWxlY3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvc2VsZWN0YWJsZSAqLyBcIi4vc3JjL21peGlucy9zZWxlY3RhYmxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9kaXJlY3RpdmVzX3RvdWNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kaXJlY3RpdmVzL3RvdWNoICovIFwiLi9zcmMvZGlyZWN0aXZlcy90b3VjaC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3RyYW5zaXRpb25zICovIFwiLi9zcmMvY29tcG9uZW50cy90cmFuc2l0aW9ucy9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlByb2dyZXNzQ2lyY3VsYXJfVlByb2dyZXNzQ2lyY3VsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZQcm9ncmVzc0NpcmN1bGFyL1ZQcm9ncmVzc0NpcmN1bGFyICovIFwiLi9zcmMvY29tcG9uZW50cy9WUHJvZ3Jlc3NDaXJjdWxhci9WUHJvZ3Jlc3NDaXJjdWxhci50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cblxuLy8gTWl4aW5zXG5cbi8vIERpcmVjdGl2ZXNcblxuLy8gQ29tcG9uZW50c1xuXG5cbi8vIEhlbHBlcnNcblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LXN3aXRjaCcsXG4gICAgZGlyZWN0aXZlczogeyBUb3VjaDogX2RpcmVjdGl2ZXNfdG91Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0gfSxcbiAgICBtaXhpbnM6IFtfbWl4aW5zX3NlbGVjdGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGxvYWRpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3YtaW5wdXQtLXNlbGVjdGlvbi1jb250cm9scyB2LWlucHV0LS1zd2l0Y2gnOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzd2l0Y2hEYXRhOiBmdW5jdGlvbiBzd2l0Y2hEYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0VGV4dENvbG9yKHRoaXMubG9hZGluZyA/IHVuZGVmaW5lZCA6IHRoaXMuY29tcHV0ZWRDb2xvciwge1xuICAgICAgICAgICAgICAgIGNsYXNzOiB0aGlzLnRoZW1lQ2xhc3Nlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuRGVmYXVsdFNsb3Q6IGZ1bmN0aW9uIGdlbkRlZmF1bHRTbG90KCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmdlblN3aXRjaCgpLCB0aGlzLmdlbkxhYmVsKCldO1xuICAgICAgICB9LFxuICAgICAgICBnZW5Td2l0Y2g6IGZ1bmN0aW9uIGdlblN3aXRjaCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LWlucHV0LS1zZWxlY3Rpb24tY29udHJvbHNfX2lucHV0J1xuICAgICAgICAgICAgfSwgW3RoaXMuZ2VuSW5wdXQoJ2NoZWNrYm94JywgdGhpcy4kYXR0cnMpLCAhdGhpcy5kaXNhYmxlZCAmJiB0aGlzLmdlblJpcHBsZSh0aGlzLnNldFRleHRDb2xvcih0aGlzLmNvbXB1dGVkQ29sb3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAndG91Y2gnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5vblN3aXBlTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLm9uU3dpcGVSaWdodFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0pKSwgdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2JywgX19hc3NpZ24oeyBzdGF0aWNDbGFzczogJ3YtaW5wdXQtLXN3aXRjaF9fdHJhY2snIH0sIHRoaXMuc3dpdGNoRGF0YSkpLCB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCBfX2Fzc2lnbih7IHN0YXRpY0NsYXNzOiAndi1pbnB1dC0tc3dpdGNoX190aHVtYicgfSwgdGhpcy5zd2l0Y2hEYXRhKSwgW3RoaXMuZ2VuUHJvZ3Jlc3MoKV0pXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblByb2dyZXNzOiBmdW5jdGlvbiBnZW5Qcm9ncmVzcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiVkZhYlRyYW5zaXRpb25cIl0sIHt9LCBbdGhpcy5sb2FkaW5nID09PSBmYWxzZSA/IG51bGwgOiB0aGlzLiRzbG90cy5wcm9ncmVzcyB8fCB0aGlzLiRjcmVhdGVFbGVtZW50KF9WUHJvZ3Jlc3NDaXJjdWxhcl9WUHJvZ3Jlc3NDaXJjdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmxvYWRpbmcgPT09IHRydWUgfHwgdGhpcy5sb2FkaW5nID09PSAnJyA/IHRoaXMuY29sb3IgfHwgJ3ByaW1hcnknIDogdGhpcy5sb2FkaW5nLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiAxNixcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDIsXG4gICAgICAgICAgICAgICAgICAgIGluZGV0ZXJtaW5hdGU6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KV0pO1xuICAgICAgICB9LFxuICAgICAgICBvblN3aXBlTGVmdDogZnVuY3Rpb24gb25Td2lwZUxlZnQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICB9LFxuICAgICAgICBvblN3aXBlUmlnaHQ6IGZ1bmN0aW9uIG9uU3dpcGVSaWdodCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSkgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICB9LFxuICAgICAgICBvbktleWRvd246IGZ1bmN0aW9uIG9uS2V5ZG93bihlKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJrZXlDb2Rlc1wiXS5sZWZ0ICYmIHRoaXMuaXNBY3RpdmUgfHwgZS5rZXlDb2RlID09PSBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJrZXlDb2Rlc1wiXS5yaWdodCAmJiAhdGhpcy5pc0FjdGl2ZSkgdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlN3aXRjaC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WU3dpdGNoL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWU3dpdGNoLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WU3dpdGNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZTd2l0Y2ggKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTd2l0Y2gvVlN3aXRjaC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZTd2l0Y2hcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlN3aXRjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WU3dpdGNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WU3lzdGVtQmFyL1ZTeXN0ZW1CYXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WU3lzdGVtQmFyL1ZTeXN0ZW1CYXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc3lzdGVtX2JhcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3N5c3RlbS1iYXJzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc3lzdGVtLWJhcnMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfc3lzdGVtX2JhcnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c19zeXN0ZW1fYmFyc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfYXBwbGljYXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvYXBwbGljYXRpb25hYmxlICovIFwiLi9zcmMvbWl4aW5zL2FwcGxpY2F0aW9uYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2NvbG9yYWJsZSAqLyBcIi4vc3JjL21peGlucy9jb2xvcmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5cblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3Ytc3lzdGVtLWJhcicsXG4gICAgbWl4aW5zOiBbT2JqZWN0KF9taXhpbnNfYXBwbGljYXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKSgnYmFyJywgWydoZWlnaHQnLCAnd2luZG93J10pLCBfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGhlaWdodDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlSW50KHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGlnaHRzT3V0OiBCb29sZWFuLFxuICAgICAgICBzdGF0dXM6IEJvb2xlYW4sXG4gICAgICAgIHdpbmRvdzogQm9vbGVhblxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7ICd2LXN5c3RlbS1iYXItLWxpZ2h0cy1vdXQnOiB0aGlzLmxpZ2h0c091dCwgJ3Ytc3lzdGVtLWJhci0tYWJzb2x1dGUnOiB0aGlzLmFic29sdXRlLCAndi1zeXN0ZW0tYmFyLS1maXhlZCc6ICF0aGlzLmFic29sdXRlICYmICh0aGlzLmFwcCB8fCB0aGlzLmZpeGVkKSwgJ3Ytc3lzdGVtLWJhci0tc3RhdHVzJzogdGhpcy5zdGF0dXMsICd2LXN5c3RlbS1iYXItLXdpbmRvdyc6IHRoaXMud2luZG93IH0sIHRoaXMudGhlbWVDbGFzc2VzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWRIZWlnaHQ6IGZ1bmN0aW9uIGNvbXB1dGVkSGVpZ2h0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0KSByZXR1cm4gcGFyc2VJbnQodGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2luZG93ID8gMzIgOiAyNDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBhcHBsaWNhdGlvbiBsYXlvdXRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlQXBwbGljYXRpb246IGZ1bmN0aW9uIHVwZGF0ZUFwcGxpY2F0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3Ytc3lzdGVtLWJhcicsXG4gICAgICAgICAgICAnY2xhc3MnOiB0aGlzLmNsYXNzZXMsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5jb21wdXRlZEhlaWdodCArIFwicHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaCgnZGl2JywgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5jb2xvciwgZGF0YSksIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTeXN0ZW1CYXIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlN5c3RlbUJhci9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlN5c3RlbUJhciwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlN5c3RlbUJhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WU3lzdGVtQmFyICovIFwiLi9zcmMvY29tcG9uZW50cy9WU3lzdGVtQmFyL1ZTeXN0ZW1CYXIuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU3lzdGVtQmFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZTeXN0ZW1CYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVlN5c3RlbUJhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRhYnMvVlRhYi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WVGFicy9WVGFiLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfZ3JvdXBhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvZ3JvdXBhYmxlICovIFwiLi9zcmMvbWl4aW5zL2dyb3VwYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3JvdXRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvcm91dGFibGUgKi8gXCIuL3NyYy9taXhpbnMvcm91dGFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbi8vIE1peGluc1xuXG5cblxuLy8gVXRpbGl0aWVzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi10YWInLFxuICAgIG1peGluczogW19taXhpbnNfcm91dGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sXG4gICAgLy8gTXVzdCBiZSBhZnRlciByb3V0YWJsZVxuICAgIC8vIHRvIG92ZXJ3cml0ZSBhY3RpdmVDbGFzc1xuICAgIE9iamVjdChfbWl4aW5zX2dyb3VwYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZmFjdG9yeVwiXSkoJ3RhYkdyb3VwJyksIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdXSxcbiAgICBwcm9wczoge1xuICAgICAgICByaXBwbGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFtCb29sZWFuLCBPYmplY3RdLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHsgJ3YtdGFic19faXRlbSc6IHRydWUsICd2LXRhYnNfX2l0ZW0tLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCB9LCB0aGlzLmdyb3VwQ2xhc3Nlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHZhciB0byA9IHRoaXMudG8gfHwgdGhpcy5ocmVmIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuJHJvdXRlciAmJiB0aGlzLnRvID09PSBPYmplY3QodGhpcy50bykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZSA9IHRoaXMuJHJvdXRlci5yZXNvbHZlKHRoaXMudG8sIHRoaXMuJHJvdXRlLCB0aGlzLmFwcGVuZCk7XG4gICAgICAgICAgICAgICAgdG8gPSByZXNvbHZlLmhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG8ucmVwbGFjZSgnIycsICcnKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgJHJvdXRlOiAnb25Sb3V0ZUNoYW5nZSdcbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMub25Sb3V0ZUNoYW5nZSgpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZSkge1xuICAgICAgICAgICAgLy8gSWYgdXNlciBwcm92aWRlcyBhblxuICAgICAgICAgICAgLy8gYWN0dWFsIGxpbmssIGRvIG5vdFxuICAgICAgICAgICAgLy8gcHJldmVudCBkZWZhdWx0XG4gICAgICAgICAgICBpZiAodGhpcy5ocmVmICYmIHRoaXMuaHJlZi5pbmRleE9mKCcjJykgPiAtMSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xpY2snLCBlKTtcbiAgICAgICAgICAgIHRoaXMudG8gfHwgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Sb3V0ZUNoYW5nZTogZnVuY3Rpb24gb25Sb3V0ZUNoYW5nZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXRoaXMudG8gfHwgIXRoaXMuJHJlZnMubGluaykgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHBhdGggPSBcIl92bm9kZS5kYXRhLmNsYXNzLlwiICsgdGhpcy5hY3RpdmVDbGFzcztcbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImdldE9iamVjdFZhbHVlQnlQYXRoXCJdKShfdGhpcy4kcmVmcy5saW5rLCBwYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2VuZXJhdGVSb3V0ZUxpbmsodGhpcy5jbGFzc2VzKTtcbiAgICAgICAgdmFyIGRhdGEgPSBsaW5rLmRhdGE7XG4gICAgICAgIC8vIElmIGRpc2FibGVkLCB1c2UgZGl2IGFzIGFuY2hvciB0YWdzIGRvIG5vdCBzdXBwb3J0XG4gICAgICAgIC8vIGJlaW5nIGRpc2FibGVkXG4gICAgICAgIHZhciB0YWcgPSB0aGlzLmRpc2FibGVkID8gJ2RpdicgOiBsaW5rLnRhZztcbiAgICAgICAgZGF0YS5yZWYgPSAnbGluayc7XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtdGFic19fZGl2J1xuICAgICAgICB9LCBbaCh0YWcsIGRhdGEsIHRoaXMuJHNsb3RzLmRlZmF1bHQpXSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRhYnMvVlRhYkl0ZW0uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUYWJzL1ZUYWJJdGVtLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVldpbmRvd19WV2luZG93SXRlbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVldpbmRvdy9WV2luZG93SXRlbSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVldpbmRvdy9WV2luZG93SXRlbS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG4vLyBFeHRlbnNpb25zXG5cbi8vIE1peGluc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVldpbmRvd19WV2luZG93SXRlbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LXRhYi1pdGVtJyxcbiAgICBwcm9wczoge1xuICAgICAgICBpZDogU3RyaW5nXG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciByZW5kZXIgPSBfVldpbmRvd19WV2luZG93SXRlbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5vcHRpb25zLnJlbmRlci5jYWxsKHRoaXMsIGgpO1xuICAgICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCB2MS4yXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICh0aGlzLmlkKSB7XG4gICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVwcmVjYXRlXCJdKSgnaWQnLCAndmFsdWUnLCB0aGlzKTtcbiAgICAgICAgICAgIHJlbmRlci5kYXRhLmRvbVByb3BzID0gcmVuZGVyLmRhdGEuZG9tUHJvcHMgfHwge307XG4gICAgICAgICAgICByZW5kZXIuZGF0YS5kb21Qcm9wcy5pZCA9IHRoaXMuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcjtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRhYnMvVlRhYnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUYWJzL1ZUYWJzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfdGFic19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fdGFicy5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3RhYnMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfdGFic19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX3RhYnNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkl0ZW1Hcm91cF9WSXRlbUdyb3VwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WSXRlbUdyb3VwL1ZJdGVtR3JvdXAgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJdGVtR3JvdXAvVkl0ZW1Hcm91cC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RhYnNfY29tcHV0ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL3RhYnMtY29tcHV0ZWQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUYWJzL21peGlucy90YWJzLWNvbXB1dGVkLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGFic19nZW5lcmF0b3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21peGlucy90YWJzLWdlbmVyYXRvcnMgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUYWJzL21peGlucy90YWJzLWdlbmVyYXRvcnMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190YWJzX3Byb3BzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21peGlucy90YWJzLXByb3BzICovIFwiLi9zcmMvY29tcG9uZW50cy9WVGFicy9taXhpbnMvdGFicy1wcm9wcy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RhYnNfdG91Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL3RhYnMtdG91Y2ggKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUYWJzL21peGlucy90YWJzLXRvdWNoLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGFic193YXRjaGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9taXhpbnMvdGFicy13YXRjaGVycyAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRhYnMvbWl4aW5zL3RhYnMtd2F0Y2hlcnMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfc3NyX2Jvb3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvc3NyLWJvb3RhYmxlICovIFwiLi9zcmMvbWl4aW5zL3Nzci1ib290YWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3RoZW1lYWJsZSAqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RpcmVjdGl2ZXNfcmVzaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUgKi8gXCIuL3NyYy9kaXJlY3RpdmVzL3Jlc2l6ZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlyZWN0aXZlc190b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RpcmVjdGl2ZXMvdG91Y2ggKi8gXCIuL3NyYy9kaXJlY3RpdmVzL3RvdWNoLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfVGhlbWVQcm92aWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvVGhlbWVQcm92aWRlciAqLyBcIi4vc3JjL3V0aWwvVGhlbWVQcm92aWRlci50c1wiKTtcbi8vIFN0eWxlc1xuXG4vLyBFeHRlbnNpb25zXG5cbi8vIENvbXBvbmVudCBsZXZlbCBtaXhpbnNcblxuXG5cblxuXG4vLyBNaXhpbnNcblxuXG5cbi8vIERpcmVjdGl2ZXNcblxuXG5cbi8vIFV0aWxzXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKF9WSXRlbUdyb3VwX1ZJdGVtR3JvdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIkJhc2VJdGVtR3JvdXBcIl0uZXh0ZW5kKHtcbiAgICBuYW1lOiAndi10YWJzJyxcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICAgIFJlc2l6ZTogX2RpcmVjdGl2ZXNfcmVzaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgVG91Y2g6IF9kaXJlY3RpdmVzX3RvdWNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiZGVmYXVsdFwiXVxuICAgIH0sXG4gICAgbWl4aW5zOiBbX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfc3NyX2Jvb3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RhYnNfY29tcHV0ZWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdGFic19wcm9wc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSwgX21peGluc190YWJzX2dlbmVyYXRvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfdGFic190b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSwgX21peGluc190YWJzX3dhdGNoZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhYkdyb3VwOiB0aGlzLFxuICAgICAgICAgICAgdGFiUHJveHk6IHRoaXMudGFiUHJveHksXG4gICAgICAgICAgICByZWdpc3Rlckl0ZW1zOiB0aGlzLnJlZ2lzdGVySXRlbXMsXG4gICAgICAgICAgICB1bnJlZ2lzdGVySXRlbXM6IHRoaXMudW5yZWdpc3Rlckl0ZW1zXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFyOiBbXSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtdLFxuICAgICAgICAgICAgaXNPdmVyZmxvd2luZzogZmFsc2UsXG4gICAgICAgICAgICBuZXh0SWNvblZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgcHJldkljb25WaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc2l6ZVRpbWVvdXQ6IG51bGwsXG4gICAgICAgICAgICBzY3JvbGxPZmZzZXQ6IDAsXG4gICAgICAgICAgICBzbGlkZXJXaWR0aDogbnVsbCxcbiAgICAgICAgICAgIHNsaWRlckxlZnQ6IG51bGwsXG4gICAgICAgICAgICBzdGFydFg6IDAsXG4gICAgICAgICAgICB0YWJJdGVtczogbnVsbCxcbiAgICAgICAgICAgIHRyYW5zaXRpb25UaW1lOiAzMDAsXG4gICAgICAgICAgICB3aWR0aHM6IHtcbiAgICAgICAgICAgICAgICBiYXI6IDAsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiAwLFxuICAgICAgICAgICAgICAgIHdyYXBwZXI6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIGl0ZW1zOiAnb25SZXNpemUnLFxuICAgICAgICB0YWJzOiAnb25SZXNpemUnXG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgY2hlY2tJY29uczogZnVuY3Rpb24gY2hlY2tJY29ucygpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkljb25WaXNpYmxlID0gdGhpcy5jaGVja1ByZXZJY29uKCk7XG4gICAgICAgICAgICB0aGlzLm5leHRJY29uVmlzaWJsZSA9IHRoaXMuY2hlY2tOZXh0SWNvbigpO1xuICAgICAgICB9LFxuICAgICAgICBjaGVja1ByZXZJY29uOiBmdW5jdGlvbiBjaGVja1ByZXZJY29uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsT2Zmc2V0ID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgY2hlY2tOZXh0SWNvbjogZnVuY3Rpb24gY2hlY2tOZXh0SWNvbigpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIG9uZSBzY3JvbGwgYWhlYWQgdG8ga25vdyB0aGUgd2lkdGggb2YgcmlnaHQtbW9zdCBpdGVtXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aHMuY29udGFpbmVyID4gdGhpcy5zY3JvbGxPZmZzZXQgKyB0aGlzLndpZHRocy53cmFwcGVyO1xuICAgICAgICB9LFxuICAgICAgICBjYWxsU2xpZGVyOiBmdW5jdGlvbiBjYWxsU2xpZGVyKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZGVTbGlkZXIgfHwgIXRoaXMuYWN0aXZlVGFiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBHaXZlIHNjcmVlbiB0aW1lIHRvIHBhaW50XG4gICAgICAgICAgICB2YXIgYWN0aXZlVGFiID0gdGhpcy5hY3RpdmVUYWI7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVUYWIgfHwgIWFjdGl2ZVRhYi4kZWwpIHJldHVybjtcbiAgICAgICAgICAgICAgICBfdGhpcy5zbGlkZXJXaWR0aCA9IGFjdGl2ZVRhYi4kZWwuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2xpZGVyTGVmdCA9IGFjdGl2ZVRhYi4kZWwub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBEbyBub3QgcHJvY2Vzc1xuICAgICAgICAvLyB1bnRpbCBET00gaXNcbiAgICAgICAgLy8gcGFpbnRlZFxuICAgICAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLiRsaXN0ZW5lcnNbJ2lucHV0J10pIHtcbiAgICAgICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcImRlcHJlY2F0ZVwiXSkoJ0BpbnB1dCcsICdAY2hhbmdlJywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHYtbmF2aWdhdGlvbi1kcmF3ZXIgY2hhbmdlcyB0aGVcbiAgICAgICAgICogd2lkdGggb2YgdGhlIGNvbnRhaW5lciwgY2FsbCByZXNpemVcbiAgICAgICAgICogYWZ0ZXIgdGhlIHRyYW5zaXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgICovXG4gICAgICAgIG9uUmVzaXplOiBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zZXRXaWR0aHMoKTtcbiAgICAgICAgICAgIHZhciBkZWxheSA9IHRoaXMuaXNCb290ZWQgPyB0aGlzLnRyYW5zaXRpb25UaW1lIDogMDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnVwZGF0ZVRhYnNWaWV3LCBkZWxheSk7XG4gICAgICAgIH0sXG4gICAgICAgIG92ZXJmbG93Q2hlY2s6IGZ1bmN0aW9uIG92ZXJmbG93Q2hlY2soZSwgZm4pIHtcbiAgICAgICAgICAgIHRoaXMuaXNPdmVyZmxvd2luZyAmJiBmbihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2Nyb2xsVG86IGZ1bmN0aW9uIHNjcm9sbFRvKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxPZmZzZXQgPSB0aGlzLm5ld09mZnNldChkaXJlY3Rpb24pO1xuICAgICAgICB9LFxuICAgICAgICBzZXRPdmVyZmxvdzogZnVuY3Rpb24gc2V0T3ZlcmZsb3coKSB7XG4gICAgICAgICAgICB0aGlzLmlzT3ZlcmZsb3dpbmcgPSB0aGlzLndpZHRocy5iYXIgPCB0aGlzLndpZHRocy5jb250YWluZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFdpZHRoczogZnVuY3Rpb24gc2V0V2lkdGhzKCkge1xuICAgICAgICAgICAgdmFyIGJhciA9IHRoaXMuJHJlZnMuYmFyID8gdGhpcy4kcmVmcy5iYXIuY2xpZW50V2lkdGggOiAwO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuJHJlZnMuY29udGFpbmVyID8gdGhpcy4kcmVmcy5jb250YWluZXIuY2xpZW50V2lkdGggOiAwO1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSB0aGlzLiRyZWZzLndyYXBwZXIgPyB0aGlzLiRyZWZzLndyYXBwZXIuY2xpZW50V2lkdGggOiAwO1xuICAgICAgICAgICAgdGhpcy53aWR0aHMgPSB7IGJhcjogYmFyLCBjb250YWluZXI6IGNvbnRhaW5lciwgd3JhcHBlcjogd3JhcHBlciB9O1xuICAgICAgICAgICAgdGhpcy5zZXRPdmVyZmxvdygpO1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZU5vZGVzOiBmdW5jdGlvbiBwYXJzZU5vZGVzKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBbXTtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHNsaWRlciA9IFtdO1xuICAgICAgICAgICAgdmFyIHRhYiA9IFtdO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9ICh0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZub2RlID0gdGhpcy4kc2xvdHMuZGVmYXVsdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUuY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3Rvci5vcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YtdGFicy1zbGlkZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlci5wdXNoKHZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YtdGFicy1pdGVtcyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh2bm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2LXRhYi1pdGVtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnB1c2godm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FzZSAndi10YWInIC0gaW50ZW50aW9uYWxseSBvbWl0dGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYi5wdXNoKHZub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYi5wdXNoKHZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB0YWI6IHRhYiwgc2xpZGVyOiBzbGlkZXIsIGl0ZW1zOiBpdGVtcywgaXRlbTogaXRlbSB9O1xuICAgICAgICB9LFxuICAgICAgICByZWdpc3Rlckl0ZW1zOiBmdW5jdGlvbiByZWdpc3Rlckl0ZW1zKGZuKSB7XG4gICAgICAgICAgICB0aGlzLnRhYkl0ZW1zID0gZm47XG4gICAgICAgICAgICBmbih0aGlzLmludGVybmFsVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICB1bnJlZ2lzdGVySXRlbXM6IGZ1bmN0aW9uIHVucmVnaXN0ZXJJdGVtcygpIHtcbiAgICAgICAgICAgIHRoaXMudGFiSXRlbXMgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVUYWJzVmlldzogZnVuY3Rpb24gdXBkYXRlVGFic1ZpZXcoKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxTbGlkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJY29ucygpO1xuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZVRhYikgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3ZlcmZsb3dpbmcpIHJldHVybiB0aGlzLnNjcm9sbE9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgdG90YWxXaWR0aCA9IHRoaXMud2lkdGhzLndyYXBwZXIgKyB0aGlzLnNjcm9sbE9mZnNldDtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuYWN0aXZlVGFiLiRlbCxcbiAgICAgICAgICAgICAgICBjbGllbnRXaWR0aCA9IF9hLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIG9mZnNldExlZnQgPSBfYS5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgdmFyIGl0ZW1PZmZzZXQgPSBjbGllbnRXaWR0aCArIG9mZnNldExlZnQ7XG4gICAgICAgICAgICB2YXIgYWRkaXRpb25hbE9mZnNldCA9IGNsaWVudFdpZHRoICogMC4zO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGFiID09PSB0aGlzLml0ZW1zW3RoaXMuaXRlbXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT2Zmc2V0ID0gMDsgLy8gZG9uJ3QgYWRkIGFuIG9mZnNldCBpZiBzZWxlY3RpbmcgdGhlIGxhc3QgdGFiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKG9mZnNldExlZnQgPCB0aGlzLnNjcm9sbE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gTWF0aC5tYXgob2Zmc2V0TGVmdCAtIGFkZGl0aW9uYWxPZmZzZXQsIDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b3RhbFdpZHRoIDwgaXRlbU9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0IC09IHRvdGFsV2lkdGggLSBpdGVtT2Zmc2V0IC0gYWRkaXRpb25hbE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGFiUHJveHk6IGZ1bmN0aW9uIHRhYlByb3h5KHZhbCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucGFyc2VOb2RlcygpLFxuICAgICAgICAgICAgdGFiID0gX2EudGFiLFxuICAgICAgICAgICAgc2xpZGVyID0gX2Euc2xpZGVyLFxuICAgICAgICAgICAgaXRlbXMgPSBfYS5pdGVtcyxcbiAgICAgICAgICAgIGl0ZW0gPSBfYS5pdGVtO1xuICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRhYnMnLFxuICAgICAgICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAncmVzaXplJyxcbiAgICAgICAgICAgICAgICBtb2RpZmllcnM6IHsgcXVpZXQ6IHRydWUgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5vblJlc2l6ZVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfSwgW3RoaXMuZ2VuQmFyKFt0aGlzLmhpZGVTbGlkZXIgPyBudWxsIDogdGhpcy5nZW5TbGlkZXIoc2xpZGVyKSwgdGFiXSksIGgoX3V0aWxfVGhlbWVQcm92aWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfX1tcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICAgIHByb3BzOiB7IGRhcms6IHRoaXMudGhlbWUuaXNEYXJrLCBsaWdodDogIXRoaXMudGhlbWUuaXNEYXJrIH1cbiAgICAgICAgfSwgW3RoaXMuZ2VuSXRlbXMoaXRlbXMsIGl0ZW0pXSldKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRhYnMvVlRhYnNJdGVtcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WVGFicy9WVGFic0l0ZW1zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WV2luZG93X1ZXaW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZXaW5kb3cvVldpbmRvdyAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVldpbmRvdy9WV2luZG93LnRzXCIpO1xuLy8gRXh0ZW5zaW9uc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVldpbmRvd19WV2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtdGFicy1pdGVtcycsXG4gICAgaW5qZWN0OiB7XG4gICAgICAgIHJlZ2lzdGVySXRlbXM6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdGFiUHJveHk6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgdW5yZWdpc3Rlckl0ZW1zOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICAgIGN5Y2xlOiBCb29sZWFuXG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBpbnRlcm5hbFZhbHVlOiBmdW5jdGlvbiBpbnRlcm5hbFZhbHVlKHZhbCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnRhYlByb3h5KSB0aGlzLnRhYlByb3h5KHZhbCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJJdGVtcyAmJiB0aGlzLnJlZ2lzdGVySXRlbXModGhpcy5jaGFuZ2VNb2RlbCk7XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJJdGVtcyAmJiB0aGlzLnVucmVnaXN0ZXJJdGVtcygpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBjaGFuZ2VNb2RlbDogZnVuY3Rpb24gY2hhbmdlTW9kZWwodmFsKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eSB3aXRoIHYxLjJcbiAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKGl0ZW0uaWQpIHJldHVybiBpdGVtLmlkO1xuICAgICAgICAgICAgcmV0dXJuIF9WV2luZG93X1ZXaW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0ub3B0aW9ucy5tZXRob2RzLmdldFZhbHVlLmNhbGwodGhpcywgaXRlbSwgaSk7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3ljbGUgJiYgdGhpcy5pbnRlcm5hbEluZGV4ID09PSB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfVldpbmRvd19WV2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLm9wdGlvbnMubWV0aG9kcy5uZXh0LmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXY6IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3ljbGUgJiYgdGhpcy5pbnRlcm5hbEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX1ZXaW5kb3dfVldpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXS5vcHRpb25zLm1ldGhvZHMucHJldi5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUYWJzL1ZUYWJzU2xpZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WVGFicy9WVGFic1NsaWRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtdGFicy1zbGlkZXInLFxuICAgIG1peGluczogW19taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdXSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCB0aGlzLnNldEJhY2tncm91bmRDb2xvcih0aGlzLmNvbG9yIHx8ICdhY2NlbnQnLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtdGFic19fc2xpZGVyJ1xuICAgICAgICB9KSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRhYnMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUYWJzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlRhYnMsIFZUYWIsIFZUYWJJdGVtLCBWVGFic0l0ZW1zLCBWVGFic1NsaWRlciwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRhYnMgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUYWJzL1ZUYWJzLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRhYnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUYWJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRhYiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRhYnMvVlRhYi5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUYWJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRhYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRhYnNJdGVtc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WVGFic0l0ZW1zICovIFwiLi9zcmMvY29tcG9uZW50cy9WVGFicy9WVGFic0l0ZW1zLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRhYnNJdGVtc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WVGFic0l0ZW1zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WVGFiSXRlbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WVGFiSXRlbSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRhYnMvVlRhYkl0ZW0uanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWVGFiSXRlbVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WVGFiSXRlbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRhYnNTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRhYnNTbGlkZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUYWJzL1ZUYWJzU2xpZGVyLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRhYnNTbGlkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRhYnNTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICAkX3Z1ZXRpZnlfc3ViY29tcG9uZW50czoge1xuICAgICAgICBWVGFiczogX1ZUYWJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWVGFiOiBfVlRhYl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgVlRhYnNJdGVtczogX1ZUYWJzSXRlbXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZUYWJJdGVtOiBfVlRhYkl0ZW1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZUYWJzU2xpZGVyOiBfVlRhYnNTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVGFicy9taXhpbnMvdGFicy1jb21wdXRlZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlRhYnMvbWl4aW5zL3RhYnMtY29tcHV0ZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyoqXG4gKiBUYWJzIGNvbXB1dGVkXG4gKlxuICogQG1peGluXG4gKi9cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBhY3RpdmVUYWI6IGZ1bmN0aW9uIGFjdGl2ZVRhYigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSXRlbXNbMF07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRhaW5lclN0eWxlczogZnVuY3Rpb24gY29udGFpbmVyU3R5bGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0ID8ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQodGhpcy5oZWlnaHQsIDEwKSArIFwicHhcIlxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0Fycm93czogZnVuY3Rpb24gaGFzQXJyb3dzKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnNob3dBcnJvd3MgfHwgIXRoaXMuaXNNb2JpbGUpICYmIHRoaXMuaXNPdmVyZmxvd2luZztcbiAgICAgICAgfSxcbiAgICAgICAgaXNNb2JpbGU6IGZ1bmN0aW9uIGlzTW9iaWxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHZ1ZXRpZnkuYnJlYWtwb2ludC53aWR0aCA8IHRoaXMubW9iaWxlQnJlYWtQb2ludDtcbiAgICAgICAgfSxcbiAgICAgICAgc2xpZGVyU3R5bGVzOiBmdW5jdGlvbiBzbGlkZXJTdHlsZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuc2xpZGVyTGVmdCArIFwicHhcIixcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB0aGlzLnNsaWRlckxlZnQgIT0gbnVsbCA/IG51bGwgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuc2xpZGVyV2lkdGggKyBcInB4XCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVGFicy9taXhpbnMvdGFicy1nZW5lcmF0b3JzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUYWJzL21peGlucy90YWJzLWdlbmVyYXRvcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUYWJzSXRlbXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZUYWJzSXRlbXMgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUYWJzL1ZUYWJzSXRlbXMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUYWJzU2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WVGFic1NsaWRlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRhYnMvVlRhYnNTbGlkZXIuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9WSWNvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkljb24vaW5kZXgudHNcIik7XG5cblxuXG4vKipcbiAqIFRhYnMgZ2VuZXJhdG9yc1xuICpcbiAqIEBtaXhpblxuICovXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZW5CYXI6IGZ1bmN0aW9uIGdlbkJhcihpdGVtcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKHRoaXMuY29sb3IsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtdGFic19fYmFyJyxcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiB0aGlzLnRoZW1lQ2xhc3NlcyxcbiAgICAgICAgICAgICAgICByZWY6ICdiYXInXG4gICAgICAgICAgICB9KSwgW3RoaXMuZ2VuVHJhbnNpdGlvbigncHJldicpLCB0aGlzLmdlbldyYXBwZXIodGhpcy5nZW5Db250YWluZXIoaXRlbXMpKSwgdGhpcy5nZW5UcmFuc2l0aW9uKCduZXh0JyldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuQ29udGFpbmVyOiBmdW5jdGlvbiBnZW5Db250YWluZXIoaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRhYnNfX2NvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3YtdGFic19fY29udGFpbmVyLS1hbGlnbi13aXRoLXRpdGxlJzogdGhpcy5hbGlnbldpdGhUaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgJ3YtdGFic19fY29udGFpbmVyLS1jZW50ZXJlZCc6IHRoaXMuY2VudGVyZWQsXG4gICAgICAgICAgICAgICAgICAgICd2LXRhYnNfX2NvbnRhaW5lci0tZml4ZWQtdGFicyc6IHRoaXMuZml4ZWRUYWJzLFxuICAgICAgICAgICAgICAgICAgICAndi10YWJzX19jb250YWluZXItLWdyb3cnOiB0aGlzLmdyb3csXG4gICAgICAgICAgICAgICAgICAgICd2LXRhYnNfX2NvbnRhaW5lci0taWNvbnMtYW5kLXRleHQnOiB0aGlzLmljb25zQW5kVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgJ3YtdGFic19fY29udGFpbmVyLS1vdmVyZmxvdyc6IHRoaXMuaXNPdmVyZmxvd2luZyxcbiAgICAgICAgICAgICAgICAgICAgJ3YtdGFic19fY29udGFpbmVyLS1yaWdodCc6IHRoaXMucmlnaHRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzLmNvbnRhaW5lclN0eWxlcyxcbiAgICAgICAgICAgICAgICByZWY6ICdjb250YWluZXInXG4gICAgICAgICAgICB9LCBpdGVtcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkljb246IGZ1bmN0aW9uIGdlbkljb24oZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0Fycm93cyB8fCAhdGhpc1tkaXJlY3Rpb24gKyBcIkljb25WaXNpYmxlXCJdKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInYtdGFic19faWNvbiB2LXRhYnNfX2ljb24tLVwiICsgZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiAhdGhpc1tkaXJlY3Rpb24gKyBcIkljb25WaXNpYmxlXCJdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2Nyb2xsVG8oZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXNbZGlyZWN0aW9uICsgXCJJY29uXCJdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSXRlbXM6IGZ1bmN0aW9uIGdlbkl0ZW1zKGl0ZW1zLCBpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgaWYgKCFpdGVtLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVlRhYnNJdGVtc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSwgaXRlbSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblRyYW5zaXRpb246IGZ1bmN0aW9uIGdlblRyYW5zaXRpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndHJhbnNpdGlvbicsIHtcbiAgICAgICAgICAgICAgICBwcm9wczogeyBuYW1lOiAnZmFkZS10cmFuc2l0aW9uJyB9XG4gICAgICAgICAgICB9LCBbdGhpcy5nZW5JY29uKGRpcmVjdGlvbildKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuV3JhcHBlcjogZnVuY3Rpb24gZ2VuV3JhcHBlcihpdGVtcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRhYnNfX3dyYXBwZXInLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgICAgICd2LXRhYnNfX3dyYXBwZXItLXNob3ctYXJyb3dzJzogdGhpcy5oYXNBcnJvd3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZjogJ3dyYXBwZXInLFxuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0b3VjaCcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5vdmVyZmxvd0NoZWNrKGUsIF90aGlzLm9uVG91Y2hTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZTogZnVuY3Rpb24gbW92ZShlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm92ZXJmbG93Q2hlY2soZSwgX3RoaXMub25Ub3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZnVuY3Rpb24gZW5kKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub3ZlcmZsb3dDaGVjayhlLCBfdGhpcy5vblRvdWNoRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LCBbaXRlbXNdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuU2xpZGVyOiBmdW5jdGlvbiBnZW5TbGlkZXIoaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMgPSBbdGhpcy4kY3JlYXRlRWxlbWVudChfVlRhYnNTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHsgY29sb3I6IHRoaXMuc2xpZGVyQ29sb3IgfVxuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRhYnNfX3NsaWRlci13cmFwcGVyJyxcbiAgICAgICAgICAgICAgICBzdHlsZTogdGhpcy5zbGlkZXJTdHlsZXNcbiAgICAgICAgICAgIH0sIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUYWJzL21peGlucy90YWJzLXByb3BzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WVGFicy9taXhpbnMvdGFicy1wcm9wcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKipcbiAqIFRhYnMgcHJvcHNcbiAqXG4gKiBAbWl4aW5cbiAqL1xuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIHByb3BzOiB7XG4gICAgICAgIGFjdGl2ZUNsYXNzOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAndi10YWJzX19pdGVtLS1hY3RpdmUnXG4gICAgICAgIH0sXG4gICAgICAgIGFsaWduV2l0aFRpdGxlOiBCb29sZWFuLFxuICAgICAgICBjZW50ZXJlZDogQm9vbGVhbixcbiAgICAgICAgZml4ZWRUYWJzOiBCb29sZWFuLFxuICAgICAgICBncm93OiBCb29sZWFuLFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUludCh2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGVTbGlkZXI6IEJvb2xlYW4sXG4gICAgICAgIGljb25zQW5kVGV4dDogQm9vbGVhbixcbiAgICAgICAgbWFuZGF0b3J5OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBtb2JpbGVCcmVha1BvaW50OiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogMTI2NCxcbiAgICAgICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlSW50KHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbmV4dEljb246IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5uZXh0J1xuICAgICAgICB9LFxuICAgICAgICBwcmV2SWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5Lmljb25zLnByZXYnXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0OiBCb29sZWFuLFxuICAgICAgICBzaG93QXJyb3dzOiBCb29sZWFuLFxuICAgICAgICBzbGlkZXJDb2xvcjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2FjY2VudCdcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IFtOdW1iZXIsIFN0cmluZ11cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVGFicy9taXhpbnMvdGFicy10b3VjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlRhYnMvbWl4aW5zL3RhYnMtdG91Y2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyoqXG4gKiBUYWJzIHRvdWNoXG4gKlxuICogQG1peGluXG4gKi9cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIG5ld09mZnNldDogZnVuY3Rpb24gbmV3T2Zmc2V0KGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGNsaWVudFdpZHRoID0gdGhpcy4kcmVmcy53cmFwcGVyLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc2Nyb2xsT2Zmc2V0IC0gY2xpZW50V2lkdGgsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5zY3JvbGxPZmZzZXQgKyBjbGllbnRXaWR0aCwgdGhpcy4kcmVmcy5jb250YWluZXIuY2xpZW50V2lkdGggLSBjbGllbnRXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uVG91Y2hTdGFydDogZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRYID0gdGhpcy5zY3JvbGxPZmZzZXQgKyBlLnRvdWNoc3RhcnRYO1xuICAgICAgICAgICAgdGhpcy4kcmVmcy5jb250YWluZXIuc3R5bGUudHJhbnNpdGlvbiA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuJHJlZnMuY29udGFpbmVyLnN0eWxlLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gdGhpcy5zdGFydFggLSBlLnRvdWNobW92ZVg7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVG91Y2hFbmQ6IGZ1bmN0aW9uIG9uVG91Y2hFbmQoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy4kcmVmcy5jb250YWluZXI7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IHRoaXMuJHJlZnMud3JhcHBlcjtcbiAgICAgICAgICAgIHZhciBtYXhTY3JvbGxPZmZzZXQgPSBjb250YWluZXIuY2xpZW50V2lkdGggLSB3cmFwcGVyLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLndpbGxDaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbE9mZnNldCA8IDAgfHwgIXRoaXMuaXNPdmVyZmxvd2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY3JvbGxPZmZzZXQgPj0gbWF4U2Nyb2xsT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxPZmZzZXQgPSBtYXhTY3JvbGxPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVGFicy9taXhpbnMvdGFicy13YXRjaGVycy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlRhYnMvbWl4aW5zL3RhYnMtd2F0Y2hlcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyoqXG4gKiBUYWJzIHdhdGNoZXJzXG4gKlxuICogQG1peGluXG4gKi9cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICB3YXRjaDoge1xuICAgICAgICBhY3RpdmVUYWI6IGZ1bmN0aW9uIGFjdGl2ZVRhYih2YWwsIG9sZFZhbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPdmVyZmxvdygpO1xuICAgICAgICAgICAgaWYgKCF2YWwpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMudGFiSXRlbXMgJiYgdGhpcy50YWJJdGVtcyh0aGlzLmdldFZhbHVlKHZhbCwgdGhpcy5pdGVtcy5pbmRleE9mKHZhbCkpKTtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgZm9yIGZpcnN0IHRhYlxuICAgICAgICAgICAgLy8gaXMgaGFuZGxlZCBmcm9tIGlzQm9vdGVkXG4gICAgICAgICAgICAvLyB3YXRjaGVyXG4gICAgICAgICAgICBpZiAob2xkVmFsID09IG51bGwpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGFic1ZpZXcoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWxpZ25XaXRoVGl0bGU6ICdjYWxsU2xpZGVyJyxcbiAgICAgICAgY2VudGVyZWQ6ICdjYWxsU2xpZGVyJyxcbiAgICAgICAgZml4ZWRUYWJzOiAnY2FsbFNsaWRlcicsXG4gICAgICAgIGhhc0Fycm93czogZnVuY3Rpb24gaGFzQXJyb3dzKHZhbCkge1xuICAgICAgICAgICAgaWYgKCF2YWwpIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgLyogQGRlcHJlY2F0ZSAqL1xuICAgICAgICBpbnRlcm5hbFZhbHVlOiBmdW5jdGlvbiBpbnRlcm5hbFZhbHVlKHZhbCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy4kbGlzdGVuZXJzWydpbnB1dCddKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxhenlWYWx1ZTogJ3VwZGF0ZVRhYnMnLFxuICAgICAgICByaWdodDogJ2NhbGxTbGlkZXInLFxuICAgICAgICAnJHZ1ZXRpZnkuYXBwbGljYXRpb24ubGVmdCc6ICdvblJlc2l6ZScsXG4gICAgICAgICckdnVldGlmeS5hcHBsaWNhdGlvbi5yaWdodCc6ICdvblJlc2l6ZScsXG4gICAgICAgIHNjcm9sbE9mZnNldDogZnVuY3Rpb24gc2Nyb2xsT2Zmc2V0KHZhbCkge1xuICAgICAgICAgICAgdGhpcy4kcmVmcy5jb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVYKFwiICsgLXZhbCArIFwicHgpXCI7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBcnJvd3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZJY29uVmlzaWJsZSA9IHRoaXMuY2hlY2tQcmV2SWNvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dEljb25WaXNpYmxlID0gdGhpcy5jaGVja05leHRJY29uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVGV4dEZpZWxkL1ZUZXh0RmllbGQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WVGV4dEZpZWxkL1ZUZXh0RmllbGQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfdGV4dF9maWVsZHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3RleHQtZmllbGRzLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdGV4dC1maWVsZHMuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfdGV4dF9maWVsZHNfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c190ZXh0X2ZpZWxkc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WSW5wdXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZJbnB1dCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVklucHV0L2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQ291bnRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVkNvdW50ZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDb3VudGVyL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WTGFiZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZMYWJlbCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkxhYmVsL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfbWFza2FibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9tYXNrYWJsZSAqLyBcIi4vc3JjL21peGlucy9tYXNrYWJsZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2xvYWRhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvbG9hZGFibGUgKi8gXCIuL3NyYy9taXhpbnMvbG9hZGFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RpcmVjdGl2ZXNfcmlwcGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kaXJlY3RpdmVzL3JpcHBsZSAqLyBcIi4vc3JjL2RpcmVjdGl2ZXMvcmlwcGxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBTdHlsZXNcblxuLy8gRXh0ZW5zaW9uc1xuXG4vLyBDb21wb25lbnRzXG5cblxuLy8gTWl4aW5zXG5cblxuLy8gRGlyZWN0aXZlc1xuXG4vLyBVdGlsaXRpZXNcblxuXG52YXIgZGlydHlUeXBlcyA9IFsnY29sb3InLCAnZmlsZScsICd0aW1lJywgJ2RhdGUnLCAnZGF0ZXRpbWUtbG9jYWwnLCAnd2VlaycsICdtb250aCddO1xuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LXRleHQtZmllbGQnLFxuICAgIGRpcmVjdGl2ZXM6IHsgUmlwcGxlOiBfZGlyZWN0aXZlc19yaXBwbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0gfSxcbiAgICBleHRlbmRzOiBfVklucHV0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLFxuICAgIG1peGluczogW19taXhpbnNfbWFza2FibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfbG9hZGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl1dLFxuICAgIGluaGVyaXRBdHRyczogZmFsc2UsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYXBwZW5kT3V0ZXJJY29uOiBTdHJpbmcsXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBhcHBlbmRPdXRlckljb25DYjogRnVuY3Rpb24sXG4gICAgICAgIGF1dG9mb2N1czogQm9vbGVhbixcbiAgICAgICAgYm94OiBCb29sZWFuLFxuICAgICAgICBicm93c2VyQXV0b2NvbXBsZXRlOiBTdHJpbmcsXG4gICAgICAgIGNsZWFyYWJsZTogQm9vbGVhbixcbiAgICAgICAgY2xlYXJJY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMuY2xlYXInXG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFySWNvbkNiOiBGdW5jdGlvbixcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5J1xuICAgICAgICB9LFxuICAgICAgICBjb3VudGVyOiBbQm9vbGVhbiwgTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBmbGF0OiBCb29sZWFuLFxuICAgICAgICBmdWxsV2lkdGg6IEJvb2xlYW4sXG4gICAgICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgICAgIG91dGxpbmU6IEJvb2xlYW4sXG4gICAgICAgIHBsYWNlaG9sZGVyOiBTdHJpbmcsXG4gICAgICAgIHByZWZpeDogU3RyaW5nLFxuICAgICAgICBwcmVwZW5kSW5uZXJJY29uOiBTdHJpbmcsXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBwcmVwZW5kSW5uZXJJY29uQ2I6IEZ1bmN0aW9uLFxuICAgICAgICByZXZlcnNlOiBCb29sZWFuLFxuICAgICAgICBzaW5nbGVMaW5lOiBCb29sZWFuLFxuICAgICAgICBzb2xvOiBCb29sZWFuLFxuICAgICAgICBzb2xvSW52ZXJ0ZWQ6IEJvb2xlYW4sXG4gICAgICAgIHN1ZmZpeDogU3RyaW5nLFxuICAgICAgICB0ZXh0YXJlYTogQm9vbGVhbixcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYWRJbnB1dDogZmFsc2UsXG4gICAgICAgICAgICBpbml0aWFsVmFsdWU6IG51bGwsXG4gICAgICAgICAgICBpbnRlcm5hbENoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICBpc0NsZWFyaW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3YtdGV4dC1maWVsZCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3YtdGV4dC1maWVsZC0tZnVsbC13aWR0aCc6IHRoaXMuZnVsbFdpZHRoLFxuICAgICAgICAgICAgICAgICd2LXRleHQtZmllbGQtLXByZWZpeCc6IHRoaXMucHJlZml4LFxuICAgICAgICAgICAgICAgICd2LXRleHQtZmllbGQtLXNpbmdsZS1saW5lJzogdGhpcy5pc1NpbmdsZSxcbiAgICAgICAgICAgICAgICAndi10ZXh0LWZpZWxkLS1zb2xvJzogdGhpcy5pc1NvbG8sXG4gICAgICAgICAgICAgICAgJ3YtdGV4dC1maWVsZC0tc29sby1pbnZlcnRlZCc6IHRoaXMuc29sb0ludmVydGVkLFxuICAgICAgICAgICAgICAgICd2LXRleHQtZmllbGQtLXNvbG8tZmxhdCc6IHRoaXMuZmxhdCxcbiAgICAgICAgICAgICAgICAndi10ZXh0LWZpZWxkLS1ib3gnOiB0aGlzLmJveCxcbiAgICAgICAgICAgICAgICAndi10ZXh0LWZpZWxkLS1lbmNsb3NlZCc6IHRoaXMuaXNFbmNsb3NlZCxcbiAgICAgICAgICAgICAgICAndi10ZXh0LWZpZWxkLS1yZXZlcnNlJzogdGhpcy5yZXZlcnNlLFxuICAgICAgICAgICAgICAgICd2LXRleHQtZmllbGQtLW91dGxpbmUnOiB0aGlzLmhhc091dGxpbmUsXG4gICAgICAgICAgICAgICAgJ3YtdGV4dC1maWVsZC0tcGxhY2Vob2xkZXInOiB0aGlzLnBsYWNlaG9sZGVyXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjb3VudGVyVmFsdWU6IGZ1bmN0aW9uIGNvdW50ZXJWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pbnRlcm5hbFZhbHVlIHx8ICcnKS50b1N0cmluZygpLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZGlyZWN0aXZlc0lucHV0OiBmdW5jdGlvbiBkaXJlY3RpdmVzSW5wdXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE86IERlcHJlY2F0ZVxuICAgICAgICBoYXNPdXRsaW5lOiBmdW5jdGlvbiBoYXNPdXRsaW5lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0bGluZSB8fCB0aGlzLnRleHRhcmVhO1xuICAgICAgICB9LFxuICAgICAgICBpbnRlcm5hbFZhbHVlOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXp5VmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWFzaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhenlWYWx1ZSA9IHRoaXMudW5tYXNrVGV4dCh0aGlzLm1hc2tUZXh0KHRoaXMudW5tYXNrVGV4dCh2YWwpKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhenlWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmxhenlWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc0RpcnR5OiBmdW5jdGlvbiBpc0RpcnR5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF6eVZhbHVlICE9IG51bGwgJiYgdGhpcy5sYXp5VmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPiAwIHx8IHRoaXMuYmFkSW5wdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRW5jbG9zZWQ6IGZ1bmN0aW9uIGlzRW5jbG9zZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3ggfHwgdGhpcy5pc1NvbG8gfHwgdGhpcy5oYXNPdXRsaW5lIHx8IHRoaXMuZnVsbFdpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBpc0xhYmVsQWN0aXZlOiBmdW5jdGlvbiBpc0xhYmVsQWN0aXZlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNEaXJ0eSB8fCBkaXJ0eVR5cGVzLmluY2x1ZGVzKHRoaXMudHlwZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzU2luZ2xlOiBmdW5jdGlvbiBpc1NpbmdsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU29sbyB8fCB0aGlzLnNpbmdsZUxpbmU7XG4gICAgICAgIH0sXG4gICAgICAgIGlzU29sbzogZnVuY3Rpb24gaXNTb2xvKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc29sbyB8fCB0aGlzLnNvbG9JbnZlcnRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWxQb3NpdGlvbjogZnVuY3Rpb24gbGFiZWxQb3NpdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnByZWZpeCAmJiAhdGhpcy5sYWJlbFZhbHVlID8gdGhpcy5wcmVmaXhXaWR0aCA6IDA7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuJHZ1ZXRpZnkucnRsICE9PSAhdGhpcy5yZXZlcnNlID8ge1xuICAgICAgICAgICAgICAgIGxlZnQ6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICByaWdodDogb2Zmc2V0XG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICByaWdodDogJ2F1dG8nXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzaG93TGFiZWw6IGZ1bmN0aW9uIHNob3dMYWJlbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0xhYmVsICYmICghdGhpcy5pc1NpbmdsZSB8fCAhdGhpcy5pc0xhYmVsQWN0aXZlICYmICF0aGlzLnBsYWNlaG9sZGVyICYmICF0aGlzLnByZWZpeExhYmVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWxWYWx1ZTogZnVuY3Rpb24gbGFiZWxWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5pc1NpbmdsZSAmJiBCb29sZWFuKHRoaXMuaXNGb2N1c2VkIHx8IHRoaXMuaXNMYWJlbEFjdGl2ZSB8fCB0aGlzLnBsYWNlaG9sZGVyIHx8IHRoaXMucHJlZml4TGFiZWwpO1xuICAgICAgICB9LFxuICAgICAgICBwcmVmaXhXaWR0aDogZnVuY3Rpb24gcHJlZml4V2lkdGgoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJlZml4ICYmICF0aGlzLiRyZWZzLnByZWZpeCkgcmV0dXJuO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucHJlZml4Lm9mZnNldFdpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBwcmVmaXhMYWJlbDogZnVuY3Rpb24gcHJlZml4TGFiZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVmaXggJiYgIXRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIGlzRm9jdXNlZDogZnVuY3Rpb24gaXNGb2N1c2VkKHZhbCkge1xuICAgICAgICAgICAgLy8gU2V0cyB2YWxpZGF0aW9uU3RhdGUgZnJvbSB2YWxpZGF0YWJsZVxuICAgICAgICAgICAgdGhpcy5oYXNDb2xvciA9IHZhbDtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHRoaXMubGF6eVZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdGhpcy5sYXp5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLmxhenlWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh2YWwpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXNrICYmICF0aGlzLmludGVybmFsQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hc2tlZF8xID0gdGhpcy5tYXNrVGV4dCh0aGlzLnVubWFza1RleHQodmFsKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXp5VmFsdWUgPSB0aGlzLnVubWFza1RleHQobWFza2VkXzEpO1xuICAgICAgICAgICAgICAgIC8vIEVtaXQgd2hlbiB0aGUgZXh0ZXJuYWxseSBzZXQgdmFsdWUgd2FzIG1vZGlmaWVkIGludGVybmFsbHlcbiAgICAgICAgICAgICAgICBTdHJpbmcodmFsKSAhPT0gdGhpcy5sYXp5VmFsdWUgJiYgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kcmVmcy5pbnB1dC52YWx1ZSA9IG1hc2tlZF8xO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kZW1pdCgnaW5wdXQnLCBfdGhpcy5sYXp5VmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHRoaXMubGF6eVZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLmF1dG9mb2N1cyAmJiB0aGlzLm9uRm9jdXMoKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgLyoqIEBwdWJsaWMgKi9cbiAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgICAgICAgdGhpcy5vbkZvY3VzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAcHVibGljICovXG4gICAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0ID8gdGhpcy4kcmVmcy5pbnB1dC5ibHVyKCkgOiB0aGlzLm9uQmx1cigpO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhcmFibGVDYWxsYmFjazogZnVuY3Rpb24gY2xlYXJhYmxlQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuJHJlZnMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5BcHBlbmRTbG90OiBmdW5jdGlvbiBnZW5BcHBlbmRTbG90KCkge1xuICAgICAgICAgICAgdmFyIHNsb3QgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzbG90c1snYXBwZW5kLW91dGVyJ10pIHtcbiAgICAgICAgICAgICAgICBzbG90LnB1c2godGhpcy4kc2xvdHNbJ2FwcGVuZC1vdXRlciddKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hcHBlbmRPdXRlckljb24pIHtcbiAgICAgICAgICAgICAgICBzbG90LnB1c2godGhpcy5nZW5JY29uKCdhcHBlbmRPdXRlcicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlblNsb3QoJ2FwcGVuZCcsICdvdXRlcicsIHNsb3QpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5QcmVwZW5kSW5uZXJTbG90OiBmdW5jdGlvbiBnZW5QcmVwZW5kSW5uZXJTbG90KCkge1xuICAgICAgICAgICAgdmFyIHNsb3QgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLiRzbG90c1sncHJlcGVuZC1pbm5lciddKSB7XG4gICAgICAgICAgICAgICAgc2xvdC5wdXNoKHRoaXMuJHNsb3RzWydwcmVwZW5kLWlubmVyJ10pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXBlbmRJbm5lckljb24pIHtcbiAgICAgICAgICAgICAgICBzbG90LnB1c2godGhpcy5nZW5JY29uKCdwcmVwZW5kSW5uZXInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5TbG90KCdwcmVwZW5kJywgJ2lubmVyJywgc2xvdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkljb25TbG90OiBmdW5jdGlvbiBnZW5JY29uU2xvdCgpIHtcbiAgICAgICAgICAgIHZhciBzbG90ID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy4kc2xvdHNbJ2FwcGVuZCddKSB7XG4gICAgICAgICAgICAgICAgc2xvdC5wdXNoKHRoaXMuJHNsb3RzWydhcHBlbmQnXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYXBwZW5kSWNvbikge1xuICAgICAgICAgICAgICAgIHNsb3QucHVzaCh0aGlzLmdlbkljb24oJ2FwcGVuZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlblNsb3QoJ2FwcGVuZCcsICdpbm5lcicsIHNsb3QpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5JbnB1dFNsb3Q6IGZ1bmN0aW9uIGdlbklucHV0U2xvdCgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IF9WSW5wdXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0ubWV0aG9kcy5nZW5JbnB1dFNsb3QuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBwcmVwZW5kID0gdGhpcy5nZW5QcmVwZW5kSW5uZXJTbG90KCk7XG4gICAgICAgICAgICBwcmVwZW5kICYmIGlucHV0LmNoaWxkcmVuLnVuc2hpZnQocHJlcGVuZCk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkNsZWFySWNvbjogZnVuY3Rpb24gZ2VuQ2xlYXJJY29uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNsZWFyYWJsZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgaWNvbiA9ICF0aGlzLmlzRGlydHkgPyBmYWxzZSA6ICdjbGVhcic7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGVhckljb25DYikgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImRlcHJlY2F0ZVwiXSkoJzpjbGVhci1pY29uLWNiJywgJ0BjbGljazpjbGVhcicsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuU2xvdCgnYXBwZW5kJywgJ2lubmVyJywgW3RoaXMuZ2VuSWNvbihpY29uLCAhdGhpcy4kbGlzdGVuZXJzWydjbGljazpjbGVhciddICYmIHRoaXMuY2xlYXJJY29uQ2IgfHwgdGhpcy5jbGVhcmFibGVDYWxsYmFjaywgZmFsc2UpXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkNvdW50ZXI6IGZ1bmN0aW9uIGdlbkNvdW50ZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudGVyID09PSBmYWxzZSB8fCB0aGlzLmNvdW50ZXIgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgbWF4ID0gdGhpcy5jb3VudGVyID09PSB0cnVlID8gdGhpcy4kYXR0cnMubWF4bGVuZ3RoIDogdGhpcy5jb3VudGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZDb3VudGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGFyazogdGhpcy5kYXJrLFxuICAgICAgICAgICAgICAgICAgICBsaWdodDogdGhpcy5saWdodCxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNvdW50ZXJWYWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5EZWZhdWx0U2xvdDogZnVuY3Rpb24gZ2VuRGVmYXVsdFNsb3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuZ2VuVGV4dEZpZWxkU2xvdCgpLCB0aGlzLmdlbkNsZWFySWNvbigpLCB0aGlzLmdlbkljb25TbG90KCksIHRoaXMuZ2VuUHJvZ3Jlc3MoKV07XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkxhYmVsOiBmdW5jdGlvbiBnZW5MYWJlbCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG93TGFiZWwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLnZhbGlkYXRpb25TdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZGFyazogdGhpcy5kYXJrLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZDogIXRoaXMuaXNTaW5nbGUgJiYgKHRoaXMuaXNGb2N1c2VkIHx8ICEhdGhpcy52YWxpZGF0aW9uU3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmxhYmVsUG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgbGlnaHQ6IHRoaXMubGlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmxhYmVsUG9zaXRpb24ucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmxhYmVsVmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuJGF0dHJzLmlkKSBkYXRhLnByb3BzLmZvciA9IHRoaXMuJGF0dHJzLmlkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX1ZMYWJlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSwgZGF0YSwgdGhpcy4kc2xvdHMubGFiZWwgfHwgdGhpcy5sYWJlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbklucHV0OiBmdW5jdGlvbiBnZW5JbnB1dCgpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRsaXN0ZW5lcnMpO1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1snY2hhbmdlJ107IC8vIENoYW5nZSBzaG91bGQgbm90IGJlIGJvdW5kIGV4dGVybmFsbHlcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7fSxcbiAgICAgICAgICAgICAgICBkb21Qcm9wczoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5tYXNrVGV4dCh0aGlzLmxhenlWYWx1ZSlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbih7ICdhcmlhLWxhYmVsJzogKCF0aGlzLiRhdHRycyB8fCAhdGhpcy4kYXR0cnMuaWQpICYmIHRoaXMubGFiZWwgfSwgdGhpcy4kYXR0cnMsIHsgYXV0b2ZvY3VzOiB0aGlzLmF1dG9mb2N1cywgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsIHJlYWRvbmx5OiB0aGlzLnJlYWRvbmx5LCB0eXBlOiB0aGlzLnR5cGUgfSksXG4gICAgICAgICAgICAgICAgb246IE9iamVjdC5hc3NpZ24obGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgIGJsdXI6IHRoaXMub25CbHVyLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5vbklucHV0LFxuICAgICAgICAgICAgICAgICAgICBmb2N1czogdGhpcy5vbkZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBrZXlkb3duOiB0aGlzLm9uS2V5RG93blxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJlZjogJ2lucHV0J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyKSBkYXRhLmF0dHJzLnBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc2spIGRhdGEuYXR0cnMubWF4bGVuZ3RoID0gdGhpcy5tYXNrZWQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnJvd3NlckF1dG9jb21wbGV0ZSkgZGF0YS5hdHRycy5hdXRvY29tcGxldGUgPSB0aGlzLmJyb3dzZXJBdXRvY29tcGxldGU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnaW5wdXQnLCBkYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuTWVzc2FnZXM6IGZ1bmN0aW9uIGdlbk1lc3NhZ2VzKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlkZURldGFpbHMpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtdGV4dC1maWVsZF9fZGV0YWlscydcbiAgICAgICAgICAgIH0sIFtfVklucHV0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLm1ldGhvZHMuZ2VuTWVzc2FnZXMuY2FsbCh0aGlzKSwgdGhpcy5nZW5Db3VudGVyKCldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuVGV4dEZpZWxkU2xvdDogZnVuY3Rpb24gZ2VuVGV4dEZpZWxkU2xvdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRleHQtZmllbGRfX3Nsb3QnXG4gICAgICAgICAgICB9LCBbdGhpcy5nZW5MYWJlbCgpLCB0aGlzLnByZWZpeCA/IHRoaXMuZ2VuQWZmaXgoJ3ByZWZpeCcpIDogbnVsbCwgdGhpcy5nZW5JbnB1dCgpLCB0aGlzLnN1ZmZpeCA/IHRoaXMuZ2VuQWZmaXgoJ3N1ZmZpeCcpIDogbnVsbF0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5BZmZpeDogZnVuY3Rpb24gZ2VuQWZmaXgodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiBcInYtdGV4dC1maWVsZF9fXCIgKyB0eXBlLFxuICAgICAgICAgICAgICAgIHJlZjogdHlwZVxuICAgICAgICAgICAgfSwgdGhpc1t0eXBlXSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmx1cjogZnVuY3Rpb24gb25CbHVyKGUpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBSZXNldCBpbnRlcm5hbENoYW5nZSBzdGF0ZVxuICAgICAgICAgICAgLy8gdG8gYWxsb3cgZXh0ZXJuYWwgY2hhbmdlXG4gICAgICAgICAgICAvLyB0byBwZXJzaXN0XG4gICAgICAgICAgICB0aGlzLmludGVybmFsQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdibHVyJywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQgfHwgdGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzOiBmdW5jdGlvbiBvbkZvY3VzKGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kcmVmcy5pbnB1dCkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRoaXMuJHJlZnMuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdmb2N1cycsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbklucHV0OiBmdW5jdGlvbiBvbklucHV0KGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYXNrICYmIHRoaXMucmVzZXRTZWxlY3Rpb25zKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5iYWRJbnB1dCA9IGUudGFyZ2V0LnZhbGlkaXR5ICYmIGUudGFyZ2V0LnZhbGlkaXR5LmJhZElucHV0O1xuICAgICAgICB9LFxuICAgICAgICBvbktleURvd246IGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImtleUNvZGVzXCJdLmVudGVyKSB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLmludGVybmFsVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgna2V5ZG93bicsIGUpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBpbnB1dCBmcm9tIGJlaW5nIGJsdXJyZWRcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCAhPT0gdGhpcy4kcmVmcy5pbnB1dCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX1ZJbnB1dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLm9uTW91c2VEb3duLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VVcDogZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc01vdXNlRG93bikgdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgX1ZJbnB1dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLm9uTW91c2VVcC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRleHRGaWVsZC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WVGV4dEZpZWxkL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWVGV4dEZpZWxkLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUZXh0RmllbGRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB3cmFwcGVyOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRleHRGaWVsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WVGV4dEZpZWxkICovIFwiLi9zcmMvY29tcG9uZW50cy9WVGV4dEZpZWxkL1ZUZXh0RmllbGQuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUZXh0YXJlYV9WVGV4dGFyZWFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZUZXh0YXJlYS9WVGV4dGFyZWEgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUZXh0YXJlYS9WVGV4dGFyZWEuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfcmVidWlsZEZ1bmN0aW9uYWxTbG90c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9yZWJ1aWxkRnVuY3Rpb25hbFNsb3RzICovIFwiLi9zcmMvdXRpbC9yZWJ1aWxkRnVuY3Rpb25hbFNsb3RzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2RlZHVwZU1vZGVsTGlzdGVuZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2RlZHVwZU1vZGVsTGlzdGVuZXJzICovIFwiLi9zcmMvdXRpbC9kZWR1cGVNb2RlbExpc3RlbmVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG5cblxuXG5cblxuLy8gVE9ETzogcmVtb3ZlIHRoaXMgaW4gdjIuMFxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbnZhciB3cmFwcGVyID0ge1xuICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgJF93cmFwcGVyRm9yOiBfVlRleHRGaWVsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSxcbiAgICBwcm9wczoge1xuICAgICAgICB0ZXh0YXJlYTogQm9vbGVhbixcbiAgICAgICAgbXVsdGlMaW5lOiBCb29sZWFuXG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoLCBfYSkge1xuICAgICAgICB2YXIgcHJvcHMgPSBfYS5wcm9wcyxcbiAgICAgICAgICAgIGRhdGEgPSBfYS5kYXRhLFxuICAgICAgICAgICAgc2xvdHMgPSBfYS5zbG90cyxcbiAgICAgICAgICAgIHBhcmVudCA9IF9hLnBhcmVudDtcbiAgICAgICAgT2JqZWN0KF91dGlsX2RlZHVwZU1vZGVsTGlzdGVuZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKShkYXRhKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gT2JqZWN0KF91dGlsX3JlYnVpbGRGdW5jdGlvbmFsU2xvdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0pKHNsb3RzKCksIGgpO1xuICAgICAgICBpZiAocHJvcHMudGV4dGFyZWEpIHtcbiAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZXByZWNhdGVcIl0pKCc8di10ZXh0LWZpZWxkIHRleHRhcmVhPicsICc8di10ZXh0YXJlYSBvdXRsaW5lPicsIHdyYXBwZXIsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLm11bHRpTGluZSkge1xuICAgICAgICAgICAgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlcHJlY2F0ZVwiXSkoJzx2LXRleHQtZmllbGQgbXVsdGktbGluZT4nLCAnPHYtdGV4dGFyZWE+Jywgd3JhcHBlciwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMudGV4dGFyZWEgfHwgcHJvcHMubXVsdGlMaW5lKSB7XG4gICAgICAgICAgICBkYXRhLmF0dHJzLm91dGxpbmUgPSBwcm9wcy50ZXh0YXJlYTtcbiAgICAgICAgICAgIHJldHVybiBoKF9WVGV4dGFyZWFfVlRleHRhcmVhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCBkYXRhLCBjaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaChfVlRleHRGaWVsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSwgZGF0YSwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh3cmFwcGVyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVGV4dGFyZWEvVlRleHRhcmVhLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUZXh0YXJlYS9WVGV4dGFyZWEuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3RleHRhcmVhX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL190ZXh0YXJlYS5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3RleHRhcmVhLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3RleHRhcmVhX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfdGV4dGFyZWFfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRleHRGaWVsZF9WVGV4dEZpZWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WVGV4dEZpZWxkL1ZUZXh0RmllbGQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUZXh0RmllbGQvVlRleHRGaWVsZC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBTdHlsZXNcblxuLy8gRXh0ZW5zaW9uc1xuXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi10ZXh0YXJlYScsXG4gICAgZXh0ZW5kczogX1ZUZXh0RmllbGRfVlRleHRGaWVsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSxcbiAgICBwcm9wczoge1xuICAgICAgICBhdXRvR3JvdzogQm9vbGVhbixcbiAgICAgICAgbm9SZXNpemU6IEJvb2xlYW4sXG4gICAgICAgIG91dGxpbmU6IEJvb2xlYW4sXG4gICAgICAgIHJvd0hlaWdodDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDI0LFxuICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3Iodikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJvd3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiA1LFxuICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3Iodikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VJbnQodiwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7ICd2LXRleHRhcmVhJzogdHJ1ZSwgJ3YtdGV4dGFyZWEtLWF1dG8tZ3Jvdyc6IHRoaXMuYXV0b0dyb3csICd2LXRleHRhcmVhLS1uby1yZXNpemUnOiB0aGlzLm5vUmVzaXplSGFuZGxlIH0sIF9WVGV4dEZpZWxkX1ZUZXh0RmllbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uY29tcHV0ZWQuY2xhc3Nlcy5jYWxsKHRoaXMsIG51bGwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHluYW1pY0hlaWdodDogZnVuY3Rpb24gZHluYW1pY0hlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1dG9Hcm93ID8gdGhpcy5pbnB1dEhlaWdodCA6ICdhdXRvJztcbiAgICAgICAgfSxcbiAgICAgICAgaXNFbmNsb3NlZDogZnVuY3Rpb24gaXNFbmNsb3NlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHRhcmVhIHx8IF9WVGV4dEZpZWxkX1ZUZXh0RmllbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0uY29tcHV0ZWQuaXNFbmNsb3NlZC5jYWxsKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBub1Jlc2l6ZUhhbmRsZTogZnVuY3Rpb24gbm9SZXNpemVIYW5kbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub1Jlc2l6ZSB8fCB0aGlzLmF1dG9Hcm93O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBsYXp5VmFsdWU6IGZ1bmN0aW9uIGxhenlWYWx1ZSgpIHtcbiAgICAgICAgICAgICF0aGlzLmludGVybmFsQ2hhbmdlICYmIHRoaXMuYXV0b0dyb3cgJiYgdGhpcy4kbmV4dFRpY2sodGhpcy5jYWxjdWxhdGVJbnB1dEhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuYXV0b0dyb3cgJiYgX3RoaXMuY2FsY3VsYXRlSW5wdXRIZWlnaHQoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSAoMi4wKVxuICAgICAgICBpZiAodGhpcy5hdXRvR3JvdyAmJiB0aGlzLm5vUmVzaXplKSB7XG4gICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiY29uc29sZUluZm9cIl0pKCdcIm5vLXJlc2l6ZVwiIGlzIG5vdyBpbXBsaWVkIHdoZW4gdXNpbmcgXCJhdXRvLWdyb3dcIiwgYW5kIGNhbiBiZSByZW1vdmVkJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgY2FsY3VsYXRlSW5wdXRIZWlnaHQ6IGZ1bmN0aW9uIGNhbGN1bGF0ZUlucHV0SGVpZ2h0KCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy4kcmVmcy5pbnB1dDtcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlucHV0LnN0eWxlLmhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGlucHV0LnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgbWluSGVpZ2h0ID0gcGFyc2VJbnQodGhpcy5yb3dzLCAxMCkgKiBwYXJzZUZsb2F0KHRoaXMucm93SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIEFTQVAsIHdhaXRpbmcgZm9yIFZ1ZVxuICAgICAgICAgICAgICAgIC8vIHRvIHVwZGF0ZSB0aGUgRE9NIGNhdXNlcyB1Z2x5IGxheW91dCBqdW1waW5nXG4gICAgICAgICAgICAgICAgaW5wdXQuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgobWluSGVpZ2h0LCBoZWlnaHQpICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSW5wdXQ6IGZ1bmN0aW9uIGdlbklucHV0KCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gX1ZUZXh0RmllbGRfVlRleHRGaWVsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXS5tZXRob2RzLmdlbklucHV0LmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpbnB1dC50YWcgPSAndGV4dGFyZWEnO1xuICAgICAgICAgICAgZGVsZXRlIGlucHV0LmRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICAgIGlucHV0LmRhdGEuYXR0cnMucm93cyA9IHRoaXMucm93cztcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgb25JbnB1dDogZnVuY3Rpb24gb25JbnB1dChlKSB7XG4gICAgICAgICAgICBfVlRleHRGaWVsZF9WVGV4dEZpZWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLm1ldGhvZHMub25JbnB1dC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgdGhpcy5hdXRvR3JvdyAmJiB0aGlzLmNhbGN1bGF0ZUlucHV0SGVpZ2h0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5RG93bjogZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnRzIGNsb3Npbmcgb2YgYVxuICAgICAgICAgICAgLy8gZGlhbG9nIHdoZW4gcHJlc3NpbmdcbiAgICAgICAgICAgIC8vIGVudGVyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0ZvY3VzZWQgJiYgZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmludGVybmFsQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2tleWRvd24nLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUZXh0YXJlYS9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUZXh0YXJlYS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWVGV4dGFyZWEsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUZXh0YXJlYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WVGV4dGFyZWEgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUZXh0YXJlYS9WVGV4dGFyZWEuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWVGV4dGFyZWFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRleHRhcmVhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX1ZUZXh0YXJlYV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRpbWVQaWNrZXIvVlRpbWVQaWNrZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUaW1lUGlja2VyL1ZUaW1lUGlja2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRpbWVQaWNrZXJUaXRsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WVGltZVBpY2tlclRpdGxlICovIFwiLi9zcmMvY29tcG9uZW50cy9WVGltZVBpY2tlci9WVGltZVBpY2tlclRpdGxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WVGltZVBpY2tlckNsb2NrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZUaW1lUGlja2VyQ2xvY2sgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUaW1lUGlja2VyL1ZUaW1lUGlja2VyQ2xvY2suanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19waWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9waWNrZXIgKi8gXCIuL3NyYy9taXhpbnMvcGlja2VyLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkRhdGVQaWNrZXJfdXRpbF9wYWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZEYXRlUGlja2VyL3V0aWwvcGFkICovIFwiLi9zcmMvY29tcG9uZW50cy9WRGF0ZVBpY2tlci91dGlsL3BhZC5qc1wiKTtcbnZhciBfX3JlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fcmVhZCB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgICByLFxuICAgICAgICBhciA9IFtdLFxuICAgICAgICBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbi8vIENvbXBvbmVudHNcblxuXG4vLyBNaXhpbnNcblxuLy8gVXRpbHNcblxuXG52YXIgcmFuZ2VIb3VyczI0ID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImNyZWF0ZVJhbmdlXCJdKSgyNCk7XG52YXIgcmFuZ2VIb3VyczEyYW0gPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiY3JlYXRlUmFuZ2VcIl0pKDEyKTtcbnZhciByYW5nZUhvdXJzMTJwbSA9IHJhbmdlSG91cnMxMmFtLm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2ICsgMTI7XG59KTtcbnZhciByYW5nZU1pbnV0ZXMgPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiY3JlYXRlUmFuZ2VcIl0pKDYwKTtcbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndi10aW1lLXBpY2tlcicsXG4gICAgbWl4aW5zOiBbX21peGluc19waWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFsbG93ZWRIb3VyczogRnVuY3Rpb24sXG4gICAgICAgIGFsbG93ZWRNaW51dGVzOiBGdW5jdGlvbixcbiAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnYW1wbScsXG4gICAgICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydhbXBtJywgJzI0aHInXS5pbmNsdWRlcyh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtaW46IFN0cmluZyxcbiAgICAgICAgbWF4OiBTdHJpbmcsXG4gICAgICAgIHJlYWRvbmx5OiBCb29sZWFuLFxuICAgICAgICBzY3JvbGxhYmxlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0SG91cjogbnVsbCxcbiAgICAgICAgICAgIGlucHV0TWludXRlOiBudWxsLFxuICAgICAgICAgICAgcGVyaW9kOiAnYW0nLFxuICAgICAgICAgICAgc2VsZWN0aW5nSG91cjogdHJ1ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaXNBbGxvd2VkSG91ckNiOiBmdW5jdGlvbiBpc0FsbG93ZWRIb3VyQ2IoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHJldHVybiB0aGlzLmFsbG93ZWRIb3VycztcbiAgICAgICAgICAgIHZhciBtaW5Ib3VyID0gdGhpcy5taW4gPyB0aGlzLm1pbi5zcGxpdCgnOicpWzBdIDogMDtcbiAgICAgICAgICAgIHZhciBtYXhIb3VyID0gdGhpcy5tYXggPyB0aGlzLm1heC5zcGxpdCgnOicpWzBdIDogMjM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPj0gbWluSG91ciAqIDEgJiYgdmFsIDw9IG1heEhvdXIgKiAxICYmICghX3RoaXMuYWxsb3dlZEhvdXJzIHx8IF90aGlzLmFsbG93ZWRIb3Vycyh2YWwpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGlzQWxsb3dlZE1pbnV0ZUNiOiBmdW5jdGlvbiBpc0FsbG93ZWRNaW51dGVDYigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaXNIb3VyQWxsb3dlZCA9ICF0aGlzLmFsbG93ZWRIb3VycyB8fCB0aGlzLmFsbG93ZWRIb3Vycyh0aGlzLmlucHV0SG91cik7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWluICYmICF0aGlzLm1heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0hvdXJBbGxvd2VkID8gdGhpcy5hbGxvd2VkTWludXRlcyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQodGhpcy5taW4gPyB0aGlzLm1pbi5zcGxpdCgnOicpIDogWzAsIDBdLCAyKSxcbiAgICAgICAgICAgICAgICBtaW5Ib3VyID0gX2FbMF0sXG4gICAgICAgICAgICAgICAgbWluTWludXRlID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQodGhpcy5tYXggPyB0aGlzLm1heC5zcGxpdCgnOicpIDogWzIzLCA1OV0sIDIpLFxuICAgICAgICAgICAgICAgIG1heEhvdXIgPSBfYlswXSxcbiAgICAgICAgICAgICAgICBtYXhNaW51dGUgPSBfYlsxXTtcbiAgICAgICAgICAgIHZhciBtaW5UaW1lID0gbWluSG91ciAqIDYwICsgbWluTWludXRlICogMTtcbiAgICAgICAgICAgIHZhciBtYXhUaW1lID0gbWF4SG91ciAqIDYwICsgbWF4TWludXRlICogMTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWUgPSA2MCAqIF90aGlzLmlucHV0SG91ciArIHZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGltZSA+PSBtaW5UaW1lICYmIHRpbWUgPD0gbWF4VGltZSAmJiBpc0hvdXJBbGxvd2VkICYmICghX3RoaXMuYWxsb3dlZE1pbnV0ZXMgfHwgX3RoaXMuYWxsb3dlZE1pbnV0ZXModmFsKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBpc0FtUG06IGZ1bmN0aW9uIGlzQW1QbSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCA9PT0gJ2FtcG0nO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICB2YWx1ZTogJ3NldElucHV0RGF0YSdcbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMuc2V0SW5wdXREYXRhKHRoaXMudmFsdWUpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBlbWl0VmFsdWU6IGZ1bmN0aW9uIGVtaXRWYWx1ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0SG91ciAhPSBudWxsICYmIHRoaXMuaW5wdXRNaW51dGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgT2JqZWN0KF9WRGF0ZVBpY2tlcl91dGlsX3BhZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSkodGhpcy5pbnB1dEhvdXIpICsgXCI6XCIgKyBPYmplY3QoX1ZEYXRlUGlja2VyX3V0aWxfcGFkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdKSh0aGlzLmlucHV0TWludXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldFBlcmlvZDogZnVuY3Rpb24gc2V0UGVyaW9kKHBlcmlvZCkge1xuICAgICAgICAgICAgdGhpcy5wZXJpb2QgPSBwZXJpb2Q7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dEhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdIb3VyID0gdGhpcy5pbnB1dEhvdXIgKyAocGVyaW9kID09PSAnYW0nID8gLTEyIDogMTIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRIb3VyID0gdGhpcy5maXJzdEFsbG93ZWQoJ2hvdXInLCBuZXdIb3VyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRJbnB1dERhdGE6IGZ1bmN0aW9uIHNldElucHV0RGF0YSh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEhvdXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRNaW51dGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0SG91ciA9IHZhbHVlLmdldEhvdXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dE1pbnV0ZSA9IHZhbHVlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX19yZWFkKHZhbHVlLnRyaW0oKS50b0xvd2VyQ2FzZSgpLm1hdGNoKC9eKFxcZCspOihcXGQrKSg6XFxkKyk/KFthcF1tKT8kLywgJycpIHx8IFtdLCA1KSxcbiAgICAgICAgICAgICAgICAgICAgaG91ciA9IF9hWzFdLFxuICAgICAgICAgICAgICAgICAgICBtaW51dGUgPSBfYVsyXSxcbiAgICAgICAgICAgICAgICAgICAgcGVyaW9kID0gX2FbNF07XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEhvdXIgPSBwZXJpb2QgPyB0aGlzLmNvbnZlcnQxMnRvMjQocGFyc2VJbnQoaG91ciwgMTApLCBwZXJpb2QpIDogcGFyc2VJbnQoaG91ciwgMTApO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRNaW51dGUgPSBwYXJzZUludChtaW51dGUsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGVyaW9kID0gdGhpcy5pbnB1dEhvdXIgPCAxMiA/ICdhbScgOiAncG0nO1xuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0MjR0bzEyOiBmdW5jdGlvbiBjb252ZXJ0MjR0bzEyKGhvdXIpIHtcbiAgICAgICAgICAgIHJldHVybiBob3VyID8gKGhvdXIgLSAxKSAlIDEyICsgMSA6IDEyO1xuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0MTJ0bzI0OiBmdW5jdGlvbiBjb252ZXJ0MTJ0bzI0KGhvdXIsIHBlcmlvZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvdXIgJSAxMiArIChwZXJpb2QgPT09ICdwbScgPyAxMiA6IDApO1xuICAgICAgICB9LFxuICAgICAgICBvbklucHV0OiBmdW5jdGlvbiBvbklucHV0KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RpbmdIb3VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEhvdXIgPSB0aGlzLmlzQW1QbSA/IHRoaXMuY29udmVydDEydG8yNCh2YWx1ZSwgdGhpcy5wZXJpb2QpIDogdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRNaW51dGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdFZhbHVlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RpbmdIb3VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW5nSG91ciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaXJzdEFsbG93ZWQ6IGZ1bmN0aW9uIGZpcnN0QWxsb3dlZCh0eXBlLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGFsbG93ZWRGbiA9IHR5cGUgPT09ICdob3VyJyA/IHRoaXMuaXNBbGxvd2VkSG91ckNiIDogdGhpcy5pc0FsbG93ZWRNaW51dGVDYjtcbiAgICAgICAgICAgIGlmICghYWxsb3dlZEZuKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAvLyBUT0RPOiBjbGVhbiB1cFxuICAgICAgICAgICAgdmFyIHJhbmdlID0gdHlwZSA9PT0gJ21pbnV0ZScgPyByYW5nZU1pbnV0ZXMgOiB0aGlzLmlzQW1QbSA/IHZhbHVlIDwgMTIgPyByYW5nZUhvdXJzMTJhbSA6IHJhbmdlSG91cnMxMnBtIDogcmFuZ2VIb3VyczI0O1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gcmFuZ2UuZmluZChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbGxvd2VkRm4oKHYgKyB2YWx1ZSkgJSByYW5nZS5sZW5ndGggKyByYW5nZVswXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKGZpcnN0IHx8IDApICsgdmFsdWUpICUgcmFuZ2UubGVuZ3RoICsgcmFuZ2VbMF07XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkNsb2NrOiBmdW5jdGlvbiBnZW5DbG9jaygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WVGltZVBpY2tlckNsb2NrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlczogdGhpcy5zZWxlY3RpbmdIb3VyID8gdGhpcy5pc0FsbG93ZWRIb3VyQ2IgOiB0aGlzLmlzQWxsb3dlZE1pbnV0ZUNiLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZGFyazogdGhpcy5kYXJrLFxuICAgICAgICAgICAgICAgICAgICBkb3VibGU6IHRoaXMuc2VsZWN0aW5nSG91ciAmJiAhdGhpcy5pc0FtUG0sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5zZWxlY3RpbmdIb3VyID8gdGhpcy5pc0FtUG0gPyB0aGlzLmNvbnZlcnQyNHRvMTIgOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdChfVkRhdGVQaWNrZXJfdXRpbF9wYWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0pKHZhbCwgMik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0OiB0aGlzLmxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBtYXg6IHRoaXMuc2VsZWN0aW5nSG91ciA/IHRoaXMuaXNBbVBtICYmIHRoaXMucGVyaW9kID09PSAnYW0nID8gMTEgOiAyMyA6IDU5LFxuICAgICAgICAgICAgICAgICAgICBtaW46IHRoaXMuc2VsZWN0aW5nSG91ciAmJiB0aGlzLmlzQW1QbSAmJiB0aGlzLnBlcmlvZCA9PT0gJ3BtJyA/IDEyIDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmVhZG9ubHk6IHRoaXMucmVhZG9ubHksXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGFibGU6IHRoaXMuc2Nyb2xsYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogdGhpcy53aWR0aCAtICghdGhpcy5mdWxsV2lkdGggJiYgdGhpcy5sYW5kc2NhcGUgPyA4MCA6IDIwKSxcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogdGhpcy5zZWxlY3RpbmdIb3VyID8gMSA6IDUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNlbGVjdGluZ0hvdXIgPyB0aGlzLmlucHV0SG91ciA6IHRoaXMuaW5wdXRNaW51dGVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLm9uSW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZTogdGhpcy5vbkNoYW5nZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVmOiAnY2xvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuUGlja2VyQm9keTogZnVuY3Rpb24gZ2VuUGlja2VyQm9keSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRpbWUtcGlja2VyLWNsb2NrX19jb250YWluZXInLFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5zZWxlY3RpbmdIb3VyXG4gICAgICAgICAgICB9LCBbdGhpcy5nZW5DbG9jaygpXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblBpY2tlclRpdGxlOiBmdW5jdGlvbiBnZW5QaWNrZXJUaXRsZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVlRpbWVQaWNrZXJUaXRsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFtcG06IHRoaXMuaXNBbVBtLFxuICAgICAgICAgICAgICAgICAgICBob3VyOiB0aGlzLmlucHV0SG91cixcbiAgICAgICAgICAgICAgICAgICAgbWludXRlOiB0aGlzLmlucHV0TWludXRlLFxuICAgICAgICAgICAgICAgICAgICBwZXJpb2Q6IHRoaXMucGVyaW9kLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seTogdGhpcy5yZWFkb25seSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW5nSG91cjogdGhpcy5zZWxlY3RpbmdIb3VyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAndXBkYXRlOnNlbGVjdGluZ0hvdXInOiBmdW5jdGlvbiB1cGRhdGVTZWxlY3RpbmdIb3VyKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VsZWN0aW5nSG91ciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAndXBkYXRlOnBlcmlvZCc6IHRoaXMuc2V0UGVyaW9kXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWY6ICd0aXRsZScsXG4gICAgICAgICAgICAgICAgc2xvdDogJ3RpdGxlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5QaWNrZXIoJ3YtcGlja2VyLS10aW1lJyk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRpbWVQaWNrZXIvVlRpbWVQaWNrZXJDbG9jay5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WVGltZVBpY2tlci9WVGltZVBpY2tlckNsb2NrLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c190aW1lX3BpY2tlcl9jbG9ja19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fdGltZS1waWNrZXItY2xvY2suc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL190aW1lLXBpY2tlci1jbG9jay5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c190aW1lX3BpY2tlcl9jbG9ja19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX3RpbWVfcGlja2VyX2Nsb2NrX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLy8gTWl4aW5zXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LXRpbWUtcGlja2VyLWNsb2NrJyxcbiAgICBtaXhpbnM6IFtfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFsbG93ZWRWYWx1ZXM6IEZ1bmN0aW9uLFxuICAgICAgICBkb3VibGU6IEJvb2xlYW4sXG4gICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgc2Nyb2xsYWJsZTogQm9vbGVhbixcbiAgICAgICAgcmVhZG9ubHk6IEJvb2xlYW4sXG4gICAgICAgIHJvdGF0ZToge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICB9LFxuICAgICAgICBzdGVwOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBOdW1iZXJcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZU9uTW91c2VEb3duOiBudWxsLFxuICAgICAgICAgICAgdmFsdWVPbk1vdXNlVXA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNvdW50OiBmdW5jdGlvbiBjb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heCAtIHRoaXMubWluICsgMTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVncmVlc1BlclVuaXQ6IGZ1bmN0aW9uIGRlZ3JlZXNQZXJVbml0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDM2MCAvIHRoaXMucm91bmRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVncmVlczogZnVuY3Rpb24gZGVncmVlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZ3JlZXNQZXJVbml0ICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheWVkVmFsdWU6IGZ1bmN0aW9uIGRpc3BsYXllZFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT0gbnVsbCA/IHRoaXMubWluIDogdGhpcy52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5uZXJSYWRpdXM6IGZ1bmN0aW9uIGlubmVyUmFkaXVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNjI7XG4gICAgICAgIH0sXG4gICAgICAgIHJvdW5kQ291bnQ6IGZ1bmN0aW9uIHJvdW5kQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb3VibGUgPyB0aGlzLmNvdW50IC8gMiA6IHRoaXMuY291bnQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICB3aGVlbDogZnVuY3Rpb24gd2hlZWwoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5zaWduKGUud2hlZWxEZWx0YSB8fCAxKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZGlzcGxheWVkVmFsdWU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArIGRlbHRhO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlIC0gdGhpcy5taW4gKyB0aGlzLmNvdW50KSAlIHRoaXMuY291bnQgKyB0aGlzLm1pbjtcbiAgICAgICAgICAgIH0gd2hpbGUgKCF0aGlzLmlzQWxsb3dlZCh2YWx1ZSkgJiYgdmFsdWUgIT09IHRoaXMuZGlzcGxheWVkVmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLmRpc3BsYXllZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc0lubmVyOiBmdW5jdGlvbiBpc0lubmVyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb3VibGUgJiYgdmFsdWUgLSB0aGlzLm1pbiA+PSB0aGlzLnJvdW5kQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRTY2FsZTogZnVuY3Rpb24gaGFuZFNjYWxlKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0lubmVyKHZhbHVlKSA/IHRoaXMuaW5uZXJSYWRpdXMgOiAxO1xuICAgICAgICB9LFxuICAgICAgICBpc0FsbG93ZWQ6IGZ1bmN0aW9uIGlzQWxsb3dlZCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmFsbG93ZWRWYWx1ZXMgfHwgdGhpcy5hbGxvd2VkVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuVmFsdWVzOiBmdW5jdGlvbiBnZW5WYWx1ZXMoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHZhbHVlID0gdGhpcy5taW47IHZhbHVlIDw9IHRoaXMubWF4OyB2YWx1ZSA9IHZhbHVlICsgdGhpcy5zdGVwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gdmFsdWUgPT09IHRoaXMudmFsdWUgJiYgKHRoaXMuY29sb3IgfHwgJ2FjY2VudCcpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy4kY3JlYXRlRWxlbWVudCgnc3BhbicsIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKGNvbG9yLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi10aW1lLXBpY2tlci1jbG9ja19faXRlbScsXG4gICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICd2LXRpbWUtcGlja2VyLWNsb2NrX19pdGVtLS1hY3RpdmUnOiB2YWx1ZSA9PT0gdGhpcy5kaXNwbGF5ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd2LXRpbWUtcGlja2VyLWNsb2NrX19pdGVtLS1kaXNhYmxlZCc6ICF0aGlzLmlzQWxsb3dlZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHRoaXMuZ2V0VHJhbnNmb3JtKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgZG9tUHJvcHM6IHsgaW5uZXJIVE1MOiBcIjxzcGFuPlwiICsgdGhpcy5mb3JtYXQodmFsdWUpICsgXCI8L3NwYW4+XCIgfVxuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkhhbmQ6IGZ1bmN0aW9uIGdlbkhhbmQoKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBcInNjYWxlWShcIiArIHRoaXMuaGFuZFNjYWxlKHRoaXMuZGlzcGxheWVkVmFsdWUpICsgXCIpXCI7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLnJvdGF0ZSArIHRoaXMuZGVncmVlc1BlclVuaXQgKiAodGhpcy5kaXNwbGF5ZWRWYWx1ZSAtIHRoaXMubWluKTtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IHRoaXMudmFsdWUgIT0gbnVsbCAmJiAodGhpcy5jb2xvciB8fCAnYWNjZW50Jyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2JywgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IoY29sb3IsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtdGltZS1waWNrZXItY2xvY2tfX2hhbmQnLFxuICAgICAgICAgICAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3YtdGltZS1waWNrZXItY2xvY2tfX2hhbmQtLWlubmVyJzogdGhpcy5pc0lubmVyKHRoaXMudmFsdWUpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwicm90YXRlKFwiICsgYW5nbGUgKyBcImRlZykgXCIgKyBzY2FsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VHJhbnNmb3JtOiBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0oaSkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRQb3NpdGlvbihpKSxcbiAgICAgICAgICAgICAgICB4ID0gX2EueCxcbiAgICAgICAgICAgICAgICB5ID0gX2EueTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdDogNTAgKyB4ICogNTAgKyBcIiVcIixcbiAgICAgICAgICAgICAgICB0b3A6IDUwICsgeSAqIDUwICsgXCIlXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbiBnZXRQb3NpdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJvdGF0ZVJhZGlhbnMgPSB0aGlzLnJvdGF0ZSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IE1hdGguc2luKCh2YWx1ZSAtIHRoaXMubWluKSAqIHRoaXMuZGVncmVlcyArIHJvdGF0ZVJhZGlhbnMpICogdGhpcy5oYW5kU2NhbGUodmFsdWUpLFxuICAgICAgICAgICAgICAgIHk6IC1NYXRoLmNvcygodmFsdWUgLSB0aGlzLm1pbikgKiB0aGlzLmRlZ3JlZXMgKyByb3RhdGVSYWRpYW5zKSAqIHRoaXMuaGFuZFNjYWxlKHZhbHVlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZURvd246IGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVPbk1vdXNlRG93biA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlT25Nb3VzZVVwID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm9uRHJhZ01vdmUoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VVcDogZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZU9uTW91c2VVcCAhPT0gbnVsbCAmJiB0aGlzLmlzQWxsb3dlZCh0aGlzLnZhbHVlT25Nb3VzZVVwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRoaXMudmFsdWVPbk1vdXNlVXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkRyYWdNb3ZlOiBmdW5jdGlvbiBvbkRyYWdNb3ZlKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nICYmIGUudHlwZSAhPT0gJ2NsaWNrJykgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy4kcmVmcy5jbG9jay5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgICAgICAgICAgIHRvcCA9IF9hLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0ID0gX2EubGVmdDtcbiAgICAgICAgICAgIHZhciBfYiA9ICd0b3VjaGVzJyBpbiBlID8gZS50b3VjaGVzWzBdIDogZSxcbiAgICAgICAgICAgICAgICBjbGllbnRYID0gX2IuY2xpZW50WCxcbiAgICAgICAgICAgICAgICBjbGllbnRZID0gX2IuY2xpZW50WTtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSB7IHg6IHdpZHRoIC8gMiwgeTogLXdpZHRoIC8gMiB9O1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHsgeDogY2xpZW50WCAtIGxlZnQsIHk6IHRvcCAtIGNsaWVudFkgfTtcbiAgICAgICAgICAgIHZhciBoYW5kQW5nbGUgPSBNYXRoLnJvdW5kKHRoaXMuYW5nbGUoY2VudGVyLCBjb29yZHMpIC0gdGhpcy5yb3RhdGUgKyAzNjApICUgMzYwO1xuICAgICAgICAgICAgLy8gKDEgKyB0aGlzLmlubmVyUmFkaXVzKSAvIDQgPSByYWRpdXMgb2YgdGhlIGNpcmNsZSBlcXVhbGx5IGRpc3RhbnQgZnJvbSBpbm5lciBhbmQgb3V0ZXIgY2lyY2xlc1xuICAgICAgICAgICAgdmFyIGluc2lkZUNsaWNrID0gdGhpcy5kb3VibGUgJiYgdGhpcy5ldWNsaWRlYW4oY2VudGVyLCBjb29yZHMpIC8gd2lkdGggPCAoMSArIHRoaXMuaW5uZXJSYWRpdXMpIC8gNDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IE1hdGgucm91bmQoaGFuZEFuZ2xlIC8gdGhpcy5kZWdyZWVzUGVyVW5pdCkgKyB0aGlzLm1pbiArIChpbnNpZGVDbGljayA/IHRoaXMucm91bmRDb3VudCA6IDApO1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IHRvIGZpeCBlZGdlIGNhc2Ugd2hlbiBzZWxlY3RpbmcgbGVmdCBwYXJ0IG9mIHRoZSB2YWx1ZShzKSBhdCAxMiBvJ2Nsb2NrXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgICAgICBpZiAoaGFuZEFuZ2xlID49IDM2MCAtIHRoaXMuZGVncmVlc1BlclVuaXQgLyAyKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBpbnNpZGVDbGljayA/IHRoaXMubWF4IC0gdGhpcy5yb3VuZENvdW50ICsgMSA6IHRoaXMubWluO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBbGxvd2VkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlT25Nb3VzZURvd24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZU9uTW91c2VEb3duID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVPbk1vdXNlVXAgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBldWNsaWRlYW46IGZ1bmN0aW9uIGV1Y2xpZGVhbihwMCwgcDEpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHAxLnggLSBwMC54O1xuICAgICAgICAgICAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfSxcbiAgICAgICAgYW5nbGU6IGZ1bmN0aW9uIGFuZ2xlKGNlbnRlciwgcDEpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IDIgKiBNYXRoLmF0YW4yKHAxLnkgLSBjZW50ZXIueSAtIHRoaXMuZXVjbGlkZWFuKGNlbnRlciwgcDEpLCBwMS54IC0gY2VudGVyLngpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZhbHVlICogMTgwIC8gTWF0aC5QSSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtdGltZS1waWNrZXItY2xvY2snLFxuICAgICAgICAgICAgY2xhc3M6IF9fYXNzaWduKHsgJ3YtdGltZS1waWNrZXItY2xvY2stLWluZGV0ZXJtaW5hdGUnOiB0aGlzLnZhbHVlID09IG51bGwgfSwgdGhpcy50aGVtZUNsYXNzZXMpLFxuICAgICAgICAgICAgb246IHRoaXMucmVhZG9ubHkgPyB1bmRlZmluZWQgOiB7XG4gICAgICAgICAgICAgICAgbW91c2Vkb3duOiB0aGlzLm9uTW91c2VEb3duLFxuICAgICAgICAgICAgICAgIG1vdXNldXA6IHRoaXMub25Nb3VzZVVwLFxuICAgICAgICAgICAgICAgIG1vdXNlbGVhdmU6IGZ1bmN0aW9uIG1vdXNlbGVhdmUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc0RyYWdnaW5nICYmIF90aGlzLm9uTW91c2VVcCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG91Y2hzdGFydDogdGhpcy5vbk1vdXNlRG93bixcbiAgICAgICAgICAgICAgICB0b3VjaGVuZDogdGhpcy5vbk1vdXNlVXAsXG4gICAgICAgICAgICAgICAgbW91c2Vtb3ZlOiB0aGlzLm9uRHJhZ01vdmUsXG4gICAgICAgICAgICAgICAgdG91Y2htb3ZlOiB0aGlzLm9uRHJhZ01vdmVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWY6ICdjbG9jaydcbiAgICAgICAgfTtcbiAgICAgICAgIXRoaXMucmVhZG9ubHkgJiYgdGhpcy5zY3JvbGxhYmxlICYmIChkYXRhLm9uLndoZWVsID0gdGhpcy53aGVlbCk7XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCBkYXRhLCBbaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRpbWUtcGlja2VyLWNsb2NrX19pbm5lcidcbiAgICAgICAgfSwgW3RoaXMuZ2VuSGFuZCgpLCB0aGlzLmdlblZhbHVlcygpXSldKTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVGltZVBpY2tlci9WVGltZVBpY2tlclRpdGxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUaW1lUGlja2VyL1ZUaW1lUGlja2VyVGl0bGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3RpbWVfcGlja2VyX3RpdGxlX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL190aW1lLXBpY2tlci10aXRsZS5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3RpbWUtcGlja2VyLXRpdGxlLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3RpbWVfcGlja2VyX3RpdGxlX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfdGltZV9waWNrZXJfdGl0bGVfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3BpY2tlcl9idXR0b25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9waWNrZXItYnV0dG9uICovIFwiLi9zcmMvbWl4aW5zL3BpY2tlci1idXR0b24uanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZEYXRlUGlja2VyX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL1ZEYXRlUGlja2VyL3V0aWwgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL3V0aWwvaW5kZXguanNcIik7XG5cbi8vIE1peGluc1xuXG4vLyBVdGlsc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3YtdGltZS1waWNrZXItdGl0bGUnLFxuICAgIG1peGluczogW19taXhpbnNfcGlja2VyX2J1dHRvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYW1wbTogQm9vbGVhbixcbiAgICAgICAgaG91cjogTnVtYmVyLFxuICAgICAgICBtaW51dGU6IE51bWJlcixcbiAgICAgICAgcGVyaW9kOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcihwZXJpb2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGVyaW9kID09PSAnYW0nIHx8IHBlcmlvZCA9PT0gJ3BtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhZG9ubHk6IEJvb2xlYW4sXG4gICAgICAgIHNlbGVjdGluZ0hvdXI6IEJvb2xlYW5cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuVGltZTogZnVuY3Rpb24gZ2VuVGltZSgpIHtcbiAgICAgICAgICAgIHZhciBob3VyID0gdGhpcy5ob3VyO1xuICAgICAgICAgICAgaWYgKHRoaXMuYW1wbSkge1xuICAgICAgICAgICAgICAgIGhvdXIgPSBob3VyID8gKGhvdXIgLSAxKSAlIDEyICsgMSA6IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRpc3BsYXllZEhvdXIgPSB0aGlzLmhvdXIgPT0gbnVsbCA/ICctLScgOiB0aGlzLmFtcG0gPyBob3VyIDogT2JqZWN0KF9WRGF0ZVBpY2tlcl91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJwYWRcIl0pKGhvdXIpO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXllZE1pbnV0ZSA9IHRoaXMubWludXRlID09IG51bGwgPyAnLS0nIDogT2JqZWN0KF9WRGF0ZVBpY2tlcl91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJwYWRcIl0pKHRoaXMubWludXRlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogJ3YtdGltZS1waWNrZXItdGl0bGVfX3RpbWUnXG4gICAgICAgICAgICB9LCBbdGhpcy5nZW5QaWNrZXJCdXR0b24oJ3NlbGVjdGluZ0hvdXInLCB0cnVlLCBkaXNwbGF5ZWRIb3VyKSwgdGhpcy4kY3JlYXRlRWxlbWVudCgnc3BhbicsICc6JyksIHRoaXMuZ2VuUGlja2VyQnV0dG9uKCdzZWxlY3RpbmdIb3VyJywgZmFsc2UsIGRpc3BsYXllZE1pbnV0ZSldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuQW1QbTogZnVuY3Rpb24gZ2VuQW1QbSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRpbWUtcGlja2VyLXRpdGxlX19hbXBtJ1xuICAgICAgICAgICAgfSwgW3RoaXMuZ2VuUGlja2VyQnV0dG9uKCdwZXJpb2QnLCAnYW0nLCAnYW0nLCB0aGlzLnJlYWRvbmx5KSwgdGhpcy5nZW5QaWNrZXJCdXR0b24oJ3BlcmlvZCcsICdwbScsICdwbScsIHRoaXMucmVhZG9ubHkpXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi10aW1lLXBpY2tlci10aXRsZSdcbiAgICAgICAgfSwgW3RoaXMuZ2VuVGltZSgpLCB0aGlzLmFtcG0gPyB0aGlzLmdlbkFtUG0oKSA6IG51bGxdKTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVGltZVBpY2tlci9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlRpbWVQaWNrZXIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWVGltZVBpY2tlciwgVlRpbWVQaWNrZXJDbG9jaywgVlRpbWVQaWNrZXJUaXRsZSwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRpbWVQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRpbWVQaWNrZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUaW1lUGlja2VyL1ZUaW1lUGlja2VyLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRpbWVQaWNrZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRpbWVQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUaW1lUGlja2VyQ2xvY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRpbWVQaWNrZXJDbG9jayAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRpbWVQaWNrZXIvVlRpbWVQaWNrZXJDbG9jay5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUaW1lUGlja2VyQ2xvY2tcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRpbWVQaWNrZXJDbG9ja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRpbWVQaWNrZXJUaXRsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WVGltZVBpY2tlclRpdGxlICovIFwiLi9zcmMvY29tcG9uZW50cy9WVGltZVBpY2tlci9WVGltZVBpY2tlclRpdGxlLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRpbWVQaWNrZXJUaXRsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WVGltZVBpY2tlclRpdGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICAkX3Z1ZXRpZnlfc3ViY29tcG9uZW50czoge1xuICAgICAgICBWVGltZVBpY2tlcjogX1ZUaW1lUGlja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLFxuICAgICAgICBWVGltZVBpY2tlckNsb2NrOiBfVlRpbWVQaWNrZXJDbG9ja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgVlRpbWVQaWNrZXJUaXRsZTogX1ZUaW1lUGlja2VyVGl0bGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVGltZWxpbmUvVlRpbWVsaW5lLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUaW1lbGluZS9WVGltZWxpbmUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3RpbWVsaW5lX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL190aW1lbGluZS5zdHlsICovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3RpbWVsaW5lLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3RpbWVsaW5lX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfdGltZWxpbmVfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuLy8gU3R5bGVzXG5cblxuLy8gTWl4aW5zXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoT2JqZWN0KF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSkoX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl1cbi8qIEB2dWUvY29tcG9uZW50ICovXG4pLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtdGltZWxpbmUnLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFsaWduVG9wOiBCb29sZWFuLFxuICAgICAgICBkZW5zZTogQm9vbGVhblxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbih7ICd2LXRpbWVsaW5lLS1hbGlnbi10b3AnOiB0aGlzLmFsaWduVG9wLCAndi10aW1lbGluZS0tZGVuc2UnOiB0aGlzLmRlbnNlIH0sIHRoaXMudGhlbWVDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRpbWVsaW5lJyxcbiAgICAgICAgICAgICdjbGFzcyc6IHRoaXMuY2xhc3Nlc1xuICAgICAgICB9LCB0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRpbWVsaW5lL1ZUaW1lbGluZUl0ZW0udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUaW1lbGluZS9WVGltZWxpbmVJdGVtLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WSWNvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkljb24vaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbi8vIFR5cGVzXG5cbi8vIENvbXBvbmVudHNcblxuLy8gTWl4aW5zXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKShfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZGVmYXVsdFwiXSwgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl1cbi8qIEB2dWUvY29tcG9uZW50ICovXG4pLmV4dGVuZCh7XG4gICAgbmFtZTogJ3YtdGltZWxpbmUtaXRlbScsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdwcmltYXJ5J1xuICAgICAgICB9LFxuICAgICAgICBmaWxsRG90OiBCb29sZWFuLFxuICAgICAgICBoaWRlRG90OiBCb29sZWFuLFxuICAgICAgICBpY29uOiBTdHJpbmcsXG4gICAgICAgIGljb25Db2xvcjogU3RyaW5nLFxuICAgICAgICBsYXJnZTogQm9vbGVhbixcbiAgICAgICAgbGVmdDogQm9vbGVhbixcbiAgICAgICAgcmlnaHQ6IEJvb2xlYW4sXG4gICAgICAgIHNtYWxsOiBCb29sZWFuXG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBoYXNJY29uOiBmdW5jdGlvbiBoYXNJY29uKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5pY29uIHx8ICEhdGhpcy4kc2xvdHMuaWNvbjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZW5Cb2R5OiBmdW5jdGlvbiBnZW5Cb2R5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtdGltZWxpbmUtaXRlbV9fYm9keSdcbiAgICAgICAgICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5JY29uOiBmdW5jdGlvbiBnZW5JY29uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJHNsb3RzLmljb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kc2xvdHMuaWNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLmljb25Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgZGFyazogIXRoaXMudGhlbWUuaXNEYXJrLFxuICAgICAgICAgICAgICAgICAgICBzbWFsbDogdGhpcy5zbWFsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMuaWNvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbklubmVyRG90OiBmdW5jdGlvbiBnZW5Jbm5lckRvdCgpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5oYXNJY29uICYmIGNoaWxkcmVuLnB1c2godGhpcy5nZW5JY29uKCkpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnNldEJhY2tncm91bmRDb2xvcih0aGlzLmNvbG9yKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCBfX2Fzc2lnbih7IHN0YXRpY0NsYXNzOiAndi10aW1lbGluZS1pdGVtX19pbm5lci1kb3QnIH0sIGRhdGEpLCBjaGlsZHJlbik7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkRvdDogZnVuY3Rpb24gZ2VuRG90KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtdGltZWxpbmUtaXRlbV9fZG90JyxcbiAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAndi10aW1lbGluZS1pdGVtX19kb3QtLXNtYWxsJzogdGhpcy5zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgJ3YtdGltZWxpbmUtaXRlbV9fZG90LS1sYXJnZSc6IHRoaXMubGFyZ2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbdGhpcy5nZW5Jbm5lckRvdCgpXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbk9wcG9zaXRlOiBmdW5jdGlvbiBnZW5PcHBvc2l0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRpbWVsaW5lLWl0ZW1fX29wcG9zaXRlJ1xuICAgICAgICAgICAgfSwgW3RoaXMuJHNsb3RzLm9wcG9zaXRlXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW3RoaXMuZ2VuQm9keSgpXTtcbiAgICAgICAgaWYgKCF0aGlzLmhpZGVEb3QpIGNoaWxkcmVuLnVuc2hpZnQodGhpcy5nZW5Eb3QoKSk7XG4gICAgICAgIGlmICh0aGlzLiRzbG90cy5vcHBvc2l0ZSkgY2hpbGRyZW4ucHVzaCh0aGlzLmdlbk9wcG9zaXRlKCkpO1xuICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRpbWVsaW5lLWl0ZW0nLFxuICAgICAgICAgICAgY2xhc3M6IF9fYXNzaWduKHsgJ3YtdGltZWxpbmUtaXRlbS0tZmlsbC1kb3QnOiB0aGlzLmZpbGxEb3QsICd2LXRpbWVsaW5lLWl0ZW0tLWxlZnQnOiB0aGlzLmxlZnQsICd2LXRpbWVsaW5lLWl0ZW0tLXJpZ2h0JzogdGhpcy5yaWdodCB9LCB0aGlzLnRoZW1lQ2xhc3NlcylcbiAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVGltZWxpbmUvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WVGltZWxpbmUvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlRpbWVsaW5lLCBWVGltZWxpbmVJdGVtLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WVGltZWxpbmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRpbWVsaW5lICovIFwiLi9zcmMvY29tcG9uZW50cy9WVGltZWxpbmUvVlRpbWVsaW5lLnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRpbWVsaW5lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZUaW1lbGluZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRpbWVsaW5lSXRlbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WVGltZWxpbmVJdGVtICovIFwiLi9zcmMvY29tcG9uZW50cy9WVGltZWxpbmUvVlRpbWVsaW5lSXRlbS50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUaW1lbGluZUl0ZW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRpbWVsaW5lSXRlbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgICRfdnVldGlmeV9zdWJjb21wb25lbnRzOiB7XG4gICAgICAgIFZUaW1lbGluZTogX1ZUaW1lbGluZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgVlRpbWVsaW5lSXRlbTogX1ZUaW1lbGluZUl0ZW1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVG9vbGJhci9WVG9vbGJhci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlRvb2xiYXIvVlRvb2xiYXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c190b29sYmFyX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3N0eWx1cy9jb21wb25lbnRzL190b29sYmFyLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdG9vbGJhci5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c190b29sYmFyX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfdG9vbGJhcl9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfYXBwbGljYXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvYXBwbGljYXRpb25hYmxlICovIFwiLi9zcmMvbWl4aW5zL2FwcGxpY2F0aW9uYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2NvbG9yYWJsZSAqLyBcIi4vc3JjL21peGlucy9jb2xvcmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfc3NyX2Jvb3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvc3NyLWJvb3RhYmxlICovIFwiLi9zcmMvbWl4aW5zL3Nzci1ib290YWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlyZWN0aXZlc19zY3JvbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RpcmVjdGl2ZXMvc2Nyb2xsICovIFwiLi9zcmMvZGlyZWN0aXZlcy9zY3JvbGwudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9jb25zb2xlICovIFwiLi9zcmMvdXRpbC9jb25zb2xlLnRzXCIpO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuLy8gU3R5bGVzXG5cbi8vIE1peGluc1xuXG5cblxuXG4vLyBEaXJlY3RpdmVzXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LXRvb2xiYXInLFxuICAgIGRpcmVjdGl2ZXM6IHsgU2Nyb2xsOiBfZGlyZWN0aXZlc19zY3JvbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0gfSxcbiAgICBtaXhpbnM6IFtPYmplY3QoX21peGluc19hcHBsaWNhdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pKCd0b3AnLCBbJ2NsaXBwZWRMZWZ0JywgJ2NsaXBwZWRSaWdodCcsICdjb21wdXRlZEhlaWdodCcsICdpbnZlcnRlZFNjcm9sbCcsICdtYW51YWxTY3JvbGwnXSksIF9taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX3Nzcl9ib290YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSwgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGNhcmQ6IEJvb2xlYW4sXG4gICAgICAgIGNsaXBwZWRMZWZ0OiBCb29sZWFuLFxuICAgICAgICBjbGlwcGVkUmlnaHQ6IEJvb2xlYW4sXG4gICAgICAgIGRlbnNlOiBCb29sZWFuLFxuICAgICAgICBleHRlbmRlZDogQm9vbGVhbixcbiAgICAgICAgZXh0ZW5zaW9uSGVpZ2h0OiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3Iodikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VJbnQodikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmbGF0OiBCb29sZWFuLFxuICAgICAgICBmbG9hdGluZzogQm9vbGVhbixcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3Iodikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VJbnQodikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnZlcnRlZFNjcm9sbDogQm9vbGVhbixcbiAgICAgICAgbWFudWFsU2Nyb2xsOiBCb29sZWFuLFxuICAgICAgICBwcm9taW5lbnQ6IEJvb2xlYW4sXG4gICAgICAgIHNjcm9sbE9mZlNjcmVlbjogQm9vbGVhbixcbiAgICAgICAgLyogQGRlcHJlY2F0ZWQgKi9cbiAgICAgICAgc2Nyb2xsVG9vbGJhck9mZlNjcmVlbjogQm9vbGVhbixcbiAgICAgICAgc2Nyb2xsVGFyZ2V0OiBTdHJpbmcsXG4gICAgICAgIHNjcm9sbFRocmVzaG9sZDoge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogMzAwXG4gICAgICAgIH0sXG4gICAgICAgIHRhYnM6IEJvb2xlYW5cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhY3RpdmVUaW1lb3V0OiBudWxsLFxuICAgICAgICAgICAgY3VycmVudFNjcm9sbDogMCxcbiAgICAgICAgICAgIGhlaWdodHM6IHtcbiAgICAgICAgICAgICAgICBtb2JpbGVMYW5kc2NhcGU6IDQ4LFxuICAgICAgICAgICAgICAgIG1vYmlsZTogNTYsXG4gICAgICAgICAgICAgICAgZGVza3RvcDogNjQsXG4gICAgICAgICAgICAgICAgZGVuc2U6IDQ4XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNBY3RpdmU6IHRydWUsXG4gICAgICAgICAgICBpc0V4dGVuZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzU2Nyb2xsaW5nVXA6IGZhbHNlLFxuICAgICAgICAgICAgcHJldmlvdXNTY3JvbGw6IG51bGwsXG4gICAgICAgICAgICBwcmV2aW91c1Njcm9sbERpcmVjdGlvbjogbnVsbCxcbiAgICAgICAgICAgIHNhdmVkU2Nyb2xsOiAwLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjYW5TY3JvbGw6IGZ1bmN0aW9uIGNhblNjcm9sbCgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZVxuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9vbGJhck9mZlNjcmVlbikge1xuICAgICAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZXByZWNhdGVcIl0pKCdzY3JvbGxUb29sYmFyT2ZmU2NyZWVuJywgJ3Njcm9sbE9mZlNjcmVlbicsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsT2ZmU2NyZWVuIHx8IHRoaXMuaW52ZXJ0ZWRTY3JvbGw7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkQ29udGVudEhlaWdodDogZnVuY3Rpb24gY29tcHV0ZWRDb250ZW50SGVpZ2h0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0KSByZXR1cm4gcGFyc2VJbnQodGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVuc2UpIHJldHVybiB0aGlzLmhlaWdodHMuZGVuc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9taW5lbnQgfHwgdGhpcy4kdnVldGlmeS5icmVha3BvaW50Lm1kQW5kVXApIHJldHVybiB0aGlzLmhlaWdodHMuZGVza3RvcDtcbiAgICAgICAgICAgIGlmICh0aGlzLiR2dWV0aWZ5LmJyZWFrcG9pbnQuc21BbmREb3duICYmIHRoaXMuJHZ1ZXRpZnkuYnJlYWtwb2ludC53aWR0aCA+IHRoaXMuJHZ1ZXRpZnkuYnJlYWtwb2ludC5oZWlnaHQpIHJldHVybiB0aGlzLmhlaWdodHMubW9iaWxlTGFuZHNjYXBlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0cy5tb2JpbGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkRXh0ZW5zaW9uSGVpZ2h0OiBmdW5jdGlvbiBjb21wdXRlZEV4dGVuc2lvbkhlaWdodCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhYnMpIHJldHVybiA0ODtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4dGVuc2lvbkhlaWdodCkgcmV0dXJuIHBhcnNlSW50KHRoaXMuZXh0ZW5zaW9uSGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkQ29udGVudEhlaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWRIZWlnaHQ6IGZ1bmN0aW9uIGNvbXB1dGVkSGVpZ2h0KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRXh0ZW5kZWQpIHJldHVybiB0aGlzLmNvbXB1dGVkQ29udGVudEhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkQ29udGVudEhlaWdodCArIHRoaXMuY29tcHV0ZWRFeHRlbnNpb25IZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkTWFyZ2luVG9wOiBmdW5jdGlvbiBjb21wdXRlZE1hcmdpblRvcCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hcHApIHJldHVybiAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHZ1ZXRpZnkuYXBwbGljYXRpb24uYmFyO1xuICAgICAgICB9LFxuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHsgJ3YtdG9vbGJhcic6IHRydWUsICdlbGV2YXRpb24tMCc6IHRoaXMuZmxhdCB8fCAhdGhpcy5pc0FjdGl2ZSAmJiAhdGhpcy50YWJzICYmIHRoaXMuY2FuU2Nyb2xsLCAndi10b29sYmFyLS1hYnNvbHV0ZSc6IHRoaXMuYWJzb2x1dGUsICd2LXRvb2xiYXItLWNhcmQnOiB0aGlzLmNhcmQsICd2LXRvb2xiYXItLWNsaXBwZWQnOiB0aGlzLmNsaXBwZWRMZWZ0IHx8IHRoaXMuY2xpcHBlZFJpZ2h0LCAndi10b29sYmFyLS1kZW5zZSc6IHRoaXMuZGVuc2UsICd2LXRvb2xiYXItLWV4dGVuZGVkJzogdGhpcy5pc0V4dGVuZGVkLCAndi10b29sYmFyLS1maXhlZCc6ICF0aGlzLmFic29sdXRlICYmICh0aGlzLmFwcCB8fCB0aGlzLmZpeGVkKSwgJ3YtdG9vbGJhci0tZmxvYXRpbmcnOiB0aGlzLmZsb2F0aW5nLCAndi10b29sYmFyLS1wcm9taW5lbnQnOiB0aGlzLnByb21pbmVudCB9LCB0aGlzLnRoZW1lQ2xhc3Nlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkUGFkZGluZ0xlZnQ6IGZ1bmN0aW9uIGNvbXB1dGVkUGFkZGluZ0xlZnQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXBwIHx8IHRoaXMuY2xpcHBlZExlZnQpIHJldHVybiAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHZ1ZXRpZnkuYXBwbGljYXRpb24ubGVmdDtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWRQYWRkaW5nUmlnaHQ6IGZ1bmN0aW9uIGNvbXB1dGVkUGFkZGluZ1JpZ2h0KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFwcCB8fCB0aGlzLmNsaXBwZWRSaWdodCkgcmV0dXJuIDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kdnVldGlmeS5hcHBsaWNhdGlvbi5yaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWRUcmFuc2Zvcm06IGZ1bmN0aW9uIGNvbXB1dGVkVHJhbnNmb3JtKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzQWN0aXZlID8gdGhpcy5jYW5TY3JvbGwgPyAtdGhpcy5jb21wdXRlZENvbnRlbnRIZWlnaHQgOiAtdGhpcy5jb21wdXRlZEhlaWdodCA6IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbnRUaHJlc2hvbGQ6IGZ1bmN0aW9uIGN1cnJlbnRUaHJlc2hvbGQoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5jdXJyZW50U2Nyb2xsIC0gdGhpcy5zYXZlZFNjcm9sbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlczogZnVuY3Rpb24gc3R5bGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IHRoaXMuY29tcHV0ZWRNYXJnaW5Ub3AgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiB0aGlzLmNvbXB1dGVkUGFkZGluZ1JpZ2h0ICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiB0aGlzLmNvbXB1dGVkUGFkZGluZ0xlZnQgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoXCIgKyB0aGlzLmNvbXB1dGVkVHJhbnNmb3JtICsgXCJweClcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgY3VycmVudFRocmVzaG9sZDogZnVuY3Rpb24gY3VycmVudFRocmVzaG9sZCh2YWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmludmVydGVkU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNBY3RpdmUgPSB0aGlzLmN1cnJlbnRTY3JvbGwgPiB0aGlzLnNjcm9sbFRocmVzaG9sZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwgPCB0aGlzLnNjcm9sbFRocmVzaG9sZCB8fCAhdGhpcy5pc0Jvb3RlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRoaXMuaXNTY3JvbGxpbmdVcDtcbiAgICAgICAgICAgIHRoaXMuc2F2ZWRTY3JvbGwgPSB0aGlzLmN1cnJlbnRTY3JvbGw7XG4gICAgICAgIH0sXG4gICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZWRTY3JvbGwgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBpbnZlcnRlZFNjcm9sbDogZnVuY3Rpb24gaW52ZXJ0ZWRTY3JvbGwodmFsKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gIXZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgbWFudWFsU2Nyb2xsOiBmdW5jdGlvbiBtYW51YWxTY3JvbGwodmFsKSB7XG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gIXZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgaXNTY3JvbGxpbmdVcDogZnVuY3Rpb24gaXNTY3JvbGxpbmdVcCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZWRTY3JvbGwgPSB0aGlzLnNhdmVkU2Nyb2xsIHx8IHRoaXMuY3VycmVudFNjcm9sbDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW52ZXJ0ZWRTY3JvbGwgfHwgdGhpcy5tYW51YWxTY3JvbGwpIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBvblNjcm9sbDogZnVuY3Rpb24gb25TY3JvbGwoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FuU2Nyb2xsIHx8IHRoaXMubWFudWFsU2Nyb2xsIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQgfHwgd2luZG93O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2Nyb2xsID0gdGhpcy5zY3JvbGxUYXJnZXQgPyB0YXJnZXQuc2Nyb2xsVG9wIDogdGFyZ2V0LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nVXAgPSB0aGlzLmN1cnJlbnRTY3JvbGwgPCB0aGlzLnByZXZpb3VzU2Nyb2xsO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1Njcm9sbCA9IHRoaXMuY3VycmVudFNjcm9sbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgYXBwbGljYXRpb24gbGF5b3V0XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUFwcGxpY2F0aW9uOiBmdW5jdGlvbiB1cGRhdGVBcHBsaWNhdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludmVydGVkU2Nyb2xsIHx8IHRoaXMubWFudWFsU2Nyb2xsID8gMCA6IHRoaXMuY29tcHV0ZWRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICAgICAgdGhpcy5pc0V4dGVuZGVkID0gdGhpcy5leHRlbmRlZCB8fCAhIXRoaXMuJHNsb3RzLmV4dGVuc2lvbjtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5jb2xvciwge1xuICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy5jbGFzc2VzLFxuICAgICAgICAgICAgc3R5bGU6IHRoaXMuc3R5bGVzLFxuICAgICAgICAgICAgb246IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgICB9KTtcbiAgICAgICAgZGF0YS5kaXJlY3RpdmVzID0gW3tcbiAgICAgICAgICAgIGFyZzogdGhpcy5zY3JvbGxUYXJnZXQsXG4gICAgICAgICAgICBuYW1lOiAnc2Nyb2xsJyxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLm9uU2Nyb2xsXG4gICAgICAgIH1dO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGgoJ2RpdicsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi10b29sYmFyX19jb250ZW50JyxcbiAgICAgICAgICAgIHN0eWxlOiB7IGhlaWdodDogdGhpcy5jb21wdXRlZENvbnRlbnRIZWlnaHQgKyBcInB4XCIgfSxcbiAgICAgICAgICAgIHJlZjogJ2NvbnRlbnQnXG4gICAgICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQpKTtcbiAgICAgICAgaWYgKHRoaXMuaXNFeHRlbmRlZCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChoKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRvb2xiYXJfX2V4dGVuc2lvbicsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHsgaGVpZ2h0OiB0aGlzLmNvbXB1dGVkRXh0ZW5zaW9uSGVpZ2h0ICsgXCJweFwiIH1cbiAgICAgICAgICAgIH0sIHRoaXMuJHNsb3RzLmV4dGVuc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoKCduYXYnLCBkYXRhLCBjaGlsZHJlbik7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRvb2xiYXIvVlRvb2xiYXJTaWRlSWNvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WVG9vbGJhci9WVG9vbGJhclNpZGVJY29uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21wb25lbnRzX1ZCdG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2NvbXBvbmVudHMvVkJ0biAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkJ0bi9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tcG9uZW50c19WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vY29tcG9uZW50cy9WSWNvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkljb24vaW5kZXgudHNcIik7XG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LXRvb2xiYXItc2lkZS1pY29uJyxcbiAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIF9hKSB7XG4gICAgICAgIHZhciBzbG90cyA9IF9hLnNsb3RzLFxuICAgICAgICAgICAgbGlzdGVuZXJzID0gX2EubGlzdGVuZXJzLFxuICAgICAgICAgICAgcHJvcHMgPSBfYS5wcm9wcyxcbiAgICAgICAgICAgIGRhdGEgPSBfYS5kYXRhO1xuICAgICAgICB2YXIgY2xhc3NlcyA9IGRhdGEuc3RhdGljQ2xhc3MgPyBkYXRhLnN0YXRpY0NsYXNzICsgXCIgdi10b29sYmFyX19zaWRlLWljb25cIiA6ICd2LXRvb2xiYXJfX3NpZGUtaWNvbic7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogY2xhc3NlcyxcbiAgICAgICAgICAgIHByb3BzOiBPYmplY3QuYXNzaWduKHByb3BzLCB7XG4gICAgICAgICAgICAgICAgaWNvbjogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbjogbGlzdGVuZXJzXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGVmYXVsdFNsb3QgPSBzbG90cygpLmRlZmF1bHQ7XG4gICAgICAgIHJldHVybiBoKF9jb21wb25lbnRzX1ZCdG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0sIGQsIGRlZmF1bHRTbG90IHx8IFtoKF9jb21wb25lbnRzX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCAnJHZ1ZXRpZnkuaWNvbnMubWVudScpXSk7XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRvb2xiYXIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUb29sYmFyL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlRvb2xiYXIsIFZUb29sYmFyU2lkZUljb24sIFZUb29sYmFyVGl0bGUsIFZUb29sYmFySXRlbXMsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRvb2xiYXJUaXRsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZUb29sYmFyVGl0bGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUb29sYmFySXRlbXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWVG9vbGJhckl0ZW1zOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUb29sYmFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZUb29sYmFyICovIFwiLi9zcmMvY29tcG9uZW50cy9WVG9vbGJhci9WVG9vbGJhci5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUb29sYmFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZUb29sYmFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WVG9vbGJhclNpZGVJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZUb29sYmFyU2lkZUljb24gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUb29sYmFyL1ZUb29sYmFyU2lkZUljb24uanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWVG9vbGJhclNpZGVJY29uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZUb29sYmFyU2lkZUljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG52YXIgVlRvb2xiYXJUaXRsZSA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVTaW1wbGVGdW5jdGlvbmFsXCJdKSgndi10b29sYmFyX190aXRsZScpO1xudmFyIFZUb29sYmFySXRlbXMgPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY3JlYXRlU2ltcGxlRnVuY3Rpb25hbFwiXSkoJ3YtdG9vbGJhcl9faXRlbXMnKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgJF92dWV0aWZ5X3N1YmNvbXBvbmVudHM6IHtcbiAgICAgICAgVlRvb2xiYXI6IF9WVG9vbGJhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgVlRvb2xiYXJJdGVtczogVlRvb2xiYXJJdGVtcyxcbiAgICAgICAgVlRvb2xiYXJUaXRsZTogVlRvb2xiYXJUaXRsZSxcbiAgICAgICAgVlRvb2xiYXJTaWRlSWNvbjogX1ZUb29sYmFyU2lkZUljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVG9vbHRpcC9WVG9vbHRpcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlRvb2x0aXAvVlRvb2x0aXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c190b29sdGlwc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9zdHlsdXMvY29tcG9uZW50cy9fdG9vbHRpcHMuc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL190b29sdGlwcy5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c190b29sdGlwc19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3N0eWx1c19jb21wb25lbnRzX3Rvb2x0aXBzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9jb2xvcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29sb3JhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfZGVsYXlhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvZGVsYXlhYmxlICovIFwiLi9zcmMvbWl4aW5zL2RlbGF5YWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2RlcGVuZGVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2RlcGVuZGVudCAqLyBcIi4vc3JjL21peGlucy9kZXBlbmRlbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19kZXRhY2hhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvZGV0YWNoYWJsZSAqLyBcIi4vc3JjL21peGlucy9kZXRhY2hhYmxlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfbWVudWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy9tZW51YWJsZSAqLyBcIi4vc3JjL21peGlucy9tZW51YWJsZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3RvZ2dsZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL21peGlucy90b2dnbGVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RvZ2dsZWFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuXG4vLyBNaXhpbnNcblxuXG5cblxuXG5cbi8vIEhlbHBlcnNcblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICd2LXRvb2x0aXAnLFxuICAgIG1peGluczogW19taXhpbnNfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCBfbWl4aW5zX2RlbGF5YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwgX21peGluc19kZXBlbmRlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sIF9taXhpbnNfZGV0YWNoYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXSwgX21peGluc19tZW51YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSwgX21peGluc190b2dnbGVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0XCJdXSxcbiAgICBwcm9wczoge1xuICAgICAgICBjbG9zZURlbGF5OiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogMjAwXG4gICAgICAgIH0sXG4gICAgICAgIGRlYm91bmNlOiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICAgICAgZml4ZWQ6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG9wZW5EZWxheToge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDIwMFxuICAgICAgICB9LFxuICAgICAgICB0YWc6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdzcGFuJ1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2l0aW9uOiBTdHJpbmcsXG4gICAgICAgIHpJbmRleDoge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsY3VsYXRlZE1pbldpZHRoOiAwLFxuICAgICAgICAgICAgY2xvc2VEZXBlbmRlbnRzOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2FsY3VsYXRlZExlZnQ6IGZ1bmN0aW9uIGNhbGN1bGF0ZWRMZWZ0KCkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIGFjdGl2YXRvciA9IF9hLmFjdGl2YXRvcixcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gX2EuY29udGVudDtcbiAgICAgICAgICAgIHZhciB1bmtub3duID0gIXRoaXMuYm90dG9tICYmICF0aGlzLmxlZnQgJiYgIXRoaXMudG9wICYmICF0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgdmFyIGxlZnQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMudG9wIHx8IHRoaXMuYm90dG9tIHx8IHVua25vd24pIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gYWN0aXZhdG9yLmxlZnQgKyBhY3RpdmF0b3Iud2lkdGggLyAyIC0gY29udGVudC53aWR0aCAvIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGVmdCB8fCB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGFjdGl2YXRvci5sZWZ0ICsgKHRoaXMucmlnaHQgPyBhY3RpdmF0b3Iud2lkdGggOiAtY29udGVudC53aWR0aCkgKyAodGhpcy5yaWdodCA/IDEwIDogLTEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm51ZGdlTGVmdCkgbGVmdCAtPSBwYXJzZUludCh0aGlzLm51ZGdlTGVmdCk7XG4gICAgICAgICAgICBpZiAodGhpcy5udWRnZVJpZ2h0KSBsZWZ0ICs9IHBhcnNlSW50KHRoaXMubnVkZ2VSaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjWE92ZXJmbG93KGxlZnQpICsgXCJweFwiO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjdWxhdGVkVG9wOiBmdW5jdGlvbiBjYWxjdWxhdGVkVG9wKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIGFjdGl2YXRvciA9IF9hLmFjdGl2YXRvcixcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gX2EuY29udGVudDtcbiAgICAgICAgICAgIHZhciB0b3AgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMudG9wIHx8IHRoaXMuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgdG9wID0gYWN0aXZhdG9yLnRvcCArICh0aGlzLmJvdHRvbSA/IGFjdGl2YXRvci5oZWlnaHQgOiAtY29udGVudC5oZWlnaHQpICsgKHRoaXMuYm90dG9tID8gMTAgOiAtMTApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxlZnQgfHwgdGhpcy5yaWdodCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGFjdGl2YXRvci50b3AgKyBhY3RpdmF0b3IuaGVpZ2h0IC8gMiAtIGNvbnRlbnQuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm51ZGdlVG9wKSB0b3AgLT0gcGFyc2VJbnQodGhpcy5udWRnZVRvcCk7XG4gICAgICAgICAgICBpZiAodGhpcy5udWRnZUJvdHRvbSkgdG9wICs9IHBhcnNlSW50KHRoaXMubnVkZ2VCb3R0b20pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY1lPdmVyZmxvdyh0b3AgKyB0aGlzLnBhZ2VZT2Zmc2V0KSArIFwicHhcIjtcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3YtdG9vbHRpcC0tdG9wJzogdGhpcy50b3AsXG4gICAgICAgICAgICAgICAgJ3YtdG9vbHRpcC0tcmlnaHQnOiB0aGlzLnJpZ2h0LFxuICAgICAgICAgICAgICAgICd2LXRvb2x0aXAtLWJvdHRvbSc6IHRoaXMuYm90dG9tLFxuICAgICAgICAgICAgICAgICd2LXRvb2x0aXAtLWxlZnQnOiB0aGlzLmxlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXB1dGVkVHJhbnNpdGlvbjogZnVuY3Rpb24gY29tcHV0ZWRUcmFuc2l0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbikgcmV0dXJuIHRoaXMudHJhbnNpdGlvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLnRvcCkgcmV0dXJuICdzbGlkZS15LXJldmVyc2UtdHJhbnNpdGlvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCkgcmV0dXJuICdzbGlkZS14LXRyYW5zaXRpb24nO1xuICAgICAgICAgICAgaWYgKHRoaXMuYm90dG9tKSByZXR1cm4gJ3NsaWRlLXktdHJhbnNpdGlvbic7XG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0KSByZXR1cm4gJ3NsaWRlLXgtcmV2ZXJzZS10cmFuc2l0aW9uJztcbiAgICAgICAgfSxcbiAgICAgICAgb2Zmc2V0WTogZnVuY3Rpb24gb2Zmc2V0WSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcCB8fCB0aGlzLmJvdHRvbTtcbiAgICAgICAgfSxcbiAgICAgICAgb2Zmc2V0WDogZnVuY3Rpb24gb2Zmc2V0WCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQgfHwgdGhpcy5yaWdodDtcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGVzOiBmdW5jdGlvbiBzdHlsZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMuY2FsY3VsYXRlZExlZnQsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGg6IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJjb252ZXJ0VG9Vbml0XCJdKSh0aGlzLm1heFdpZHRoKSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLmlzQWN0aXZlID8gMC45IDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuY2FsY3VsYXRlZFRvcCxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IHRoaXMuekluZGV4IHx8IHRoaXMuYWN0aXZlWkluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLnZhbHVlICYmIHRoaXMuY2FsbEFjdGl2YXRlKCk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbiBhY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucyBvZiBtZW51XG4gICAgICAgICAgICAvLyBhbmQgaXRzIGFjdGl2YXRvclxuICAgICAgICAgICAgdGhpcy51cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgdHJhbnNpdGlvblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc3RhcnRUcmFuc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciB0b29sdGlwID0gaCgnZGl2JywgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IodGhpcy5jb2xvciwge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRvb2x0aXBfX2NvbnRlbnQnLFxuICAgICAgICAgICAgJ2NsYXNzJzogKF9hID0ge30sIF9hW3RoaXMuY29udGVudENsYXNzXSA9IHRydWUsIF9hWydtZW51YWJsZV9fY29udGVudF9fYWN0aXZlJ10gPSB0aGlzLmlzQWN0aXZlLCBfYSksXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5zdHlsZXMsXG4gICAgICAgICAgICBhdHRyczogdGhpcy5nZXRTY29wZUlkQXR0cnMoKSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3Nob3cnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmlzQ29udGVudEFjdGl2ZVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICByZWY6ICdjb250ZW50J1xuICAgICAgICB9KSwgdGhpcy5zaG93TGF6eUNvbnRlbnQodGhpcy4kc2xvdHMuZGVmYXVsdCkpO1xuICAgICAgICByZXR1cm4gaCh0aGlzLnRhZywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRvb2x0aXAnLFxuICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy5jbGFzc2VzXG4gICAgICAgIH0sIFtoKCd0cmFuc2l0aW9uJywge1xuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmNvbXB1dGVkVHJhbnNpdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbdG9vbHRpcF0pLCBoKCdzcGFuJywge1xuICAgICAgICAgICAgb246IHRoaXMuZGlzYWJsZWQgPyB7fSA6IHtcbiAgICAgICAgICAgICAgICBtb3VzZWVudGVyOiBmdW5jdGlvbiBtb3VzZWVudGVyKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ydW5EZWxheSgnb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW91c2VsZWF2ZTogZnVuY3Rpb24gbW91c2VsZWF2ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucnVuRGVsYXkoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWY6ICdhY3RpdmF0b3InXG4gICAgICAgIH0sIHRoaXMuJHNsb3RzLmFjdGl2YXRvcildKTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WVG9vbHRpcC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlRvb2x0aXAvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWVG9vbHRpcCwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRvb2x0aXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRvb2x0aXAgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUb29sdGlwL1ZUb29sdGlwLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRvb2x0aXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRvb2x0aXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVlRvb2x0aXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUcmVldmlldy9WVHJlZXZpZXcudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlRyZWV2aWV3L1ZUcmVldmlldy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfdHJlZXZpZXdfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3RyZWV2aWV3LnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdHJlZXZpZXcuc3R5bFwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3R5bHVzX2NvbXBvbmVudHNfdHJlZXZpZXdfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c190cmVldmlld19zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WVHJlZXZpZXdOb2RlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZUcmVldmlld05vZGUgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUcmVldmlldy9WVHJlZXZpZXdOb2RlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3JlZ2lzdHJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvcmVnaXN0cmFibGUgKi8gXCIuL3NyYy9taXhpbnMvcmVnaXN0cmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9taXhpbnMgKi8gXCIuL3NyYy91dGlsL21peGlucy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZWFkID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3JlYWQgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSxcbiAgICAgICAgcixcbiAgICAgICAgYXIgPSBbXSxcbiAgICAgICAgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgYXIucHVzaChyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGUgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChlKSB0aHJvdyBlLmVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fc3ByZWFkIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gICAgfXJldHVybiBhcjtcbn07XG4vLyBTdHlsZXNcblxuLy8gQ29tcG9uZW50c1xuXG4vLyBNaXhpbnNcblxuXG4vLyBVdGlsc1xuXG5cblxuZnVuY3Rpb24gc3RvbihzKSB7XG4gICAgdmFyIG4gPSBOdW1iZXIocyk7XG4gICAgcmV0dXJuICFpc05hTihuKSA/IG4gOiBzO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0XCJdKShPYmplY3QoX21peGluc19yZWdpc3RyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wicHJvdmlkZVwiXSkoJ3RyZWV2aWV3JyksIF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LXRyZWV2aWV3JyxcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgICAgICByZXR1cm4geyB0cmVldmlldzogdGhpcyB9O1xuICAgIH0sXG4gICAgcHJvcHM6IF9fYXNzaWduKHsgYWN0aXZlOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaXRlbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBob3ZlcmFibGU6IEJvb2xlYW4sIG11bHRpcGxlQWN0aXZlOiBCb29sZWFuLCBvcGVuOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgb3BlbkFsbDogQm9vbGVhbiwgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IH0sIF9WVHJlZXZpZXdOb2RlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJWVHJlZXZpZXdOb2RlUHJvcHNcIl0pLFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2Rlczoge30sXG4gICAgICAgICAgICBzZWxlY3RlZENhY2hlOiBuZXcgU2V0KCksXG4gICAgICAgICAgICBhY3RpdmVDYWNoZTogbmV3IFNldCgpLFxuICAgICAgICAgICAgb3BlbkNhY2hlOiBuZXcgU2V0KClcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgY2FyZSBpZiBub2RlcyBhcmUgcmVtb3ZlZCBvciBhZGRlZFxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLm5vZGVzKS5sZW5ndGggPT09IHRoaXMuY291bnRJdGVtcyh0aGlzLml0ZW1zKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTZWxlY3RlZENhY2hlID0gX19zcHJlYWQodGhpcy5zZWxlY3RlZENhY2hlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ2FjaGUgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVDYWNoZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5DYWNoZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkVHJlZSh0aGlzLml0ZW1zKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGVtaXQgc2VsZWN0ZWQgaWYgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gYXMgYSByZXN1bHQgb2YgaXRlbXMgY2hhbmdpbmcuIFRoaXMgZml4ZXMgYVxuICAgICAgICAgICAgICAgIC8vIHBvdGVudGlhbCBkb3VibGUgZW1pdCB3aGVuIHNlbGVjdGluZyBhIG5vZGVcbiAgICAgICAgICAgICAgICAvLyB3aXRoIGR5bmFtaWMgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWVwRXF1YWxcIl0pKG9sZFNlbGVjdGVkQ2FjaGUsIF9fc3ByZWFkKHRoaXMuc2VsZWN0ZWRDYWNoZSkpKSB0aGlzLmVtaXRTZWxlY3RlZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlZXA6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZlOiBmdW5jdGlvbiBhY3RpdmUodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgb2xkID0gX19zcHJlYWQodGhpcy5hY3RpdmVDYWNoZSk7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWVwRXF1YWxcIl0pKG9sZCwgdmFsdWUpKSByZXR1cm47XG4gICAgICAgICAgICBvbGQuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFjdGl2ZShrZXksIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFjdGl2ZShrZXksIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXRBY3RpdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF92YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBvbGQgPSBfX3NwcmVhZCh0aGlzLnNlbGVjdGVkQ2FjaGUpO1xuICAgICAgICAgICAgaWYgKCFfdmFsdWUgfHwgT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZXBFcXVhbFwiXSkob2xkLCBfdmFsdWUpKSByZXR1cm47XG4gICAgICAgICAgICBvbGQuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZVNlbGVjdGVkKGtleSwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZVNlbGVjdGVkKGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFNlbGVjdGVkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4odmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgb2xkID0gX19zcHJlYWQodGhpcy5vcGVuQ2FjaGUpO1xuICAgICAgICAgICAgaWYgKE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWVwRXF1YWxcIl0pKG9sZCwgdmFsdWUpKSByZXR1cm47XG4gICAgICAgICAgICBvbGQuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZU9wZW4oa2V5LCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy51cGRhdGVPcGVuKGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdE9wZW4oKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5idWlsZFRyZWUodGhpcy5pdGVtcyk7XG4gICAgICAgIHRoaXMudmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlU2VsZWN0ZWQoa2V5LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdFNlbGVjdGVkKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUFjdGl2ZShrZXksIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0QWN0aXZlKCk7XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBTYXZlIHRoZSBkZXZlbG9wZXIgZnJvbSB0aGVtc2VsdmVzXG4gICAgICAgIGlmICh0aGlzLiRzbG90cy5wcmVwZW5kIHx8IHRoaXMuJHNsb3RzLmFwcGVuZCkge1xuICAgICAgICAgICAgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImNvbnNvbGVXYXJuXCJdKSgnVGhlIHByZXBlbmQgYW5kIGFwcGVuZCBzbG90cyByZXF1aXJlIGEgc2xvdC1zY29wZSBhdHRyaWJ1dGUnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcGVuQWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLm5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlT3BlbihzdG9uKGtleSksIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZU9wZW4oa2V5LCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdE9wZW4oKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYnVpbGRUcmVlOiBmdW5jdGlvbiBidWlsZFRyZWUoaXRlbXMsIHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImdldE9iamVjdFZhbHVlQnlQYXRoXCJdKShpdGVtLCB0aGlzLml0ZW1LZXkpO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJnZXRPYmplY3RWYWx1ZUJ5UGF0aFwiXSkoaXRlbSwgdGhpcy5pdGVtQ2hpbGRyZW4sIFtdKTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkTm9kZSA9IHRoaXMubm9kZXMuaGFzT3duUHJvcGVydHkoa2V5KSA/IHRoaXMubm9kZXNba2V5XSA6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZDogZmFsc2UsIGlzSW5kZXRlcm1pbmF0ZTogZmFsc2UsIGlzQWN0aXZlOiBmYWxzZSwgaXNPcGVuOiBmYWxzZSwgdm5vZGU6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0ge1xuICAgICAgICAgICAgICAgICAgICB2bm9kZTogb2xkTm9kZS52bm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZ2V0T2JqZWN0VmFsdWVCeVBhdGhcIl0pKGMsIF90aGlzLml0ZW1LZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFRyZWUoY2hpbGRyZW4sIGtleSk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmaXhlZCBidWcgd2l0aCBkeW5hbWljIGNoaWxkcmVuIHJlc2V0dGluZyBzZWxlY3RlZCBwYXJlbnQgc3RhdGVcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubm9kZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBwYXJlbnQgIT09IG51bGwgJiYgdGhpcy5ub2Rlcy5oYXNPd25Qcm9wZXJ0eShwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaXNTZWxlY3RlZCA9IHRoaXMubm9kZXNbcGFyZW50XS5pc1NlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmlzSW5kZXRlcm1pbmF0ZSA9IHRoaXMubm9kZXNbcGFyZW50XS5pc0luZGV0ZXJtaW5hdGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pc1NlbGVjdGVkID0gb2xkTm9kZS5pc1NlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmlzSW5kZXRlcm1pbmF0ZSA9IG9sZE5vZGUuaXNJbmRldGVybWluYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLmlzQWN0aXZlID0gb2xkTm9kZS5pc0FjdGl2ZTtcbiAgICAgICAgICAgICAgICBub2RlLmlzT3BlbiA9IG9sZE5vZGUuaXNPcGVuO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNba2V5XSA9ICFjaGlsZHJlbi5sZW5ndGggPyBub2RlIDogdGhpcy5jYWxjdWxhdGVTdGF0ZShub2RlLCB0aGlzLm5vZGVzKTtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBmb3JnZXQgdG8gcmVidWlsZCBjYWNoZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2tleV0uaXNTZWxlY3RlZCkgdGhpcy5zZWxlY3RlZENhY2hlLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2tleV0uaXNBY3RpdmUpIHRoaXMuYWN0aXZlQ2FjaGUuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNba2V5XS5pc09wZW4pIHRoaXMub3BlbkNhY2hlLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVm5vZGVTdGF0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb3VudEl0ZW1zOiBmdW5jdGlvbiBjb3VudEl0ZW1zKGl0ZW1zKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICBjb3VudCArPSBpdGVtLmNoaWxkcmVuID8gdGhpcy5jb3VudEl0ZW1zKGl0ZW0uY2hpbGRyZW4pIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY3VsYXRlU3RhdGU6IGZ1bmN0aW9uIGNhbGN1bGF0ZVN0YXRlKG5vZGUsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgY291bnRzID0gbm9kZS5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50cywgY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb3VudHNbMF0gKz0gK0Jvb2xlYW4oc3RhdGVbY2hpbGRdLmlzU2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIGNvdW50c1sxXSArPSArQm9vbGVhbihzdGF0ZVtjaGlsZF0uaXNJbmRldGVybWluYXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnRzO1xuICAgICAgICAgICAgfSwgWzAsIDBdKTtcbiAgICAgICAgICAgIG5vZGUuaXNTZWxlY3RlZCA9ICEhbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgY291bnRzWzBdID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIG5vZGUuaXNJbmRldGVybWluYXRlID0gIW5vZGUuaXNTZWxlY3RlZCAmJiAoY291bnRzWzBdID4gMCB8fCBjb3VudHNbMV0gPiAwKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuICAgICAgICBlbWl0T3BlbjogZnVuY3Rpb24gZW1pdE9wZW4oKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6b3BlbicsIF9fc3ByZWFkKHRoaXMub3BlbkNhY2hlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXRTZWxlY3RlZDogZnVuY3Rpb24gZW1pdFNlbGVjdGVkKCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBfX3NwcmVhZCh0aGlzLnNlbGVjdGVkQ2FjaGUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW1pdEFjdGl2ZTogZnVuY3Rpb24gZW1pdEFjdGl2ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTphY3RpdmUnLCBfX3NwcmVhZCh0aGlzLmFjdGl2ZUNhY2hlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERlc2NlbmRhbnRzOiBmdW5jdGlvbiBnZXREZXNjZW5kYW50cyhrZXksIGRlc2NlbmRhbnRzKSB7XG4gICAgICAgICAgICBpZiAoZGVzY2VuZGFudHMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGRlc2NlbmRhbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm5vZGVzW2tleV0uY2hpbGRyZW47XG4gICAgICAgICAgICBkZXNjZW5kYW50cy5wdXNoLmFwcGx5KGRlc2NlbmRhbnRzLCBfX3NwcmVhZChjaGlsZHJlbikpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlc2NlbmRhbnRzID0gdGhpcy5nZXREZXNjZW5kYW50cyhjaGlsZHJlbltpXSwgZGVzY2VuZGFudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NlbmRhbnRzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRQYXJlbnRzOiBmdW5jdGlvbiBnZXRQYXJlbnRzKGtleSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMubm9kZXNba2V5XS5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMubm9kZXNbcGFyZW50XS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50cztcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZ2V0T2JqZWN0VmFsdWVCeVBhdGhcIl0pKG5vZGUuaXRlbSwgdGhpcy5pdGVtS2V5KTtcbiAgICAgICAgICAgIHRoaXMubm9kZXNba2V5XS52bm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZub2RlU3RhdGUoa2V5KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24gdW5yZWdpc3Rlcihub2RlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImdldE9iamVjdFZhbHVlQnlQYXRoXCJdKShub2RlLml0ZW0sIHRoaXMuaXRlbUtleSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzW2tleV0udm5vZGUgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVBY3RpdmU6IGZ1bmN0aW9uIHVwZGF0ZUFjdGl2ZShrZXksIGlzQWN0aXZlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vZGVzLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZUFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2FjaGUuZm9yRWFjaChmdW5jdGlvbiAoYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5vZGVzW2FjdGl2ZV0uaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVm5vZGVTdGF0ZShhY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVDYWNoZS5kZWxldGUoYWN0aXZlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1trZXldO1xuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoaXNBY3RpdmUpIHRoaXMuYWN0aXZlQ2FjaGUuYWRkKGtleSk7ZWxzZSB0aGlzLmFjdGl2ZUNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgbm9kZS5pc0FjdGl2ZSA9IGlzQWN0aXZlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWbm9kZVN0YXRlKGtleSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVNlbGVjdGVkOiBmdW5jdGlvbiB1cGRhdGVTZWxlY3RlZChrZXksIGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9kZXMuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSB7fTtcbiAgICAgICAgICAgIHZhciBkZXNjZW5kYW50cyA9IF9fc3ByZWFkKFtrZXldLCB0aGlzLmdldERlc2NlbmRhbnRzKGtleSkpO1xuICAgICAgICAgICAgZGVzY2VuZGFudHMuZm9yRWFjaChmdW5jdGlvbiAoZGVzY2VuZGFudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm5vZGVzW2Rlc2NlbmRhbnRdLmlzU2VsZWN0ZWQgPSBpc1NlbGVjdGVkO1xuICAgICAgICAgICAgICAgIF90aGlzLm5vZGVzW2Rlc2NlbmRhbnRdLmlzSW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRbZGVzY2VuZGFudF0gPSBpc1NlbGVjdGVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcGFyZW50cyA9IHRoaXMuZ2V0UGFyZW50cyhrZXkpO1xuICAgICAgICAgICAgcGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub2Rlc1twYXJlbnRdID0gX3RoaXMuY2FsY3VsYXRlU3RhdGUoX3RoaXMubm9kZXNbcGFyZW50XSwgX3RoaXMubm9kZXMpO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRbcGFyZW50XSA9IF90aGlzLm5vZGVzW3BhcmVudF0uaXNTZWxlY3RlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGFsbCA9IF9fc3ByZWFkKFtrZXldLCBkZXNjZW5kYW50cywgcGFyZW50cyk7XG4gICAgICAgICAgICBhbGwuZm9yRWFjaCh0aGlzLnVwZGF0ZVZub2RlU3RhdGUpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY2hhbmdlZCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgIGNoYW5nZWRba10gPT09IHRydWUgPyBfdGhpcy5zZWxlY3RlZENhY2hlLmFkZChzdG9uKGspKSA6IF90aGlzLnNlbGVjdGVkQ2FjaGUuZGVsZXRlKHN0b24oaykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZU9wZW46IGZ1bmN0aW9uIHVwZGF0ZU9wZW4oa2V5LCBpc09wZW4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9kZXMuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2tleV07XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbiAmJiAhbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgbm9kZS52bm9kZSAmJiAhbm9kZS52bm9kZS5oYXNMb2FkZWQpIHtcbiAgICAgICAgICAgICAgICBub2RlLnZub2RlLmNoZWNrQ2hpbGRyZW4oKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZU9wZW4oa2V5LCBpc09wZW4pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLmlzT3BlbiA9IGlzT3BlbjtcbiAgICAgICAgICAgICAgICBub2RlLmlzT3BlbiA/IHRoaXMub3BlbkNhY2hlLmFkZChrZXkpIDogdGhpcy5vcGVuQ2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWbm9kZVN0YXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVZub2RlU3RhdGU6IGZ1bmN0aW9uIHVwZGF0ZVZub2RlU3RhdGUoa2V5KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZXNba2V5XTtcbiAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUudm5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnZub2RlLmlzU2VsZWN0ZWQgPSBub2RlLmlzU2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgbm9kZS52bm9kZS5pc0luZGV0ZXJtaW5hdGUgPSBub2RlLmlzSW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgICAgICAgICBub2RlLnZub2RlLmlzQWN0aXZlID0gbm9kZS5pc0FjdGl2ZTtcbiAgICAgICAgICAgICAgICBub2RlLnZub2RlLmlzT3BlbiA9IG5vZGUuaXNPcGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuaXRlbXMubGVuZ3RoID8gdGhpcy5pdGVtcy5tYXAoX1ZUcmVldmlld05vZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0ub3B0aW9ucy5tZXRob2RzLmdlbkNoaWxkLmJpbmQodGhpcykpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIGgoJ2RpdicsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi10cmVldmlldycsXG4gICAgICAgICAgICBjbGFzczogX19hc3NpZ24oeyAndi10cmVldmlldy0taG92ZXJhYmxlJzogdGhpcy5ob3ZlcmFibGUgfSwgdGhpcy50aGVtZUNsYXNzZXMpXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRyZWV2aWV3L1ZUcmVldmlld05vZGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZUcmVldmlldy9WVHJlZXZpZXdOb2RlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVlRyZWV2aWV3Tm9kZVByb3BzLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUcmVldmlld05vZGVQcm9wc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZUcmVldmlld05vZGVQcm9wczsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYW5zaXRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi90cmFuc2l0aW9ucyAqLyBcIi4vc3JjL2NvbXBvbmVudHMvdHJhbnNpdGlvbnMvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9WSWNvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkljb24vaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUcmVldmlld05vZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRyZWV2aWV3Tm9kZSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRyZWV2aWV3L1ZUcmVldmlld05vZGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19yZWdpc3RyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL3JlZ2lzdHJhYmxlICovIFwiLi9zcmMvbWl4aW5zL3JlZ2lzdHJhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9taXhpbnMgKi8gXCIuL3NyYy91dGlsL21peGlucy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBDb21wb25lbnRzXG5cblxuXG4vLyBNaXhpbnNcblxuLy8gVXRpbHNcblxuXG52YXIgVlRyZWV2aWV3Tm9kZVByb3BzID0ge1xuICAgIGFjdGl2YXRhYmxlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3YtdHJlZXZpZXctbm9kZS0tYWN0aXZlJ1xuICAgIH0sXG4gICAgc2VsZWN0YWJsZTogQm9vbGVhbixcbiAgICBzZWxlY3RlZENvbG9yOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ2FjY2VudCdcbiAgICB9LFxuICAgIGluZGV0ZXJtaW5hdGVJY29uOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5Lmljb25zLmNoZWNrYm94SW5kZXRlcm1pbmF0ZSdcbiAgICB9LFxuICAgIG9uSWNvbjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5jaGVja2JveE9uJ1xuICAgIH0sXG4gICAgb2ZmSWNvbjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5jaGVja2JveE9mZidcbiAgICB9LFxuICAgIGV4cGFuZEljb246IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMuc3ViZ3JvdXAnXG4gICAgfSxcbiAgICBsb2FkaW5nSWNvbjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5pY29ucy5sb2FkaW5nJ1xuICAgIH0sXG4gICAgaXRlbUtleToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICdpZCdcbiAgICB9LFxuICAgIGl0ZW1UZXh0OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ25hbWUnXG4gICAgfSxcbiAgICBpdGVtQ2hpbGRyZW46IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnY2hpbGRyZW4nXG4gICAgfSxcbiAgICBsb2FkQ2hpbGRyZW46IEZ1bmN0aW9uLFxuICAgIG9wZW5PbkNsaWNrOiBCb29sZWFuLFxuICAgIHRyYW5zaXRpb246IEJvb2xlYW5cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKE9iamVjdChfdXRpbF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImRlZmF1bHRcIl0pKE9iamVjdChfbWl4aW5zX3JlZ2lzdHJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJpbmplY3RcIl0pKCd0cmVldmlldycpXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuKS5leHRlbmQoe1xuICAgIG5hbWU6ICd2LXRyZWV2aWV3LW5vZGUnLFxuICAgIGluamVjdDoge1xuICAgICAgICB0cmVldmlldzoge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICB9XG4gICAgfSxcbiAgICBwcm9wczogX19hc3NpZ24oeyBpdGVtOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB9LCBWVHJlZXZpZXdOb2RlUHJvcHMpLFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc09wZW46IGZhbHNlLFxuICAgICAgICAgICAgaXNTZWxlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0luZGV0ZXJtaW5hdGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNBY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGhhc0xvYWRlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGtleTogZnVuY3Rpb24ga2V5KCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJnZXRPYmplY3RWYWx1ZUJ5UGF0aFwiXSkodGhpcy5pdGVtLCB0aGlzLml0ZW1LZXkpO1xuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImdldE9iamVjdFZhbHVlQnlQYXRoXCJdKSh0aGlzLml0ZW0sIHRoaXMuaXRlbUNoaWxkcmVuKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dDogZnVuY3Rpb24gdGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZ2V0T2JqZWN0VmFsdWVCeVBhdGhcIl0pKHRoaXMuaXRlbSwgdGhpcy5pdGVtVGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjb3BlZFByb3BzOiBmdW5jdGlvbiBzY29wZWRQcm9wcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXRlbTogdGhpcy5pdGVtLFxuICAgICAgICAgICAgICAgIGxlYWY6ICF0aGlzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0aGlzLmlzU2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZTogdGhpcy5pc0luZGV0ZXJtaW5hdGUsXG4gICAgICAgICAgICAgICAgYWN0aXZlOiB0aGlzLmlzQWN0aXZlLFxuICAgICAgICAgICAgICAgIG9wZW46IHRoaXMuaXNPcGVuXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjb21wdXRlZEljb246IGZ1bmN0aW9uIGNvbXB1dGVkSWNvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5kZXRlcm1pbmF0ZSkgcmV0dXJuIHRoaXMuaW5kZXRlcm1pbmF0ZUljb247ZWxzZSBpZiAodGhpcy5pc1NlbGVjdGVkKSByZXR1cm4gdGhpcy5vbkljb247ZWxzZSByZXR1cm4gdGhpcy5vZmZJY29uO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLnRyZWV2aWV3LnJlZ2lzdGVyKHRoaXMpO1xuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50cmVldmlldy51bnJlZ2lzdGVyKHRoaXMpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBjaGVja0NoaWxkcmVuOiBmdW5jdGlvbiBjaGVja0NoaWxkcmVuKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFBvdGVudGlhbCBpc3N1ZSB3aXRoIGFsd2F5cyB0cnlpbmdcbiAgICAgICAgICAgICAgICAvLyB0byBsb2FkIGNoaWxkcmVuIGlmIHJlc3BvbnNlIGlzIGVtcHR5P1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuY2hpbGRyZW4gfHwgX3RoaXMuY2hpbGRyZW4ubGVuZ3RoIHx8ICFfdGhpcy5sb2FkQ2hpbGRyZW4gfHwgX3RoaXMuaGFzTG9hZGVkKSByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy5sb2FkQ2hpbGRyZW4oX3RoaXMuaXRlbSkpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICAgICAgdGhpcy5pc09wZW4gPSAhdGhpcy5pc09wZW47XG4gICAgICAgICAgICB0aGlzLnRyZWV2aWV3LnVwZGF0ZU9wZW4odGhpcy5rZXksIHRoaXMuaXNPcGVuKTtcbiAgICAgICAgICAgIHRoaXMudHJlZXZpZXcuZW1pdE9wZW4oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuTGFiZWw6IGZ1bmN0aW9uIGdlbkxhYmVsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2xhYmVsJywge1xuICAgICAgICAgICAgICAgIHNsb3Q6ICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRyZWV2aWV3LW5vZGVfX2xhYmVsJ1xuICAgICAgICAgICAgfSwgW3RoaXMudGV4dF0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5Db250ZW50OiBmdW5jdGlvbiBnZW5Db250ZW50KCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW3RoaXMuJHNjb3BlZFNsb3RzLnByZXBlbmQgJiYgdGhpcy4kc2NvcGVkU2xvdHMucHJlcGVuZCh0aGlzLnNjb3BlZFByb3BzKSwgdGhpcy5nZW5MYWJlbCgpLCB0aGlzLiRzY29wZWRTbG90cy5hcHBlbmQgJiYgdGhpcy4kc2NvcGVkU2xvdHMuYXBwZW5kKHRoaXMuc2NvcGVkUHJvcHMpXTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRyZWV2aWV3LW5vZGVfX2NvbnRlbnQnXG4gICAgICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblRvZ2dsZTogZnVuY3Rpb24gZ2VuVG9nZ2xlKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiVkljb25cIl0sIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtdHJlZXZpZXctbm9kZV9fdG9nZ2xlJyxcbiAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAndi10cmVldmlldy1ub2RlX190b2dnbGUtLW9wZW4nOiB0aGlzLmlzT3BlbixcbiAgICAgICAgICAgICAgICAgICAgJ3YtdHJlZXZpZXctbm9kZV9fdG9nZ2xlLS1sb2FkaW5nJzogdGhpcy5pc0xvYWRpbmdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNsb3Q6ICdwcmVwZW5kJyxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0xvYWRpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrQ2hpbGRyZW4oKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMub3BlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbdGhpcy5pc0xvYWRpbmcgPyB0aGlzLmxvYWRpbmdJY29uIDogdGhpcy5leHBhbmRJY29uXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkNoZWNrYm94OiBmdW5jdGlvbiBnZW5DaGVja2JveCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVkljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlZJY29uXCJdLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRyZWV2aWV3LW5vZGVfX2NoZWNrYm94JyxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5pc1NlbGVjdGVkID8gdGhpcy5zZWxlY3RlZENvbG9yIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0xvYWRpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrQ2hpbGRyZW4oKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZXh0VGljayBoZXJlIHNvIHRoYXQgaXRlbXMgd2F0Y2ggaW4gVlRyZWV2aWV3IGhhcyBhIGNoYW5jZSB0byBydW4gZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc1NlbGVjdGVkID0gIV90aGlzLmlzU2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlzSW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmVldmlldy51cGRhdGVTZWxlY3RlZChfdGhpcy5rZXksIF90aGlzLmlzU2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmVldmlldy5lbWl0U2VsZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgW3RoaXMuY29tcHV0ZWRJY29uXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbk5vZGU6IGZ1bmN0aW9uIGdlbk5vZGUoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW3RoaXMuZ2VuQ29udGVudCgpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIGNoaWxkcmVuLnVuc2hpZnQodGhpcy5nZW5DaGVja2JveCgpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuKSBjaGlsZHJlbi51bnNoaWZ0KHRoaXMuZ2VuVG9nZ2xlKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtdHJlZXZpZXctbm9kZV9fcm9vdCcsXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLm9wZW5PbkNsaWNrICYmIF90aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub3BlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5hY3RpdmF0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlzQWN0aXZlID0gIV90aGlzLmlzQWN0aXZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRyZWV2aWV3LnVwZGF0ZUFjdGl2ZShfdGhpcy5rZXksIF90aGlzLmlzQWN0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmVldmlldy5lbWl0QWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkNoaWxkOiBmdW5jdGlvbiBnZW5DaGlsZChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfVlRyZWV2aWV3Tm9kZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIGtleTogT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImdldE9iamVjdFZhbHVlQnlQYXRoXCJdKShpdGVtLCB0aGlzLml0ZW1LZXkpLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2YXRhYmxlOiB0aGlzLmFjdGl2YXRhYmxlLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVDbGFzczogdGhpcy5hY3RpdmVDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0YWJsZTogdGhpcy5zZWxlY3RhYmxlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZENvbG9yOiB0aGlzLnNlbGVjdGVkQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZEljb246IHRoaXMuZXhwYW5kSWNvbixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZUljb246IHRoaXMuaW5kZXRlcm1pbmF0ZUljb24sXG4gICAgICAgICAgICAgICAgICAgIG9mZkljb246IHRoaXMub2ZmSWNvbixcbiAgICAgICAgICAgICAgICAgICAgb25JY29uOiB0aGlzLm9uSWNvbixcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ0ljb246IHRoaXMubG9hZGluZ0ljb24sXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1LZXk6IHRoaXMuaXRlbUtleSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbVRleHQ6IHRoaXMuaXRlbVRleHQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1DaGlsZHJlbjogdGhpcy5pdGVtQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgIGxvYWRDaGlsZHJlbjogdGhpcy5sb2FkQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IHRoaXMudHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgb3Blbk9uQ2xpY2s6IHRoaXMub3Blbk9uQ2xpY2tcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNjb3BlZFNsb3RzOiB0aGlzLiRzY29wZWRTbG90c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkNoaWxkcmVuV3JhcHBlcjogZnVuY3Rpb24gZ2VuQ2hpbGRyZW5XcmFwcGVyKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3BlbiB8fCAhdGhpcy5jaGlsZHJlbikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbdGhpcy5jaGlsZHJlbi5tYXAodGhpcy5nZW5DaGlsZCldO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogJ3YtdHJlZXZpZXctbm9kZV9fY2hpbGRyZW4nXG4gICAgICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgICAgIH0sXG4gICAgICAgIGdlblRyYW5zaXRpb246IGZ1bmN0aW9uIGdlblRyYW5zaXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIlZFeHBhbmRUcmFuc2l0aW9uXCJdLCBbdGhpcy5nZW5DaGlsZHJlbldyYXBwZXIoKV0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW3RoaXMuZ2VuTm9kZSgpXTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbikgY2hpbGRyZW4ucHVzaCh0aGlzLmdlblRyYW5zaXRpb24oKSk7ZWxzZSBjaGlsZHJlbi5wdXNoKHRoaXMuZ2VuQ2hpbGRyZW5XcmFwcGVyKCkpO1xuICAgICAgICByZXR1cm4gaCgnZGl2Jywge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXRyZWV2aWV3LW5vZGUnLFxuICAgICAgICAgICAgY2xhc3M6IChfYSA9IHt9LCBfYVt0aGlzLmFjdGl2ZUNsYXNzXSA9IHRoaXMuaXNBY3RpdmUsIF9hWyd2LXRyZWV2aWV3LW5vZGUtLWxlYWYnXSA9ICF0aGlzLmNoaWxkcmVuLCBfYVsndi10cmVldmlldy1ub2RlLS1jbGljayddID0gdGhpcy5vcGVuT25DbGljaywgX2FbJ3YtdHJlZXZpZXctbm9kZS0tc2VsZWN0ZWQnXSA9IHRoaXMuaXNTZWxlY3RlZCwgX2EpXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRyZWV2aWV3L2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVlRyZWV2aWV3L2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IFZUcmVldmlldywgVlRyZWV2aWV3Tm9kZSwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRyZWV2aWV3X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZUcmVldmlldyAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRyZWV2aWV3L1ZUcmVldmlldy50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUcmVldmlld1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WVHJlZXZpZXdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUcmVldmlld05vZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRyZWV2aWV3Tm9kZSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRyZWV2aWV3L1ZUcmVldmlld05vZGUudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWVHJlZXZpZXdOb2RlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZUcmVldmlld05vZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICAkX3Z1ZXRpZnlfc3ViY29tcG9uZW50czoge1xuICAgICAgICBWVHJlZXZpZXc6IF9WVHJlZXZpZXdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgIFZUcmVldmlld05vZGU6IF9WVHJlZXZpZXdOb2RlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdXG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVldpbmRvdy9WV2luZG93LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVldpbmRvdy9WV2luZG93LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3dpbmRvd3Nfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vc3R5bHVzL2NvbXBvbmVudHMvX3dpbmRvd3Muc3R5bCAqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL193aW5kb3dzLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19jb21wb25lbnRzX3dpbmRvd3Nfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfY29tcG9uZW50c193aW5kb3dzX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJdGVtR3JvdXBfVkl0ZW1Hcm91cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vVkl0ZW1Hcm91cC9WSXRlbUdyb3VwICovIFwiLi9zcmMvY29tcG9uZW50cy9WSXRlbUdyb3VwL1ZJdGVtR3JvdXAudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RpcmVjdGl2ZXNfdG91Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RpcmVjdGl2ZXMvdG91Y2ggKi8gXCIuL3NyYy9kaXJlY3RpdmVzL3RvdWNoLnRzXCIpO1xuLy8gU3R5bGVzXG5cbi8vIENvbXBvbmVudHNcblxuLy8gRGlyZWN0aXZlc1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfVkl0ZW1Hcm91cF9WSXRlbUdyb3VwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJCYXNlSXRlbUdyb3VwXCJdLmV4dGVuZCh7XG4gICAgbmFtZTogJ3Ytd2luZG93JyxcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2luZG93R3JvdXA6IHRoaXNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGRpcmVjdGl2ZXM6IHsgVG91Y2g6IF9kaXJlY3RpdmVzX3RvdWNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgbWFuZGF0b3J5OiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoOiBPYmplY3QsXG4gICAgICAgIHRvdWNobGVzczogQm9vbGVhbixcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbDogQm9vbGVhblxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVybmFsSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBpc0Jvb3RlZDogZmFsc2UsXG4gICAgICAgICAgICBpc1JldmVyc2U6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjb21wdXRlZFRyYW5zaXRpb246IGZ1bmN0aW9uIGNvbXB1dGVkVHJhbnNpdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Jvb3RlZCkgcmV0dXJuICcnO1xuICAgICAgICAgICAgdmFyIGF4aXMgPSB0aGlzLnZlcnRpY2FsID8gJ3knIDogJ3gnO1xuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuaW50ZXJuYWxSZXZlcnNlID09PSAhdGhpcy4kdnVldGlmeS5ydGwgPyAnLXJldmVyc2UnIDogJyc7XG4gICAgICAgICAgICByZXR1cm4gXCJ2LXdpbmRvdy1cIiArIGF4aXMgKyBkaXJlY3Rpb24gKyBcIi10cmFuc2l0aW9uXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVybmFsSW5kZXg6IGZ1bmN0aW9uIGludGVybmFsSW5kZXgoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmludGVybmFsVmFsdWUgPT09IF90aGlzLmdldFZhbHVlKGl0ZW0sIGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVybmFsUmV2ZXJzZTogZnVuY3Rpb24gaW50ZXJuYWxSZXZlcnNlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmV2ZXJzZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5yZXZlcnNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNSZXZlcnNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBpbnRlcm5hbEluZGV4OiAndXBkYXRlUmV2ZXJzZSdcbiAgICB9LFxuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc0Jvb3RlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZW5Db250YWluZXI6IGZ1bmN0aW9uIGdlbkNvbnRhaW5lcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6ICd2LXdpbmRvd19fY29udGFpbmVyJyxcbiAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAndi13aW5kb3dfX2NvbnRhaW5lci0taXMtYWN0aXZlJzogdGhpcy5pc0FjdGl2ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmludGVybmFsSGVpZ2h0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG5leHRJbmRleCA9ICh0aGlzLmludGVybmFsSW5kZXggKyAxKSAlIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zW25leHRJbmRleF07XG4gICAgICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSB0aGlzLmdldFZhbHVlKGl0ZW0sIG5leHRJbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXY6IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmV2ZXJzZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gKHRoaXMuaW50ZXJuYWxJbmRleCArIHRoaXMuaXRlbXMubGVuZ3RoIC0gMSkgJSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5pdGVtc1tsYXN0SW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gdGhpcy5nZXRWYWx1ZShpdGVtLCBsYXN0SW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVSZXZlcnNlOiBmdW5jdGlvbiB1cGRhdGVSZXZlcnNlKHZhbCwgb2xkVmFsKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmV2ZXJzZSA9IHZhbCA8IG9sZFZhbDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiAndi13aW5kb3cnLFxuICAgICAgICAgICAgZGlyZWN0aXZlczogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLnRvdWNobGVzcykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy50b3VjaCB8fCB7XG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5uZXh0LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLnByZXZcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhLmRpcmVjdGl2ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3RvdWNoJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoKCdkaXYnLCBkYXRhLCBbdGhpcy5nZW5Db250YWluZXIoKV0pO1xuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WV2luZG93L1ZXaW5kb3dJdGVtLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1ZXaW5kb3cvVldpbmRvd0l0ZW0udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19ib290YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vbWl4aW5zL2Jvb3RhYmxlICovIFwiLi9zcmMvbWl4aW5zL2Jvb3RhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfZ3JvdXBhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9taXhpbnMvZ3JvdXBhYmxlICovIFwiLi9zcmMvbWl4aW5zL2dyb3VwYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlyZWN0aXZlc190b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGlyZWN0aXZlcy90b3VjaCAqLyBcIi4vc3JjL2RpcmVjdGl2ZXMvdG91Y2gudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9taXhpbnMgKi8gXCIuL3NyYy91dGlsL21peGlucy50c1wiKTtcbi8vIE1peGluc1xuXG5cbi8vIERpcmVjdGl2ZXNcblxuLy8gVXRpbGl0aWVzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdKShfbWl4aW5zX2Jvb3RhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLCBPYmplY3QoX21peGluc19ncm91cGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImZhY3RvcnlcIl0pKCd3aW5kb3dHcm91cCcsICd2LXdpbmRvdy1pdGVtJywgJ3Ytd2luZG93Jylcbi8qIEB2dWUvY29tcG9uZW50ICovXG4pLmV4dGVuZCh7XG4gICAgbmFtZTogJ3Ytd2luZG93LWl0ZW0nLFxuICAgIGRpcmVjdGl2ZXM6IHtcbiAgICAgICAgVG91Y2g6IF9kaXJlY3RpdmVzX3RvdWNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICByZXZlcnNlVHJhbnNpdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNpdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNBY3RpdmU6IGZhbHNlLFxuICAgICAgICAgICAgd2FzQ2FuY2VsbGVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29tcHV0ZWRUcmFuc2l0aW9uOiBmdW5jdGlvbiBjb21wdXRlZFRyYW5zaXRpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2luZG93R3JvdXAuaW50ZXJuYWxSZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLnRyYW5zaXRpb24gIT09ICd1bmRlZmluZWQnID8gdGhpcy50cmFuc2l0aW9uIHx8ICcnIDogdGhpcy53aW5kb3dHcm91cC5jb21wdXRlZFRyYW5zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMucmV2ZXJzZVRyYW5zaXRpb24gIT09ICd1bmRlZmluZWQnID8gdGhpcy5yZXZlcnNlVHJhbnNpdGlvbiB8fCAnJyA6IHRoaXMud2luZG93R3JvdXAuY29tcHV0ZWRUcmFuc2l0aW9uO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlbkRlZmF1bHRTbG90OiBmdW5jdGlvbiBnZW5EZWZhdWx0U2xvdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgICAgICB9LFxuICAgICAgICBvbkFmdGVyRW50ZXI6IGZ1bmN0aW9uIG9uQWZ0ZXJFbnRlcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy53YXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhc0NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMud2luZG93R3JvdXAuaW50ZXJuYWxIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgX3RoaXMud2luZG93R3JvdXAuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZUVudGVyOiBmdW5jdGlvbiBvbkJlZm9yZUVudGVyKCkge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dHcm91cC5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlTGVhdmU6IGZ1bmN0aW9uIG9uQmVmb3JlTGVhdmUoZWwpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93R3JvdXAuaW50ZXJuYWxIZWlnaHQgPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiY29udmVydFRvVW5pdFwiXSkoZWwuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZDogZnVuY3Rpb24gb25FbnRlckNhbmNlbGxlZCgpIHtcbiAgICAgICAgICAgIHRoaXMud2FzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlcjogZnVuY3Rpb24gb25FbnRlcihlbCwgZG9uZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpc0Jvb3RlZCA9IHRoaXMud2luZG93R3JvdXAuaXNCb290ZWQ7XG4gICAgICAgICAgICBpZiAoaXNCb290ZWQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiYWRkT25jZUV2ZW50TGlzdGVuZXJcIl0pKGVsLCAndHJhbnNpdGlvbmVuZCcsIGRvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53aW5kb3dHcm91cC5pbnRlcm5hbEhlaWdodCA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJjb252ZXJ0VG9Vbml0XCJdKShlbC5jbGllbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgIC8vIE9uIGluaXRpYWwgcmVuZGVyLCB0aGVyZSBpcyBubyB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gVnVlIGxlYXZlcyBhIGBlbnRlcmAgdHJhbnNpdGlvbiBjbGFzc1xuICAgICAgICAgICAgICAgIC8vIGlmIGRvbmUgaXMgY2FsbGVkIHRvbyBmYXN0XG4gICAgICAgICAgICAgICAgIWlzQm9vdGVkICYmIHNldFRpbWVvdXQoZG9uZSwgMTAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihoKSB7XG4gICAgICAgIHZhciBkaXYgPSBoKCdkaXYnLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogJ3Ytd2luZG93LWl0ZW0nLFxuICAgICAgICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnc2hvdycsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuaXNBY3RpdmVcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgb246IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgICB9LCB0aGlzLnNob3dMYXp5Q29udGVudCh0aGlzLmdlbkRlZmF1bHRTbG90KCkpKTtcbiAgICAgICAgcmV0dXJuIGgoJ3RyYW5zaXRpb24nLCB7XG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuY29tcHV0ZWRUcmFuc2l0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBhZnRlckVudGVyOiB0aGlzLm9uQWZ0ZXJFbnRlcixcbiAgICAgICAgICAgICAgICBiZWZvcmVFbnRlcjogdGhpcy5vbkJlZm9yZUVudGVyLFxuICAgICAgICAgICAgICAgIGJlZm9yZUxlYXZlOiB0aGlzLm9uQmVmb3JlTGVhdmUsXG4gICAgICAgICAgICAgICAgZW50ZXI6IHRoaXMub25FbnRlcixcbiAgICAgICAgICAgICAgICBlbnRlckNhbmNlbGxlZDogdGhpcy5vbkVudGVyQ2FuY2VsbGVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtkaXZdKTtcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVldpbmRvdy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WV2luZG93L2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBWV2luZG93LCBWV2luZG93SXRlbSwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVldpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WV2luZG93ICovIFwiLi9zcmMvY29tcG9uZW50cy9WV2luZG93L1ZXaW5kb3cudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWV2luZG93XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZXaW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZXaW5kb3dJdGVtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZXaW5kb3dJdGVtICovIFwiLi9zcmMvY29tcG9uZW50cy9WV2luZG93L1ZXaW5kb3dJdGVtLnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVldpbmRvd0l0ZW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVldpbmRvd0l0ZW1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICAkX3Z1ZXRpZnlfc3ViY29tcG9uZW50czoge1xuICAgICAgICBWV2luZG93OiBfVldpbmRvd19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSxcbiAgICAgICAgVldpbmRvd0l0ZW06IF9WV2luZG93SXRlbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1Z1ZXRpZnkvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVnVldGlmeS9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogY2hlY2tWdWVWZXJzaW9uLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNoZWNrVnVlVmVyc2lvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNoZWNrVnVlVmVyc2lvbjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB2dWUgKi8gXCJ2dWVcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfYXBwbGljYXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL2FwcGxpY2F0aW9uICovIFwiLi9zcmMvY29tcG9uZW50cy9WdWV0aWZ5L21peGlucy9hcHBsaWNhdGlvbi50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX2JyZWFrcG9pbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL2JyZWFrcG9pbnQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1Z1ZXRpZnkvbWl4aW5zL2JyZWFrcG9pbnQudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9taXhpbnMvdGhlbWUgKi8gXCIuL3NyYy9jb21wb25lbnRzL1Z1ZXRpZnkvbWl4aW5zL3RoZW1lLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfaWNvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL2ljb25zICovIFwiLi9zcmMvY29tcG9uZW50cy9WdWV0aWZ5L21peGlucy9pY29ucy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX29wdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zL29wdGlvbnMgKi8gXCIuL3NyYy9jb21wb25lbnRzL1Z1ZXRpZnkvbWl4aW5zL29wdGlvbnMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19sYW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21peGlucy9sYW5nICovIFwiLi9zcmMvY29tcG9uZW50cy9WdWV0aWZ5L21peGlucy9sYW5nLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2dvVG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbC9nb1RvICovIFwiLi9zcmMvY29tcG9uZW50cy9WdWV0aWZ5L3V0aWwvZ29Uby5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG5cblxuXG5cblxuXG5cblxuLy8gVXRpbHNcblxudmFyIFZ1ZXRpZnkgPSB7XG4gICAgaW5zdGFsbDogZnVuY3Rpb24gaW5zdGFsbChWdWUsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluc3RhbGxlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLmluc3RhbGxlZCA9IHRydWU7XG4gICAgICAgIGlmICh2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEgIT09IFZ1ZSkge1xuICAgICAgICAgICAgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1tcImNvbnNvbGVFcnJvclwiXSkoJ011bHRpcGxlIGluc3RhbmNlcyBvZiBWdWUgZGV0ZWN0ZWRcXG5TZWUgaHR0cHM6Ly9naXRodWIuY29tL3Z1ZXRpZnlqcy92dWV0aWZ5L2lzc3Vlcy80MDY4XFxuXFxuSWYgeW91XFwncmUgc2VlaW5nIFwiJGF0dHJzIGlzIHJlYWRvbmx5XCIsIGl0XFwncyBjYXVzZWQgYnkgdGhpcycpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrVnVlVmVyc2lvbihWdWUpO1xuICAgICAgICB2YXIgbGFuZyA9IE9iamVjdChfbWl4aW5zX2xhbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0pKG9wdHMubGFuZyk7XG4gICAgICAgIFZ1ZS5wcm90b3R5cGUuJHZ1ZXRpZnkgPSBuZXcgVnVlKHtcbiAgICAgICAgICAgIG1peGluczogW19taXhpbnNfYnJlYWtwb2ludF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXV0sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgYXBwbGljYXRpb246IF9taXhpbnNfYXBwbGljYXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgICAgICAgICAgZGFyazogZmFsc2UsXG4gICAgICAgICAgICAgICAgaWNvbnM6IE9iamVjdChfbWl4aW5zX2ljb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJkZWZhdWx0XCJdKShvcHRzLmljb25mb250LCBvcHRzLmljb25zKSxcbiAgICAgICAgICAgICAgICBsYW5nOiBsYW5nLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IE9iamVjdChfbWl4aW5zX29wdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0pKG9wdHMub3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcnRsOiBvcHRzLnJ0bCxcbiAgICAgICAgICAgICAgICB0aGVtZTogT2JqZWN0KF9taXhpbnNfdGhlbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0pKG9wdHMudGhlbWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgICAgIGdvVG86IF91dGlsX2dvVG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImRlZmF1bHRcIl0sXG4gICAgICAgICAgICAgICAgdDogbGFuZy50LmJpbmQobGFuZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHRzLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gb3B0cy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICAgICAgVnVlLmRpcmVjdGl2ZShuYW1lLCBvcHRzLmRpcmVjdGl2ZXNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudHMoY29tcG9uZW50cykge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmICFyZWdpc3RlckNvbXBvbmVudHMoY29tcG9uZW50LiRfdnVldGlmeV9zdWJjb21wb25lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgVnVlLmNvbXBvbmVudChrZXksIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pKG9wdHMuY29tcG9uZW50cyk7XG4gICAgfSxcbiAgICB2ZXJzaW9uOiAnMS4zLjcnXG59O1xuZnVuY3Rpb24gY2hlY2tWdWVWZXJzaW9uKFZ1ZSwgcmVxdWlyZWRWdWUpIHtcbiAgICB2YXIgdnVlRGVwID0gcmVxdWlyZWRWdWUgfHwgJ14yLjUuMTAnO1xuICAgIHZhciByZXF1aXJlZCA9IHZ1ZURlcC5zcGxpdCgnLicsIDMpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi5yZXBsYWNlKC9cXEQvZywgJycpO1xuICAgIH0pLm1hcChOdW1iZXIpO1xuICAgIHZhciBhY3R1YWwgPSBWdWUudmVyc2lvbi5zcGxpdCgnLicsIDMpLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQobiwgMTApO1xuICAgIH0pO1xuICAgIC8vIFNpbXBsZSBzZW12ZXIgY2FyZXQgcmFuZ2UgY29tcGFyaXNvblxuICAgIHZhciBwYXNzZXMgPSBhY3R1YWxbMF0gPT09IHJlcXVpcmVkWzBdICYmICggLy8gbWFqb3IgbWF0Y2hlc1xuICAgIGFjdHVhbFsxXSA+IHJlcXVpcmVkWzFdIHx8IC8vIG1pbm9yIGlzIGdyZWF0ZXJcbiAgICBhY3R1YWxbMV0gPT09IHJlcXVpcmVkWzFdICYmIGFjdHVhbFsyXSA+PSByZXF1aXJlZFsyXSAvLyBvciBtaW5vciBpcyBlcSBhbmQgcGF0Y2ggaXMgPj1cbiAgICApO1xuICAgIGlmICghcGFzc2VzKSB7XG4gICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJjb25zb2xlV2FyblwiXSkoXCJWdWV0aWZ5IHJlcXVpcmVzIFZ1ZSB2ZXJzaW9uIFwiICsgdnVlRGVwKTtcbiAgICB9XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFZ1ZXRpZnkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1Z1ZXRpZnkvbWl4aW5zL2FwcGxpY2F0aW9uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WdWV0aWZ5L21peGlucy9hcHBsaWNhdGlvbi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBiYXI6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGZvb3RlcjogMCxcbiAgICBpbnNldEZvb3RlcjogMCxcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAgIGJhcjoge30sXG4gICAgICAgIGJvdHRvbToge30sXG4gICAgICAgIGZvb3Rlcjoge30sXG4gICAgICAgIGluc2V0Rm9vdGVyOiB7fSxcbiAgICAgICAgbGVmdDoge30sXG4gICAgICAgIHJpZ2h0OiB7fSxcbiAgICAgICAgdG9wOiB7fVxuICAgIH0sXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh1aWQsIHRhcmdldCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50c1t0YXJnZXRdKSByZXR1cm47XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1t0YXJnZXRdID0gKF9hID0ge30sIF9hW3VpZF0gPSB2YWx1ZSwgX2EpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh0YXJnZXQpO1xuICAgIH0sXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQodWlkLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50c1t0YXJnZXRdW3VpZF0gPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBkZWxldGUgdGhpcy5jb21wb25lbnRzW3RhcmdldF1bdWlkXTtcbiAgICAgICAgdGhpcy51cGRhdGUodGFyZ2V0KTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHRhcmdldCkge1xuICAgICAgICB0aGlzW3RhcmdldF0gPSBPYmplY3QudmFsdWVzKHRoaXMuY29tcG9uZW50c1t0YXJnZXRdKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgY3VyO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WdWV0aWZ5L21peGlucy9icmVha3BvaW50LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1Z1ZXRpZnkvbWl4aW5zL2JyZWFrcG9pbnQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB2dWUgKi8gXCJ2dWVcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuXG4vKipcbiAqIEEgbW9kaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9jYjEwOS9iMDc0YTY1Zjc1OTVjZmZjMjFjZWE1OWNlOGQxNWY5YlxuICovXG4vKipcbiAqIEEgVnVlIG1peGluIHRvIGdldCB0aGUgY3VycmVudCB3aWR0aC9oZWlnaHQgYW5kIHRoZSBhc3NvY2lhdGVkIGJyZWFrcG9pbnQuXG4gKlxuICogICA8ZGl2IHYtaWY9XCIkYnJlYWtwb2ludC5zbUFuZERvd25cIj4uLi48L2Rpdj5cbiAqXG4gKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7XG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsaWVudEhlaWdodDogZ2V0Q2xpZW50SGVpZ2h0KCksXG4gICAgICAgICAgICBjbGllbnRXaWR0aDogZ2V0Q2xpZW50V2lkdGgoKSxcbiAgICAgICAgICAgIHJlc2l6ZVRpbWVvdXQ6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYnJlYWtwb2ludDogZnVuY3Rpb24gYnJlYWtwb2ludCgpIHtcbiAgICAgICAgICAgIHZhciB4cyA9IHRoaXMuY2xpZW50V2lkdGggPCA2MDA7XG4gICAgICAgICAgICB2YXIgc20gPSB0aGlzLmNsaWVudFdpZHRoIDwgOTYwICYmICF4cztcbiAgICAgICAgICAgIHZhciBtZCA9IHRoaXMuY2xpZW50V2lkdGggPCAxMjgwIC0gMTYgJiYgIShzbSB8fCB4cyk7XG4gICAgICAgICAgICB2YXIgbGcgPSB0aGlzLmNsaWVudFdpZHRoIDwgMTkyMCAtIDE2ICYmICEobWQgfHwgc20gfHwgeHMpO1xuICAgICAgICAgICAgdmFyIHhsID0gdGhpcy5jbGllbnRXaWR0aCA+PSAxOTIwIC0gMTY7XG4gICAgICAgICAgICB2YXIgeHNPbmx5ID0geHM7XG4gICAgICAgICAgICB2YXIgc21Pbmx5ID0gc207XG4gICAgICAgICAgICB2YXIgc21BbmREb3duID0gKHhzIHx8IHNtKSAmJiAhKG1kIHx8IGxnIHx8IHhsKTtcbiAgICAgICAgICAgIHZhciBzbUFuZFVwID0gIXhzICYmIChzbSB8fCBtZCB8fCBsZyB8fCB4bCk7XG4gICAgICAgICAgICB2YXIgbWRPbmx5ID0gbWQ7XG4gICAgICAgICAgICB2YXIgbWRBbmREb3duID0gKHhzIHx8IHNtIHx8IG1kKSAmJiAhKGxnIHx8IHhsKTtcbiAgICAgICAgICAgIHZhciBtZEFuZFVwID0gISh4cyB8fCBzbSkgJiYgKG1kIHx8IGxnIHx8IHhsKTtcbiAgICAgICAgICAgIHZhciBsZ09ubHkgPSBsZztcbiAgICAgICAgICAgIHZhciBsZ0FuZERvd24gPSAoeHMgfHwgc20gfHwgbWQgfHwgbGcpICYmICF4bDtcbiAgICAgICAgICAgIHZhciBsZ0FuZFVwID0gISh4cyB8fCBzbSB8fCBtZCkgJiYgKGxnIHx8IHhsKTtcbiAgICAgICAgICAgIHZhciB4bE9ubHkgPSB4bDtcbiAgICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB4czpcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9ICd4cyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc206XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnc20nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIG1kOlxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gJ21kJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBsZzpcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9ICdsZyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSAneGwnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy8gRGVmaW5pdGUgYnJlYWtwb2ludC5cbiAgICAgICAgICAgICAgICB4czogeHMsXG4gICAgICAgICAgICAgICAgc206IHNtLFxuICAgICAgICAgICAgICAgIG1kOiBtZCxcbiAgICAgICAgICAgICAgICBsZzogbGcsXG4gICAgICAgICAgICAgICAgeGw6IHhsLFxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBlLmcuIHRvIGNvbnN0cnVjdCBDU1MgY2xhc3MgbmFtZXMgZHluYW1pY2FsbHkuXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAvLyBCcmVha3BvaW50IHJhbmdlcy5cbiAgICAgICAgICAgICAgICB4c09ubHk6IHhzT25seSxcbiAgICAgICAgICAgICAgICBzbU9ubHk6IHNtT25seSxcbiAgICAgICAgICAgICAgICBzbUFuZERvd246IHNtQW5kRG93bixcbiAgICAgICAgICAgICAgICBzbUFuZFVwOiBzbUFuZFVwLFxuICAgICAgICAgICAgICAgIG1kT25seTogbWRPbmx5LFxuICAgICAgICAgICAgICAgIG1kQW5kRG93bjogbWRBbmREb3duLFxuICAgICAgICAgICAgICAgIG1kQW5kVXA6IG1kQW5kVXAsXG4gICAgICAgICAgICAgICAgbGdPbmx5OiBsZ09ubHksXG4gICAgICAgICAgICAgICAgbGdBbmREb3duOiBsZ0FuZERvd24sXG4gICAgICAgICAgICAgICAgbGdBbmRVcDogbGdBbmRVcCxcbiAgICAgICAgICAgICAgICB4bE9ubHk6IHhsT25seSxcbiAgICAgICAgICAgICAgICAvLyBGb3IgY3VzdG9tIGJyZWFrcG9pbnQgbG9naWMuXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmNsaWVudEhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25SZXNpemUpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBvblJlc2l6ZTogZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgICAgIC8vIEFkZGVkIGRlYm91bmNlIHRvIG1hdGNoIHdoYXRcbiAgICAgICAgICAgIC8vIHYtcmVzaXplIHVzZWQgdG8gZG8gYnV0IHdhc1xuICAgICAgICAgICAgLy8gcmVtb3ZlZCBkdWUgdG8gYSBtZW1vcnkgbGVha1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZXRpZnlqcy92dWV0aWZ5L3B1bGwvMjk5N1xuICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5zZXREaW1lbnNpb25zLCAyMDApO1xuICAgICAgICB9LFxuICAgICAgICBzZXREaW1lbnNpb25zOiBmdW5jdGlvbiBzZXREaW1lbnNpb25zKCkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnRIZWlnaHQgPSBnZXRDbGllbnRIZWlnaHQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50V2lkdGggPSBnZXRDbGllbnRXaWR0aCgpO1xuICAgICAgICB9XG4gICAgfVxufSkpO1xuLy8gQ3Jvc3MtYnJvd3NlciBzdXBwb3J0IGFzIGRlc2NyaWJlZCBpbjpcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNDgwODFcbmZ1bmN0aW9uIGdldENsaWVudFdpZHRoKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gMDsgLy8gU1NSXG4gICAgcmV0dXJuIE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG59XG5mdW5jdGlvbiBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAwOyAvLyBTU1JcbiAgICByZXR1cm4gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb21wb25lbnRzL1Z1ZXRpZnkvbWl4aW5zL2ljb25zLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WdWV0aWZ5L21peGlucy9pY29ucy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGljb25zOyB9KTtcbi8vIE1hcHMgaW50ZXJuYWwgVnVldGlmeSBpY29uIG5hbWVzIHRvIGFjdHVhbCBNYXRlcmlhbCBEZXNpZ24gaWNvbiBuYW1lcy5cbnZhciBJQ09OU19NQVRFUklBTCA9IHtcbiAgICAnY29tcGxldGUnOiAnY2hlY2snLFxuICAgICdjYW5jZWwnOiAnY2FuY2VsJyxcbiAgICAnY2xvc2UnOiAnY2xvc2UnLFxuICAgICdkZWxldGUnOiAnY2FuY2VsJyxcbiAgICAnY2xlYXInOiAnY2xlYXInLFxuICAgICdzdWNjZXNzJzogJ2NoZWNrX2NpcmNsZScsXG4gICAgJ2luZm8nOiAnaW5mbycsXG4gICAgJ3dhcm5pbmcnOiAncHJpb3JpdHlfaGlnaCcsXG4gICAgJ2Vycm9yJzogJ3dhcm5pbmcnLFxuICAgICdwcmV2JzogJ2NoZXZyb25fbGVmdCcsXG4gICAgJ25leHQnOiAnY2hldnJvbl9yaWdodCcsXG4gICAgJ2NoZWNrYm94T24nOiAnY2hlY2tfYm94JyxcbiAgICAnY2hlY2tib3hPZmYnOiAnY2hlY2tfYm94X291dGxpbmVfYmxhbmsnLFxuICAgICdjaGVja2JveEluZGV0ZXJtaW5hdGUnOiAnaW5kZXRlcm1pbmF0ZV9jaGVja19ib3gnLFxuICAgICdkZWxpbWl0ZXInOiAnZmliZXJfbWFudWFsX3JlY29yZCcsXG4gICAgJ3NvcnQnOiAnYXJyb3dfdXB3YXJkJyxcbiAgICAnZXhwYW5kJzogJ2tleWJvYXJkX2Fycm93X2Rvd24nLFxuICAgICdtZW51JzogJ21lbnUnLFxuICAgICdzdWJncm91cCc6ICdhcnJvd19kcm9wX2Rvd24nLFxuICAgICdkcm9wZG93bic6ICdhcnJvd19kcm9wX2Rvd24nLFxuICAgICdyYWRpb09uJzogJ3JhZGlvX2J1dHRvbl9jaGVja2VkJyxcbiAgICAncmFkaW9PZmYnOiAncmFkaW9fYnV0dG9uX3VuY2hlY2tlZCcsXG4gICAgJ2VkaXQnOiAnZWRpdCcsXG4gICAgJ3JhdGluZ0VtcHR5JzogJ3N0YXJfYm9yZGVyJyxcbiAgICAncmF0aW5nRnVsbCc6ICdzdGFyJyxcbiAgICAncmF0aW5nSGFsZic6ICdzdGFyX2hhbGYnLFxuICAgICdsb2FkaW5nJzogJ2NhY2hlZCdcbn07XG4vLyBNYXBzIGludGVybmFsIFZ1ZXRpZnkgaWNvbiBuYW1lcyB0byBhY3R1YWwgaWNvbnMgZnJvbSBtYXRlcmlhbGRlc2lnbmljb25zLmNvbVxudmFyIElDT05TX01ESSA9IHtcbiAgICAnY29tcGxldGUnOiAnbWRpLWNoZWNrJyxcbiAgICAnY2FuY2VsJzogJ21kaS1jbG9zZS1jaXJjbGUnLFxuICAgICdjbG9zZSc6ICdtZGktY2xvc2UnLFxuICAgICdkZWxldGUnOiAnbWRpLWNsb3NlLWNpcmNsZScsXG4gICAgJ2NsZWFyJzogJ21kaS1jbG9zZScsXG4gICAgJ3N1Y2Nlc3MnOiAnbWRpLWNoZWNrLWNpcmNsZScsXG4gICAgJ2luZm8nOiAnbWRpLWluZm9ybWF0aW9uJyxcbiAgICAnd2FybmluZyc6ICdtZGktZXhjbGFtYXRpb24nLFxuICAgICdlcnJvcic6ICdtZGktYWxlcnQnLFxuICAgICdwcmV2JzogJ21kaS1jaGV2cm9uLWxlZnQnLFxuICAgICduZXh0JzogJ21kaS1jaGV2cm9uLXJpZ2h0JyxcbiAgICAnY2hlY2tib3hPbic6ICdtZGktY2hlY2tib3gtbWFya2VkJyxcbiAgICAnY2hlY2tib3hPZmYnOiAnbWRpLWNoZWNrYm94LWJsYW5rLW91dGxpbmUnLFxuICAgICdjaGVja2JveEluZGV0ZXJtaW5hdGUnOiAnbWRpLW1pbnVzLWJveCcsXG4gICAgJ2RlbGltaXRlcic6ICdtZGktY2lyY2xlJyxcbiAgICAnc29ydCc6ICdtZGktYXJyb3ctdXAnLFxuICAgICdleHBhbmQnOiAnbWRpLWNoZXZyb24tZG93bicsXG4gICAgJ21lbnUnOiAnbWRpLW1lbnUnLFxuICAgICdzdWJncm91cCc6ICdtZGktbWVudS1kb3duJyxcbiAgICAnZHJvcGRvd24nOiAnbWRpLW1lbnUtZG93bicsXG4gICAgJ3JhZGlvT24nOiAnbWRpLXJhZGlvYm94LW1hcmtlZCcsXG4gICAgJ3JhZGlvT2ZmJzogJ21kaS1yYWRpb2JveC1ibGFuaycsXG4gICAgJ2VkaXQnOiAnbWRpLXBlbmNpbCcsXG4gICAgJ3JhdGluZ0VtcHR5JzogJ21kaS1zdGFyLW91dGxpbmUnLFxuICAgICdyYXRpbmdGdWxsJzogJ21kaS1zdGFyJyxcbiAgICAncmF0aW5nSGFsZic6ICdtZGktc3Rhci1oYWxmJ1xufTtcbi8vIE1hcHMgaW50ZXJuYWwgVnVldGlmeSBpY29uIG5hbWVzIHRvIGFjdHVhbCBGb250LUF3ZXNvbWUgNCBpY29uIG5hbWVzLlxudmFyIElDT05TX0ZPTlRBV0VTT01FNCA9IHtcbiAgICAnY29tcGxldGUnOiAnZmEgZmEtY2hlY2snLFxuICAgICdjYW5jZWwnOiAnZmEgZmEtdGltZXMtY2lyY2xlJyxcbiAgICAnY2xvc2UnOiAnZmEgZmEtdGltZXMnLFxuICAgICdkZWxldGUnOiAnZmEgZmEtdGltZXMtY2lyY2xlJyxcbiAgICAnY2xlYXInOiAnZmEgZmEtdGltZXMtY2lyY2xlJyxcbiAgICAnc3VjY2Vzcyc6ICdmYSBmYS1jaGVjay1jaXJjbGUnLFxuICAgICdpbmZvJzogJ2ZhIGZhLWluZm8tY2lyY2xlJyxcbiAgICAnd2FybmluZyc6ICdmYSBmYS1leGNsYW1hdGlvbicsXG4gICAgJ2Vycm9yJzogJ2ZhIGZhLWV4Y2xhbWF0aW9uLXRyaWFuZ2xlJyxcbiAgICAncHJldic6ICdmYSBmYS1jaGV2cm9uLWxlZnQnLFxuICAgICduZXh0JzogJ2ZhIGZhLWNoZXZyb24tcmlnaHQnLFxuICAgICdjaGVja2JveE9uJzogJ2ZhIGZhLWNoZWNrLXNxdWFyZScsXG4gICAgJ2NoZWNrYm94T2ZmJzogJ2ZhIGZhLXNxdWFyZS1vJyxcbiAgICAnY2hlY2tib3hJbmRldGVybWluYXRlJzogJ2ZhIGZhLW1pbnVzLXNxdWFyZScsXG4gICAgJ2RlbGltaXRlcic6ICdmYSBmYS1jaXJjbGUnLFxuICAgICdzb3J0JzogJ2ZhIGZhLXNvcnQtdXAnLFxuICAgICdleHBhbmQnOiAnZmEgZmEtY2hldnJvbi1kb3duJyxcbiAgICAnbWVudSc6ICdmYSBmYS1iYXJzJyxcbiAgICAnc3ViZ3JvdXAnOiAnZmEgZmEtY2FyZXQtZG93bicsXG4gICAgJ2Ryb3Bkb3duJzogJ2ZhIGZhLWNhcmV0LWRvd24nLFxuICAgICdyYWRpb09uJzogJ2ZhIGZhLWRvdC1jaXJjbGUnLFxuICAgICdyYWRpb09mZic6ICdmYSBmYS1jaXJjbGUtbycsXG4gICAgJ2VkaXQnOiAnZmEgZmEtcGVuY2lsJyxcbiAgICAncmF0aW5nRW1wdHknOiAnZmEgZmEtc3Rhci1vJyxcbiAgICAncmF0aW5nRnVsbCc6ICdmYSBmYS1zdGFyJyxcbiAgICAncmF0aW5nSGFsZic6ICdmYSBmYS1zdGFyLWhhbGYtbydcbn07XG4vLyBNYXBzIGludGVybmFsIFZ1ZXRpZnkgaWNvbiBuYW1lcyB0byBhY3R1YWwgRm9udC1Bd2Vzb21lIDUrIGljb24gbmFtZXMuXG52YXIgSUNPTlNfRk9OVEFXRVNPTUUgPSB7XG4gICAgJ2NvbXBsZXRlJzogJ2ZhcyBmYS1jaGVjaycsXG4gICAgJ2NhbmNlbCc6ICdmYXMgZmEtdGltZXMtY2lyY2xlJyxcbiAgICAnY2xvc2UnOiAnZmFzIGZhLXRpbWVzJyxcbiAgICAnZGVsZXRlJzogJ2ZhcyBmYS10aW1lcy1jaXJjbGUnLFxuICAgICdjbGVhcic6ICdmYXMgZmEtdGltZXMtY2lyY2xlJyxcbiAgICAnc3VjY2Vzcyc6ICdmYXMgZmEtY2hlY2stY2lyY2xlJyxcbiAgICAnaW5mbyc6ICdmYXMgZmEtaW5mby1jaXJjbGUnLFxuICAgICd3YXJuaW5nJzogJ2ZhcyBmYS1leGNsYW1hdGlvbicsXG4gICAgJ2Vycm9yJzogJ2ZhcyBmYS1leGNsYW1hdGlvbi10cmlhbmdsZScsXG4gICAgJ3ByZXYnOiAnZmFzIGZhLWNoZXZyb24tbGVmdCcsXG4gICAgJ25leHQnOiAnZmFzIGZhLWNoZXZyb24tcmlnaHQnLFxuICAgICdjaGVja2JveE9uJzogJ2ZhcyBmYS1jaGVjay1zcXVhcmUnLFxuICAgICdjaGVja2JveE9mZic6ICdmYXIgZmEtc3F1YXJlJyxcbiAgICAnY2hlY2tib3hJbmRldGVybWluYXRlJzogJ2ZhcyBmYS1taW51cy1zcXVhcmUnLFxuICAgICdkZWxpbWl0ZXInOiAnZmFzIGZhLWNpcmNsZScsXG4gICAgJ3NvcnQnOiAnZmFzIGZhLXNvcnQtdXAnLFxuICAgICdleHBhbmQnOiAnZmFzIGZhLWNoZXZyb24tZG93bicsXG4gICAgJ21lbnUnOiAnZmFzIGZhLWJhcnMnLFxuICAgICdzdWJncm91cCc6ICdmYXMgZmEtY2FyZXQtZG93bicsXG4gICAgJ2Ryb3Bkb3duJzogJ2ZhcyBmYS1jYXJldC1kb3duJyxcbiAgICAncmFkaW9Pbic6ICdmYXIgZmEtZG90LWNpcmNsZScsXG4gICAgJ3JhZGlvT2ZmJzogJ2ZhciBmYS1jaXJjbGUnLFxuICAgICdlZGl0JzogJ2ZhcyBmYS1lZGl0JyxcbiAgICAncmF0aW5nRW1wdHknOiAnZmFyIGZhLXN0YXInLFxuICAgICdyYXRpbmdGdWxsJzogJ2ZhcyBmYS1zdGFyJyxcbiAgICAncmF0aW5nSGFsZic6ICdmYXMgZmEtc3Rhci1oYWxmJ1xufTtcbnZhciBpY29uU2V0cyA9IHtcbiAgICBtZDogSUNPTlNfTUFURVJJQUwsXG4gICAgbWRpOiBJQ09OU19NREksXG4gICAgZmE6IElDT05TX0ZPTlRBV0VTT01FLFxuICAgIGZhNDogSUNPTlNfRk9OVEFXRVNPTUU0XG59O1xuZnVuY3Rpb24gaWNvbnMoaWNvbmZvbnQsIGljb25zKSB7XG4gICAgaWYgKGljb25mb250ID09PSB2b2lkIDApIHtcbiAgICAgICAgaWNvbmZvbnQgPSAnbWQnO1xuICAgIH1cbiAgICBpZiAoaWNvbnMgPT09IHZvaWQgMCkge1xuICAgICAgICBpY29ucyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgaWNvblNldHNbaWNvbmZvbnRdIHx8IGljb25TZXRzLm1kLCBpY29ucyk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVnVldGlmeS9taXhpbnMvbGFuZy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29tcG9uZW50cy9WdWV0aWZ5L21peGlucy9sYW5nLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsYW5nOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9jYWxlX2VuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi9sb2NhbGUvZW4gKi8gXCIuL3NyYy9sb2NhbGUvZW4udHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3V0aWwvY29uc29sZSAqLyBcIi4vc3JjL3V0aWwvY29uc29sZS50c1wiKTtcbnZhciBfX3JlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fcmVhZCB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgICByLFxuICAgICAgICBhciA9IFtdLFxuICAgICAgICBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19zcHJlYWQgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICB9cmV0dXJuIGFyO1xufTtcblxuXG5cbnZhciBMQU5HX1BSRUZJWCA9ICckdnVldGlmeS4nO1xudmFyIGZhbGxiYWNrID0gU3ltYm9sKCdMYW5nIGZhbGxiYWNrJyk7XG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbihsb2NhbGUsIGtleSwgdXNpbmdGYWxsYmFjaykge1xuICAgIGlmICh1c2luZ0ZhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgdXNpbmdGYWxsYmFjayA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgc2hvcnRLZXkgPSBrZXkucmVwbGFjZShMQU5HX1BSRUZJWCwgJycpO1xuICAgIHZhciB0cmFuc2xhdGlvbiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJnZXRPYmplY3RWYWx1ZUJ5UGF0aFwiXSkobG9jYWxlLCBzaG9ydEtleSwgZmFsbGJhY2spO1xuICAgIGlmICh0cmFuc2xhdGlvbiA9PT0gZmFsbGJhY2spIHtcbiAgICAgICAgaWYgKHVzaW5nRmFsbGJhY2spIHtcbiAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJjb25zb2xlRXJyb3JcIl0pKFwiVHJhbnNsYXRpb24ga2V5IFxcXCJcIiArIHNob3J0S2V5ICsgXCJcXFwiIG5vdCBmb3VuZCBpbiBmYWxsYmFja1wiKTtcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uID0ga2V5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImNvbnNvbGVXYXJuXCJdKShcIlRyYW5zbGF0aW9uIGtleSBcXFwiXCIgKyBzaG9ydEtleSArIFwiXFxcIiBub3QgZm91bmQsIGZhbGxpbmcgYmFjayB0byBkZWZhdWx0XCIpO1xuICAgICAgICAgICAgdHJhbnNsYXRpb24gPSBnZXRUcmFuc2xhdGlvbihfbG9jYWxlX2VuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLCBrZXksIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2xhdGlvbjtcbn1cbmZ1bmN0aW9uIGxhbmcoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbmZpZyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbGVzOiBPYmplY3QuYXNzaWduKHsgZW46IF9sb2NhbGVfZW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0gfSwgY29uZmlnLmxvY2FsZXMpLFxuICAgICAgICBjdXJyZW50OiBjb25maWcuY3VycmVudCB8fCAnZW4nLFxuICAgICAgICB0OiBmdW5jdGlvbiB0KGtleSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtleS5zdGFydHNXaXRoKExBTkdfUFJFRklYKSkgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIGlmIChjb25maWcudCkgcmV0dXJuIGNvbmZpZy50LmFwcGx5KGNvbmZpZywgX19zcHJlYWQoW2tleV0sIHBhcmFtcykpO1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gZ2V0VHJhbnNsYXRpb24odGhpcy5sb2NhbGVzW3RoaXMuY3VycmVudF0sIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb24ucmVwbGFjZSgvXFx7KFxcZCspXFx9L2csIGZ1bmN0aW9uIChtYXRjaCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHBhcmFtc1sraW5kZXhdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WdWV0aWZ5L21peGlucy9vcHRpb25zLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1Z1ZXRpZnkvbWl4aW5zL29wdGlvbnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9wdGlvbnM7IH0pO1xudmFyIE9QVElPTlNfREVGQVVMVFMgPSB7XG4gICAgbWluaWZ5VGhlbWU6IG51bGwsXG4gICAgdGhlbWVDYWNoZTogbnVsbCxcbiAgICBjdXN0b21Qcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICBjc3BOb25jZTogbnVsbFxufTtcbmZ1bmN0aW9uIG9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgT1BUSU9OU19ERUZBVUxUUywgb3B0aW9ucyk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvVnVldGlmeS9taXhpbnMvdGhlbWUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL1Z1ZXRpZnkvbWl4aW5zL3RoZW1lLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhlbWU7IH0pO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuLyogZXNsaW50LWRpc2FibGUgbm8tbXVsdGktc3BhY2VzICovXG52YXIgVEhFTUVfREVGQVVMVFMgPSB7XG4gICAgcHJpbWFyeTogJyMxOTc2RDInLFxuICAgIHNlY29uZGFyeTogJyM0MjQyNDInLFxuICAgIGFjY2VudDogJyM4MkIxRkYnLFxuICAgIGVycm9yOiAnI0ZGNTI1MicsXG4gICAgaW5mbzogJyMyMTk2RjMnLFxuICAgIHN1Y2Nlc3M6ICcjNENBRjUwJyxcbiAgICB3YXJuaW5nOiAnI0ZGQzEwNycgLy8gYW1iZXIuYmFzZVxufTtcbmZ1bmN0aW9uIHRoZW1lKHRoZW1lKSB7XG4gICAgaWYgKHRoZW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhlbWUgPSB7fTtcbiAgICB9XG4gICAgaWYgKHRoZW1lID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBfX2Fzc2lnbih7fSwgVEhFTUVfREVGQVVMVFMsIHRoZW1lKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy9WdWV0aWZ5L3V0aWwvZ29Uby5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvVnVldGlmeS91dGlsL2dvVG8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnb1RvOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9lYXNpbmdfcGF0dGVybnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uLy4uL3V0aWwvZWFzaW5nLXBhdHRlcm5zICovIFwiLi9zcmMvdXRpbC9lYXNpbmctcGF0dGVybnMuanNcIik7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBkdXJhdGlvbjogNTAwLFxuICAgIG9mZnNldDogMCxcbiAgICBlYXNpbmc6ICdlYXNlSW5PdXRDdWJpYydcbn07XG5mdW5jdGlvbiBnZXREb2N1bWVudEhlaWdodCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0LCBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLmNsaWVudEhlaWdodDtcbn1cbmZ1bmN0aW9uIGlzVnVlQ29tcG9uZW50KG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmouX2lzVnVlO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0TG9jYXRpb24odGFyZ2V0LCBzZXR0aW5ncykge1xuICAgIHZhciBsb2NhdGlvbjtcbiAgICBpZiAoaXNWdWVDb21wb25lbnQodGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQuJGVsO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICBsb2NhdGlvbiA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdGFyZ2V0RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgICAgIGlmICghdGFyZ2V0RWwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUYXJnZXQgZWxlbWVudCBcXFwiXCIgKyB0YXJnZXQgKyBcIlxcXCIgbm90IGZvdW5kLlwiKTtcbiAgICAgICAgbG9jYXRpb24gPSB0YXJnZXRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBsb2NhdGlvbiA9IHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdHlwZSA9IHRhcmdldCA9PSBudWxsID8gdGFyZ2V0IDogdGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUYXJnZXQgbXVzdCBiZSBhIFNlbGVjdG9yL051bWJlci9ET01FbGVtZW50L1Z1ZUNvbXBvbmVudCwgcmVjZWl2ZWQgXCIgKyB0eXBlICsgXCIgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWluKE1hdGgubWF4KGxvY2F0aW9uICsgc2V0dGluZ3Mub2Zmc2V0LCAwKSwgZ2V0RG9jdW1lbnRIZWlnaHQoKSAtIGdldFdpbmRvd0hlaWdodCgpKSk7XG59XG5mdW5jdGlvbiBnb1RvKHRhcmdldCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHJlamVjdCgnV2luZG93IGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdmFyIHN0YXJ0TG9jYXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHZhciB0YXJnZXRMb2NhdGlvbiA9IGdldFRhcmdldExvY2F0aW9uKHRhcmdldCwgc2V0dGluZ3MpO1xuICAgICAgICB2YXIgZGlzdGFuY2VUb1Njcm9sbCA9IHRhcmdldExvY2F0aW9uIC0gc3RhcnRMb2NhdGlvbjtcbiAgICAgICAgdmFyIGVhc2luZ0Z1bmN0aW9uID0gdHlwZW9mIHNldHRpbmdzLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJyA/IHNldHRpbmdzLmVhc2luZyA6IF91dGlsX2Vhc2luZ19wYXR0ZXJuc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW3NldHRpbmdzLmVhc2luZ107XG4gICAgICAgIGlmICghZWFzaW5nRnVuY3Rpb24pIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFYXNpbmcgZnVuY3Rpb24gJ1wiICsgc2V0dGluZ3MuZWFzaW5nICsgXCInIG5vdCBmb3VuZC5cIik7XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAoY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc1BlcmNlbnRhZ2UgPSBNYXRoLm1pbigxLCAoY3VycmVudFRpbWUgLSBzdGFydFRpbWUpIC8gc2V0dGluZ3MuZHVyYXRpb24pO1xuICAgICAgICAgICAgdmFyIHRhcmdldFBvc2l0aW9uID0gTWF0aC5mbG9vcihzdGFydExvY2F0aW9uICsgZGlzdGFuY2VUb1Njcm9sbCAqIGVhc2luZ0Z1bmN0aW9uKHByb2dyZXNzUGVyY2VudGFnZSkpO1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHRhcmdldFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChNYXRoLnJvdW5kKHdpbmRvdy5wYWdlWU9mZnNldCkgPT09IHRhcmdldExvY2F0aW9uIHx8IHByb2dyZXNzUGVyY2VudGFnZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgfSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvaW5kZXgudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVkFwcCwgVkFsZXJ0LCBWQXV0b2NvbXBsZXRlLCBWQXZhdGFyLCBWQmFkZ2UsIFZCb3R0b21OYXYsIFZCb3R0b21TaGVldCwgVkJyZWFkY3J1bWJzLCBWQnJlYWRjcnVtYnNJdGVtLCBWQnJlYWRjcnVtYnNEaXZpZGVyLCBWQnRuLCBWQnRuVG9nZ2xlLCBWQ2FyZCwgVkNhcmRNZWRpYSwgVkNhcmRUaXRsZSwgVkNhcmRBY3Rpb25zLCBWQ2FyZFRleHQsIFZDYXJvdXNlbCwgVkNhcm91c2VsSXRlbSwgVkNoZWNrYm94LCBWQ2hpcCwgVkNvbWJvYm94LCBWQ291bnRlciwgVkRhdGFJdGVyYXRvciwgVkRhdGFUYWJsZSwgVkVkaXREaWFsb2csIFZUYWJsZU92ZXJmbG93LCBWRGF0ZVBpY2tlciwgVkRhdGVQaWNrZXJUaXRsZSwgVkRhdGVQaWNrZXJIZWFkZXIsIFZEYXRlUGlja2VyRGF0ZVRhYmxlLCBWRGF0ZVBpY2tlck1vbnRoVGFibGUsIFZEYXRlUGlja2VyWWVhcnMsIFZEaWFsb2csIFZEaXZpZGVyLCBWRXhwYW5zaW9uUGFuZWwsIFZFeHBhbnNpb25QYW5lbENvbnRlbnQsIFZGb290ZXIsIFZGb3JtLCBWQ29udGFpbmVyLCBWQ29udGVudCwgVkZsZXgsIFZMYXlvdXQsIFZTcGFjZXIsIFZIb3ZlciwgVkljb24sIFZJbWcsIFZJbnB1dCwgVkl0ZW0sIFZJdGVtR3JvdXAsIFZKdW1ib3Ryb24sIFZMYWJlbCwgVkxpc3QsIFZMaXN0R3JvdXAsIFZMaXN0VGlsZSwgVkxpc3RUaWxlQWN0aW9uLCBWTGlzdFRpbGVBdmF0YXIsIFZMaXN0VGlsZUFjdGlvblRleHQsIFZMaXN0VGlsZUNvbnRlbnQsIFZMaXN0VGlsZVRpdGxlLCBWTGlzdFRpbGVTdWJUaXRsZSwgVk1lbnUsIFZNZXNzYWdlcywgVk5hdmlnYXRpb25EcmF3ZXIsIFZPdmVyZmxvd0J0biwgVlBhZ2luYXRpb24sIFZQYXJhbGxheCwgVlBpY2tlciwgVlByb2dyZXNzQ2lyY3VsYXIsIFZQcm9ncmVzc0xpbmVhciwgVlJhZGlvR3JvdXAsIFZSYWRpbywgVlJhbmdlU2xpZGVyLCBWUmF0aW5nLCBWUmVzcG9uc2l2ZSwgVlNlbGVjdCwgVlNsaWRlciwgVlNuYWNrYmFyLCBWU3BlZWREaWFsLCBWU3RlcHBlciwgVlN0ZXBwZXJDb250ZW50LCBWU3RlcHBlclN0ZXAsIFZTdGVwcGVySGVhZGVyLCBWU3RlcHBlckl0ZW1zLCBWU3ViaGVhZGVyLCBWU3dpdGNoLCBWU3lzdGVtQmFyLCBWVGFicywgVlRhYiwgVlRhYkl0ZW0sIFZUYWJzSXRlbXMsIFZUYWJzU2xpZGVyLCBWVGV4dGFyZWEsIFZUZXh0RmllbGQsIFZUaW1lbGluZSwgVlRpbWVsaW5lSXRlbSwgVlRpbWVQaWNrZXIsIFZUaW1lUGlja2VyQ2xvY2ssIFZUaW1lUGlja2VyVGl0bGUsIFZUb29sYmFyLCBWVG9vbGJhclNpZGVJY29uLCBWVG9vbGJhclRpdGxlLCBWVG9vbGJhckl0ZW1zLCBWVG9vbHRpcCwgVlRyZWV2aWV3LCBWVHJlZXZpZXdOb2RlLCBWV2luZG93LCBWV2luZG93SXRlbSwgVkJvdHRvbVNoZWV0VHJhbnNpdGlvbiwgVkNhcm91c2VsVHJhbnNpdGlvbiwgVkNhcm91c2VsUmV2ZXJzZVRyYW5zaXRpb24sIFZUYWJUcmFuc2l0aW9uLCBWVGFiUmV2ZXJzZVRyYW5zaXRpb24sIFZNZW51VHJhbnNpdGlvbiwgVkZhYlRyYW5zaXRpb24sIFZEaWFsb2dUcmFuc2l0aW9uLCBWRGlhbG9nQm90dG9tVHJhbnNpdGlvbiwgVkZhZGVUcmFuc2l0aW9uLCBWU2NhbGVUcmFuc2l0aW9uLCBWU2Nyb2xsWFRyYW5zaXRpb24sIFZTY3JvbGxYUmV2ZXJzZVRyYW5zaXRpb24sIFZTY3JvbGxZVHJhbnNpdGlvbiwgVlNjcm9sbFlSZXZlcnNlVHJhbnNpdGlvbiwgVlNsaWRlWFRyYW5zaXRpb24sIFZTbGlkZVhSZXZlcnNlVHJhbnNpdGlvbiwgVlNsaWRlWVRyYW5zaXRpb24sIFZTbGlkZVlSZXZlcnNlVHJhbnNpdGlvbiwgVkV4cGFuZFRyYW5zaXRpb24sIFZSb3dFeHBhbmRUcmFuc2l0aW9uICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQXBwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZBcHAgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZBcHAvaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQXBwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZBcHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIlZBcHBcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZBbGVydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQWxlcnQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZBbGVydC9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZBbGVydFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQWxlcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcIlZBbGVydFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkF1dG9jb21wbGV0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQXV0b2NvbXBsZXRlICovIFwiLi9zcmMvY29tcG9uZW50cy9WQXV0b2NvbXBsZXRlL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkF1dG9jb21wbGV0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQXV0b2NvbXBsZXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJWQXV0b2NvbXBsZXRlXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQXZhdGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZBdmF0YXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZBdmF0YXIvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQXZhdGFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZBdmF0YXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIlZBdmF0YXJcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZCYWRnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQmFkZ2UgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZCYWRnZS9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZCYWRnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQmFkZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcIlZCYWRnZVwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkJvdHRvbU5hdl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQm90dG9tTmF2ICovIFwiLi9zcmMvY29tcG9uZW50cy9WQm90dG9tTmF2L2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkJvdHRvbU5hdlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQm90dG9tTmF2X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJWQm90dG9tTmF2XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQm90dG9tU2hlZXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkJvdHRvbVNoZWV0ICovIFwiLi9zcmMvY29tcG9uZW50cy9WQm90dG9tU2hlZXQvaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQm90dG9tU2hlZXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkJvdHRvbVNoZWV0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJWQm90dG9tU2hlZXRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZCcmVhZGNydW1ic19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQnJlYWRjcnVtYnMgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZCcmVhZGNydW1icy9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZCcmVhZGNydW1ic1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQnJlYWRjcnVtYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIlZCcmVhZGNydW1ic1wiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZCcmVhZGNydW1ic0l0ZW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkJyZWFkY3J1bWJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJWQnJlYWRjcnVtYnNJdGVtXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkJyZWFkY3J1bWJzRGl2aWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQnJlYWRjcnVtYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcIlZCcmVhZGNydW1ic0RpdmlkZXJcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZCdG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkJ0biAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkJ0bi9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZCdG5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkJ0bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiVkJ0blwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkJ0blRvZ2dsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WQnRuVG9nZ2xlICovIFwiLi9zcmMvY29tcG9uZW50cy9WQnRuVG9nZ2xlL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkJ0blRvZ2dsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQnRuVG9nZ2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJWQnRuVG9nZ2xlXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQ2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkNhcmQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDYXJkL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNhcmRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNhcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJWQ2FyZFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZDYXJkTWVkaWFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNhcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJWQ2FyZE1lZGlhXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNhcmRUaXRsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQ2FyZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1tcIlZDYXJkVGl0bGVcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQ2FyZEFjdGlvbnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNhcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJWQ2FyZEFjdGlvbnNcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQ2FyZFRleHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNhcmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bXCJWQ2FyZFRleHRcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZDYXJvdXNlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkNhcm91c2VsICovIFwiLi9zcmMvY29tcG9uZW50cy9WQ2Fyb3VzZWwvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQ2Fyb3VzZWxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNhcm91c2VsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fW1wiVkNhcm91c2VsXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNhcm91c2VsSXRlbVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WQ2Fyb3VzZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bXCJWQ2Fyb3VzZWxJdGVtXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQ2hlY2tib3hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZDaGVja2JveCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkNoZWNrYm94L2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNoZWNrYm94XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZDaGVja2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTJfX1tcIlZDaGVja2JveFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkNoaXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZDaGlwICovIFwiLi9zcmMvY29tcG9uZW50cy9WQ2hpcC9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZDaGlwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZDaGlwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fW1wiVkNoaXBcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZDb21ib2JveF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkNvbWJvYm94ICovIFwiLi9zcmMvY29tcG9uZW50cy9WQ29tYm9ib3gvaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQ29tYm9ib3hcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNvbWJvYm94X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fW1wiVkNvbWJvYm94XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WQ291bnRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkNvdW50ZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZDb3VudGVyL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNvdW50ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkNvdW50ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bXCJWQ291bnRlclwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkRhdGFJdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkRhdGFJdGVyYXRvciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRhdGFJdGVyYXRvci9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZEYXRhSXRlcmF0b3JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGFJdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1tcIlZEYXRhSXRlcmF0b3JcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZEYXRhVGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZEYXRhVGFibGUgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRhVGFibGUvaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRGF0YVRhYmxlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZEYXRhVGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X19bXCJWRGF0YVRhYmxlXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkVkaXREaWFsb2dcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGFUYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTdfX1tcIlZFZGl0RGlhbG9nXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRhYmxlT3ZlcmZsb3dcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGFUYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTdfX1tcIlZUYWJsZU92ZXJmbG93XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WRGF0ZVBpY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMThfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkRhdGVQaWNrZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZEYXRlUGlja2VyL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkRhdGVQaWNrZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGVQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X19bXCJWRGF0ZVBpY2tlclwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZEYXRlUGlja2VyVGl0bGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGVQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X19bXCJWRGF0ZVBpY2tlclRpdGxlXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkRhdGVQaWNrZXJIZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGVQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X19bXCJWRGF0ZVBpY2tlckhlYWRlclwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZEYXRlUGlja2VyRGF0ZVRhYmxlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZEYXRlUGlja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOF9fW1wiVkRhdGVQaWNrZXJEYXRlVGFibGVcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRGF0ZVBpY2tlck1vbnRoVGFibGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRhdGVQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X19bXCJWRGF0ZVBpY2tlck1vbnRoVGFibGVcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRGF0ZVBpY2tlclllYXJzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZEYXRlUGlja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOF9fW1wiVkRhdGVQaWNrZXJZZWFyc1wiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkRpYWxvZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkRpYWxvZyAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRpYWxvZy9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZEaWFsb2dcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkRpYWxvZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTlfX1tcIlZEaWFsb2dcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZEaXZpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WRGl2aWRlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkRpdmlkZXIvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRGl2aWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WRGl2aWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjBfX1tcIlZEaXZpZGVyXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WRXhwYW5zaW9uUGFuZWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzIxX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZFeHBhbnNpb25QYW5lbCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkV4cGFuc2lvblBhbmVsL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkV4cGFuc2lvblBhbmVsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZFeHBhbnNpb25QYW5lbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjFfX1tcIlZFeHBhbnNpb25QYW5lbFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZFeHBhbnNpb25QYW5lbENvbnRlbnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkV4cGFuc2lvblBhbmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yMV9fW1wiVkV4cGFuc2lvblBhbmVsQ29udGVudFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkZvb3Rlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkZvb3RlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkZvb3Rlci9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZGb290ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkZvb3Rlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjJfX1tcIlZGb290ZXJcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZGb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WRm9ybSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkZvcm0vaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRm9ybVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WRm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjNfX1tcIlZGb3JtXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WR3JpZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkdyaWQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZHcmlkL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNvbnRhaW5lclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WR3JpZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjRfX1tcIlZDb250YWluZXJcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQ29udGVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WR3JpZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjRfX1tcIlZDb250ZW50XCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkZsZXhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkdyaWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI0X19bXCJWRmxleFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZMYXlvdXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkdyaWRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI0X19bXCJWTGF5b3V0XCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNwYWNlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WR3JpZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjRfX1tcIlZTcGFjZXJcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZIb3Zlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkhvdmVyICovIFwiLi9zcmMvY29tcG9uZW50cy9WSG92ZXIvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWSG92ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkhvdmVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yNV9fW1wiVkhvdmVyXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkljb24gKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJY29uL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkljb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkljb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzI2X19bXCJWSWNvblwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkltZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkltZyAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkltZy9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZJbWdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkltZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjdfX1tcIlZJbWdcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZJbnB1dF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVklucHV0ICovIFwiLi9zcmMvY29tcG9uZW50cy9WSW5wdXQvaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWSW5wdXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVklucHV0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yOF9fW1wiVklucHV0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WSXRlbUdyb3VwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WSXRlbUdyb3VwICovIFwiLi9zcmMvY29tcG9uZW50cy9WSXRlbUdyb3VwL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkl0ZW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkl0ZW1Hcm91cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMjlfX1tcIlZJdGVtXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkl0ZW1Hcm91cFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WSXRlbUdyb3VwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yOV9fW1wiVkl0ZW1Hcm91cFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVkp1bWJvdHJvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkp1bWJvdHJvbiAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVkp1bWJvdHJvbi9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZKdW1ib3Ryb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkp1bWJvdHJvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzBfX1tcIlZKdW1ib3Ryb25cIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZMYWJlbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkxhYmVsICovIFwiLi9zcmMvY29tcG9uZW50cy9WTGFiZWwvaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWTGFiZWxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkxhYmVsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zMV9fW1wiVkxhYmVsXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WTGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVkxpc3QgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZMaXN0L2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkxpc3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkxpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzMyX19bXCJWTGlzdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZMaXN0R3JvdXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVkxpc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzMyX19bXCJWTGlzdEdyb3VwXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkxpc3RUaWxlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zMl9fW1wiVkxpc3RUaWxlXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkxpc3RUaWxlQWN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zMl9fW1wiVkxpc3RUaWxlQWN0aW9uXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkxpc3RUaWxlQXZhdGFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zMl9fW1wiVkxpc3RUaWxlQXZhdGFyXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkxpc3RUaWxlQWN0aW9uVGV4dFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WTGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzJfX1tcIlZMaXN0VGlsZUFjdGlvblRleHRcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWTGlzdFRpbGVDb250ZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zMl9fW1wiVkxpc3RUaWxlQ29udGVudFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZMaXN0VGlsZVRpdGxlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZMaXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zMl9fW1wiVkxpc3RUaWxlVGl0bGVcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWTGlzdFRpbGVTdWJUaXRsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WTGlzdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzJfX1tcIlZMaXN0VGlsZVN1YlRpdGxlXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WTWVudV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVk1lbnUgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZNZW51L2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVk1lbnVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVk1lbnVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzMzX19bXCJWTWVudVwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVk1lc3NhZ2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WTWVzc2FnZXMgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZNZXNzYWdlcy9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZNZXNzYWdlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WTWVzc2FnZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzM0X19bXCJWTWVzc2FnZXNcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZOYXZpZ2F0aW9uRHJhd2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WTmF2aWdhdGlvbkRyYXdlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk5hdmlnYXRpb25EcmF3ZXIvaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWTmF2aWdhdGlvbkRyYXdlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WTmF2aWdhdGlvbkRyYXdlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzVfX1tcIlZOYXZpZ2F0aW9uRHJhd2VyXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WT3ZlcmZsb3dCdG5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzM2X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZPdmVyZmxvd0J0biAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVk92ZXJmbG93QnRuL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVk92ZXJmbG93QnRuXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZPdmVyZmxvd0J0bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzZfX1tcIlZPdmVyZmxvd0J0blwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlBhZ2luYXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzM3X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZQYWdpbmF0aW9uICovIFwiLi9zcmMvY29tcG9uZW50cy9WUGFnaW5hdGlvbi9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZQYWdpbmF0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZQYWdpbmF0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zN19fW1wiVlBhZ2luYXRpb25cIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZQYXJhbGxheF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlBhcmFsbGF4ICovIFwiLi9zcmMvY29tcG9uZW50cy9WUGFyYWxsYXgvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWUGFyYWxsYXhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlBhcmFsbGF4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zOF9fW1wiVlBhcmFsbGF4XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WUGlja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WUGlja2VyICovIFwiLi9zcmMvY29tcG9uZW50cy9WUGlja2VyL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlBpY2tlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WUGlja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zOV9fW1wiVlBpY2tlclwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlByb2dyZXNzQ2lyY3VsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzQwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZQcm9ncmVzc0NpcmN1bGFyICovIFwiLi9zcmMvY29tcG9uZW50cy9WUHJvZ3Jlc3NDaXJjdWxhci9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZQcm9ncmVzc0NpcmN1bGFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZQcm9ncmVzc0NpcmN1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80MF9fW1wiVlByb2dyZXNzQ2lyY3VsYXJcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZQcm9ncmVzc0xpbmVhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNDFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlByb2dyZXNzTGluZWFyICovIFwiLi9zcmMvY29tcG9uZW50cy9WUHJvZ3Jlc3NMaW5lYXIvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWUHJvZ3Jlc3NMaW5lYXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlByb2dyZXNzTGluZWFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80MV9fW1wiVlByb2dyZXNzTGluZWFyXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WUmFkaW9Hcm91cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNDJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlJhZGlvR3JvdXAgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZSYWRpb0dyb3VwL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlJhZGlvR3JvdXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlJhZGlvR3JvdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzQyX19bXCJWUmFkaW9Hcm91cFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZSYWRpb1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WUmFkaW9Hcm91cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNDJfX1tcIlZSYWRpb1wiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlJhbmdlU2xpZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80M19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WUmFuZ2VTbGlkZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZSYW5nZVNsaWRlci9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZSYW5nZVNsaWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WUmFuZ2VTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzQzX19bXCJWUmFuZ2VTbGlkZXJcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZSYXRpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzQ0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZSYXRpbmcgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZSYXRpbmcvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWUmF0aW5nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZSYXRpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzQ0X19bXCJWUmF0aW5nXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WUmVzcG9uc2l2ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNDVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlJlc3BvbnNpdmUgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZSZXNwb25zaXZlL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlJlc3BvbnNpdmVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlJlc3BvbnNpdmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzQ1X19bXCJWUmVzcG9uc2l2ZVwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNDZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlNlbGVjdCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlNlbGVjdC9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZTZWxlY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlNlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNDZfX1tcIlZTZWxlY3RcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzQ3X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZTbGlkZXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTbGlkZXIvaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU2xpZGVyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZTbGlkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzQ3X19bXCJWU2xpZGVyXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WU25hY2tiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzQ4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZTbmFja2JhciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlNuYWNrYmFyL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNuYWNrYmFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZTbmFja2Jhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNDhfX1tcIlZTbmFja2JhclwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlNwZWVkRGlhbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNDlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlNwZWVkRGlhbCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlNwZWVkRGlhbC9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZTcGVlZERpYWxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlNwZWVkRGlhbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNDlfX1tcIlZTcGVlZERpYWxcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZTdGVwcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81MF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WU3RlcHBlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlN0ZXBwZXIvaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU3RlcHBlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WU3RlcHBlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNTBfX1tcIlZTdGVwcGVyXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlN0ZXBwZXJDb250ZW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZTdGVwcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81MF9fW1wiVlN0ZXBwZXJDb250ZW50XCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlN0ZXBwZXJTdGVwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZTdGVwcGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81MF9fW1wiVlN0ZXBwZXJTdGVwXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlN0ZXBwZXJIZWFkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlN0ZXBwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzUwX19bXCJWU3RlcHBlckhlYWRlclwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZTdGVwcGVySXRlbXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlN0ZXBwZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzUwX19bXCJWU3RlcHBlckl0ZW1zXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WU3ViaGVhZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81MV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WU3ViaGVhZGVyICovIFwiLi9zcmMvY29tcG9uZW50cy9WU3ViaGVhZGVyL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlN1YmhlYWRlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WU3ViaGVhZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81MV9fW1wiVlN1YmhlYWRlclwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlN3aXRjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNTJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlN3aXRjaCAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlN3aXRjaC9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZTd2l0Y2hcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlN3aXRjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNTJfX1tcIlZTd2l0Y2hcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZTeXN0ZW1CYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzUzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZTeXN0ZW1CYXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTeXN0ZW1CYXIvaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU3lzdGVtQmFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZTeXN0ZW1CYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzUzX19bXCJWU3lzdGVtQmFyXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WVGFic19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRhYnMgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUYWJzL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRhYnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU0X19bXCJWVGFic1wiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUYWJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU0X19bXCJWVGFiXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRhYkl0ZW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU0X19bXCJWVGFiSXRlbVwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUYWJzSXRlbXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU0X19bXCJWVGFic0l0ZW1zXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRhYnNTbGlkZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRhYnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU0X19bXCJWVGFic1NsaWRlclwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRleHRhcmVhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81NV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WVGV4dGFyZWEgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUZXh0YXJlYS9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUZXh0YXJlYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WVGV4dGFyZWFfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU1X19bXCJWVGV4dGFyZWFcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUZXh0RmllbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU2X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZUZXh0RmllbGQgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUZXh0RmllbGQvaW5kZXguanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWVGV4dEZpZWxkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZUZXh0RmllbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU2X19bXCJWVGV4dEZpZWxkXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WVGltZWxpbmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU3X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZUaW1lbGluZSAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlRpbWVsaW5lL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRpbWVsaW5lXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZUaW1lbGluZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNTdfX1tcIlZUaW1lbGluZVwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUaW1lbGluZUl0ZW1cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRpbWVsaW5lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81N19fW1wiVlRpbWVsaW5lSXRlbVwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRpbWVQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZUaW1lUGlja2VyICovIFwiLi9zcmMvY29tcG9uZW50cy9WVGltZVBpY2tlci9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUaW1lUGlja2VyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZUaW1lUGlja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81OF9fW1wiVlRpbWVQaWNrZXJcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWVGltZVBpY2tlckNsb2NrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZUaW1lUGlja2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81OF9fW1wiVlRpbWVQaWNrZXJDbG9ja1wiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUaW1lUGlja2VyVGl0bGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRpbWVQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU4X19bXCJWVGltZVBpY2tlclRpdGxlXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WVG9vbGJhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNTlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRvb2xiYXIgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZUb29sYmFyL2luZGV4LmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRvb2xiYXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRvb2xiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU5X19bXCJWVG9vbGJhclwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUb29sYmFyU2lkZUljb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRvb2xiYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzU5X19bXCJWVG9vbGJhclNpZGVJY29uXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRvb2xiYXJUaXRsZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WVG9vbGJhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNTlfX1tcIlZUb29sYmFyVGl0bGVcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWVG9vbGJhckl0ZW1zXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZUb29sYmFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81OV9fW1wiVlRvb2xiYXJJdGVtc1wiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfVlRvb2x0aXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzYwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL1ZUb29sdGlwICovIFwiLi9zcmMvY29tcG9uZW50cy9WVG9vbHRpcC9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUb29sdGlwXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZUb29sdGlwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82MF9fW1wiVlRvb2x0aXBcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX1ZUcmVldmlld19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNjFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vVlRyZWV2aWV3ICovIFwiLi9zcmMvY29tcG9uZW50cy9WVHJlZXZpZXcvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWVHJlZXZpZXdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfVlRyZWV2aWV3X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82MV9fW1wiVlRyZWV2aWV3XCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRyZWV2aWV3Tm9kZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WVHJlZXZpZXdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzYxX19bXCJWVHJlZXZpZXdOb2RlXCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9WV2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82Ml9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9WV2luZG93ICovIFwiLi9zcmMvY29tcG9uZW50cy9WV2luZG93L2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVldpbmRvd1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9WV2luZG93X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82Ml9fW1wiVldpbmRvd1wiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZXaW5kb3dJdGVtXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX1ZXaW5kb3dfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzYyX19bXCJWV2luZG93SXRlbVwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzYzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zaXRpb25zICovIFwiLi9zcmMvY29tcG9uZW50cy90cmFuc2l0aW9ucy9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZCb3R0b21TaGVldFRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzYzX19bXCJWQm90dG9tU2hlZXRUcmFuc2l0aW9uXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNhcm91c2VsVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNjNfX1tcIlZDYXJvdXNlbFRyYW5zaXRpb25cIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQ2Fyb3VzZWxSZXZlcnNlVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNjNfX1tcIlZDYXJvdXNlbFJldmVyc2VUcmFuc2l0aW9uXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRhYlRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzYzX19bXCJWVGFiVHJhbnNpdGlvblwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZUYWJSZXZlcnNlVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNjNfX1tcIlZUYWJSZXZlcnNlVHJhbnNpdGlvblwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZNZW51VHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNjNfX1tcIlZNZW51VHJhbnNpdGlvblwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZGYWJUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3RyYW5zaXRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82M19fW1wiVkZhYlRyYW5zaXRpb25cIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRGlhbG9nVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNjNfX1tcIlZEaWFsb2dUcmFuc2l0aW9uXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkRpYWxvZ0JvdHRvbVRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzYzX19bXCJWRGlhbG9nQm90dG9tVHJhbnNpdGlvblwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZGYWRlVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNjNfX1tcIlZGYWRlVHJhbnNpdGlvblwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZTY2FsZVRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzYzX19bXCJWU2NhbGVUcmFuc2l0aW9uXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNjcm9sbFhUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3RyYW5zaXRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82M19fW1wiVlNjcm9sbFhUcmFuc2l0aW9uXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNjcm9sbFhSZXZlcnNlVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNjNfX1tcIlZTY3JvbGxYUmV2ZXJzZVRyYW5zaXRpb25cIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU2Nyb2xsWVRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzYzX19bXCJWU2Nyb2xsWVRyYW5zaXRpb25cIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU2Nyb2xsWVJldmVyc2VUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3RyYW5zaXRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82M19fW1wiVlNjcm9sbFlSZXZlcnNlVHJhbnNpdGlvblwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZTbGlkZVhUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3RyYW5zaXRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82M19fW1wiVlNsaWRlWFRyYW5zaXRpb25cIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU2xpZGVYUmV2ZXJzZVRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzYzX19bXCJWU2xpZGVYUmV2ZXJzZVRyYW5zaXRpb25cIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWU2xpZGVZVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90cmFuc2l0aW9uc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNjNfX1tcIlZTbGlkZVlUcmFuc2l0aW9uXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNsaWRlWVJldmVyc2VUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3RyYW5zaXRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82M19fW1wiVlNsaWRlWVJldmVyc2VUcmFuc2l0aW9uXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkV4cGFuZFRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfdHJhbnNpdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzYzX19bXCJWRXhwYW5kVHJhbnNpdGlvblwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZSb3dFeHBhbmRUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3RyYW5zaXRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82M19fW1wiVlJvd0V4cGFuZFRyYW5zaXRpb25cIl07IH0pO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29tcG9uZW50cy90cmFuc2l0aW9ucy9leHBhbmQtdHJhbnNpdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbXBvbmVudHMvdHJhbnNpdGlvbnMvZXhwYW5kLXRyYW5zaXRpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmdW5jdGlvbiAoZXhwYW5kZWRQYXJlbnRDbGFzcykge1xuICAgIGlmIChleHBhbmRlZFBhcmVudENsYXNzID09PSB2b2lkIDApIHtcbiAgICAgICAgZXhwYW5kZWRQYXJlbnRDbGFzcyA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIoZWwsIGRvbmUpIHtcbiAgICAgICAgICAgIGVsLl9wYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgZWwuX2hlaWdodCA9IGVsLl9oZWlnaHQgIT0gbnVsbCA/IGVsLl9oZWlnaHQgOiBlbC5zdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgICBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiYWRkT25jZUV2ZW50TGlzdGVuZXJcIl0pKGVsLCAndHJhbnNpdGlvbmVuZCcsIGRvbmUpO1xuICAgICAgICAgICAgLy8gR2V0IGhlaWdodCB0aGF0IGlzIHRvIGJlIHNjcm9sbGVkXG4gICAgICAgICAgICBlbC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgZXhwYW5kZWRQYXJlbnRDbGFzcyAmJiBlbC5fcGFyZW50LmNsYXNzTGlzdC5hZGQoZXhwYW5kZWRQYXJlbnRDbGFzcyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBlbC5faGVpZ2h0IHx8ICghZWwuc2Nyb2xsSGVpZ2h0ID8gJ2F1dG8nIDogZWwuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFmdGVyRW50ZXI6IGZ1bmN0aW9uIGFmdGVyRW50ZXIoZWwpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLm92ZXJmbG93ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIElmIHVzZXIgc3VwcGxpZWQgaGVpZ2h0XG4gICAgICAgICAgICAvLyBsZWF2ZSBpdFxuICAgICAgICAgICAgaWYgKGVsLl9oZWlnaHQpIHJldHVybjtcbiAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGxlYXZlOiBmdW5jdGlvbiBsZWF2ZShlbCwgZG9uZSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGluaXRpYWwgdHJhbnNpdGlvblxuICAgICAgICAgICAgT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImFkZE9uY2VFdmVudExpc3RlbmVyXCJdKShlbCwgJ3RyYW5zaXRpb25lbmQnLCBkb25lKTtcbiAgICAgICAgICAgIC8vIFNldCBoZWlnaHQgYmVmb3JlIHdlIHRyYW5zaXRpb24gdG8gMFxuICAgICAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIC8vIElmIG5vIHVzZXIgc3VwcGxpZWQgaGVpZ2h0XG4gICAgICAgICAgICAvLyBwYXNzIGluIHRoZSBzY3JvbGxIZWlnaHRcbiAgICAgICAgICAgIGlmICghZWwuX2hlaWdodCkge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGVsLnNjcm9sbEhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5zdHlsZS5oZWlnaHQgPSAwO1xuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWZ0ZXJMZWF2ZTogZnVuY3Rpb24gYWZ0ZXJMZWF2ZShlbCkge1xuICAgICAgICAgICAgZXhwYW5kZWRQYXJlbnRDbGFzcyAmJiBlbC5fcGFyZW50ICYmIGVsLl9wYXJlbnQuY2xhc3NMaXN0LnJlbW92ZShleHBhbmRlZFBhcmVudENsYXNzKTtcbiAgICAgICAgICAgIC8vIElmIHVzZXIgc3VwcGxpZWQgaGVpZ2h0XG4gICAgICAgICAgICAvLyBsZWF2ZSBpdFxuICAgICAgICAgICAgaWYgKGVsLl9oZWlnaHQpIHJldHVybjtcbiAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2NvbXBvbmVudHMvdHJhbnNpdGlvbnMvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9jb21wb25lbnRzL3RyYW5zaXRpb25zL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogVkJvdHRvbVNoZWV0VHJhbnNpdGlvbiwgVkNhcm91c2VsVHJhbnNpdGlvbiwgVkNhcm91c2VsUmV2ZXJzZVRyYW5zaXRpb24sIFZUYWJUcmFuc2l0aW9uLCBWVGFiUmV2ZXJzZVRyYW5zaXRpb24sIFZNZW51VHJhbnNpdGlvbiwgVkZhYlRyYW5zaXRpb24sIFZEaWFsb2dUcmFuc2l0aW9uLCBWRGlhbG9nQm90dG9tVHJhbnNpdGlvbiwgVkZhZGVUcmFuc2l0aW9uLCBWU2NhbGVUcmFuc2l0aW9uLCBWU2Nyb2xsWFRyYW5zaXRpb24sIFZTY3JvbGxYUmV2ZXJzZVRyYW5zaXRpb24sIFZTY3JvbGxZVHJhbnNpdGlvbiwgVlNjcm9sbFlSZXZlcnNlVHJhbnNpdGlvbiwgVlNsaWRlWFRyYW5zaXRpb24sIFZTbGlkZVhSZXZlcnNlVHJhbnNpdGlvbiwgVlNsaWRlWVRyYW5zaXRpb24sIFZTbGlkZVlSZXZlcnNlVHJhbnNpdGlvbiwgVkV4cGFuZFRyYW5zaXRpb24sIFZSb3dFeHBhbmRUcmFuc2l0aW9uLCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZCb3R0b21TaGVldFRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWQm90dG9tU2hlZXRUcmFuc2l0aW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWQ2Fyb3VzZWxUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVkNhcm91c2VsVHJhbnNpdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVkNhcm91c2VsUmV2ZXJzZVRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWQ2Fyb3VzZWxSZXZlcnNlVHJhbnNpdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRhYlRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWVGFiVHJhbnNpdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlRhYlJldmVyc2VUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVlRhYlJldmVyc2VUcmFuc2l0aW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWTWVudVRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWTWVudVRyYW5zaXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZGYWJUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVkZhYlRyYW5zaXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZEaWFsb2dUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVkRpYWxvZ1RyYW5zaXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZEaWFsb2dCb3R0b21UcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVkRpYWxvZ0JvdHRvbVRyYW5zaXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZGYWRlVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZGYWRlVHJhbnNpdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNjYWxlVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZTY2FsZVRyYW5zaXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZTY3JvbGxYVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZTY3JvbGxYVHJhbnNpdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNjcm9sbFhSZXZlcnNlVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZTY3JvbGxYUmV2ZXJzZVRyYW5zaXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZTY3JvbGxZVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZTY3JvbGxZVHJhbnNpdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNjcm9sbFlSZXZlcnNlVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZTY3JvbGxZUmV2ZXJzZVRyYW5zaXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZTbGlkZVhUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVlNsaWRlWFRyYW5zaXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlZTbGlkZVhSZXZlcnNlVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZTbGlkZVhSZXZlcnNlVHJhbnNpdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNsaWRlWVRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBWU2xpZGVZVHJhbnNpdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVlNsaWRlWVJldmVyc2VUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVlNsaWRlWVJldmVyc2VUcmFuc2l0aW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWRXhwYW5kVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZFeHBhbmRUcmFuc2l0aW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJWUm93RXhwYW5kVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFZSb3dFeHBhbmRUcmFuc2l0aW9uOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V4cGFuZF90cmFuc2l0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V4cGFuZC10cmFuc2l0aW9uICovIFwiLi9zcmMvY29tcG9uZW50cy90cmFuc2l0aW9ucy9leHBhbmQtdHJhbnNpdGlvbi5qc1wiKTtcblxuXG4vLyBDb21wb25lbnQgc3BlY2lmaWMgdHJhbnNpdGlvbnNcbnZhciBWQm90dG9tU2hlZXRUcmFuc2l0aW9uID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZVRyYW5zaXRpb25cIl0pKCdib3R0b20tc2hlZXQtdHJhbnNpdGlvbicpO1xudmFyIFZDYXJvdXNlbFRyYW5zaXRpb24gPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY3JlYXRlU2ltcGxlVHJhbnNpdGlvblwiXSkoJ2Nhcm91c2VsLXRyYW5zaXRpb24nKTtcbnZhciBWQ2Fyb3VzZWxSZXZlcnNlVHJhbnNpdGlvbiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVTaW1wbGVUcmFuc2l0aW9uXCJdKSgnY2Fyb3VzZWwtcmV2ZXJzZS10cmFuc2l0aW9uJyk7XG52YXIgVlRhYlRyYW5zaXRpb24gPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY3JlYXRlU2ltcGxlVHJhbnNpdGlvblwiXSkoJ3RhYi10cmFuc2l0aW9uJyk7XG52YXIgVlRhYlJldmVyc2VUcmFuc2l0aW9uID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZVRyYW5zaXRpb25cIl0pKCd0YWItcmV2ZXJzZS10cmFuc2l0aW9uJyk7XG52YXIgVk1lbnVUcmFuc2l0aW9uID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZVRyYW5zaXRpb25cIl0pKCdtZW51LXRyYW5zaXRpb24nKTtcbnZhciBWRmFiVHJhbnNpdGlvbiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVTaW1wbGVUcmFuc2l0aW9uXCJdKSgnZmFiLXRyYW5zaXRpb24nLCAnY2VudGVyIGNlbnRlcicsICdvdXQtaW4nKTtcbi8vIEdlbmVyaWMgdHJhbnNpdGlvbnNcbnZhciBWRGlhbG9nVHJhbnNpdGlvbiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVTaW1wbGVUcmFuc2l0aW9uXCJdKSgnZGlhbG9nLXRyYW5zaXRpb24nKTtcbnZhciBWRGlhbG9nQm90dG9tVHJhbnNpdGlvbiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVTaW1wbGVUcmFuc2l0aW9uXCJdKSgnZGlhbG9nLWJvdHRvbS10cmFuc2l0aW9uJyk7XG52YXIgVkZhZGVUcmFuc2l0aW9uID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZVRyYW5zaXRpb25cIl0pKCdmYWRlLXRyYW5zaXRpb24nKTtcbnZhciBWU2NhbGVUcmFuc2l0aW9uID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZVRyYW5zaXRpb25cIl0pKCdzY2FsZS10cmFuc2l0aW9uJyk7XG52YXIgVlNjcm9sbFhUcmFuc2l0aW9uID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZVRyYW5zaXRpb25cIl0pKCdzY3JvbGwteC10cmFuc2l0aW9uJyk7XG52YXIgVlNjcm9sbFhSZXZlcnNlVHJhbnNpdGlvbiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVTaW1wbGVUcmFuc2l0aW9uXCJdKSgnc2Nyb2xsLXgtcmV2ZXJzZS10cmFuc2l0aW9uJyk7XG52YXIgVlNjcm9sbFlUcmFuc2l0aW9uID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZVRyYW5zaXRpb25cIl0pKCdzY3JvbGwteS10cmFuc2l0aW9uJyk7XG52YXIgVlNjcm9sbFlSZXZlcnNlVHJhbnNpdGlvbiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVTaW1wbGVUcmFuc2l0aW9uXCJdKSgnc2Nyb2xsLXktcmV2ZXJzZS10cmFuc2l0aW9uJyk7XG52YXIgVlNsaWRlWFRyYW5zaXRpb24gPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY3JlYXRlU2ltcGxlVHJhbnNpdGlvblwiXSkoJ3NsaWRlLXgtdHJhbnNpdGlvbicpO1xudmFyIFZTbGlkZVhSZXZlcnNlVHJhbnNpdGlvbiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVTaW1wbGVUcmFuc2l0aW9uXCJdKSgnc2xpZGUteC1yZXZlcnNlLXRyYW5zaXRpb24nKTtcbnZhciBWU2xpZGVZVHJhbnNpdGlvbiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVTaW1wbGVUcmFuc2l0aW9uXCJdKSgnc2xpZGUteS10cmFuc2l0aW9uJyk7XG52YXIgVlNsaWRlWVJldmVyc2VUcmFuc2l0aW9uID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZVNpbXBsZVRyYW5zaXRpb25cIl0pKCdzbGlkZS15LXJldmVyc2UtdHJhbnNpdGlvbicpO1xuLy8gSmF2YVNjcmlwdCB0cmFuc2l0aW9uc1xudmFyIFZFeHBhbmRUcmFuc2l0aW9uID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNyZWF0ZUphdmFTY3JpcHRUcmFuc2l0aW9uXCJdKSgnZXhwYW5kLXRyYW5zaXRpb24nLCBPYmplY3QoX2V4cGFuZF90cmFuc2l0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKSgpKTtcbnZhciBWUm93RXhwYW5kVHJhbnNpdGlvbiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVKYXZhU2NyaXB0VHJhbnNpdGlvblwiXSkoJ3Jvdy1leHBhbmQtdHJhbnNpdGlvbicsIE9iamVjdChfZXhwYW5kX3RyYW5zaXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pKCdkYXRhdGFibGVfX2V4cGFuZC1jb2wtLWV4cGFuZGVkJykpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgJF92dWV0aWZ5X3N1YmNvbXBvbmVudHM6IHtcbiAgICAgICAgVkJvdHRvbVNoZWV0VHJhbnNpdGlvbjogVkJvdHRvbVNoZWV0VHJhbnNpdGlvbixcbiAgICAgICAgVkNhcm91c2VsVHJhbnNpdGlvbjogVkNhcm91c2VsVHJhbnNpdGlvbixcbiAgICAgICAgVkNhcm91c2VsUmV2ZXJzZVRyYW5zaXRpb246IFZDYXJvdXNlbFJldmVyc2VUcmFuc2l0aW9uLFxuICAgICAgICBWRGlhbG9nVHJhbnNpdGlvbjogVkRpYWxvZ1RyYW5zaXRpb24sXG4gICAgICAgIFZEaWFsb2dCb3R0b21UcmFuc2l0aW9uOiBWRGlhbG9nQm90dG9tVHJhbnNpdGlvbixcbiAgICAgICAgVkZhYlRyYW5zaXRpb246IFZGYWJUcmFuc2l0aW9uLFxuICAgICAgICBWRmFkZVRyYW5zaXRpb246IFZGYWRlVHJhbnNpdGlvbixcbiAgICAgICAgVk1lbnVUcmFuc2l0aW9uOiBWTWVudVRyYW5zaXRpb24sXG4gICAgICAgIFZTY2FsZVRyYW5zaXRpb246IFZTY2FsZVRyYW5zaXRpb24sXG4gICAgICAgIFZTY3JvbGxYVHJhbnNpdGlvbjogVlNjcm9sbFhUcmFuc2l0aW9uLFxuICAgICAgICBWU2Nyb2xsWFJldmVyc2VUcmFuc2l0aW9uOiBWU2Nyb2xsWFJldmVyc2VUcmFuc2l0aW9uLFxuICAgICAgICBWU2Nyb2xsWVRyYW5zaXRpb246IFZTY3JvbGxZVHJhbnNpdGlvbixcbiAgICAgICAgVlNjcm9sbFlSZXZlcnNlVHJhbnNpdGlvbjogVlNjcm9sbFlSZXZlcnNlVHJhbnNpdGlvbixcbiAgICAgICAgVlNsaWRlWFRyYW5zaXRpb246IFZTbGlkZVhUcmFuc2l0aW9uLFxuICAgICAgICBWU2xpZGVYUmV2ZXJzZVRyYW5zaXRpb246IFZTbGlkZVhSZXZlcnNlVHJhbnNpdGlvbixcbiAgICAgICAgVlNsaWRlWVRyYW5zaXRpb246IFZTbGlkZVlUcmFuc2l0aW9uLFxuICAgICAgICBWU2xpZGVZUmV2ZXJzZVRyYW5zaXRpb246IFZTbGlkZVlSZXZlcnNlVHJhbnNpdGlvbixcbiAgICAgICAgVlRhYlJldmVyc2VUcmFuc2l0aW9uOiBWVGFiUmV2ZXJzZVRyYW5zaXRpb24sXG4gICAgICAgIFZUYWJUcmFuc2l0aW9uOiBWVGFiVHJhbnNpdGlvbixcbiAgICAgICAgVkV4cGFuZFRyYW5zaXRpb246IFZFeHBhbmRUcmFuc2l0aW9uLFxuICAgICAgICBWUm93RXhwYW5kVHJhbnNpdGlvbjogVlJvd0V4cGFuZFRyYW5zaXRpb25cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG52YXIgX192YWx1ZXMgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fdmFsdWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLFxuICAgICAgICBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuZnVuY3Rpb24gY2xvc2VDb25kaXRpb25hbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkaXJlY3RpdmUoZSwgZWwsIGJpbmRpbmcpIHtcbiAgICAvLyBBcmdzIG1heSBub3QgYWx3YXlzIGJlIHN1cHBsaWVkXG4gICAgYmluZGluZy5hcmdzID0gYmluZGluZy5hcmdzIHx8IHt9O1xuICAgIC8vIElmIG5vIGNsb3NlQ29uZGl0aW9uYWwgd2FzIHN1cHBsaWVkIGFzc2lnbiBhIGRlZmF1bHRcbiAgICB2YXIgaXNBY3RpdmUgPSBiaW5kaW5nLmFyZ3MuY2xvc2VDb25kaXRpb25hbCB8fCBjbG9zZUNvbmRpdGlvbmFsO1xuICAgIC8vIFRoZSBpbmNsdWRlIGVsZW1lbnQgY2FsbGJhY2tzIGJlbG93IGNhbiBiZSBleHBlbnNpdmVcbiAgICAvLyBzbyB3ZSBzaG91bGQgYXZvaWQgY2FsbGluZyB0aGVtIHdoZW4gd2UncmUgbm90IGFjdGl2ZS5cbiAgICAvLyBFeHBsaWNpdGx5IGNoZWNrIGZvciBmYWxzZSB0byBhbGxvdyBmYWxsYmFjayBjb21wYXRpYmlsaXR5XG4gICAgLy8gd2l0aCBub24tdG9nZ2xlYWJsZSBjb21wb25lbnRzXG4gICAgaWYgKCFlIHx8IGlzQWN0aXZlKGUpID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIC8vIElmIGNsaWNrIHdhcyB0cmlnZ2VyZWQgcHJvZ3JhbW1hdGljYWx5IChkb21FbC5jbGljaygpKSB0aGVuXG4gICAgLy8gaXQgc2hvdWxkbid0IGJlIHRyZWF0ZWQgYXMgY2xpY2stb3V0c2lkZVxuICAgIC8vIENocm9tZS9GaXJlZm94IHN1cHBvcnQgaXNUcnVzdGVkIHByb3BlcnR5XG4gICAgLy8gSUUvRWRnZSBzdXBwb3J0IHBvaW50ZXJUeXBlIHByb3BlcnR5IChlbXB0eSBpZiBub3QgdHJpZ2dlcmVkXG4gICAgLy8gYnkgcG9pbnRpbmcgZGV2aWNlKVxuICAgIGlmICgnaXNUcnVzdGVkJyBpbiBlICYmICFlLmlzVHJ1c3RlZCB8fCAncG9pbnRlclR5cGUnIGluIGUgJiYgIWUucG9pbnRlclR5cGUpIHJldHVybjtcbiAgICAvLyBDaGVjayBpZiBhZGRpdGlvbmFsIGVsZW1lbnRzIHdlcmUgcGFzc2VkIHRvIGJlIGluY2x1ZGVkIGluIGNoZWNrXG4gICAgLy8gKGNsaWNrIG11c3QgYmUgb3V0c2lkZSBhbGwgaW5jbHVkZWQgZWxlbWVudHMsIGlmIGFueSlcbiAgICB2YXIgZWxlbWVudHMgPSAoYmluZGluZy5hcmdzLmluY2x1ZGUgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfSkoKTtcbiAgICAvLyBBZGQgdGhlIHJvb3QgZWxlbWVudCBmb3IgdGhlIGNvbXBvbmVudCB0aGlzIGRpcmVjdGl2ZSB3YXMgZGVmaW5lZCBvblxuICAgIGVsZW1lbnRzLnB1c2goZWwpO1xuICAgIC8vIENoZWNrIGlmIGl0J3MgYSBjbGljayBvdXRzaWRlIG91ciBlbGVtZW50cywgYW5kIHRoZW4gaWYgb3VyIGNhbGxiYWNrIHJldHVybnMgdHJ1ZS5cbiAgICAvLyBOb24tdG9nZ2xlYWJsZSBjb21wb25lbnRzIHNob3VsZCB0YWtlIGFjdGlvbiBpbiB0aGVpciBjYWxsYmFjayBhbmQgcmV0dXJuIGZhbHN5LlxuICAgIC8vIFRvZ2dsZWFibGUgY2FuIHJldHVybiB0cnVlIGlmIGl0IHdhbnRzIHRvIGRlYWN0aXZhdGUuXG4gICAgLy8gTm90ZSB0aGF0LCBiZWNhdXNlIHdlJ3JlIGluIHRoZSBjYXB0dXJlIHBoYXNlLCB0aGlzIGNhbGxiYWNrIHdpbGwgb2NjdXJlIGJlZm9yZVxuICAgIC8vIHRoZSBidWJibGluZyBjbGljayBldmVudCBvbiBhbnkgb3V0c2lkZSBlbGVtZW50cy5cbiAgICAhY2xpY2tlZEluRWxzKGUsIGVsZW1lbnRzKSAmJiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNBY3RpdmUoZSkgJiYgYmluZGluZy52YWx1ZShlKTtcbiAgICB9LCAwKTtcbn1cbmZ1bmN0aW9uIGNsaWNrZWRJbkVscyhlLCBlbGVtZW50cykge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIC8vIEdldCBwb3NpdGlvbiBvZiBjbGlja1xuICAgIHZhciB4ID0gZS5jbGllbnRYLFxuICAgICAgICB5ID0gZS5jbGllbnRZO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIExvb3Agb3ZlciBhbGwgaW5jbHVkZWQgZWxlbWVudHMgdG8gc2VlIGlmIGNsaWNrIHdhcyBpbiBhbnkgb2YgdGhlbVxuICAgICAgICBmb3IgKHZhciBlbGVtZW50c18xID0gX192YWx1ZXMoZWxlbWVudHMpLCBlbGVtZW50c18xXzEgPSBlbGVtZW50c18xLm5leHQoKTsgIWVsZW1lbnRzXzFfMS5kb25lOyBlbGVtZW50c18xXzEgPSBlbGVtZW50c18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGVsID0gZWxlbWVudHNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGNsaWNrZWRJbkVsKGVsLCB4LCB5KSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHNfMV8xICYmICFlbGVtZW50c18xXzEuZG9uZSAmJiAoX2EgPSBlbGVtZW50c18xLnJldHVybikpIF9hLmNhbGwoZWxlbWVudHNfMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2xpY2tlZEluRWwoZWwsIHgsIHkpIHtcbiAgICAvLyBHZXQgYm91bmRpbmcgcmVjdCBmb3IgZWxlbWVudFxuICAgIC8vICh3ZSdyZSBpbiBjYXB0dXJpbmcgZXZlbnQgYW5kIHdlIHdhbnQgdG8gY2hlY2sgZm9yIG11bHRpcGxlIGVsZW1lbnRzLFxuICAgIC8vICBzbyBjYW4ndCB1c2UgdGFyZ2V0LilcbiAgICB2YXIgYiA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayB3YXMgaW4gdGhlIGVsZW1lbnQncyBib3VuZGluZyByZWN0XG4gICAgcmV0dXJuIHggPj0gYi5sZWZ0ICYmIHggPD0gYi5yaWdodCAmJiB5ID49IGIudG9wICYmIHkgPD0gYi5ib3R0b207XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICAvLyBbZGF0YS1hcHBdIG1heSBub3QgYmUgZm91bmRcbiAgICAvLyBpZiB1c2luZyBiaW5kLCBpbnNlcnRlZCBtYWtlc1xuICAgIC8vIHN1cmUgdGhhdCB0aGUgcm9vdCBlbGVtZW50IGlzXG4gICAgLy8gYXZhaWxhYmxlLCBpT1MgZG9lcyBub3Qgc3VwcG9ydFxuICAgIC8vIGNsaWNrcyBvbiBib2R5XG4gICAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkKGVsLCBiaW5kaW5nKSB7XG4gICAgICAgIHZhciBvbkNsaWNrID0gZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlKGUsIGVsLCBiaW5kaW5nKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaU9TIGRvZXMgbm90IHJlY29nbml6ZSBjbGljayBldmVudHMgb24gZG9jdW1lbnRcbiAgICAgICAgLy8gb3IgYm9keSwgdGhpcyBpcyB0aGUgZW50aXJlIHB1cnBvc2Ugb2YgdGhlIHYtYXBwXG4gICAgICAgIC8vIGNvbXBvbmVudCBhbmQgW2RhdGEtYXBwXSwgc3RvcCByZW1vdmluZyB0aGlzXG4gICAgICAgIHZhciBhcHAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hcHBdJykgfHwgZG9jdW1lbnQuYm9keTsgLy8gVGhpcyBpcyBvbmx5IGZvciB1bml0IHRlc3RzXG4gICAgICAgIGFwcC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIHRydWUpO1xuICAgICAgICBlbC5fY2xpY2tPdXRzaWRlID0gb25DbGljaztcbiAgICB9LFxuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGVsKSB7XG4gICAgICAgIGlmICghZWwuX2NsaWNrT3V0c2lkZSkgcmV0dXJuO1xuICAgICAgICB2YXIgYXBwID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtYXBwXScpIHx8IGRvY3VtZW50LmJvZHk7IC8vIFRoaXMgaXMgb25seSBmb3IgdW5pdCB0ZXN0c1xuICAgICAgICBhcHAgJiYgYXBwLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZWwuX2NsaWNrT3V0c2lkZSwgdHJ1ZSk7XG4gICAgICAgIGRlbGV0ZSBlbC5fY2xpY2tPdXRzaWRlO1xuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kaXJlY3RpdmVzL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGlyZWN0aXZlcy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IENsaWNrT3V0c2lkZSwgUmlwcGxlLCBSZXNpemUsIFNjcm9sbCwgVG91Y2gsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NsaWNrX291dHNpZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2xpY2stb3V0c2lkZSAqLyBcIi4vc3JjL2RpcmVjdGl2ZXMvY2xpY2stb3V0c2lkZS50c1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNsaWNrT3V0c2lkZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9jbGlja19vdXRzaWRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZXNpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVzaXplICovIFwiLi9zcmMvZGlyZWN0aXZlcy9yZXNpemUudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJSZXNpemVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfcmVzaXplX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yaXBwbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmlwcGxlICovIFwiLi9zcmMvZGlyZWN0aXZlcy9yaXBwbGUudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJSaXBwbGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfcmlwcGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zY3JvbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2Nyb2xsICovIFwiLi9zcmMvZGlyZWN0aXZlcy9zY3JvbGwudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTY3JvbGxcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfc2Nyb2xsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b3VjaCAqLyBcIi4vc3JjL2RpcmVjdGl2ZXMvdG91Y2gudHNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUb3VjaFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIENsaWNrT3V0c2lkZTogX2NsaWNrX291dHNpZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0sXG4gICAgUmlwcGxlOiBfcmlwcGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLFxuICAgIFJlc2l6ZTogX3Jlc2l6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSxcbiAgICBTY3JvbGw6IF9zY3JvbGxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sXG4gICAgVG91Y2g6IF90b3VjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RpcmVjdGl2ZXMvcmVzaXplLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2RpcmVjdGl2ZXMvcmVzaXplLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5mdW5jdGlvbiBpbnNlcnRlZChlbCwgYmluZGluZykge1xuICAgIHZhciBjYWxsYmFjayA9IGJpbmRpbmcudmFsdWU7XG4gICAgdmFyIG9wdGlvbnMgPSBiaW5kaW5nLm9wdGlvbnMgfHwgeyBwYXNzaXZlOiB0cnVlIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICBlbC5fb25SZXNpemUgPSB7XG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH07XG4gICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycyB8fCAhYmluZGluZy5tb2RpZmllcnMucXVpZXQpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bmJpbmQoZWwpIHtcbiAgICBpZiAoIWVsLl9vblJlc2l6ZSkgcmV0dXJuO1xuICAgIHZhciBfYSA9IGVsLl9vblJlc2l6ZSxcbiAgICAgICAgY2FsbGJhY2sgPSBfYS5jYWxsYmFjayxcbiAgICAgICAgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICBkZWxldGUgZWwuX29uUmVzaXplO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgaW5zZXJ0ZWQ6IGluc2VydGVkLFxuICAgIHVuYmluZDogdW5iaW5kXG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGlyZWN0aXZlcy9yaXBwbGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGlyZWN0aXZlcy9yaXBwbGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShlbCwgdmFsdWUpIHtcbiAgICBlbC5zdHlsZVsndHJhbnNmb3JtJ10gPSB2YWx1ZTtcbiAgICBlbC5zdHlsZVsnd2Via2l0VHJhbnNmb3JtJ10gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIG9wYWNpdHkoZWwsIHZhbHVlKSB7XG4gICAgZWwuc3R5bGVbJ29wYWNpdHknXSA9IHZhbHVlLnRvU3RyaW5nKCk7XG59XG52YXIgY2FsY3VsYXRlID0gZnVuY3Rpb24gY2FsY3VsYXRlKGUsIGVsLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhbHVlID0ge307XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbG9jYWxYID0gZS5jbGllbnRYIC0gb2Zmc2V0LmxlZnQ7XG4gICAgdmFyIGxvY2FsWSA9IGUuY2xpZW50WSAtIG9mZnNldC50b3A7XG4gICAgdmFyIHJhZGl1cyA9IDA7XG4gICAgdmFyIHNjYWxlID0gMC4zO1xuICAgIGlmIChlbC5fcmlwcGxlICYmIGVsLl9yaXBwbGUuY2lyY2xlKSB7XG4gICAgICAgIHNjYWxlID0gMC4xNTtcbiAgICAgICAgcmFkaXVzID0gZWwuY2xpZW50V2lkdGggLyAyO1xuICAgICAgICByYWRpdXMgPSB2YWx1ZS5jZW50ZXIgPyByYWRpdXMgOiByYWRpdXMgKyBNYXRoLnNxcnQoTWF0aC5wb3cobG9jYWxYIC0gcmFkaXVzLCAyKSArIE1hdGgucG93KGxvY2FsWSAtIHJhZGl1cywgMikpIC8gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByYWRpdXMgPSBNYXRoLnNxcnQoTWF0aC5wb3coZWwuY2xpZW50V2lkdGgsIDIpICsgTWF0aC5wb3coZWwuY2xpZW50SGVpZ2h0LCAyKSkgLyAyO1xuICAgIH1cbiAgICB2YXIgY2VudGVyWCA9IChlbC5jbGllbnRXaWR0aCAtIHJhZGl1cyAqIDIpIC8gMiArIFwicHhcIjtcbiAgICB2YXIgY2VudGVyWSA9IChlbC5jbGllbnRIZWlnaHQgLSByYWRpdXMgKiAyKSAvIDIgKyBcInB4XCI7XG4gICAgdmFyIHggPSB2YWx1ZS5jZW50ZXIgPyBjZW50ZXJYIDogbG9jYWxYIC0gcmFkaXVzICsgXCJweFwiO1xuICAgIHZhciB5ID0gdmFsdWUuY2VudGVyID8gY2VudGVyWSA6IGxvY2FsWSAtIHJhZGl1cyArIFwicHhcIjtcbiAgICByZXR1cm4geyByYWRpdXM6IHJhZGl1cywgc2NhbGU6IHNjYWxlLCB4OiB4LCB5OiB5LCBjZW50ZXJYOiBjZW50ZXJYLCBjZW50ZXJZOiBjZW50ZXJZIH07XG59O1xudmFyIHJpcHBsZSA9IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuICAgIHNob3c6IGZ1bmN0aW9uIHNob3coZSwgZWwsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghZWwuX3JpcHBsZSB8fCAhZWwuX3JpcHBsZS5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGFuaW1hdGlvbik7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSAndi1yaXBwbGVfX2NvbnRhaW5lcic7XG4gICAgICAgIGlmICh2YWx1ZS5jbGFzcykge1xuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSArPSBcIiBcIiArIHZhbHVlLmNsYXNzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IGNhbGN1bGF0ZShlLCBlbCwgdmFsdWUpLFxuICAgICAgICAgICAgcmFkaXVzID0gX2EucmFkaXVzLFxuICAgICAgICAgICAgc2NhbGUgPSBfYS5zY2FsZSxcbiAgICAgICAgICAgIHggPSBfYS54LFxuICAgICAgICAgICAgeSA9IF9hLnksXG4gICAgICAgICAgICBjZW50ZXJYID0gX2EuY2VudGVyWCxcbiAgICAgICAgICAgIGNlbnRlclkgPSBfYS5jZW50ZXJZO1xuICAgICAgICBhbmltYXRpb24uY2xhc3NOYW1lID0gJ3YtcmlwcGxlX19hbmltYXRpb24nO1xuICAgICAgICBhbmltYXRpb24uc3R5bGUud2lkdGggPSByYWRpdXMgKiAyICsgXCJweFwiO1xuICAgICAgICBhbmltYXRpb24uc3R5bGUuaGVpZ2h0ID0gYW5pbWF0aW9uLnN0eWxlLndpZHRoO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIGlmIChjb21wdXRlZC5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIGVsLmRhdGFzZXQucHJldmlvdXNQb3NpdGlvbiA9ICdzdGF0aWMnO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvbi5jbGFzc0xpc3QuYWRkKCd2LXJpcHBsZV9fYW5pbWF0aW9uLS1lbnRlcicpO1xuICAgICAgICBhbmltYXRpb24uY2xhc3NMaXN0LmFkZCgndi1yaXBwbGVfX2FuaW1hdGlvbi0tdmlzaWJsZScpO1xuICAgICAgICB0cmFuc2Zvcm0oYW5pbWF0aW9uLCBcInRyYW5zbGF0ZShcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIpIHNjYWxlM2QoXCIgKyBzY2FsZSArIFwiLFwiICsgc2NhbGUgKyBcIixcIiArIHNjYWxlICsgXCIpXCIpO1xuICAgICAgICBvcGFjaXR5KGFuaW1hdGlvbiwgMCk7XG4gICAgICAgIGFuaW1hdGlvbi5kYXRhc2V0LmFjdGl2YXRlZCA9IFN0cmluZyhwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYW5pbWF0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ3YtcmlwcGxlX19hbmltYXRpb24tLWVudGVyJyk7XG4gICAgICAgICAgICBhbmltYXRpb24uY2xhc3NMaXN0LmFkZCgndi1yaXBwbGVfX2FuaW1hdGlvbi0taW4nKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybShhbmltYXRpb24sIFwidHJhbnNsYXRlKFwiICsgY2VudGVyWCArIFwiLCBcIiArIGNlbnRlclkgKyBcIikgc2NhbGUzZCgxLDEsMSlcIik7XG4gICAgICAgICAgICBvcGFjaXR5KGFuaW1hdGlvbiwgMC4yNSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uY2xhc3NMaXN0LnJlbW92ZSgndi1yaXBwbGVfX2FuaW1hdGlvbi0taW4nKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uY2xhc3NMaXN0LmFkZCgndi1yaXBwbGVfX2FuaW1hdGlvbi0tb3V0Jyk7XG4gICAgICAgICAgICAgICAgb3BhY2l0eShhbmltYXRpb24sIDApO1xuICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSxcbiAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKGVsKSB7XG4gICAgICAgIGlmICghZWwgfHwgIWVsLl9yaXBwbGUgfHwgIWVsLl9yaXBwbGUuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgICB2YXIgcmlwcGxlcyA9IGVsLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3YtcmlwcGxlX19hbmltYXRpb24nKTtcbiAgICAgICAgaWYgKHJpcHBsZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHZhciBhbmltYXRpb24gPSByaXBwbGVzW3JpcHBsZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChhbmltYXRpb24uZGF0YXNldC5pc0hpZGluZykgcmV0dXJuO2Vsc2UgYW5pbWF0aW9uLmRhdGFzZXQuaXNIaWRpbmcgPSAndHJ1ZSc7XG4gICAgICAgIHZhciBkaWZmID0gcGVyZm9ybWFuY2Uubm93KCkgLSBOdW1iZXIoYW5pbWF0aW9uLmRhdGFzZXQuYWN0aXZhdGVkKTtcbiAgICAgICAgdmFyIGRlbGF5ID0gTWF0aC5tYXgoMjAwIC0gZGlmZiwgMCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYW5pbWF0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ3YtcmlwcGxlX19hbmltYXRpb24tLW91dCcpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJpcHBsZXMgPSBlbC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd2LXJpcHBsZV9fYW5pbWF0aW9uJyk7XG4gICAgICAgICAgICAgICAgaWYgKHJpcHBsZXMubGVuZ3RoID09PSAxICYmIGVsLmRhdGFzZXQucHJldmlvdXNQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5wb3NpdGlvbiA9IGVsLmRhdGFzZXQucHJldmlvdXNQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVsLmRhdGFzZXQucHJldmlvdXNQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLnBhcmVudE5vZGUgJiYgZWwucmVtb3ZlQ2hpbGQoYW5pbWF0aW9uLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBpc1JpcHBsZUVuYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCAhIXZhbHVlO1xufVxuZnVuY3Rpb24gcmlwcGxlU2hvdyhlKSB7XG4gICAgdmFyIHZhbHVlID0ge307XG4gICAgdmFyIGVsZW1lbnQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG4gICAgdmFsdWUuY2VudGVyID0gZWxlbWVudC5fcmlwcGxlLmNlbnRlcmVkO1xuICAgIGlmIChlbGVtZW50Ll9yaXBwbGUuY2xhc3MpIHtcbiAgICAgICAgdmFsdWUuY2xhc3MgPSBlbGVtZW50Ll9yaXBwbGUuY2xhc3M7XG4gICAgfVxuICAgIHJpcHBsZS5zaG93KGUsIGVsZW1lbnQsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHJpcHBsZUhpZGUoZSkge1xuICAgIHJpcHBsZS5oaWRlKGUuY3VycmVudFRhcmdldCk7XG59XG5mdW5jdGlvbiB1cGRhdGVSaXBwbGUoZWwsIGJpbmRpbmcsIHdhc0VuYWJsZWQpIHtcbiAgICB2YXIgZW5hYmxlZCA9IGlzUmlwcGxlRW5hYmxlZChiaW5kaW5nLnZhbHVlKTtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgcmlwcGxlLmhpZGUoZWwpO1xuICAgIH1cbiAgICBlbC5fcmlwcGxlID0gZWwuX3JpcHBsZSB8fCB7fTtcbiAgICBlbC5fcmlwcGxlLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWUgfHwge307XG4gICAgaWYgKHZhbHVlLmNlbnRlcikge1xuICAgICAgICBlbC5fcmlwcGxlLmNlbnRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmNsYXNzKSB7XG4gICAgICAgIGVsLl9yaXBwbGUuY2xhc3MgPSBiaW5kaW5nLnZhbHVlLmNsYXNzO1xuICAgIH1cbiAgICBpZiAodmFsdWUuY2lyY2xlKSB7XG4gICAgICAgIGVsLl9yaXBwbGUuY2lyY2xlID0gdmFsdWUuY2lyY2xlO1xuICAgIH1cbiAgICBpZiAoZW5hYmxlZCAmJiAhd2FzRW5hYmxlZCkge1xuICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHJpcHBsZUhpZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgcmlwcGxlSGlkZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHJpcHBsZVNob3csIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHJpcHBsZUhpZGUsIGZhbHNlKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJpcHBsZUhpZGUsIGZhbHNlKTtcbiAgICAgICAgLy8gQW5jaG9yIHRhZ3MgY2FuIGJlIGRyYWdnZWQsIGNhdXNlcyBvdGhlciBoaWRlcyB0byBmYWlsIC0gIzE1MzdcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcmlwcGxlSGlkZSwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgd2FzRW5hYmxlZCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcnMoZWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycyhlbCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHJpcHBsZVNob3csIGZhbHNlKTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHJpcHBsZUhpZGUsIGZhbHNlKTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHJpcHBsZUhpZGUsIGZhbHNlKTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgcmlwcGxlSGlkZSwgZmFsc2UpO1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByaXBwbGVIaWRlLCBmYWxzZSk7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgcmlwcGxlSGlkZSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gZGlyZWN0aXZlKGVsLCBiaW5kaW5nKSB7XG4gICAgdXBkYXRlUmlwcGxlKGVsLCBiaW5kaW5nLCBmYWxzZSk7XG59XG5mdW5jdGlvbiB1bmJpbmQoZWwpIHtcbiAgICBkZWxldGUgZWwuX3JpcHBsZTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoZWwpO1xufVxuZnVuY3Rpb24gdXBkYXRlKGVsLCBiaW5kaW5nKSB7XG4gICAgaWYgKGJpbmRpbmcudmFsdWUgPT09IGJpbmRpbmcub2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FzRW5hYmxlZCA9IGlzUmlwcGxlRW5hYmxlZChiaW5kaW5nLm9sZFZhbHVlKTtcbiAgICB1cGRhdGVSaXBwbGUoZWwsIGJpbmRpbmcsIHdhc0VuYWJsZWQpO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgYmluZDogZGlyZWN0aXZlLFxuICAgIHVuYmluZDogdW5iaW5kLFxuICAgIHVwZGF0ZTogdXBkYXRlXG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvZGlyZWN0aXZlcy9zY3JvbGwudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvZGlyZWN0aXZlcy9zY3JvbGwudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbmZ1bmN0aW9uIGluc2VydGVkKGVsLCBiaW5kaW5nKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gYmluZGluZy52YWx1ZTtcbiAgICB2YXIgb3B0aW9ucyA9IGJpbmRpbmcub3B0aW9ucyB8fCB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICB2YXIgdGFyZ2V0ID0gYmluZGluZy5hcmcgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGJpbmRpbmcuYXJnKSA6IHdpbmRvdztcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgZWwuX29uU2Nyb2xsID0ge1xuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVuYmluZChlbCkge1xuICAgIGlmICghZWwuX29uU2Nyb2xsKSByZXR1cm47XG4gICAgdmFyIF9hID0gZWwuX29uU2Nyb2xsLFxuICAgICAgICBjYWxsYmFjayA9IF9hLmNhbGxiYWNrLFxuICAgICAgICBvcHRpb25zID0gX2Eub3B0aW9ucyxcbiAgICAgICAgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgZGVsZXRlIGVsLl9vblNjcm9sbDtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIGluc2VydGVkOiBpbnNlcnRlZCxcbiAgICB1bmJpbmQ6IHVuYmluZFxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2RpcmVjdGl2ZXMvdG91Y2gudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kaXJlY3RpdmVzL3RvdWNoLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG5cbnZhciBoYW5kbGVHZXN0dXJlID0gZnVuY3Rpb24gaGFuZGxlR2VzdHVyZSh3cmFwcGVyKSB7XG4gICAgdmFyIHRvdWNoc3RhcnRYID0gd3JhcHBlci50b3VjaHN0YXJ0WCxcbiAgICAgICAgdG91Y2hlbmRYID0gd3JhcHBlci50b3VjaGVuZFgsXG4gICAgICAgIHRvdWNoc3RhcnRZID0gd3JhcHBlci50b3VjaHN0YXJ0WSxcbiAgICAgICAgdG91Y2hlbmRZID0gd3JhcHBlci50b3VjaGVuZFk7XG4gICAgdmFyIGRpclJhdGlvID0gMC41O1xuICAgIHZhciBtaW5EaXN0YW5jZSA9IDE2O1xuICAgIHdyYXBwZXIub2Zmc2V0WCA9IHRvdWNoZW5kWCAtIHRvdWNoc3RhcnRYO1xuICAgIHdyYXBwZXIub2Zmc2V0WSA9IHRvdWNoZW5kWSAtIHRvdWNoc3RhcnRZO1xuICAgIGlmIChNYXRoLmFicyh3cmFwcGVyLm9mZnNldFkpIDwgZGlyUmF0aW8gKiBNYXRoLmFicyh3cmFwcGVyLm9mZnNldFgpKSB7XG4gICAgICAgIHdyYXBwZXIubGVmdCAmJiB0b3VjaGVuZFggPCB0b3VjaHN0YXJ0WCAtIG1pbkRpc3RhbmNlICYmIHdyYXBwZXIubGVmdCh3cmFwcGVyKTtcbiAgICAgICAgd3JhcHBlci5yaWdodCAmJiB0b3VjaGVuZFggPiB0b3VjaHN0YXJ0WCArIG1pbkRpc3RhbmNlICYmIHdyYXBwZXIucmlnaHQod3JhcHBlcik7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyh3cmFwcGVyLm9mZnNldFgpIDwgZGlyUmF0aW8gKiBNYXRoLmFicyh3cmFwcGVyLm9mZnNldFkpKSB7XG4gICAgICAgIHdyYXBwZXIudXAgJiYgdG91Y2hlbmRZIDwgdG91Y2hzdGFydFkgLSBtaW5EaXN0YW5jZSAmJiB3cmFwcGVyLnVwKHdyYXBwZXIpO1xuICAgICAgICB3cmFwcGVyLmRvd24gJiYgdG91Y2hlbmRZID4gdG91Y2hzdGFydFkgKyBtaW5EaXN0YW5jZSAmJiB3cmFwcGVyLmRvd24od3JhcHBlcik7XG4gICAgfVxufTtcbmZ1bmN0aW9uIF90b3VjaHN0YXJ0KGV2ZW50LCB3cmFwcGVyKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgd3JhcHBlci50b3VjaHN0YXJ0WCA9IHRvdWNoLmNsaWVudFg7XG4gICAgd3JhcHBlci50b3VjaHN0YXJ0WSA9IHRvdWNoLmNsaWVudFk7XG4gICAgd3JhcHBlci5zdGFydCAmJiB3cmFwcGVyLnN0YXJ0KE9iamVjdC5hc3NpZ24oZXZlbnQsIHdyYXBwZXIpKTtcbn1cbmZ1bmN0aW9uIF90b3VjaGVuZChldmVudCwgd3JhcHBlcikge1xuICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHdyYXBwZXIudG91Y2hlbmRYID0gdG91Y2guY2xpZW50WDtcbiAgICB3cmFwcGVyLnRvdWNoZW5kWSA9IHRvdWNoLmNsaWVudFk7XG4gICAgd3JhcHBlci5lbmQgJiYgd3JhcHBlci5lbmQoT2JqZWN0LmFzc2lnbihldmVudCwgd3JhcHBlcikpO1xuICAgIGhhbmRsZUdlc3R1cmUod3JhcHBlcik7XG59XG5mdW5jdGlvbiBfdG91Y2htb3ZlKGV2ZW50LCB3cmFwcGVyKSB7XG4gICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgd3JhcHBlci50b3VjaG1vdmVYID0gdG91Y2guY2xpZW50WDtcbiAgICB3cmFwcGVyLnRvdWNobW92ZVkgPSB0b3VjaC5jbGllbnRZO1xuICAgIHdyYXBwZXIubW92ZSAmJiB3cmFwcGVyLm1vdmUoT2JqZWN0LmFzc2lnbihldmVudCwgd3JhcHBlcikpO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFuZGxlcnModmFsdWUpIHtcbiAgICB2YXIgd3JhcHBlciA9IHtcbiAgICAgICAgdG91Y2hzdGFydFg6IDAsXG4gICAgICAgIHRvdWNoc3RhcnRZOiAwLFxuICAgICAgICB0b3VjaGVuZFg6IDAsXG4gICAgICAgIHRvdWNoZW5kWTogMCxcbiAgICAgICAgdG91Y2htb3ZlWDogMCxcbiAgICAgICAgdG91Y2htb3ZlWTogMCxcbiAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgb2Zmc2V0WTogMCxcbiAgICAgICAgbGVmdDogdmFsdWUubGVmdCxcbiAgICAgICAgcmlnaHQ6IHZhbHVlLnJpZ2h0LFxuICAgICAgICB1cDogdmFsdWUudXAsXG4gICAgICAgIGRvd246IHZhbHVlLmRvd24sXG4gICAgICAgIHN0YXJ0OiB2YWx1ZS5zdGFydCxcbiAgICAgICAgbW92ZTogdmFsdWUubW92ZSxcbiAgICAgICAgZW5kOiB2YWx1ZS5lbmRcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uIHRvdWNoc3RhcnQoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90b3VjaHN0YXJ0KGUsIHdyYXBwZXIpO1xuICAgICAgICB9LFxuICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24gdG91Y2hlbmQoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90b3VjaGVuZChlLCB3cmFwcGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG91Y2htb3ZlOiBmdW5jdGlvbiB0b3VjaG1vdmUoZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90b3VjaG1vdmUoZSwgd3JhcHBlcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gaW5zZXJ0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgICB2YXIgdGFyZ2V0ID0gdmFsdWUucGFyZW50ID8gZWwucGFyZW50RWxlbWVudCA6IGVsO1xuICAgIHZhciBvcHRpb25zID0gdmFsdWUub3B0aW9ucyB8fCB7IHBhc3NpdmU6IHRydWUgfTtcbiAgICAvLyBOZWVkZWQgdG8gcGFzcyB1bml0IHRlc3RzXG4gICAgaWYgKCF0YXJnZXQpIHJldHVybjtcbiAgICB2YXIgaGFuZGxlcnMgPSBjcmVhdGVIYW5kbGVycyhiaW5kaW5nLnZhbHVlKTtcbiAgICB0YXJnZXQuX3RvdWNoSGFuZGxlcnMgPSBPYmplY3QodGFyZ2V0Ll90b3VjaEhhbmRsZXJzKTtcbiAgICB0YXJnZXQuX3RvdWNoSGFuZGxlcnNbdm5vZGUuY29udGV4dC5fdWlkXSA9IGhhbmRsZXJzO1xuICAgIE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJrZXlzXCJdKShoYW5kbGVycykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcnNbZXZlbnROYW1lXSwgb3B0aW9ucyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB1bmJpbmQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgdmFyIHRhcmdldCA9IGJpbmRpbmcudmFsdWUucGFyZW50ID8gZWwucGFyZW50RWxlbWVudCA6IGVsO1xuICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuX3RvdWNoSGFuZGxlcnMpIHJldHVybjtcbiAgICB2YXIgaGFuZGxlcnMgPSB0YXJnZXQuX3RvdWNoSGFuZGxlcnNbdm5vZGUuY29udGV4dC5fdWlkXTtcbiAgICBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wia2V5c1wiXSkoaGFuZGxlcnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXJzW2V2ZW50TmFtZV0pO1xuICAgIH0pO1xuICAgIGRlbGV0ZSB0YXJnZXQuX3RvdWNoSGFuZGxlcnNbdm5vZGUuY29udGV4dC5fdWlkXTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIGluc2VydGVkOiBpbnNlcnRlZCxcbiAgICB1bmJpbmQ6IHVuYmluZFxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19hcHBfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdHlsdXMvYXBwLnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvYXBwLnN0eWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0eWx1c19hcHBfc3R5bF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zdHlsdXNfYXBwX3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbXBvbmVudHNfVnVldGlmeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb21wb25lbnRzL1Z1ZXRpZnkgKi8gXCIuL3NyYy9jb21wb25lbnRzL1Z1ZXRpZnkvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbXBvbmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29tcG9uZW50cyAqLyBcIi4vc3JjL2NvbXBvbmVudHMvaW5kZXgudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RpcmVjdGl2ZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGlyZWN0aXZlcyAqLyBcIi4vc3JjL2RpcmVjdGl2ZXMvaW5kZXgudHNcIik7XG52YXIgX19hc3NpZ24gPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cblxuXG5cbnZhciBWdWV0aWZ5ID0ge1xuICAgIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoVnVlLCBhcmdzKSB7XG4gICAgICAgIFZ1ZS51c2UoX2NvbXBvbmVudHNfVnVldGlmeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgX19hc3NpZ24oeyBjb21wb25lbnRzOiBfY29tcG9uZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLFxuICAgICAgICAgICAgZGlyZWN0aXZlczogX2RpcmVjdGl2ZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0gfSwgYXJncykpO1xuICAgIH0sXG4gICAgdmVyc2lvbjogJzEuMy43J1xufTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgd2luZG93LlZ1ZS51c2UoVnVldGlmeSk7XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFZ1ZXRpZnkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9sb2NhbGUvZW4udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2xvY2FsZS9lbi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIGRhdGFJdGVyYXRvcjoge1xuICAgICAgICByb3dzUGVyUGFnZVRleHQ6ICdJdGVtcyBwZXIgcGFnZTonLFxuICAgICAgICByb3dzUGVyUGFnZUFsbDogJ0FsbCcsXG4gICAgICAgIHBhZ2VUZXh0OiAnezB9LXsxfSBvZiB7Mn0nLFxuICAgICAgICBub1Jlc3VsdHNUZXh0OiAnTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZCcsXG4gICAgICAgIG5leHRQYWdlOiAnTmV4dCBwYWdlJyxcbiAgICAgICAgcHJldlBhZ2U6ICdQcmV2aW91cyBwYWdlJ1xuICAgIH0sXG4gICAgZGF0YVRhYmxlOiB7XG4gICAgICAgIHJvd3NQZXJQYWdlVGV4dDogJ1Jvd3MgcGVyIHBhZ2U6J1xuICAgIH0sXG4gICAgbm9EYXRhVGV4dDogJ05vIGRhdGEgYXZhaWxhYmxlJ1xufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21peGlucy9hcHBsaWNhdGlvbmFibGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9taXhpbnMvYXBwbGljYXRpb25hYmxlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXBwbGljYXRpb25hYmxlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcG9zaXRpb25hYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Bvc2l0aW9uYWJsZSAqLyBcIi4vc3JjL21peGlucy9wb3NpdGlvbmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL21peGlucyAqLyBcIi4vc3JjL3V0aWwvbWl4aW5zLnRzXCIpO1xuXG4vLyBVdGlsXG5cbmZ1bmN0aW9uIGFwcGxpY2F0aW9uYWJsZSh2YWx1ZSwgZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGV2ZW50cyA9IFtdO1xuICAgIH1cbiAgICAvKiBAdnVlL2NvbXBvbmVudCAqL1xuICAgIHJldHVybiBPYmplY3QoX3V0aWxfbWl4aW5zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdKShPYmplY3QoX3Bvc2l0aW9uYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZmFjdG9yeVwiXSkoWydhYnNvbHV0ZScsICdmaXhlZCddKSkuZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogJ2FwcGxpY2F0aW9uYWJsZScsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBhcHA6IEJvb2xlYW5cbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uUHJvcGVydHk6IGZ1bmN0aW9uIGFwcGxpY2F0aW9uUHJvcGVydHkoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3YXRjaDoge1xuICAgICAgICAgICAgLy8gSWYgcHJldmlvdXMgdmFsdWUgd2FzIGFwcFxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIHByb3ZpZGVkIHByb3BcbiAgICAgICAgICAgIGFwcDogZnVuY3Rpb24gYXBwKHgsIHByZXYpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID8gdGhpcy5yZW1vdmVBcHBsaWNhdGlvbih0cnVlKSA6IHRoaXMuY2FsbFVwZGF0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGxpY2F0aW9uUHJvcGVydHk6IGZ1bmN0aW9uIGFwcGxpY2F0aW9uUHJvcGVydHkobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR2dWV0aWZ5LmFwcGxpY2F0aW9uLnVuYmluZCh0aGlzLl91aWQsIG9sZFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2YXRlZDogZnVuY3Rpb24gYWN0aXZhdGVkKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZXZlbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kd2F0Y2goZXZlbnRzW2ldLCB0aGlzLmNhbGxVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYWxsVXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxVcGRhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVhY3RpdmF0ZWQ6IGZ1bmN0aW9uIGRlYWN0aXZhdGVkKCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBcHBsaWNhdGlvbigpO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQXBwbGljYXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgY2FsbFVwZGF0ZTogZnVuY3Rpb24gY2FsbFVwZGF0ZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXBwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy4kdnVldGlmeS5hcHBsaWNhdGlvbi5iaW5kKHRoaXMuX3VpZCwgdGhpcy5hcHBsaWNhdGlvblByb3BlcnR5LCB0aGlzLnVwZGF0ZUFwcGxpY2F0aW9uKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUFwcGxpY2F0aW9uOiBmdW5jdGlvbiByZW1vdmVBcHBsaWNhdGlvbihmb3JjZSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZm9yY2UgJiYgIXRoaXMuYXBwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy4kdnVldGlmeS5hcHBsaWNhdGlvbi51bmJpbmQodGhpcy5fdWlkLCB0aGlzLmFwcGxpY2F0aW9uUHJvcGVydHkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZUFwcGxpY2F0aW9uOiBmdW5jdGlvbiB1cGRhdGVBcHBsaWNhdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvYm9vdGFibGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9ib290YWJsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHZ1ZSAqLyBcInZ1ZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG5cbi8qKlxuICogQm9vdGFibGVcbiAqIEBtaXhpblxuICpcbiAqIFVzZWQgdG8gYWRkIGxhenkgY29udGVudCBmdW5jdGlvbmFsaXR5IHRvIGNvbXBvbmVudHNcbiAqIExvb2tzIGZvciBjaGFuZ2UgaW4gXCJpc0FjdGl2ZVwiIHRvIGF1dG9tYXRpY2FsbHkgYm9vdFxuICogT3RoZXJ3aXNlIGNhbiBiZSBzZXQgbWFudWFsbHlcbiAqL1xuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCgpLmV4dGVuZCh7XG4gICAgbmFtZTogJ2Jvb3RhYmxlJyxcbiAgICBwcm9wczoge1xuICAgICAgICBsYXp5OiBCb29sZWFuXG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNCb290ZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBoYXNDb250ZW50OiBmdW5jdGlvbiBoYXNDb250ZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNCb290ZWQgfHwgIXRoaXMubGF6eSB8fCB0aGlzLmlzQWN0aXZlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgICAgICAgICB0aGlzLmlzQm9vdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBzaG93TGF6eUNvbnRlbnQ6IGZ1bmN0aW9uIHNob3dMYXp5Q29udGVudChjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNDb250ZW50ID8gY29udGVudCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWl4aW5zL2J1dHRvbi1ncm91cC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9idXR0b24tZ3JvdXAudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21wb25lbnRzX1ZJdGVtR3JvdXBfVkl0ZW1Hcm91cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29tcG9uZW50cy9WSXRlbUdyb3VwL1ZJdGVtR3JvdXAgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZJdGVtR3JvdXAvVkl0ZW1Hcm91cC50c1wiKTtcbi8vIEV4dGVuc2lvbnNcblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX2NvbXBvbmVudHNfVkl0ZW1Hcm91cF9WSXRlbUdyb3VwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJCYXNlSXRlbUdyb3VwXCJdLmV4dGVuZCh7XG4gICAgbmFtZTogJ2J1dHRvbi1ncm91cCcsXG4gICAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ0blRvZ2dsZTogdGhpc1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYWN0aXZlQ2xhc3M6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICd2LWJ0bi0tYWN0aXZlJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jb21wb25lbnRzX1ZJdGVtR3JvdXBfVkl0ZW1Hcm91cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiQmFzZUl0ZW1Hcm91cFwiXS5vcHRpb25zLmNvbXB1dGVkLmNsYXNzZXMuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9jb2xvcmFibGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFwidnVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3JlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fcmVhZCB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgICByLFxuICAgICAgICBhciA9IFtdLFxuICAgICAgICBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcblxuZnVuY3Rpb24gaXNDc3NDb2xvcihjb2xvcikge1xuICAgIHJldHVybiAhIWNvbG9yICYmICEhY29sb3IubWF0Y2goL14oI3wocmdifGhzbClhP1xcKCkvKTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7XG4gICAgbmFtZTogJ2NvbG9yYWJsZScsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IFN0cmluZ1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uIHNldEJhY2tncm91bmRDb2xvcihjb2xvciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChpc0Nzc0NvbG9yKGNvbG9yKSkge1xuICAgICAgICAgICAgICAgIGRhdGEuc3R5bGUgPSBfX2Fzc2lnbih7fSwgZGF0YS5zdHlsZSwgeyAnYmFja2dyb3VuZC1jb2xvcic6IFwiXCIgKyBjb2xvciwgJ2JvcmRlci1jb2xvcic6IFwiXCIgKyBjb2xvciB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmNsYXNzID0gX19hc3NpZ24oe30sIGRhdGEuY2xhc3MsIChfYSA9IHt9LCBfYVtjb2xvcl0gPSB0cnVlLCBfYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFRleHRDb2xvcjogZnVuY3Rpb24gc2V0VGV4dENvbG9yKGNvbG9yLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGlzQ3NzQ29sb3IoY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zdHlsZSA9IF9fYXNzaWduKHt9LCBkYXRhLnN0eWxlLCB7ICdjb2xvcic6IFwiXCIgKyBjb2xvciwgJ2NhcmV0LWNvbG9yJzogXCJcIiArIGNvbG9yIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xvcikge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChjb2xvci50b1N0cmluZygpLnRyaW0oKS5zcGxpdCgnICcsIDIpLCAyKSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JOYW1lID0gX2JbMF0sXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yTW9kaWZpZXIgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICBkYXRhLmNsYXNzID0gX19hc3NpZ24oe30sIGRhdGEuY2xhc3MsIChfYSA9IHt9LCBfYVtjb2xvck5hbWUgKyAnLS10ZXh0J10gPSB0cnVlLCBfYSkpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xvck1vZGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuY2xhc3NbJ3RleHQtLScgKyBjb2xvck1vZGlmaWVyXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21peGlucy9jb21wYXJhYmxlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9jb21wYXJhYmxlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB2dWUgKi8gXCJ2dWVcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe1xuICAgIG5hbWU6ICdjb21wYXJhYmxlJyxcbiAgICBwcm9wczoge1xuICAgICAgICB2YWx1ZUNvbXBhcmF0b3I6IHtcbiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdDogX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVlcEVxdWFsXCJdXG4gICAgICAgIH1cbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21peGlucy9kYXRhLWl0ZXJhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9kYXRhLWl0ZXJhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbXBvbmVudHNfVkJ0bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29tcG9uZW50cy9WQnRuICovIFwiLi9zcmMvY29tcG9uZW50cy9WQnRuL2luZGV4LnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21wb25lbnRzX1ZJY29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jb21wb25lbnRzL1ZJY29uICovIFwiLi9zcmMvY29tcG9uZW50cy9WSWNvbi9pbmRleC50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tcG9uZW50c19WU2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jb21wb25lbnRzL1ZTZWxlY3QgKi8gXCIuL3NyYy9jb21wb25lbnRzL1ZTZWxlY3QvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2ZpbHRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmlsdGVyYWJsZSAqLyBcIi4vc3JjL21peGlucy9maWx0ZXJhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGhlbWVhYmxlICovIFwiLi9zcmMvbWl4aW5zL3RoZW1lYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9hZGFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9hZGFibGUgKi8gXCIuL3NyYy9taXhpbnMvbG9hZGFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvY29uc29sZSAqLyBcIi4vc3JjL3V0aWwvY29uc29sZS50c1wiKTtcbnZhciBfX3JlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fcmVhZCB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgICByLFxuICAgICAgICBhciA9IFtdLFxuICAgICAgICBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19zcHJlYWQgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICB9cmV0dXJuIGFyO1xufTtcblxuXG5cblxuXG5cblxuXG4vKipcbiAqIERhdGFJdGVyYWJsZVxuICpcbiAqIEBtaXhpblxuICpcbiAqIEJhc2UgYmVoYXZpb3IgZm9yIGRhdGEgdGFibGUgYW5kIGRhdGEgaXRlcmF0b3JcbiAqIHByb3ZpZGluZyBzZWxlY3Rpb24sIHBhZ2luYXRpb24sIHNvcnRpbmcgYW5kIGZpbHRlcmluZy5cbiAqXG4gKi9cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAnZGF0YS1pdGVyYWJsZScsXG4gICAgbWl4aW5zOiBbX2ZpbHRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sIF9sb2FkYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFwiXSwgX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZXhwYW5kOiBCb29sZWFuLFxuICAgICAgICBoaWRlQWN0aW9uczogQm9vbGVhbixcbiAgICAgICAgZGlzYWJsZUluaXRpYWxTb3J0OiBCb29sZWFuLFxuICAgICAgICBtdXN0U29ydDogQm9vbGVhbixcbiAgICAgICAgbm9SZXN1bHRzVGV4dDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5LmRhdGFJdGVyYXRvci5ub1Jlc3VsdHNUZXh0J1xuICAgICAgICB9LFxuICAgICAgICBuZXh0SWNvbjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5Lmljb25zLm5leHQnXG4gICAgICAgIH0sXG4gICAgICAgIHByZXZJY29uOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnJHZ1ZXRpZnkuaWNvbnMucHJldidcbiAgICAgICAgfSxcbiAgICAgICAgcm93c1BlclBhZ2VJdGVtczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzUsIDEwLCAyNSwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJHZ1ZXRpZnkuZGF0YUl0ZXJhdG9yLnJvd3NQZXJQYWdlQWxsJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IC0xXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJvd3NQZXJQYWdlVGV4dDoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJyR2dWV0aWZ5LmRhdGFJdGVyYXRvci5yb3dzUGVyUGFnZVRleHQnXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdEFsbDogW0Jvb2xlYW4sIFN0cmluZ10sXG4gICAgICAgIHNlYXJjaDoge1xuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCh2YWwsIHNlYXJjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCAmJiB0eXBlb2YgdmFsICE9PSAnYm9vbGVhbicgJiYgdmFsLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHNlYXJjaCkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21GaWx0ZXI6IHtcbiAgICAgICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoaXRlbXMsIHNlYXJjaCwgZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoID0gc2VhcmNoLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLnRyaW0oKSA9PT0gJycpIHJldHVybiBpdGVtcztcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhpKS5zb21lKGZ1bmN0aW9uIChqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyKGlbal0sIHNlYXJjaCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21Tb3J0OiB7XG4gICAgICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KGl0ZW1zLCBpbmRleCwgaXNEZXNjZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSBudWxsKSByZXR1cm4gaXRlbXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvcnRBID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImdldE9iamVjdFZhbHVlQnlQYXRoXCJdKShhLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3J0QiA9IE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJnZXRPYmplY3RWYWx1ZUJ5UGF0aFwiXSkoYiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZXNjZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9fcmVhZChbc29ydEIsIHNvcnRBXSwgMiksIHNvcnRBID0gX2FbMF0sIHNvcnRCID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYm90aCBhcmUgbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHNvcnRBKSAmJiAhaXNOYU4oc29ydEIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ydEEgLSBzb3J0QjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBib3RoIGNhbm5vdCBiZSBldmFsdWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRBID09PSBudWxsICYmIHNvcnRCID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYiA9IF9fcmVhZChbc29ydEEsIHNvcnRCXS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocyB8fCAnJykudG9TdHJpbmcoKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgMiksIHNvcnRBID0gX2JbMF0sIHNvcnRCID0gX2JbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0QSA+IHNvcnRCKSByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRBIDwgc29ydEIpIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvdGFsSXRlbXM6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbUtleToge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2lkJ1xuICAgICAgICB9LFxuICAgICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWFyY2hMZW5ndGg6IDAsXG4gICAgICAgICAgICBkZWZhdWx0UGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgICAgIGRlc2NlbmRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhZ2U6IDEsXG4gICAgICAgICAgICAgICAgcm93c1BlclBhZ2U6IDUsXG4gICAgICAgICAgICAgICAgc29ydEJ5OiBudWxsLFxuICAgICAgICAgICAgICAgIHRvdGFsSXRlbXM6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHBhbmRlZDoge30sXG4gICAgICAgICAgICBhY3Rpb25zQ2xhc3NlczogJ3YtZGF0YS1pdGVyYXRvcl9fYWN0aW9ucycsXG4gICAgICAgICAgICBhY3Rpb25zUmFuZ2VDb250cm9sc0NsYXNzZXM6ICd2LWRhdGEtaXRlcmF0b3JfX2FjdGlvbnNfX3JhbmdlLWNvbnRyb2xzJyxcbiAgICAgICAgICAgIGFjdGlvbnNTZWxlY3RDbGFzc2VzOiAndi1kYXRhLWl0ZXJhdG9yX19hY3Rpb25zX19zZWxlY3QnLFxuICAgICAgICAgICAgYWN0aW9uc1BhZ2luYXRpb25DbGFzc2VzOiAndi1kYXRhLWl0ZXJhdG9yX19hY3Rpb25zX19wYWdpbmF0aW9uJ1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29tcHV0ZWRQYWdpbmF0aW9uOiBmdW5jdGlvbiBjb21wdXRlZFBhZ2luYXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNQYWdpbmF0aW9uID8gdGhpcy5wYWdpbmF0aW9uIDogdGhpcy5kZWZhdWx0UGFnaW5hdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWRSb3dzUGVyUGFnZUl0ZW1zOiBmdW5jdGlvbiBjb21wdXRlZFJvd3NQZXJQYWdlSXRlbXMoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93c1BlclBhZ2VJdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImlzT2JqZWN0XCJdKShpdGVtKSA/IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogX3RoaXMuJHZ1ZXRpZnkudChpdGVtLnRleHQpXG4gICAgICAgICAgICAgICAgfSkgOiB7IHZhbHVlOiBpdGVtLCB0ZXh0OiBOdW1iZXIoaXRlbSkudG9Mb2NhbGVTdHJpbmcoX3RoaXMuJHZ1ZXRpZnkubGFuZy5jdXJyZW50KSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc1BhZ2luYXRpb246IGZ1bmN0aW9uIGhhc1BhZ2luYXRpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFnaW5hdGlvbiA9IHRoaXMucGFnaW5hdGlvbiB8fCB7fTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhwYWdpbmF0aW9uKS5sZW5ndGggPiAwO1xuICAgICAgICB9LFxuICAgICAgICBoYXNTZWxlY3RBbGw6IGZ1bmN0aW9uIGhhc1NlbGVjdEFsbCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdEFsbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2VsZWN0QWxsICE9PSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbXNMZW5ndGg6IGZ1bmN0aW9uIGl0ZW1zTGVuZ3RoKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzU2VhcmNoKSByZXR1cm4gdGhpcy5zZWFyY2hMZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbEl0ZW1zIHx8IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBpbmRldGVybWluYXRlOiBmdW5jdGlvbiBpbmRldGVybWluYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzU2VsZWN0QWxsICYmIHRoaXMuc29tZUl0ZW1zICYmICF0aGlzLmV2ZXJ5SXRlbTtcbiAgICAgICAgfSxcbiAgICAgICAgZXZlcnlJdGVtOiBmdW5jdGlvbiBldmVyeUl0ZW0oKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyZWRJdGVtcy5sZW5ndGggJiYgdGhpcy5maWx0ZXJlZEl0ZW1zLmV2ZXJ5KGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzU2VsZWN0ZWQoaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc29tZUl0ZW1zOiBmdW5jdGlvbiBzb21lSXRlbXMoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyZWRJdGVtcy5zb21lKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzU2VsZWN0ZWQoaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UGFnZTogZnVuY3Rpb24gZ2V0UGFnZSgpIHtcbiAgICAgICAgICAgIHZhciByb3dzUGVyUGFnZSA9IHRoaXMuY29tcHV0ZWRQYWdpbmF0aW9uLnJvd3NQZXJQYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHJvd3NQZXJQYWdlID09PSBPYmplY3Qocm93c1BlclBhZ2UpID8gcm93c1BlclBhZ2UudmFsdWUgOiByb3dzUGVyUGFnZTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFnZVN0YXJ0OiBmdW5jdGlvbiBwYWdlU3RhcnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWdlID09PSAtMSA/IDAgOiAodGhpcy5jb21wdXRlZFBhZ2luYXRpb24ucGFnZSAtIDEpICogdGhpcy5nZXRQYWdlO1xuICAgICAgICB9LFxuICAgICAgICBwYWdlU3RvcDogZnVuY3Rpb24gcGFnZVN0b3AoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWdlID09PSAtMSA/IHRoaXMuaXRlbXNMZW5ndGggOiB0aGlzLmNvbXB1dGVkUGFnaW5hdGlvbi5wYWdlICogdGhpcy5nZXRQYWdlO1xuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXJlZEl0ZW1zOiBmdW5jdGlvbiBmaWx0ZXJlZEl0ZW1zKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyZWRJdGVtc0ltcGwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0ZWQ6IGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy52YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImdldE9iamVjdFZhbHVlQnlQYXRoXCJdKSh0aGlzLnZhbHVlW2luZGV4XSwgdGhpcy5pdGVtS2V5KTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzU2VhcmNoOiBmdW5jdGlvbiBoYXNTZWFyY2goKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2ggIT0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgaXRlbXM6IGZ1bmN0aW9uIGl0ZW1zKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFnZVN0YXJ0ID49IHRoaXMuaXRlbXNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0UGFnaW5hdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uIHNlYXJjaCgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlUGFnaW5hdGlvbih7IHBhZ2U6IDEsIHRvdGFsSXRlbXM6IF90aGlzLml0ZW1zTGVuZ3RoIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgICdjb21wdXRlZFBhZ2luYXRpb24uc29ydEJ5JzogJ3Jlc2V0UGFnaW5hdGlvbicsXG4gICAgICAgICdjb21wdXRlZFBhZ2luYXRpb24uZGVzY2VuZGluZyc6ICdyZXNldFBhZ2luYXRpb24nXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGluaXRQYWdpbmF0aW9uOiBmdW5jdGlvbiBpbml0UGFnaW5hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb3dzUGVyUGFnZUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJjb25zb2xlV2FyblwiXSkoXCJUaGUgcHJvcCAncm93cy1wZXItcGFnZS1pdGVtcycgY2FuIG5vdCBiZSBlbXB0eVwiLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0UGFnaW5hdGlvbi5yb3dzUGVyUGFnZSA9IHRoaXMucm93c1BlclBhZ2VJdGVtc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFBhZ2luYXRpb24udG90YWxJdGVtcyA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYWdpbmF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFBhZ2luYXRpb24sIHRoaXMucGFnaW5hdGlvbikpO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVQYWdpbmF0aW9uOiBmdW5jdGlvbiB1cGRhdGVQYWdpbmF0aW9uKHZhbCkge1xuICAgICAgICAgICAgdmFyIHBhZ2luYXRpb24gPSB0aGlzLmhhc1BhZ2luYXRpb24gPyB0aGlzLnBhZ2luYXRpb24gOiB0aGlzLmRlZmF1bHRQYWdpbmF0aW9uO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZWRQYWdpbmF0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgcGFnaW5hdGlvbiwgdmFsKTtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTpwYWdpbmF0aW9uJywgdXBkYXRlZFBhZ2luYXRpb24pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1BhZ2luYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRQYWdpbmF0aW9uID0gdXBkYXRlZFBhZ2luYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIGlzU2VsZWN0ZWQoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRbT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImdldE9iamVjdFZhbHVlQnlQYXRoXCJdKShpdGVtLCB0aGlzLml0ZW1LZXkpXTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNFeHBhbmRlZDogZnVuY3Rpb24gaXNFeHBhbmRlZChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmRlZFtPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZ2V0T2JqZWN0VmFsdWVCeVBhdGhcIl0pKGl0ZW0sIHRoaXMuaXRlbUtleSldO1xuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXJlZEl0ZW1zSW1wbDogZnVuY3Rpb24gZmlsdGVyZWRJdGVtc0ltcGwoKSB7XG4gICAgICAgICAgICB2YXIgYWRkaXRpb25hbEZpbHRlckFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbEZpbHRlckFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRvdGFsSXRlbXMpIHJldHVybiB0aGlzLml0ZW1zO1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzU2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMgPSB0aGlzLmN1c3RvbUZpbHRlci5hcHBseSh0aGlzLCBfX3NwcmVhZChbaXRlbXMsIHRoaXMuc2VhcmNoLCB0aGlzLmZpbHRlcl0sIGFkZGl0aW9uYWxGaWx0ZXJBcmdzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtcyA9IHRoaXMuY3VzdG9tU29ydChpdGVtcywgdGhpcy5jb21wdXRlZFBhZ2luYXRpb24uc29ydEJ5LCB0aGlzLmNvbXB1dGVkUGFnaW5hdGlvbi5kZXNjZW5kaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGVBY3Rpb25zICYmICF0aGlzLmhhc1BhZ2luYXRpb24gPyBpdGVtcyA6IGl0ZW1zLnNsaWNlKHRoaXMucGFnZVN0YXJ0LCB0aGlzLnBhZ2VTdG9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXRQYWdpbmF0aW9uOiBmdW5jdGlvbiByZXNldFBhZ2luYXRpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVkUGFnaW5hdGlvbi5wYWdlICE9PSAxICYmIHRoaXMudXBkYXRlUGFnaW5hdGlvbih7IHBhZ2U6IDEgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuY29tcHV0ZWRQYWdpbmF0aW9uLFxuICAgICAgICAgICAgICAgIHNvcnRCeSA9IF9hLnNvcnRCeSxcbiAgICAgICAgICAgICAgICBkZXNjZW5kaW5nID0gX2EuZGVzY2VuZGluZztcbiAgICAgICAgICAgIGlmIChzb3J0QnkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2luYXRpb24oeyBzb3J0Qnk6IGluZGV4LCBkZXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc29ydEJ5ID09PSBpbmRleCAmJiAhZGVzY2VuZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGFnaW5hdGlvbih7IGRlc2NlbmRpbmc6IHRydWUgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvcnRCeSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2luYXRpb24oeyBzb3J0Qnk6IGluZGV4LCBkZXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMubXVzdFNvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBhZ2luYXRpb24oeyBzb3J0Qnk6IG51bGwsIGRlc2NlbmRpbmc6IG51bGwgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGFnaW5hdGlvbih7IHNvcnRCeTogaW5kZXgsIGRlc2NlbmRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuZmlsdGVyZWRJdGVtcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImdldE9iamVjdFZhbHVlQnlQYXRoXCJdKSh0aGlzLmZpbHRlcmVkSXRlbXNbaW5kZXhdLCB0aGlzLml0ZW1LZXkpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImdldE9iamVjdFZhbHVlQnlQYXRoXCJdKShpLCBfdGhpcy5pdGVtS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRba2V5XTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlUHJvcHM6IGZ1bmN0aW9uIGNyZWF0ZVByb3BzKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHByb3BzID0geyBpdGVtOiBpdGVtLCBpbmRleDogaW5kZXggfTtcbiAgICAgICAgICAgIHZhciBrZXlQcm9wID0gdGhpcy5pdGVtS2V5O1xuICAgICAgICAgICAgdmFyIGl0ZW1LZXkgPSBPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZ2V0T2JqZWN0VmFsdWVCeVBhdGhcIl0pKGl0ZW0sIGtleVByb3ApO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAnc2VsZWN0ZWQnLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZWxlY3RlZFtpdGVtS2V5XTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJjb25zb2xlV2FyblwiXSkoXCJcXFwiXCIgKyBrZXlQcm9wICsgXCJcXFwiIGF0dHJpYnV0ZSBtdXN0IGJlIGRlZmluZWQgZm9yIGl0ZW1cIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IF90aGlzLnZhbHVlLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkgc2VsZWN0ZWQucHVzaChpdGVtKTtlbHNlIHNlbGVjdGVkID0gc2VsZWN0ZWQuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImdldE9iamVjdFZhbHVlQnlQYXRoXCJdKShpLCBrZXlQcm9wKSAhPT0gaXRlbUtleTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLiRlbWl0KCdpbnB1dCcsIHNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2V4cGFuZGVkJywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXhwYW5kZWRbaXRlbUtleV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QoX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiY29uc29sZVdhcm5cIl0pKFwiXFxcIlwiICsga2V5UHJvcCArIFwiXFxcIiBhdHRyaWJ1dGUgbXVzdCBiZSBkZWZpbmVkIGZvciBpdGVtXCIsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmV4cGFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIF90aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXhwYW5kZWQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBfdGhpcy4kc2V0KF90aGlzLmV4cGFuZGVkLCBrZXksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kc2V0KF90aGlzLmV4cGFuZGVkLCBpdGVtS2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIGdlbkl0ZW1zOiBmdW5jdGlvbiBnZW5JdGVtcygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pdGVtc0xlbmd0aCAmJiAhdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9EYXRhID0gdGhpcy4kc2xvdHNbJ25vLWRhdGEnXSB8fCB0aGlzLiR2dWV0aWZ5LnQodGhpcy5ub0RhdGFUZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMuZ2VuRW1wdHlJdGVtcyhub0RhdGEpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5maWx0ZXJlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBub1Jlc3VsdHMgPSB0aGlzLiRzbG90c1snbm8tcmVzdWx0cyddIHx8IHRoaXMuJHZ1ZXRpZnkudCh0aGlzLm5vUmVzdWx0c1RleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5nZW5FbXB0eUl0ZW1zKG5vUmVzdWx0cyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuRmlsdGVyZWRJdGVtcygpO1xuICAgICAgICB9LFxuICAgICAgICBnZW5QcmV2SWNvbjogZnVuY3Rpb24gZ2VuUHJldkljb24oKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX2NvbXBvbmVudHNfVkJ0bl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmNvbXB1dGVkUGFnaW5hdGlvbi5wYWdlID09PSAxLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBmbGF0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFnZSA9IF90aGlzLmNvbXB1dGVkUGFnaW5hdGlvbi5wYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlUGFnaW5hdGlvbih7IHBhZ2U6IHBhZ2UgLSAxIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAnYXJpYS1sYWJlbCc6IHRoaXMuJHZ1ZXRpZnkudCgnJHZ1ZXRpZnkuZGF0YUl0ZXJhdG9yLnByZXZQYWdlJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbdGhpcy4kY3JlYXRlRWxlbWVudChfY29tcG9uZW50c19WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgdGhpcy4kdnVldGlmeS5ydGwgPyB0aGlzLm5leHRJY29uIDogdGhpcy5wcmV2SWNvbildKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuTmV4dEljb246IGZ1bmN0aW9uIGdlbk5leHRJY29uKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBwYWdpbmF0aW9uID0gdGhpcy5jb21wdXRlZFBhZ2luYXRpb247XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBwYWdpbmF0aW9uLnJvd3NQZXJQYWdlIDwgMCB8fCBwYWdpbmF0aW9uLnBhZ2UgKiBwYWdpbmF0aW9uLnJvd3NQZXJQYWdlID49IHRoaXMuaXRlbXNMZW5ndGggfHwgdGhpcy5wYWdlU3RvcCA8IDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudChfY29tcG9uZW50c19WQnRuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICBpY29uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBmbGF0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFnZSA9IF90aGlzLmNvbXB1dGVkUGFnaW5hdGlvbi5wYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlUGFnaW5hdGlvbih7IHBhZ2U6IHBhZ2UgKyAxIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAnYXJpYS1sYWJlbCc6IHRoaXMuJHZ1ZXRpZnkudCgnJHZ1ZXRpZnkuZGF0YUl0ZXJhdG9yLm5leHRQYWdlJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbdGhpcy4kY3JlYXRlRWxlbWVudChfY29tcG9uZW50c19WSWNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgdGhpcy4kdnVldGlmeS5ydGwgPyB0aGlzLnByZXZJY29uIDogdGhpcy5uZXh0SWNvbildKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuU2VsZWN0OiBmdW5jdGlvbiBnZW5TZWxlY3QoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiB0aGlzLmFjdGlvbnNTZWxlY3RDbGFzc2VzXG4gICAgICAgICAgICB9LCBbdGhpcy4kdnVldGlmeS50KHRoaXMucm93c1BlclBhZ2VUZXh0KSwgdGhpcy4kY3JlYXRlRWxlbWVudChfY29tcG9uZW50c19WU2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLiR2dWV0aWZ5LnQodGhpcy5yb3dzUGVyUGFnZVRleHQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBpdGVtczogdGhpcy5jb21wdXRlZFJvd3NQZXJQYWdlSXRlbXMsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNvbXB1dGVkUGFnaW5hdGlvbi5yb3dzUGVyUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZURldGFpbHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lbnVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0bzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhcms6IHRoaXMuZGFyayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZ2h0OiB0aGlzLmxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6ICc3NXB4J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24gaW5wdXQodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVQYWdpbmF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd3NQZXJQYWdlOiB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuUGFnaW5hdGlvbjogZnVuY3Rpb24gZ2VuUGFnaW5hdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcGFnaW5hdGlvbiA9ICfigJMnO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcCA9IHRoaXMuaXRlbXNMZW5ndGggPCB0aGlzLnBhZ2VTdG9wIHx8IHRoaXMucGFnZVN0b3AgPCAwID8gdGhpcy5pdGVtc0xlbmd0aCA6IHRoaXMucGFnZVN0b3A7XG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvbiA9IHRoaXMuJHNjb3BlZFNsb3RzLnBhZ2VUZXh0ID8gdGhpcy4kc2NvcGVkU2xvdHMucGFnZVRleHQoe1xuICAgICAgICAgICAgICAgICAgICBwYWdlU3RhcnQ6IHRoaXMucGFnZVN0YXJ0ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZVN0b3A6IHN0b3AsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zTGVuZ3RoOiB0aGlzLml0ZW1zTGVuZ3RoXG4gICAgICAgICAgICAgICAgfSkgOiAoX2EgPSB0aGlzLiR2dWV0aWZ5KS50LmFwcGx5KF9hLCBfX3NwcmVhZChbJyR2dWV0aWZ5LmRhdGFJdGVyYXRvci5wYWdlVGV4dCddLCBbdGhpcy5wYWdlU3RhcnQgKyAxLCBzdG9wLCB0aGlzLml0ZW1zTGVuZ3RoXS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcihuKS50b0xvY2FsZVN0cmluZyhfdGhpcy4kdnVldGlmeS5sYW5nLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgICAgICdjbGFzcyc6IHRoaXMuYWN0aW9uc1BhZ2luYXRpb25DbGFzc2VzXG4gICAgICAgICAgICB9LCBbcGFnaW5hdGlvbl0pO1xuICAgICAgICB9LFxuICAgICAgICBnZW5BY3Rpb25zOiBmdW5jdGlvbiBnZW5BY3Rpb25zKCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlQ29udHJvbHMgPSB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogdGhpcy5hY3Rpb25zUmFuZ2VDb250cm9sc0NsYXNzZXNcbiAgICAgICAgICAgIH0sIFt0aGlzLmdlblBhZ2luYXRpb24oKSwgdGhpcy5nZW5QcmV2SWNvbigpLCB0aGlzLmdlbk5leHRJY29uKCldKTtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgICAgICdjbGFzcyc6IHRoaXMuYWN0aW9uc0NsYXNzZXNcbiAgICAgICAgICAgIH0sIFt0aGlzLiRzbG90c1snYWN0aW9ucy1wcmVwZW5kJ10gPyB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7fSwgdGhpcy4kc2xvdHNbJ2FjdGlvbnMtcHJlcGVuZCddKSA6IG51bGwsIHRoaXMucm93c1BlclBhZ2VJdGVtcy5sZW5ndGggPiAxID8gdGhpcy5nZW5TZWxlY3QoKSA6IG51bGwsIHJhbmdlQ29udHJvbHMsIHRoaXMuJHNsb3RzWydhY3Rpb25zLWFwcGVuZCddID8gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2Jywge30sIHRoaXMuJHNsb3RzWydhY3Rpb25zLWFwcGVuZCddKSA6IG51bGxdKV07XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWl4aW5zL2RlbGF5YWJsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9kZWxheWFibGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFwidnVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcblxuLyoqXG4gKiBEZWxheWFibGVcbiAqXG4gKiBAbWl4aW5cbiAqXG4gKiBDaGFuZ2VzIHRoZSBvcGVuIG9yIGNsb3NlIGRlbGF5IHRpbWUgZm9yIGVsZW1lbnRzXG4gKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7XG4gICAgbmFtZTogJ2RlbGF5YWJsZScsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgb3BlbkRlbGF5OiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICB9LFxuICAgICAgICBjbG9zZURlbGF5OiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3BlblRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNsb3NlVGltZW91dDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhciBhbnkgcGVuZGluZyBkZWxheSB0aW1lcnMgZnJvbSBleGVjdXRpbmdcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyRGVsYXk6IGZ1bmN0aW9uIGNsZWFyRGVsYXkoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5vcGVuVGltZW91dCk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zZVRpbWVvdXQpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUnVucyBjYWxsYmFjayBhZnRlciBhIHNwZWNpZmllZCBkZWxheVxuICAgICAgICAgKi9cbiAgICAgICAgcnVuRGVsYXk6IGZ1bmN0aW9uIHJ1bkRlbGF5KHR5cGUsIGNiKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyRGVsYXkoKTtcbiAgICAgICAgICAgIHZhciBkZWxheSA9IHBhcnNlSW50KHRoaXNbdHlwZSArIFwiRGVsYXlcIl0sIDEwKTtcbiAgICAgICAgICAgIHRoaXNbdHlwZSArIFwiVGltZW91dFwiXSA9IHNldFRpbWVvdXQoY2IsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWl4aW5zL2RlcGVuZGVudC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9kZXBlbmRlbnQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9taXhpbnMgKi8gXCIuL3NyYy91dGlsL21peGlucy50c1wiKTtcbnZhciBfX3JlYWQgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fcmVhZCB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLFxuICAgICAgICByLFxuICAgICAgICBhciA9IFtdLFxuICAgICAgICBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBhci5wdXNoKHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZSA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19zcHJlYWQgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICB9cmV0dXJuIGFyO1xufTtcblxuZnVuY3Rpb24gc2VhcmNoQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjaGlsZHJlbi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGQuaXNBY3RpdmUgJiYgY2hpbGQuaXNEZXBlbmRlbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgX19zcHJlYWQoc2VhcmNoQ2hpbGRyZW4oY2hpbGQuJGNoaWxkcmVuKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoT2JqZWN0KF91dGlsX21peGluc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSkoKS5leHRlbmQoe1xuICAgIG5hbWU6ICdkZXBlbmRlbnQnLFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbG9zZURlcGVuZGVudHM6IHRydWUsXG4gICAgICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBpc0RlcGVuZGVudDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKHZhbCkge1xuICAgICAgICAgICAgaWYgKHZhbCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG9wZW5EZXBlbmRlbnRzID0gdGhpcy5nZXRPcGVuRGVwZW5kZW50cygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG9wZW5EZXBlbmRlbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIG9wZW5EZXBlbmRlbnRzW2luZGV4XS5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldE9wZW5EZXBlbmRlbnRzOiBmdW5jdGlvbiBnZXRPcGVuRGVwZW5kZW50cygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsb3NlRGVwZW5kZW50cykgcmV0dXJuIHNlYXJjaENoaWxkcmVuKHRoaXMuJGNoaWxkcmVuKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3BlbkRlcGVuZGVudEVsZW1lbnRzOiBmdW5jdGlvbiBnZXRPcGVuRGVwZW5kZW50RWxlbWVudHMoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgb3BlbkRlcGVuZGVudHMgPSB0aGlzLmdldE9wZW5EZXBlbmRlbnRzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgb3BlbkRlcGVuZGVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfX3NwcmVhZChvcGVuRGVwZW5kZW50c1tpbmRleF0uZ2V0Q2xpY2thYmxlRGVwZW5kZW50RWxlbWVudHMoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q2xpY2thYmxlRGVwZW5kZW50RWxlbWVudHM6IGZ1bmN0aW9uIGdldENsaWNrYWJsZURlcGVuZGVudEVsZW1lbnRzKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFt0aGlzLiRlbF07XG4gICAgICAgICAgICBpZiAodGhpcy4kcmVmcy5jb250ZW50KSByZXN1bHQucHVzaCh0aGlzLiRyZWZzLmNvbnRlbnQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBfX3NwcmVhZCh0aGlzLmdldE9wZW5EZXBlbmRlbnRFbGVtZW50cygpKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvZGV0YWNoYWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9taXhpbnMvZGV0YWNoYWJsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ib290YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ib290YWJsZSAqLyBcIi4vc3JjL21peGlucy9ib290YWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2NvbnNvbGUgKi8gXCIuL3NyYy91dGlsL2NvbnNvbGUudHNcIik7XG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUF0dGFjaFRhcmdldCh2YWwpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCk7XG4gICAgaWYgKHR5cGUgPT09ICdib29sZWFuJyB8fCB0eXBlID09PSAnc3RyaW5nJykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHZhbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG59XG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ2RldGFjaGFibGUnLFxuICAgIG1peGluczogW19ib290YWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgYXR0YWNoOiB7XG4gICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICB2YWxpZGF0b3I6IHZhbGlkYXRlQXR0YWNoVGFyZ2V0XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRDbGFzczoge1xuICAgICAgICAgICAgZGVmYXVsdDogJydcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc0RldGFjaGVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgYXR0YWNoOiBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0RldGFjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmluaXREZXRhY2goKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzQ29udGVudDogJ2luaXREZXRhY2gnXG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICAhdGhpcy5sYXp5ICYmIHRoaXMuaW5pdERldGFjaCgpO1xuICAgIH0sXG4gICAgZGVhY3RpdmF0ZWQ6IGZ1bmN0aW9uIGRlYWN0aXZhdGVkKCkge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMuJHJlZnMuY29udGVudCkgcmV0dXJuO1xuICAgICAgICAvLyBJRTExIEZpeFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy4kcmVmcy5jb250ZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kcmVmcy5jb250ZW50KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2V0U2NvcGVJZEF0dHJzOiBmdW5jdGlvbiBnZXRTY29wZUlkQXR0cnMoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgc2NvcGVJZCA9IHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLmNvbnRleHQuJG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVJZCAmJiAoX2EgPSB7fSwgX2Fbc2NvcGVJZF0gPSAnJywgX2EpO1xuICAgICAgICB9LFxuICAgICAgICBpbml0RGV0YWNoOiBmdW5jdGlvbiBpbml0RGV0YWNoKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzRGVzdHJveWVkIHx8ICF0aGlzLiRyZWZzLmNvbnRlbnQgfHwgdGhpcy5oYXNEZXRhY2hlZCB8fFxuICAgICAgICAgICAgLy8gTGVhdmUgbWVudSBpbiBwbGFjZSBpZiBhdHRhY2hlZFxuICAgICAgICAgICAgLy8gYW5kIGRldiBoYXMgbm90IGNoYW5nZWQgdGFyZ2V0XG4gICAgICAgICAgICB0aGlzLmF0dGFjaCA9PT0gJycgfHwgLy8gSWYgdXNlZCBhcyBhIGJvb2xlYW4gcHJvcCAoPHYtbWVudSBhdHRhY2g+KVxuICAgICAgICAgICAgdGhpcy5hdHRhY2ggPT09IHRydWUgfHwgLy8gSWYgYm91bmQgdG8gYSBib29sZWFuICg8di1tZW51IDphdHRhY2g9XCJ0cnVlXCI+KVxuICAgICAgICAgICAgdGhpcy5hdHRhY2ggPT09ICdhdHRhY2gnIC8vIElmIGJvdW5kIGFzIGJvb2xlYW4gcHJvcCBpbiBwdWcgKHYtbWVudShhdHRhY2gpKVxuICAgICAgICAgICAgKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHRoaXMuYXR0YWNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQsIGRldGFjaCB0byBhcHBcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hcHBdJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmF0dGFjaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBDU1Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuYXR0YWNoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRE9NIEVsZW1lbnRcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmF0dGFjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImNvbnNvbGVXYXJuXCJdKShcIlVuYWJsZSB0byBsb2NhdGUgdGFyZ2V0IFwiICsgKHRoaXMuYXR0YWNoIHx8ICdbZGF0YS1hcHBdJyksIHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcy4kcmVmcy5jb250ZW50LCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLmhhc0RldGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvZmlsdGVyYWJsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9taXhpbnMvZmlsdGVyYWJsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFwidnVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7XG4gICAgbmFtZTogJ2ZpbHRlcmFibGUnLFxuICAgIHByb3BzOiB7XG4gICAgICAgIG5vRGF0YVRleHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICckdnVldGlmeS5ub0RhdGFUZXh0J1xuICAgICAgICB9XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvZ3JvdXBhYmxlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWl4aW5zL2dyb3VwYWJsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGZhY3RvcnksIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmFjdG9yeVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhY3Rvcnk7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZWdpc3RyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZWdpc3RyYWJsZSAqLyBcIi4vc3JjL21peGlucy9yZWdpc3RyYWJsZS50c1wiKTtcbi8vIE1peGluc1xuXG5mdW5jdGlvbiBmYWN0b3J5KG5hbWVzcGFjZSwgY2hpbGQsIHBhcmVudCkge1xuICAgIHJldHVybiBPYmplY3QoX3JlZ2lzdHJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpbmplY3RcIl0pKG5hbWVzcGFjZSwgY2hpbGQsIHBhcmVudCkuZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogJ2dyb3VwYWJsZScsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBhY3RpdmVDbGFzczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzW25hbWVzcGFjZV0pIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW25hbWVzcGFjZV0uYWN0aXZlQ2xhc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBCb29sZWFuXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgICAgIGdyb3VwQ2xhc3NlczogZnVuY3Rpb24gZ3JvdXBDbGFzc2VzKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlQ2xhc3MpIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2EgPSB7fSwgX2FbdGhpcy5hY3RpdmVDbGFzc10gPSB0aGlzLmlzQWN0aXZlLCBfYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZXNwYWNlXSAmJiB0aGlzW25hbWVzcGFjZV0ucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVzcGFjZV0gJiYgdGhpc1tuYW1lc3BhY2VdLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlICovXG52YXIgR3JvdXBhYmxlID0gZmFjdG9yeSgnaXRlbUdyb3VwJyk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKEdyb3VwYWJsZSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21peGlucy9sb2FkYWJsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWl4aW5zL2xvYWRhYmxlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFwidnVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tcG9uZW50c19WUHJvZ3Jlc3NMaW5lYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NvbXBvbmVudHMvVlByb2dyZXNzTGluZWFyICovIFwiLi9zcmMvY29tcG9uZW50cy9WUHJvZ3Jlc3NMaW5lYXIvaW5kZXgudHNcIik7XG5cblxuLyoqXG4gKiBMb2FkYWJsZVxuICpcbiAqIEBtaXhpblxuICpcbiAqIFVzZWQgdG8gYWRkIGxpbmVhciBwcm9ncmVzcyBiYXIgdG8gY29tcG9uZW50c1xuICogQ2FuIHVzZSBhIGRlZmF1bHQgYmFyIHdpdGggYSBzcGVjaWZpYyBjb2xvclxuICogb3IgZGVzaWduYXRlIGEgY3VzdG9tIHByb2dyZXNzIGxpbmVhciBiYXJcbiAqL1xuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCgpLmV4dGVuZCh7XG4gICAgbmFtZTogJ2xvYWRhYmxlJyxcbiAgICBwcm9wczoge1xuICAgICAgICBsb2FkaW5nOiB7XG4gICAgICAgICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuUHJvZ3Jlc3M6IGZ1bmN0aW9uIGdlblByb2dyZXNzKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGluZyA9PT0gZmFsc2UpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNsb3RzLnByb2dyZXNzIHx8IHRoaXMuJGNyZWF0ZUVsZW1lbnQoX2NvbXBvbmVudHNfVlByb2dyZXNzTGluZWFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLCB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMubG9hZGluZyA9PT0gdHJ1ZSB8fCB0aGlzLmxvYWRpbmcgPT09ICcnID8gdGhpcy5jb2xvciB8fCAncHJpbWFyeScgOiB0aGlzLmxvYWRpbmcsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMixcbiAgICAgICAgICAgICAgICAgICAgaW5kZXRlcm1pbmF0ZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvbWFza2FibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9tYXNrYWJsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9tYXNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL21hc2sgKi8gXCIuL3NyYy91dGlsL21hc2suanNcIik7XG4vKipcbiAqIE1hc2thYmxlXG4gKlxuICogQG1peGluXG4gKlxuICogQ3JlYXRlcyBhbiBpbnB1dCBtYXNrIHRoYXQgaXNcbiAqIGdlbmVyYXRlZCBmcm9tIGEgbWFza2VkIHN0clxuICpcbiAqIEV4YW1wbGU6IG1hc2s9XCIjIyMjICMjIyMgIyMjIyAjIyMjXCJcbiAqL1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ21hc2thYmxlJyxcbiAgICBwcm9wczoge1xuICAgICAgICBkb250RmlsbE1hc2tCbGFua3M6IEJvb2xlYW4sXG4gICAgICAgIG1hc2s6IHtcbiAgICAgICAgICAgIHR5cGU6IFtPYmplY3QsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHJldHVybk1hc2tlZFZhbHVlOiBCb29sZWFuXG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0aW9uOiAwLFxuICAgICAgICAgICAgbGF6eVNlbGVjdGlvbjogMCxcbiAgICAgICAgICAgIHByZURlZmluZWQ6IHtcbiAgICAgICAgICAgICAgICAnY3JlZGl0LWNhcmQnOiAnIyMjIyAtICMjIyMgLSAjIyMjIC0gIyMjIycsXG4gICAgICAgICAgICAgICAgJ2RhdGUnOiAnIyMvIyMvIyMjIycsXG4gICAgICAgICAgICAgICAgJ2RhdGUtd2l0aC10aW1lJzogJyMjLyMjLyMjIyMgIyM6IyMnLFxuICAgICAgICAgICAgICAgICdwaG9uZSc6ICcoIyMjKSAjIyMgLSAjIyMjJyxcbiAgICAgICAgICAgICAgICAnc29jaWFsJzogJyMjIy0jIy0jIyMjJyxcbiAgICAgICAgICAgICAgICAndGltZSc6ICcjIzojIycsXG4gICAgICAgICAgICAgICAgJ3RpbWUtd2l0aC1zZWNvbmRzJzogJyMjOiMjOiMjJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgbWFza2VkOiBmdW5jdGlvbiBtYXNrZWQoKSB7XG4gICAgICAgICAgICB2YXIgcHJlRGVmaW5lZCA9IHRoaXMucHJlRGVmaW5lZFt0aGlzLm1hc2tdO1xuICAgICAgICAgICAgdmFyIG1hc2sgPSBwcmVEZWZpbmVkIHx8IHRoaXMubWFzayB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBtYXNrLnNwbGl0KCcnKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzIGluIHRoZSBjb3JyZWN0XG4gICAgICAgICAqIGxvY2F0aW9uIHdoZW4gdGhlIG1hc2sgY2hhbmdlc1xuICAgICAgICAgKi9cbiAgICAgICAgbWFzazogZnVuY3Rpb24gbWFzaygpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJHJlZnMuaW5wdXQpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuJHJlZnMuaW5wdXQudmFsdWU7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLm1hc2tUZXh0KE9iamVjdChfdXRpbF9tYXNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJ1bm1hc2tUZXh0XCJdKSh0aGlzLmxhenlWYWx1ZSkpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzZWxlY3Rpb247IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBPYmplY3QoX3V0aWxfbWFza19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNNYXNrRGVsaW1pdGVyXCJdKShvbGRWYWx1ZVtpbmRleF0pIHx8IHBvc2l0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSAwO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG5ld1ZhbHVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QoX3V0aWxfbWFza19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaXNNYXNrRGVsaW1pdGVyXCJdKShuZXdWYWx1ZVtpbmRleF0pIHx8IHBvc2l0aW9uLS07XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbisrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gMCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLiRyZWZzLmlucHV0LnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0Q2FyZXRQb3NpdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hc2sgfHwgdGhpcy52YWx1ZSA9PSBudWxsIHx8ICF0aGlzLnJldHVybk1hc2tlZFZhbHVlKSByZXR1cm47XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubWFza1RleHQodGhpcy52YWx1ZSk7XG4gICAgICAgIC8vIFNlZSBpZiBtYXNrZWQgdmFsdWUgZG9lcyBub3RcbiAgICAgICAgLy8gbWF0Y2ggdGhlIHVzZXIgZ2l2ZW4gdmFsdWVcbiAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLnZhbHVlKSByZXR1cm47XG4gICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdmFsdWUpO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBzZXRDYXJldFBvc2l0aW9uOiBmdW5jdGlvbiBzZXRDYXJldFBvc2l0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLiRyZWZzLmlucHV0ICYmIF90aGlzLiRyZWZzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKF90aGlzLnNlbGVjdGlvbiwgX3RoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVSYW5nZTogZnVuY3Rpb24gdXBkYXRlUmFuZ2UoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuJHJlZnMuaW5wdXQpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMubWFza1RleHQodGhpcy5sYXp5VmFsdWUpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IDA7XG4gICAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0LnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbmV3VmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhenlTZWxlY3Rpb24gPD0gMCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdChfdXRpbF9tYXNrX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpc01hc2tEZWxpbWl0ZXJcIl0pKG5ld1ZhbHVlW2luZGV4XSkgfHwgdGhpcy5sYXp5U2VsZWN0aW9uLS07XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0Q2FyZXRQb3NpdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICAgICAgLy8gdGhpcy4kZW1pdCgpIG11c3Qgb2NjdXIgb25seSB3aGVuIGFsbCBpbnRlcm5hbCB2YWx1ZXMgYXJlIGNvcnJlY3RcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy5yZXR1cm5NYXNrZWRWYWx1ZSA/IHRoaXMuJHJlZnMuaW5wdXQudmFsdWUgOiB0aGlzLmxhenlWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1hc2tUZXh0OiBmdW5jdGlvbiBtYXNrVGV4dCh0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXNrID8gT2JqZWN0KF91dGlsX21hc2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIm1hc2tUZXh0XCJdKSh0ZXh0LCB0aGlzLm1hc2tlZCwgdGhpcy5kb250RmlsbE1hc2tCbGFua3MpIDogdGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgdW5tYXNrVGV4dDogZnVuY3Rpb24gdW5tYXNrVGV4dCh0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXNrICYmICF0aGlzLnJldHVybk1hc2tlZFZhbHVlID8gT2JqZWN0KF91dGlsX21hc2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInVubWFza1RleHRcIl0pKHRleHQpIDogdGV4dDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gV2hlbiB0aGUgaW5wdXQgY2hhbmdlcyBhbmQgaXNcbiAgICAgICAgLy8gcmUtY3JlYXRlZCwgZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgIC8vIGNhcmV0IGxvY2F0aW9uIGlzIGNvcnJlY3RcbiAgICAgICAgc2V0U2VsZWN0aW9uUmFuZ2U6IGZ1bmN0aW9uIHNldFNlbGVjdGlvblJhbmdlKCkge1xuICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2sodGhpcy51cGRhdGVSYW5nZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0U2VsZWN0aW9uczogZnVuY3Rpb24gcmVzZXRTZWxlY3Rpb25zKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0LnNlbGVjdGlvbkVuZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBpbnB1dC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICB0aGlzLmxhenlTZWxlY3Rpb24gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc2VsZWN0aW9uOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0KF91dGlsX21hc2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImlzTWFza0RlbGltaXRlclwiXSkoaW5wdXQudmFsdWVbaW5kZXhdKSB8fCB0aGlzLmxhenlTZWxlY3Rpb24rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvbWVhc3VyYWJsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9taXhpbnMvbWVhc3VyYWJsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFwidnVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHtcbiAgICBuYW1lOiAnbWVhc3VyYWJsZScsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgaGVpZ2h0OiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICBtYXhIZWlnaHQ6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgIG1heFdpZHRoOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICB3aWR0aDogW051bWJlciwgU3RyaW5nXVxuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWl4aW5zL21lbnVhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9taXhpbnMvbWVudWFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB2dWUgKi8gXCJ2dWVcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wb3NpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9zaXRpb25hYmxlICovIFwiLi9zcmMvbWl4aW5zL3Bvc2l0aW9uYWJsZS50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3RhY2thYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0YWNrYWJsZSAqLyBcIi4vc3JjL21peGlucy9zdGFja2FibGUuanNcIik7XG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cblxuXG5cbi8qIGVzbGludC1kaXNhYmxlIG9iamVjdC1wcm9wZXJ0eS1uZXdsaW5lICovXG52YXIgZGltZW5zaW9ucyA9IHtcbiAgICBhY3RpdmF0b3I6IHtcbiAgICAgICAgdG9wOiAwLCBsZWZ0OiAwLFxuICAgICAgICBib3R0b206IDAsIHJpZ2h0OiAwLFxuICAgICAgICB3aWR0aDogMCwgaGVpZ2h0OiAwLFxuICAgICAgICBvZmZzZXRUb3A6IDAsIHNjcm9sbEhlaWdodDogMFxuICAgIH0sXG4gICAgY29udGVudDoge1xuICAgICAgICB0b3A6IDAsIGxlZnQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCwgcmlnaHQ6IDAsXG4gICAgICAgIHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG4gICAgICAgIG9mZnNldFRvcDogMCwgc2Nyb2xsSGVpZ2h0OiAwXG4gICAgfSxcbiAgICBoYXNXaW5kb3c6IGZhbHNlXG59O1xuLyogZXNsaW50LWVuYWJsZSBvYmplY3QtcHJvcGVydHktbmV3bGluZSAqL1xuLyoqXG4gKiBNZW51YWJsZVxuICpcbiAqIEBtaXhpblxuICpcbiAqIFVzZWQgZm9yIGZpeGVkIG9yIGFic29sdXRlbHkgcG9zaXRpb25pbmdcbiAqIGVsZW1lbnRzIHdpdGhpbiB0aGUgRE9NXG4gKiBDYW4gY2FsY3VsYXRlIFggYW5kIFkgYXhpcyBvdmVyZmxvd3NcbiAqIEFzIHdlbGwgYXMgYmUgbWFudWFsbHkgcG9zaXRpb25lZFxuICovXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHtcbiAgICBuYW1lOiAnbWVudWFibGUnLFxuICAgIG1peGluczogW19wb3NpdGlvbmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIF9zdGFja2FibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl1dLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGFjdGl2YXRvcjoge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ3N0cmluZycsICdvYmplY3QnXS5pbmNsdWRlcyh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWxsb3dPdmVyZmxvdzogQm9vbGVhbixcbiAgICAgICAgaW5wdXRBY3RpdmF0b3I6IEJvb2xlYW4sXG4gICAgICAgIGxpZ2h0OiBCb29sZWFuLFxuICAgICAgICBkYXJrOiBCb29sZWFuLFxuICAgICAgICBtYXhXaWR0aDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhdXRvJ1xuICAgICAgICB9LFxuICAgICAgICBtaW5XaWR0aDogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgbnVkZ2VCb3R0b206IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG51ZGdlTGVmdDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgbnVkZ2VSaWdodDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgbnVkZ2VUb3A6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG51ZGdlV2lkdGg6IHtcbiAgICAgICAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldE92ZXJmbG93OiBCb29sZWFuLFxuICAgICAgICBwb3NpdGlvblg6IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb25ZOiB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHpJbmRleDoge1xuICAgICAgICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFic29sdXRlWDogMCxcbiAgICAgICAgICAgIGFic29sdXRlWTogMCxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IE9iamVjdC5hc3NpZ24oe30sIGRpbWVuc2lvbnMpLFxuICAgICAgICAgICAgaXNDb250ZW50QWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIHBhZ2VZT2Zmc2V0OiAwLFxuICAgICAgICAgICAgc3RhY2tDbGFzczogJ3YtbWVudV9fY29udGVudC0tYWN0aXZlJyxcbiAgICAgICAgICAgIHN0YWNrTWluWkluZGV4OiA2XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBjb21wdXRlZExlZnQ6IGZ1bmN0aW9uIGNvbXB1dGVkTGVmdCgpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5kaW1lbnNpb25zLmFjdGl2YXRvcjtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5kaW1lbnNpb25zLmNvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgbWluV2lkdGggPSBhLndpZHRoIDwgYy53aWR0aCA/IGMud2lkdGggOiBhLndpZHRoO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSAwO1xuICAgICAgICAgICAgbGVmdCArPSB0aGlzLmxlZnQgPyBhLmxlZnQgLSAobWluV2lkdGggLSBhLndpZHRoKSA6IGEubGVmdDtcbiAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldFgpIGxlZnQgKz0gdGhpcy5sZWZ0ID8gLWEud2lkdGggOiBhLndpZHRoO1xuICAgICAgICAgICAgaWYgKHRoaXMubnVkZ2VMZWZ0KSBsZWZ0IC09IHBhcnNlSW50KHRoaXMubnVkZ2VMZWZ0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm51ZGdlUmlnaHQpIGxlZnQgKz0gcGFyc2VJbnQodGhpcy5udWRnZVJpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9LFxuICAgICAgICBjb21wdXRlZFRvcDogZnVuY3Rpb24gY29tcHV0ZWRUb3AoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuZGltZW5zaW9ucy5hY3RpdmF0b3I7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuZGltZW5zaW9ucy5jb250ZW50O1xuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMudG9wID8gYS5ib3R0b20gLSBjLmhlaWdodCA6IGEudG9wO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpIHRvcCArPSB0aGlzLnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHRoaXMub2Zmc2V0WSkgdG9wICs9IHRoaXMudG9wID8gLWEuaGVpZ2h0IDogYS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5udWRnZVRvcCkgdG9wIC09IHBhcnNlSW50KHRoaXMubnVkZ2VUb3ApO1xuICAgICAgICAgICAgaWYgKHRoaXMubnVkZ2VCb3R0b20pIHRvcCArPSBwYXJzZUludCh0aGlzLm51ZGdlQm90dG9tKTtcbiAgICAgICAgICAgIHJldHVybiB0b3A7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc0FjdGl2YXRvcjogZnVuY3Rpb24gaGFzQWN0aXZhdG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHMuYWN0aXZhdG9yIHx8IHRoaXMuYWN0aXZhdG9yIHx8IHRoaXMuaW5wdXRBY3RpdmF0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIGlzQXR0YWNoZWQ6IGZ1bmN0aW9uIGlzQXR0YWNoZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2ggIT09IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQodmFsKSB7XG4gICAgICAgICAgICB2YWwgJiYgdGhpcy5jYWxsRGVhY3RpdmF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUodmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFsID8gdGhpcy5jYWxsQWN0aXZhdGUoKSA6IHRoaXMuY2FsbERlYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50KCkge1xuICAgICAgICB0aGlzLmNoZWNrRm9yV2luZG93KCk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGFic29sdXRlUG9zaXRpb246IGZ1bmN0aW9uIGFic29sdXRlUG9zaXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9mZnNldFRvcDogMCxcbiAgICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLnBvc2l0aW9uWSB8fCB0aGlzLmFic29sdXRlWSxcbiAgICAgICAgICAgICAgICBib3R0b206IHRoaXMucG9zaXRpb25ZIHx8IHRoaXMuYWJzb2x1dGVZLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMucG9zaXRpb25YIHx8IHRoaXMuYWJzb2x1dGVYLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLnBvc2l0aW9uWCB8fCB0aGlzLmFic29sdXRlWCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbiBhY3RpdmF0ZSgpIHt9LFxuICAgICAgICBjYWxjTGVmdDogZnVuY3Rpb24gY2FsY0xlZnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaXNBdHRhY2hlZCA/IHRoaXMuY29tcHV0ZWRMZWZ0IDogdGhpcy5jYWxjWE92ZXJmbG93KHRoaXMuY29tcHV0ZWRMZWZ0KSkgKyBcInB4XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGNUb3A6IGZ1bmN0aW9uIGNhbGNUb3AoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaXNBdHRhY2hlZCA/IHRoaXMuY29tcHV0ZWRUb3AgOiB0aGlzLmNhbGNZT3ZlcmZsb3codGhpcy5jb21wdXRlZFRvcCkpICsgXCJweFwiO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjWE92ZXJmbG93OiBmdW5jdGlvbiBjYWxjWE92ZXJmbG93KGxlZnQpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRNYXhXaWR0aCA9IGlzTmFOKHBhcnNlSW50KHRoaXMubWF4V2lkdGgpKSA/IDAgOiBwYXJzZUludCh0aGlzLm1heFdpZHRoKTtcbiAgICAgICAgICAgIHZhciBpbm5lcldpZHRoID0gdGhpcy5nZXRJbm5lcldpZHRoKCk7XG4gICAgICAgICAgICB2YXIgbWF4V2lkdGggPSBNYXRoLm1heCh0aGlzLmRpbWVuc2lvbnMuY29udGVudC53aWR0aCwgcGFyc2VkTWF4V2lkdGgpO1xuICAgICAgICAgICAgdmFyIHRvdGFsV2lkdGggPSBsZWZ0ICsgbWF4V2lkdGg7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB0b3RhbFdpZHRoIC0gaW5uZXJXaWR0aDtcbiAgICAgICAgICAgIGlmICgoIXRoaXMubGVmdCB8fCB0aGlzLnJpZ2h0KSAmJiBhdmFpbGFibGVXaWR0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gaW5uZXJXaWR0aCAtIG1heFdpZHRoIC0gKGlubmVyV2lkdGggPiA2MDAgPyAzMCA6IDEyKSAvLyBBY2NvdW50IGZvciBzY3JvbGxiYXJcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdCA8IDApIGxlZnQgPSAxMjtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgICB9LFxuICAgICAgICBjYWxjWU92ZXJmbG93OiBmdW5jdGlvbiBjYWxjWU92ZXJmbG93KHRvcCkge1xuICAgICAgICAgICAgdmFyIGRvY3VtZW50SGVpZ2h0ID0gdGhpcy5nZXRJbm5lckhlaWdodCgpO1xuICAgICAgICAgICAgdmFyIHRvVG9wID0gdGhpcy5wYWdlWU9mZnNldCArIGRvY3VtZW50SGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGFjdGl2YXRvciA9IHRoaXMuZGltZW5zaW9ucy5hY3RpdmF0b3I7XG4gICAgICAgICAgICB2YXIgY29udGVudEhlaWdodCA9IHRoaXMuZGltZW5zaW9ucy5jb250ZW50LmhlaWdodDtcbiAgICAgICAgICAgIHZhciB0b3RhbEhlaWdodCA9IHRvcCArIGNvbnRlbnRIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgaXNPdmVyZmxvd2luZyA9IHRvVG9wIDwgdG90YWxIZWlnaHQ7XG4gICAgICAgICAgICAvLyBJZiBvdmVyZmxvd2luZyBib3R0b20gYW5kIG9mZnNldFxuICAgICAgICAgICAgLy8gVE9ETzogc2V0ICdib3R0b20nIHBvc2l0aW9uIGluc3RlYWQgb2YgJ3RvcCdcbiAgICAgICAgICAgIGlmIChpc092ZXJmbG93aW5nICYmIHRoaXMub2Zmc2V0T3ZlcmZsb3cgJiZcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgZW5vdWdoIHJvb20gdG8gb2Zmc2V0XG4gICAgICAgICAgICAvLyB0aGUgb3ZlcmZsb3csIGRvbid0IG9mZnNldFxuICAgICAgICAgICAgYWN0aXZhdG9yLnRvcCA+IGNvbnRlbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLnBhZ2VZT2Zmc2V0ICsgKGFjdGl2YXRvci50b3AgLSBjb250ZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAvLyBJZiBvdmVyZmxvd2luZyBib3R0b21cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPdmVyZmxvd2luZyAmJiAhdGhpcy5hbGxvd092ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgdG9wID0gdG9Ub3AgLSBjb250ZW50SGVpZ2h0IC0gMTI7XG4gICAgICAgICAgICAgICAgLy8gSWYgb3ZlcmZsb3dpbmcgdG9wXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvcCA8IHRoaXMucGFnZVlPZmZzZXQgJiYgIXRoaXMuYWxsb3dPdmVyZmxvdykge1xuICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMucGFnZVlPZmZzZXQgKyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3AgPCAxMiA/IDEyIDogdG9wO1xuICAgICAgICB9LFxuICAgICAgICBjYWxsQWN0aXZhdGU6IGZ1bmN0aW9uIGNhbGxBY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNXaW5kb3cpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsbERlYWN0aXZhdGU6IGZ1bmN0aW9uIGNhbGxEZWFjdGl2YXRlKCkge1xuICAgICAgICAgICAgdGhpcy5pc0NvbnRlbnRBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBjaGVja0ZvcldpbmRvdzogZnVuY3Rpb24gY2hlY2tGb3JXaW5kb3coKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzV2luZG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2hlY2tGb3JQYWdlWU9mZnNldDogZnVuY3Rpb24gY2hlY2tGb3JQYWdlWU9mZnNldCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1dpbmRvdykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZVlPZmZzZXQgPSB0aGlzLmdldE9mZnNldFRvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWFjdGl2YXRlOiBmdW5jdGlvbiBkZWFjdGl2YXRlKCkge30sXG4gICAgICAgIGdldEFjdGl2YXRvcjogZnVuY3Rpb24gZ2V0QWN0aXZhdG9yKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRBY3RpdmF0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLnYtaW5wdXRfX3Nsb3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2YXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5hY3RpdmF0b3IgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmFjdGl2YXRvcikgOiB0aGlzLmFjdGl2YXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmFjdGl2YXRvci5jaGlsZHJlbi5sZW5ndGggPiAwID8gdGhpcy4kcmVmcy5hY3RpdmF0b3IuY2hpbGRyZW5bMF0gOiB0aGlzLiRyZWZzLmFjdGl2YXRvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SW5uZXJIZWlnaHQ6IGZ1bmN0aW9uIGdldElubmVySGVpZ2h0KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1dpbmRvdykgcmV0dXJuIDA7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldElubmVyV2lkdGg6IGZ1bmN0aW9uIGdldElubmVyV2lkdGgoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzV2luZG93KSByZXR1cm4gMDtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T2Zmc2V0VG9wOiBmdW5jdGlvbiBnZXRPZmZzZXRUb3AoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzV2luZG93KSByZXR1cm4gMDtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Um91bmRlZEJvdW5kZWRDbGllbnRSZWN0OiBmdW5jdGlvbiBnZXRSb3VuZGVkQm91bmRlZENsaWVudFJlY3QoZWwpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogTWF0aC5yb3VuZChyZWN0LnRvcCksXG4gICAgICAgICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChyZWN0LmxlZnQpLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogTWF0aC5yb3VuZChyZWN0LmJvdHRvbSksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IE1hdGgucm91bmQocmVjdC5yaWdodCksXG4gICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQocmVjdC53aWR0aCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHJlY3QuaGVpZ2h0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVhc3VyZTogZnVuY3Rpb24gbWVhc3VyZShlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGVsID0gc2VsZWN0b3IgPyBlbC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA6IGVsO1xuICAgICAgICAgICAgaWYgKCFlbCB8fCAhdGhpcy5oYXNXaW5kb3cpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldFJvdW5kZWRCb3VuZGVkQ2xpZW50UmVjdChlbCk7XG4gICAgICAgICAgICAvLyBBY2NvdW50IGZvciBhY3RpdmF0b3IgbWFyZ2luXG4gICAgICAgICAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICAgICAgICAgIHJlY3QubGVmdCA9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQpO1xuICAgICAgICAgICAgICAgIHJlY3QudG9wID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luVG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9LFxuICAgICAgICBzbmVha1BlZWs6IGZ1bmN0aW9uIHNuZWFrUGVlayhjYikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gX3RoaXMuJHJlZnMuY29udGVudDtcbiAgICAgICAgICAgICAgICBpZiAoIWVsIHx8IF90aGlzLmlzU2hvd24oZWwpKSByZXR1cm4gY2IoKTtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbjogZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzQ29udGVudEFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNTaG93bjogZnVuY3Rpb24gaXNTaG93bihlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlRGltZW5zaW9uczogZnVuY3Rpb24gdXBkYXRlRGltZW5zaW9ucygpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRm9yV2luZG93KCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRm9yUGFnZVlPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0ge307XG4gICAgICAgICAgICAvLyBBY3RpdmF0b3Igc2hvdWxkIGFscmVhZHkgYmUgc2hvd25cbiAgICAgICAgICAgIGRpbWVuc2lvbnMuYWN0aXZhdG9yID0gIXRoaXMuaGFzQWN0aXZhdG9yIHx8IHRoaXMuYWJzb2x1dGUgPyB0aGlzLmFic29sdXRlUG9zaXRpb24oKSA6IHRoaXMubWVhc3VyZSh0aGlzLmdldEFjdGl2YXRvcigpKTtcbiAgICAgICAgICAgIC8vIERpc3BsYXkgYW5kIGhpZGUgdG8gZ2V0IGRpbWVuc2lvbnNcbiAgICAgICAgICAgIHRoaXMuc25lYWtQZWVrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmNvbnRlbnQgPSBfdGhpcy5tZWFzdXJlKF90aGlzLiRyZWZzLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLmRpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21peGlucy9vdmVybGF5YWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWl4aW5zL292ZXJsYXlhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19vdmVybGF5X3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3N0eWx1cy9jb21wb25lbnRzL19vdmVybGF5LnN0eWwgKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fb3ZlcmxheS5zdHlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdHlsdXNfY29tcG9uZW50c19vdmVybGF5X3N0eWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc3R5bHVzX2NvbXBvbmVudHNfb3ZlcmxheV9zdHlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcblxuLy8gVXRpbHNcblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICdvdmVybGF5YWJsZScsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgaGlkZU92ZXJsYXk6IEJvb2xlYW5cbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgb3ZlcmxheU9mZnNldDogMCxcbiAgICAgICAgICAgIG92ZXJsYXlUaW1lb3V0OiBudWxsLFxuICAgICAgICAgICAgb3ZlcmxheVRyYW5zaXRpb25EdXJhdGlvbjogNTAwICsgMTUwIC8vIHRyYW5zaXRpb24gKyBkZWxheVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVPdmVybGF5KCk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlbk92ZXJsYXk6IGZ1bmN0aW9uIGdlbk92ZXJsYXkoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gSWYgZm4gaXMgY2FsbGVkIGFuZCB0aW1lb3V0IGlzIGFjdGl2ZVxuICAgICAgICAgICAgLy8gb3Igb3ZlcmxheSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgLy8gY2FuY2VsIHJlbW92YWwgb2Ygb3ZlcmxheSBhbmQgcmUtYWRkIGFjdGl2ZVxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8IHRoaXMuaGlkZU92ZXJsYXkgfHwgdGhpcy5pc0FjdGl2ZSAmJiB0aGlzLm92ZXJsYXlUaW1lb3V0IHx8IHRoaXMub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm92ZXJsYXlUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5ICYmIHRoaXMub3ZlcmxheS5jbGFzc0xpc3QuYWRkKCd2LW92ZXJsYXktLWFjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXkuY2xhc3NOYW1lID0gJ3Ytb3ZlcmxheSc7XG4gICAgICAgICAgICBpZiAodGhpcy5hYnNvbHV0ZSkgdGhpcy5vdmVybGF5LmNsYXNzTmFtZSArPSAnIHYtb3ZlcmxheS0tYWJzb2x1dGUnO1xuICAgICAgICAgICAgdGhpcy5oaWRlU2Nyb2xsKCk7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5hYnNvbHV0ZSA/IHRoaXMuJGVsLnBhcmVudE5vZGUgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hcHBdJyk7XG4gICAgICAgICAgICBwYXJlbnQgJiYgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLm92ZXJsYXksIHBhcmVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheS5jbGllbnRIZWlnaHQ7IC8vIEZvcmNlIHJlcGFpbnRcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZXRpZnlqcy92dWV0aWZ5L2lzc3Vlcy80Njc4XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vdmVybGF5KSByZXR1cm47XG4gICAgICAgICAgICAgICAgX3RoaXMub3ZlcmxheS5jbGFzc05hbWUgKz0gJyB2LW92ZXJsYXktLWFjdGl2ZSc7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmFjdGl2ZVpJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm92ZXJsYXkuc3R5bGUuekluZGV4ID0gX3RoaXMuYWN0aXZlWkluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVPdmVybGF5OiBmdW5jdGlvbiByZW1vdmVPdmVybGF5KCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvd1Njcm9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vdmVybGF5LmNsYXNzTGlzdC5yZW1vdmUoJ3Ytb3ZlcmxheS0tYWN0aXZlJyk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gSUUxMSBGaXhcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3ZlcmxheSAmJiBfdGhpcy5vdmVybGF5LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm92ZXJsYXkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpcy5vdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vdmVybGF5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2hvd1Njcm9sbCgpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5vdmVybGF5VGltZW91dCk7XG4gICAgICAgICAgICAgICAgX3RoaXMub3ZlcmxheVRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfSwgdGhpcy5vdmVybGF5VHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgc2Nyb2xsTGlzdGVuZXI6IGZ1bmN0aW9uIHNjcm9sbExpc3RlbmVyKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgIGlmIChbJ0lOUFVUJywgJ1RFWFRBUkVBJywgJ1NFTEVDVCddLmluY2x1ZGVzKGUudGFyZ2V0LnRhZ05hbWUpIHx8XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZXRpZnlqcy92dWV0aWZ5L2lzc3Vlcy80NzE1XG4gICAgICAgICAgICAgICAgZS50YXJnZXQuaXNDb250ZW50RWRpdGFibGUpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgdXAgPSBbX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wia2V5Q29kZXNcIl0udXAsIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImtleUNvZGVzXCJdLnBhZ2V1cF07XG4gICAgICAgICAgICAgICAgdmFyIGRvd24gPSBbX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wia2V5Q29kZXNcIl0uZG93biwgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wia2V5Q29kZXNcIl0ucGFnZWRvd25dO1xuICAgICAgICAgICAgICAgIGlmICh1cC5pbmNsdWRlcyhlLmtleUNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGUuZGVsdGFZID0gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb3duLmluY2x1ZGVzKGUua2V5Q29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kZWx0YVkgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMub3ZlcmxheSB8fCBlLnR5cGUgIT09ICdrZXlkb3duJyAmJiBlLnRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSB8fCB0aGlzLmNoZWNrUGF0aChlKSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LFxuICAgICAgICBoYXNTY3JvbGxiYXI6IGZ1bmN0aW9uIGhhc1Njcm9sbGJhcihlbCkge1xuICAgICAgICAgICAgaWYgKCFlbCB8fCBlbC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgICAgICAgIHJldHVybiBbJ2F1dG8nLCAnc2Nyb2xsJ10uaW5jbHVkZXMoc3R5bGVbJ292ZXJmbG93LXknXSkgJiYgZWwuc2Nyb2xsSGVpZ2h0ID4gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzaG91bGRTY3JvbGw6IGZ1bmN0aW9uIHNob3VsZFNjcm9sbChlbCwgZGVsdGEpIHtcbiAgICAgICAgICAgIGlmIChlbC5zY3JvbGxUb3AgPT09IDAgJiYgZGVsdGEgPCAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBlbC5zY3JvbGxUb3AgKyBlbC5jbGllbnRIZWlnaHQgPT09IGVsLnNjcm9sbEhlaWdodCAmJiBkZWx0YSA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGlzSW5zaWRlOiBmdW5jdGlvbiBpc0luc2lkZShlbCwgcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoZWwgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbCA9PT0gbnVsbCB8fCBlbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNJbnNpZGUoZWwucGFyZW50Tm9kZSwgcGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgY2hlY2tQYXRoOiBmdW5jdGlvbiBjaGVja1BhdGgoZSkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBlLnBhdGggfHwgdGhpcy5jb21wb3NlZFBhdGgoZSk7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBlLmRlbHRhWSB8fCAtZS53aGVlbERlbHRhO1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nICYmIHBhdGhbMF0gPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy4kcmVmcy5kaWFsb2c7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gd2luZG93LmdldFNlbGVjdGlvbigpLmFuY2hvck5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzU2Nyb2xsYmFyKGRpYWxvZykgJiYgdGhpcy5pc0luc2lkZShzZWxlY3RlZCwgZGlhbG9nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaG91bGRTY3JvbGwoZGlhbG9nLCBkZWx0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHBhdGgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gcGF0aFtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGVsID09PSBkb2N1bWVudCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gdGhpcy4kcmVmcy5jb250ZW50KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNTY3JvbGxiYXIoZWwpKSByZXR1cm4gdGhpcy5zaG91bGRTY3JvbGwoZWwsIGRlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUG9seWZpbGwgZm9yIEV2ZW50LnByb3RvdHlwZS5jb21wb3NlZFBhdGhcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgKiBAcmV0dXJucyBFbGVtZW50W11cbiAgICAgICAgICovXG4gICAgICAgIGNvbXBvc2VkUGF0aDogZnVuY3Rpb24gY29tcG9zZWRQYXRoKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmNvbXBvc2VkUGF0aCkgcmV0dXJuIGUuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgICAgICAgdmFyIGVsID0gZS50YXJnZXQ7XG4gICAgICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgIGlmIChlbC50YWdOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGVTY3JvbGw6IGZ1bmN0aW9uIGhpZGVTY3JvbGwoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdnVldGlmeS5icmVha3BvaW50LnNtQW5kRG93bikge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdvdmVyZmxvdy15LWhpZGRlbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLnNjcm9sbExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuc2Nyb2xsTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaG93U2Nyb2xsOiBmdW5jdGlvbiBzaG93U2Nyb2xsKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ292ZXJmbG93LXktaGlkZGVuJyk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLnNjcm9sbExpc3RlbmVyKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5zY3JvbGxMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWl4aW5zL3BpY2tlci1idXR0b24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWl4aW5zL3BpY2tlci1idXR0b24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlblBpY2tlckJ1dHRvbjogZnVuY3Rpb24gZ2VuUGlja2VyQnV0dG9uKHByb3AsIHZhbHVlLCBjb250ZW50LCByZWFkb25seSwgc3RhdGljQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAocmVhZG9ubHkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGljQ2xhc3MgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWN0aXZlID0gdGhpc1twcm9wXSA9PT0gdmFsdWU7XG4gICAgICAgICAgICB2YXIgY2xpY2sgPSBmdW5jdGlvbiBjbGljayhldmVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIF90aGlzLiRlbWl0KFwidXBkYXRlOlwiICsgcHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IChcInYtcGlja2VyX190aXRsZV9fYnRuIFwiICsgc3RhdGljQ2xhc3MpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiB7XG4gICAgICAgICAgICAgICAgICAgICd2LXBpY2tlcl9fdGl0bGVfX2J0bi0tYWN0aXZlJzogYWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICAndi1waWNrZXJfX3RpdGxlX19idG4tLXJlYWRvbmx5JzogcmVhZG9ubHlcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uOiBhY3RpdmUgfHwgcmVhZG9ubHkgPyB1bmRlZmluZWQgOiB7IGNsaWNrOiBjbGljayB9XG4gICAgICAgICAgICB9LCBBcnJheS5pc0FycmF5KGNvbnRlbnQpID8gY29udGVudCA6IFtjb250ZW50XSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWl4aW5zL3BpY2tlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9waWNrZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21wb25lbnRzX1ZQaWNrZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NvbXBvbmVudHMvVlBpY2tlciAqLyBcIi4vc3JjL2NvbXBvbmVudHMvVlBpY2tlci9pbmRleC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29sb3JhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbG9yYWJsZSAqLyBcIi4vc3JjL21peGlucy9jb2xvcmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLy8gQ29tcG9uZW50c1xuXG4vLyBNaXhpbnNcblxuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3BpY2tlcicsXG4gICAgbWl4aW5zOiBbX2NvbG9yYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXSwgX3RoZW1lYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZnVsbFdpZHRoOiBCb29sZWFuLFxuICAgICAgICBoZWFkZXJDb2xvcjogU3RyaW5nLFxuICAgICAgICBsYW5kc2NhcGU6IEJvb2xlYW4sXG4gICAgICAgIG5vVGl0bGU6IEJvb2xlYW4sXG4gICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogMjkwXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2VuUGlja2VyVGl0bGU6IGZ1bmN0aW9uIGdlblBpY2tlclRpdGxlKCkge30sXG4gICAgICAgIGdlblBpY2tlckJvZHk6IGZ1bmN0aW9uIGdlblBpY2tlckJvZHkoKSB7fSxcbiAgICAgICAgZ2VuUGlja2VyQWN0aW9uc1Nsb3Q6IGZ1bmN0aW9uIGdlblBpY2tlckFjdGlvbnNTbG90KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNjb3BlZFNsb3RzLmRlZmF1bHQgPyB0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICBzYXZlOiB0aGlzLnNhdmUsXG4gICAgICAgICAgICAgICAgY2FuY2VsOiB0aGlzLmNhbmNlbFxuICAgICAgICAgICAgfSkgOiB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgICAgICB9LFxuICAgICAgICBnZW5QaWNrZXI6IGZ1bmN0aW9uIGdlblBpY2tlcihzdGF0aWNDbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoX2NvbXBvbmVudHNfVlBpY2tlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSwge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBzdGF0aWNDbGFzcyxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5oZWFkZXJDb2xvciB8fCB0aGlzLmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBkYXJrOiB0aGlzLmRhcmssXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxXaWR0aDogdGhpcy5mdWxsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGxhbmRzY2FwZTogdGhpcy5sYW5kc2NhcGUsXG4gICAgICAgICAgICAgICAgICAgIGxpZ2h0OiB0aGlzLmxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFt0aGlzLm5vVGl0bGUgPyBudWxsIDogdGhpcy5nZW5QaWNrZXJUaXRsZSgpLCB0aGlzLmdlblBpY2tlckJvZHkoKSwgdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6ICdhY3Rpb25zJyB9LCBbdGhpcy5nZW5QaWNrZXJBY3Rpb25zU2xvdCgpXSldKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvcG9zaXRpb25hYmxlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWl4aW5zL3Bvc2l0aW9uYWJsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGZhY3RvcnksIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmFjdG9yeVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhY3Rvcnk7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFwidnVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2hlbHBlcnMgKi8gXCIuL3NyYy91dGlsL2hlbHBlcnMudHNcIik7XG5cblxudmFyIGF2YWlsYWJsZVByb3BzID0ge1xuICBhYnNvbHV0ZTogQm9vbGVhbixcbiAgYm90dG9tOiBCb29sZWFuLFxuICBmaXhlZDogQm9vbGVhbixcbiAgbGVmdDogQm9vbGVhbixcbiAgcmlnaHQ6IEJvb2xlYW4sXG4gIHRvcDogQm9vbGVhblxufTtcbmZ1bmN0aW9uIGZhY3Rvcnkoc2VsZWN0ZWQpIHtcbiAgaWYgKHNlbGVjdGVkID09PSB2b2lkIDApIHtcbiAgICBzZWxlY3RlZCA9IFtdO1xuICB9XG4gIHJldHVybiB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHtcbiAgICBuYW1lOiAncG9zaXRpb25hYmxlJyxcbiAgICBwcm9wczogc2VsZWN0ZWQubGVuZ3RoID8gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImZpbHRlck9iamVjdE9uS2V5c1wiXSkoYXZhaWxhYmxlUHJvcHMsIHNlbGVjdGVkKSA6IGF2YWlsYWJsZVByb3BzXG4gIH0pO1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChmYWN0b3J5KCkpO1xuLy8gQWRkIGEgYCpgIGJlZm9yZSB0aGUgc2Vjb25kIGAvYFxuLyogVGVzdHMgL1xubGV0IHNpbmdsZSA9IGZhY3RvcnkoWyd0b3AnXSkuZXh0ZW5kKHtcbiAgY3JlYXRlZCAoKSB7XG4gICAgdGhpcy50b3BcbiAgICB0aGlzLmJvdHRvbVxuICAgIHRoaXMuYWJzb2x1dGVcbiAgfVxufSlcblxubGV0IHNvbWUgPSBmYWN0b3J5KFsndG9wJywgJ2JvdHRvbSddKS5leHRlbmQoe1xuICBjcmVhdGVkICgpIHtcbiAgICB0aGlzLnRvcFxuICAgIHRoaXMuYm90dG9tXG4gICAgdGhpcy5hYnNvbHV0ZVxuICB9XG59KVxuXG5sZXQgYWxsID0gZmFjdG9yeSgpLmV4dGVuZCh7XG4gIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMudG9wXG4gICAgdGhpcy5ib3R0b21cbiAgICB0aGlzLmFic29sdXRlXG4gICAgdGhpcy5mb29iYXJcbiAgfVxufSlcbi8qKi9cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWl4aW5zL3Byb3h5YWJsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9wcm94eWFibGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBmYWN0b3J5LCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZhY3RvcnlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmYWN0b3J5OyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHZ1ZSAqLyBcInZ1ZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkocHJvcCwgZXZlbnQpIHtcbiAgICBpZiAocHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByb3AgPSAndmFsdWUnO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgPT09IHZvaWQgMCkge1xuICAgICAgICBldmVudCA9ICdjaGFuZ2UnO1xuICAgIH1cbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogJ3Byb3h5YWJsZScsXG4gICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICBwcm9wOiBwcm9wLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgIH0sXG4gICAgICAgIHByb3BzOiAoX2EgPSB7fSwgX2FbcHJvcF0gPSB7XG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgfSwgX2EpLFxuICAgICAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbExhenlWYWx1ZTogdGhpc1twcm9wXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgICAgIGludGVybmFsVmFsdWU6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxMYXp5VmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdGhpcy5pbnRlcm5hbExhenlWYWx1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsTGF6eVZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KGV2ZW50LCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd2F0Y2g6IChfYiA9IHt9LCBfYltwcm9wXSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxMYXp5VmFsdWUgPSB2YWw7XG4gICAgICAgIH0sIF9iKVxuICAgIH0pO1xufVxuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZSAqL1xudmFyIFByb3h5YWJsZSA9IGZhY3RvcnkoKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoUHJveHlhYmxlKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWl4aW5zL3JlZ2lzdHJhYmxlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9taXhpbnMvcmVnaXN0cmFibGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGluamVjdCwgcHJvdmlkZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpbmplY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpbmplY3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInByb3ZpZGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwcm92aWRlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHZ1ZSAqLyBcInZ1ZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9jb25zb2xlICovIFwiLi9zcmMvdXRpbC9jb25zb2xlLnRzXCIpO1xuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlV2FybmluZyhjaGlsZCwgcGFyZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdChfdXRpbF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJjb25zb2xlV2FyblwiXSkoXCJUaGUgXCIgKyBjaGlsZCArIFwiIGNvbXBvbmVudCBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgXCIgKyBwYXJlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBpbmplY3QobmFtZXNwYWNlLCBjaGlsZCwgcGFyZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBkZWZhdWx0SW1wbCA9IGNoaWxkICYmIHBhcmVudCA/IHtcbiAgICAgICAgcmVnaXN0ZXI6IGdlbmVyYXRlV2FybmluZyhjaGlsZCwgcGFyZW50KSxcbiAgICAgICAgdW5yZWdpc3RlcjogZ2VuZXJhdGVXYXJuaW5nKGNoaWxkLCBwYXJlbnQpXG4gICAgfSA6IG51bGw7XG4gICAgcmV0dXJuIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe1xuICAgICAgICBuYW1lOiAncmVnaXN0cmFibGUtaW5qZWN0JyxcbiAgICAgICAgaW5qZWN0OiAoX2EgPSB7fSwgX2FbbmFtZXNwYWNlXSA9IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRJbXBsXG4gICAgICAgIH0sIF9hKVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJvdmlkZShuYW1lc3BhY2UpIHtcbiAgICByZXR1cm4gdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7XG4gICAgICAgIG5hbWU6ICdyZWdpc3RyYWJsZS1wcm92aWRlJyxcbiAgICAgICAgbWV0aG9kczoge1xuICAgICAgICAgICAgcmVnaXN0ZXI6IG51bGwsXG4gICAgICAgICAgICB1bnJlZ2lzdGVyOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gX2EgPSB7fSwgX2FbbmFtZXNwYWNlXSA9IHtcbiAgICAgICAgICAgICAgICByZWdpc3RlcjogdGhpcy5yZWdpc3RlcixcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyOiB0aGlzLnVucmVnaXN0ZXJcbiAgICAgICAgICAgIH0sIF9hO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21peGlucy9yZXR1cm5hYmxlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9yZXR1cm5hYmxlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB2dWUgKi8gXCJ2dWVcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHtcbiAgICBuYW1lOiAncmV0dXJuYWJsZScsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgcmV0dXJuVmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBudWxsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUodmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5hbFZhbHVlID0gdGhpcy5yZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnJldHVyblZhbHVlJywgdGhpcy5vcmlnaW5hbFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBzYXZlOiBmdW5jdGlvbiBzYXZlKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWl4aW5zL3JpcHBsZWFibGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWl4aW5zL3JpcHBsZWFibGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGlyZWN0aXZlc19yaXBwbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RpcmVjdGl2ZXMvcmlwcGxlICovIFwiLi9zcmMvZGlyZWN0aXZlcy9yaXBwbGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB2dWUgKi8gXCJ2dWVcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLy8gRGlyZWN0aXZlc1xuXG4vLyBUeXBlc1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQuYS5leHRlbmQoe1xuICAgIG5hbWU6ICdyaXBwbGVhYmxlJyxcbiAgICBkaXJlY3RpdmVzOiB7IFJpcHBsZTogX2RpcmVjdGl2ZXNfcmlwcGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgcmlwcGxlOiB7XG4gICAgICAgICAgICB0eXBlOiBbQm9vbGVhbiwgT2JqZWN0XSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZW5SaXBwbGU6IGZ1bmN0aW9uIGdlblJpcHBsZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJpcHBsZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBkYXRhLnN0YXRpY0NsYXNzID0gJ3YtaW5wdXQtLXNlbGVjdGlvbi1jb250cm9sc19fcmlwcGxlJztcbiAgICAgICAgICAgIGRhdGEuZGlyZWN0aXZlcyA9IGRhdGEuZGlyZWN0aXZlcyB8fCBbXTtcbiAgICAgICAgICAgIGRhdGEuZGlyZWN0aXZlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAncmlwcGxlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBjZW50ZXI6IHRydWUgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkYXRhLm9uID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgY2xpY2s6IHRoaXMub25DaGFuZ2VcbiAgICAgICAgICAgIH0sIHRoaXMuJGxpc3RlbmVycyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnZGl2JywgZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHt9XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvcm91dGFibGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9yb3V0YWJsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHZ1ZSAqLyBcInZ1ZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RpcmVjdGl2ZXNfcmlwcGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kaXJlY3RpdmVzL3JpcHBsZSAqLyBcIi4vc3JjL2RpcmVjdGl2ZXMvcmlwcGxlLnRzXCIpO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7XG4gICAgbmFtZTogJ3JvdXRhYmxlJyxcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICAgIFJpcHBsZTogX2RpcmVjdGl2ZXNfcmlwcGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdXG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBhY3RpdmVDbGFzczogU3RyaW5nLFxuICAgICAgICBhcHBlbmQ6IEJvb2xlYW4sXG4gICAgICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgICAgICBleGFjdDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgICAgIGhyZWY6IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgICAgIHRvOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgICAgICBudXh0OiBCb29sZWFuLFxuICAgICAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgICAgICByaXBwbGU6IFtCb29sZWFuLCBPYmplY3RdLFxuICAgICAgICB0YWc6IFN0cmluZyxcbiAgICAgICAgdGFyZ2V0OiBTdHJpbmdcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNvbXB1dGVkUmlwcGxlOiBmdW5jdGlvbiBjb21wdXRlZFJpcHBsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpcHBsZSAmJiAhdGhpcy5kaXNhYmxlZCA/IHRoaXMucmlwcGxlIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhlKSB7fSxcbiAgICAgICAgZ2VuZXJhdGVSb3V0ZUxpbms6IGZ1bmN0aW9uIGdlbmVyYXRlUm91dGVMaW5rKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBleGFjdCA9IHRoaXMuZXhhY3Q7XG4gICAgICAgICAgICB2YXIgdGFnO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSAoX2EgPSB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQgfSxcbiAgICAgICAgICAgICAgICBjbGFzczogY2xhc3NlcyxcbiAgICAgICAgICAgICAgICBwcm9wczoge30sXG4gICAgICAgICAgICAgICAgZGlyZWN0aXZlczogW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3JpcHBsZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNvbXB1dGVkUmlwcGxlXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sIF9hW3RoaXMudG8gPyAnbmF0aXZlT24nIDogJ29uJ10gPSBfX2Fzc2lnbih7fSwgdGhpcy4kbGlzdGVuZXJzLCB7IGNsaWNrOiB0aGlzLmNsaWNrIH0pLCBfYSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuZXhhY3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZXhhY3QgPSB0aGlzLnRvID09PSAnLycgfHwgdGhpcy50byA9PT0gT2JqZWN0KHRoaXMudG8pICYmIHRoaXMudG8ucGF0aCA9PT0gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBzcGVjaWFsIGFjdGl2ZUNsYXNzIGhvb2tcbiAgICAgICAgICAgICAgICAvLyBmb3IgY29tcG9uZW50IGxldmVsIHN0eWxlc1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3M7XG4gICAgICAgICAgICAgICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3MgPSB0aGlzLmV4YWN0QWN0aXZlQ2xhc3MgfHwgYWN0aXZlQ2xhc3M7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYXBwbHkgb25seSBpbiBWTGlzdFRpbGVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm94eUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNsYXNzICs9ICcgJyArIHRoaXMucHJveHlDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgZXhhY3RBY3RpdmVDbGFzcyArPSAnICcgKyB0aGlzLnByb3h5Q2xhc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhZyA9IHRoaXMubnV4dCA/ICdudXh0LWxpbmsnIDogJ3JvdXRlci1saW5rJztcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEucHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBleGFjdCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ2xhc3M6IGFjdGl2ZUNsYXNzLFxuICAgICAgICAgICAgICAgICAgICBleGFjdEFjdGl2ZUNsYXNzOiBleGFjdEFjdGl2ZUNsYXNzLFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmQ6IHRoaXMuYXBwZW5kLFxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlOiB0aGlzLnJlcGxhY2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFnID0gdGhpcy5ocmVmICYmICdhJyB8fCB0aGlzLnRhZyB8fCAnYSc7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gJ2EnICYmIHRoaXMuaHJlZikgZGF0YS5hdHRycy5ocmVmID0gdGhpcy5ocmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0KSBkYXRhLmF0dHJzLnRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIHsgdGFnOiB0YWcsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWl4aW5zL3NlbGVjdGFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWl4aW5zL3NlbGVjdGFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tcG9uZW50c19WSW5wdXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NvbXBvbmVudHMvVklucHV0ICovIFwiLi9zcmMvY29tcG9uZW50cy9WSW5wdXQvaW5kZXguanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JpcHBsZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmlwcGxlYWJsZSAqLyBcIi4vc3JjL21peGlucy9yaXBwbGVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21wYXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbXBhcmFibGUgKi8gXCIuL3NyYy9taXhpbnMvY29tcGFyYWJsZS50c1wiKTtcbi8vIENvbXBvbmVudHNcblxuLy8gTWl4aW5zXG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICAgIG5hbWU6ICdzZWxlY3RhYmxlJyxcbiAgICBleHRlbmRzOiBfY29tcG9uZW50c19WSW5wdXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0sXG4gICAgbWl4aW5zOiBbX3JpcHBsZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0sIF9jb21wYXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJkZWZhdWx0XCJdXSxcbiAgICBtb2RlbDoge1xuICAgICAgICBwcm9wOiAnaW5wdXRWYWx1ZScsXG4gICAgICAgIGV2ZW50OiAnY2hhbmdlJ1xuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdhY2NlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIGlkOiBTdHJpbmcsXG4gICAgICAgIGlucHV0VmFsdWU6IG51bGwsXG4gICAgICAgIGZhbHNlVmFsdWU6IG51bGwsXG4gICAgICAgIHRydWVWYWx1ZTogbnVsbCxcbiAgICAgICAgbXVsdGlwbGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiBTdHJpbmdcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEodm0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhenlWYWx1ZTogdm0uaW5wdXRWYWx1ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY29tcHV0ZWRDb2xvcjogZnVuY3Rpb24gY29tcHV0ZWRDb2xvcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQWN0aXZlID8gdGhpcy5jb2xvciA6IHRoaXMudmFsaWRhdGlvblN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBpc011bHRpcGxlOiBmdW5jdGlvbiBpc011bHRpcGxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGUgPT09IHRydWUgfHwgdGhpcy5tdWx0aXBsZSA9PT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHRoaXMuaW50ZXJuYWxWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnRlcm5hbFZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQuc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudmFsdWVDb21wYXJhdG9yKGl0ZW0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRydWVWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuZmFsc2VWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy52YWx1ZUNvbXBhcmF0b3IodmFsdWUsIGlucHV0KSA6IEJvb2xlYW4oaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVDb21wYXJhdG9yKGlucHV0LCB0aGlzLnRydWVWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRGlydHk6IGZ1bmN0aW9uIGlzRGlydHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0FjdGl2ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgaW5wdXRWYWx1ZTogZnVuY3Rpb24gaW5wdXRWYWx1ZSh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMubGF6eVZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdlbkxhYmVsOiBmdW5jdGlvbiBnZW5MYWJlbCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNMYWJlbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBfY29tcG9uZW50c19WSW5wdXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0ubWV0aG9kcy5nZW5MYWJlbC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgbGFiZWwuZGF0YS5vbiA9IHsgY2xpY2s6IHRoaXMub25DaGFuZ2UgfTtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2VuSW5wdXQ6IGZ1bmN0aW9uIGdlbklucHV0KHR5cGUsIGF0dHJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgnaW5wdXQnLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWNoZWNrZWQnOiB0aGlzLmlzQWN0aXZlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmlzRGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICAgICAgfSwgYXR0cnMpLFxuICAgICAgICAgICAgICAgIGRvbVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiB0aGlzLmlzQWN0aXZlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBibHVyOiB0aGlzLm9uQmx1cixcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiB0aGlzLm9uQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICBmb2N1czogdGhpcy5vbkZvY3VzLFxuICAgICAgICAgICAgICAgICAgICBrZXlkb3duOiB0aGlzLm9uS2V5ZG93blxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVmOiAnaW5wdXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25CbHVyOiBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW50ZXJuYWxWYWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFfdGhpcy52YWx1ZUNvbXBhcmF0b3IoaXRlbSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJ1ZVZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mYWxzZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHRoaXMudmFsdWVDb21wYXJhdG9yKGlucHV0LCB0aGlzLnRydWVWYWx1ZSkgPyB0aGlzLmZhbHNlVmFsdWUgOiB0aGlzLnRydWVWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHRoaXMudmFsdWVDb21wYXJhdG9yKGlucHV0LCB2YWx1ZSkgPyBudWxsIDogdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gIWlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSh0cnVlLCBpbnB1dCk7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSBpbnB1dDtcbiAgICAgICAgfSxcbiAgICAgICAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cygpIHtcbiAgICAgICAgICAgIHRoaXMuaXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEBhYnN0cmFjdCAqL1xuICAgICAgICBvbktleWRvd246IGZ1bmN0aW9uIG9uS2V5ZG93bihlKSB7fVxuICAgIH1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvc2l6ZWFibGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy9zaXplYWJsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHZ1ZSAqLyBcInZ1ZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7XG4gICAgbmFtZTogJ3NpemVhYmxlJyxcbiAgICBwcm9wczoge1xuICAgICAgICBsYXJnZTogQm9vbGVhbixcbiAgICAgICAgbWVkaXVtOiBCb29sZWFuLFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddXG4gICAgICAgIH0sXG4gICAgICAgIHNtYWxsOiBCb29sZWFuLFxuICAgICAgICB4TGFyZ2U6IEJvb2xlYW5cbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21peGlucy9zc3ItYm9vdGFibGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9taXhpbnMvc3NyLWJvb3RhYmxlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHZ1ZSAqLyBcInZ1ZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG5cbi8qKlxuICogU1NSQm9vdGFibGVcbiAqXG4gKiBAbWl4aW5cbiAqXG4gKiBVc2VkIGluIGxheW91dCBjb21wb25lbnRzIChkcmF3ZXIsIHRvb2xiYXIsIGNvbnRlbnQpXG4gKiB0byBhdm9pZCBhbiBlbnRyeSBhbmltYXRpb24gd2hlbiB1c2luZyBTU1JcbiAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKHtcbiAgICBuYW1lOiAnc3NyLWJvb3RhYmxlJyxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNCb290ZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBVc2Ugc2V0QXR0cmlidXRlIGluc3RlYWQgb2YgZGF0YXNldFxuICAgICAgICAvLyBiZWNhdXNlIGRhdGFzZXQgZG9lcyBub3Qgd29yayB3ZWxsXG4gICAgICAgIC8vIHdpdGggdW5pdCB0ZXN0c1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLiRlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYm9vdGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgIF90aGlzLmlzQm9vdGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvc3RhY2thYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWl4aW5zL3N0YWNrYWJsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9oZWxwZXJzICovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCIpO1xudmFyIF9fcmVhZCA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19yZWFkIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksXG4gICAgICAgIHIsXG4gICAgICAgIGFyID0gW10sXG4gICAgICAgIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlID0geyBlcnJvcjogZXJyb3IgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZSkgdGhyb3cgZS5lcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3NwcmVhZCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICAgIH1yZXR1cm4gYXI7XG59O1xuXG4vKiBAdnVlL2NvbXBvbmVudCAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gICAgbmFtZTogJ3N0YWNrYWJsZScsXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YWNrQmFzZTogbnVsbCxcbiAgICAgICAgICAgIHN0YWNrQ2xhc3M6ICd1bnBlY2lmaWVkJyxcbiAgICAgICAgICAgIHN0YWNrRWxlbWVudDogbnVsbCxcbiAgICAgICAgICAgIHN0YWNrRXhjbHVkZTogbnVsbCxcbiAgICAgICAgICAgIHN0YWNrTWluWkluZGV4OiAwXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudGx5IGFjdGl2ZSB6LWluZGV4XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGFjdGl2ZVpJbmRleDogZnVuY3Rpb24gYWN0aXZlWkluZGV4KCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gMDtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5zdGFja0VsZW1lbnQgfHwgdGhpcy4kcmVmcy5jb250ZW50O1xuICAgICAgICAgICAgLy8gUmV0dXJuIGN1cnJlbnQgemluZGV4IGlmIG5vdCBhY3RpdmVcbiAgICAgICAgICAgIHZhciBpbmRleCA9ICF0aGlzLmlzQWN0aXZlID8gT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFpJbmRleFwiXSkoY29udGVudCkgOiB0aGlzLmdldE1heFpJbmRleCh0aGlzLnN0YWNrRXhjbHVkZSB8fCBbY29udGVudF0pICsgMjtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSBudWxsKSByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICAvLyBSZXR1cm4gbWF4IGN1cnJlbnQgei1pbmRleCAoZXhjbHVkaW5nIHNlbGYpICsgMlxuICAgICAgICAgICAgLy8gKDIgdG8gbGVhdmUgcm9vbSBmb3IgYW4gb3ZlcmxheSBiZWxvdywgaWYgbmVlZGVkKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZXRNYXhaSW5kZXg6IGZ1bmN0aW9uIGdldE1heFpJbmRleChleGNsdWRlKSB7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLnN0YWNrQmFzZSB8fCB0aGlzLiRlbDtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggbG93ZXN0IGFsbG93ZWQgei1pbmRleCBvciB6LWluZGV4IG9mXG4gICAgICAgICAgICAvLyBiYXNlIGNvbXBvbmVudCdzIGVsZW1lbnQsIHdoaWNoZXZlciBpcyBncmVhdGVyXG4gICAgICAgICAgICB2YXIgemlzID0gW3RoaXMuc3RhY2tNaW5aSW5kZXgsIE9iamVjdChfdXRpbF9oZWxwZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJnZXRaSW5kZXhcIl0pKGJhc2UpXTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIE5vZGVMaXN0IHRvIGFuIGFycmF5IHRvXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGFuIEVkZ2UgYnVnIHdpdGggU3ltYm9sLml0ZXJhdG9yXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVldGlmeWpzL3Z1ZXRpZnkvaXNzdWVzLzIxNDZcbiAgICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50cyA9IF9fc3ByZWFkKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUodGhpcy5zdGFja0NsYXNzKSk7XG4gICAgICAgICAgICAvLyBHZXQgei1pbmRleCBmb3IgYWxsIGFjdGl2ZSBkaWFsb2dzXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgYWN0aXZlRWxlbWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGNsdWRlLmluY2x1ZGVzKGFjdGl2ZUVsZW1lbnRzW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgemlzLnB1c2goT2JqZWN0KF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImdldFpJbmRleFwiXSkoYWN0aXZlRWxlbWVudHNbaW5kZXhdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIF9fc3ByZWFkKHppcykpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21peGlucy90aGVtZWFibGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZnVuY3Rpb25hbFRoZW1lQ2xhc3NlcywgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmdW5jdGlvbmFsVGhlbWVDbGFzc2VzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVuY3Rpb25hbFRoZW1lQ2xhc3NlczsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB2dWUgKi8gXCJ2dWVcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xudmFyIF9fYXNzaWduID0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5mdW5jdGlvbiBmdW5jdGlvbmFsVGhlbWVDbGFzc2VzKGNvbnRleHQpIHtcbiAgICB2YXIgdm0gPSBfX2Fzc2lnbih7fSwgY29udGV4dC5wcm9wcywgY29udGV4dC5pbmplY3Rpb25zKTtcbiAgICB2YXIgaXNEYXJrID0gVGhlbWVhYmxlLm9wdGlvbnMuY29tcHV0ZWQuaXNEYXJrLmNhbGwodm0pO1xuICAgIHJldHVybiBUaGVtZWFibGUub3B0aW9ucy5jb21wdXRlZC50aGVtZUNsYXNzZXMuY2FsbCh7IGlzRGFyazogaXNEYXJrIH0pO1xufVxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbnZhciBUaGVtZWFibGUgPSB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuZXh0ZW5kKCkuZXh0ZW5kKHtcbiAgICBuYW1lOiAndGhlbWVhYmxlJyxcbiAgICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWVhYmxlUHJvdmlkZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaW5qZWN0OiB7XG4gICAgICAgIHRoZW1lOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgaXNEYXJrOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgICBkYXJrOiB7XG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBsaWdodDoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRoZW1lYWJsZVByb3ZpZGU6IHtcbiAgICAgICAgICAgICAgICBpc0Rhcms6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBpc0Rhcms6IGZ1bmN0aW9uIGlzRGFyaygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhcmsgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBleHBsaWNpdGx5IGRhcmtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5saWdodCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGV4cGxpY2l0bHkgbGlnaHRcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGluaGVyaXQgZnJvbSBwYXJlbnQsIG9yIGRlZmF1bHQgZmFsc2UgaWYgdGhlcmUgaXMgbm9uZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW1lLmlzRGFyaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGhlbWVDbGFzc2VzOiBmdW5jdGlvbiB0aGVtZUNsYXNzZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICd0aGVtZS0tZGFyayc6IHRoaXMuaXNEYXJrLFxuICAgICAgICAgICAgICAgICd0aGVtZS0tbGlnaHQnOiAhdGhpcy5pc0RhcmtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBVc2VkIGJ5IG1lbnVzIGFuZCBkaWFsb2dzLCBpbmhlcml0cyBmcm9tIHYtYXBwIGluc3RlYWQgb2YgdGhlIHBhcmVudCAqL1xuICAgICAgICByb290SXNEYXJrOiBmdW5jdGlvbiByb290SXNEYXJrKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGFyayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGV4cGxpY2l0bHkgZGFya1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxpZ2h0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwbGljaXRseSBsaWdodFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW5oZXJpdCBmcm9tIHYtYXBwXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHZ1ZXRpZnkuZGFyaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcm9vdFRoZW1lQ2xhc3NlczogZnVuY3Rpb24gcm9vdFRoZW1lQ2xhc3NlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ3RoZW1lLS1kYXJrJzogdGhpcy5yb290SXNEYXJrLFxuICAgICAgICAgICAgICAgICd0aGVtZS0tbGlnaHQnOiAhdGhpcy5yb290SXNEYXJrXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBpc0Rhcms6IHtcbiAgICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIobmV3VmFsLCBvbGRWYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsICE9PSBvbGRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aGVtZWFibGVQcm92aWRlLmlzRGFyayA9IHRoaXMuaXNEYXJrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChUaGVtZWFibGUpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvdG9nZ2xlYWJsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9taXhpbnMvdG9nZ2xlYWJsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBmYWN0b3J5LCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZhY3RvcnlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmYWN0b3J5OyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHZ1ZSAqLyBcInZ1ZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG5cbmZ1bmN0aW9uIGZhY3RvcnkocHJvcCwgZXZlbnQpIHtcbiAgICBpZiAocHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByb3AgPSAndmFsdWUnO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgPT09IHZvaWQgMCkge1xuICAgICAgICBldmVudCA9ICdpbnB1dCc7XG4gICAgfVxuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoe1xuICAgICAgICBuYW1lOiAndG9nZ2xlYWJsZScsXG4gICAgICAgIG1vZGVsOiB7IHByb3A6IHByb3AsIGV2ZW50OiBldmVudCB9LFxuICAgICAgICBwcm9wczogKF9hID0ge30sIF9hW3Byb3BdID0geyByZXF1aXJlZDogZmFsc2UgfSwgX2EpLFxuICAgICAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZTogISF0aGlzW3Byb3BdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB3YXRjaDogKF9iID0ge30sIF9iW3Byb3BdID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9ICEhdmFsO1xuICAgICAgICB9LCBfYi5pc0FjdGl2ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICEhdmFsICE9PSB0aGlzW3Byb3BdICYmIHRoaXMuJGVtaXQoZXZlbnQsIHZhbCk7XG4gICAgICAgIH0sIF9iKVxuICAgIH0pO1xufVxuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZSAqL1xudmFyIFRvZ2dsZWFibGUgPSBmYWN0b3J5KCk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFRvZ2dsZWFibGUpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9taXhpbnMvdHJhbnNpdGlvbmFibGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL21peGlucy90cmFuc2l0aW9uYWJsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHZ1ZSAqLyBcInZ1ZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7XG4gICAgbmFtZTogJ3RyYW5zaXRpb25hYmxlJyxcbiAgICBwcm9wczoge1xuICAgICAgICBtb2RlOiBTdHJpbmcsXG4gICAgICAgIG9yaWdpbjogU3RyaW5nLFxuICAgICAgICB0cmFuc2l0aW9uOiBTdHJpbmdcbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21peGlucy90cmFuc2xhdGFibGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9taXhpbnMvdHJhbnNsYXRhYmxlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHZ1ZSAqLyBcInZ1ZVwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciB2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih2dWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodnVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmV4dGVuZCh7XG4gICAgbmFtZTogJ3RyYW5zbGF0YWJsZScsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgaGVpZ2h0OiBOdW1iZXJcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbE9mZnNldFRvcDogMCxcbiAgICAgICAgICAgIHBhcmFsbGF4OiAwLFxuICAgICAgICAgICAgcGFyYWxsYXhEaXN0OiAwLFxuICAgICAgICAgICAgcGVyY2VudFNjcm9sbGVkOiAwLFxuICAgICAgICAgICAgc2Nyb2xsVG9wOiAwLFxuICAgICAgICAgICAgd2luZG93SGVpZ2h0OiAwLFxuICAgICAgICAgICAgd2luZG93Qm90dG9tOiAwXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgICBpbWdIZWlnaHQ6IGZ1bmN0aW9uIGltZ0hlaWdodCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9iakhlaWdodCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy50cmFuc2xhdGUsIGZhbHNlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMudHJhbnNsYXRlLCBmYWxzZSk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGNhbGNEaW1lbnNpb25zOiBmdW5jdGlvbiBjYWxjRGltZW5zaW9ucygpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5wYXJhbGxheERpc3QgPSB0aGlzLmltZ0hlaWdodCAtIHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5lbE9mZnNldFRvcCA9IG9mZnNldC50b3AgKyB0aGlzLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIHRoaXMud2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy53aW5kb3dCb3R0b20gPSB0aGlzLnNjcm9sbFRvcCArIHRoaXMud2luZG93SGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBsaXN0ZW5lcnM6IGZ1bmN0aW9uIGxpc3RlbmVycygpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnRyYW5zbGF0ZSwgZmFsc2UpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMudHJhbnNsYXRlLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAYWJzdHJhY3QgKiovXG4gICAgICAgIG9iakhlaWdodDogZnVuY3Rpb24gb2JqSGVpZ2h0KCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQgIScpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIHRyYW5zbGF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY0RpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIHRoaXMucGVyY2VudFNjcm9sbGVkID0gKHRoaXMud2luZG93Qm90dG9tIC0gdGhpcy5lbE9mZnNldFRvcCkgLyAocGFyc2VJbnQodGhpcy5oZWlnaHQpICsgdGhpcy53aW5kb3dIZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5wYXJhbGxheCA9IE1hdGgucm91bmQodGhpcy5wYXJhbGxheERpc3QgKiB0aGlzLnBlcmNlbnRTY3JvbGxlZCk7XG4gICAgICAgIH1cbiAgICB9XG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL21peGlucy92YWxpZGF0YWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWl4aW5zL3ZhbGlkYXRhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2hlbHBlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvaGVscGVycyAqLyBcIi4vc3JjL3V0aWwvaGVscGVycy50c1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVnaXN0cmFibGUgKi8gXCIuL3NyYy9taXhpbnMvcmVnaXN0cmFibGUudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9jb25zb2xlICovIFwiLi9zcmMvdXRpbC9jb25zb2xlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29sb3JhYmxlICovIFwiLi9zcmMvbWl4aW5zL2NvbG9yYWJsZS50c1wiKTtcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuXG5cblxuLy8gTWl4aW5zXG5cbi8qIEB2dWUvY29tcG9uZW50ICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgICBuYW1lOiAndmFsaWRhdGFibGUnLFxuICAgIG1peGluczogW19jb2xvcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcImRlZmF1bHRcIl0sIE9iamVjdChfcmVnaXN0cmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImluamVjdFwiXSkoJ2Zvcm0nKV0sXG4gICAgcHJvcHM6IHtcbiAgICAgICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgICAgIGVycm9yOiBCb29sZWFuLFxuICAgICAgICBlcnJvckNvdW50OiB7XG4gICAgICAgICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgICAgICAgICAgZGVmYXVsdDogMVxuICAgICAgICB9LFxuICAgICAgICBlcnJvck1lc3NhZ2VzOiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRvbmx5OiBCb29sZWFuLFxuICAgICAgICBydWxlczoge1xuICAgICAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN1Y2Nlc3M6IEJvb2xlYW4sXG4gICAgICAgIHN1Y2Nlc3NNZXNzYWdlczoge1xuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0ZU9uQmx1cjogQm9vbGVhblxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yQnVja2V0OiBbXSxcbiAgICAgICAgICAgIGhhc0NvbG9yOiBmYWxzZSxcbiAgICAgICAgICAgIGhhc0ZvY3VzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaGFzSW5wdXQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNGb2N1c2VkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUmVzZXR0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaGFzRXJyb3I6IGZ1bmN0aW9uIGhhc0Vycm9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFcnJvck1lc3NhZ2VzLmxlbmd0aCA+IDAgfHwgdGhpcy5lcnJvckJ1Y2tldC5sZW5ndGggPiAwIHx8IHRoaXMuZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVybmFsRXJyb3I6IGZ1bmN0aW9uIGV4dGVybmFsRXJyb3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEVycm9yTWVzc2FnZXMubGVuZ3RoID4gMCB8fCB0aGlzLmVycm9yO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUT0RPOiBBZGQgbG9naWMgdGhhdCBhbGxvd3MgdGhlIHVzZXIgdG8gZW5hYmxlIGJhc2VkXG4gICAgICAgIC8vIHVwb24gYSBnb29kIHZhbGlkYXRpb25cbiAgICAgICAgaGFzU3VjY2VzczogZnVuY3Rpb24gaGFzU3VjY2VzcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1Y2Nlc3NNZXNzYWdlcy5sZW5ndGggPiAwIHx8IHRoaXMuc3VjY2VzcztcbiAgICAgICAgfSxcbiAgICAgICAgaGFzTWVzc2FnZXM6IGZ1bmN0aW9uIGhhc01lc3NhZ2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvbnMubGVuZ3RoID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzU3RhdGU6IGZ1bmN0aW9uIGhhc1N0YXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzU3VjY2VzcyB8fCB0aGlzLnNob3VsZFZhbGlkYXRlICYmIHRoaXMuaGFzRXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGludGVybmFsRXJyb3JNZXNzYWdlczogZnVuY3Rpb24gaW50ZXJuYWxFcnJvck1lc3NhZ2VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JNZXNzYWdlcyB8fCAnJztcbiAgICAgICAgfSxcbiAgICAgICAgc2hvdWxkVmFsaWRhdGU6IGZ1bmN0aW9uIHNob3VsZFZhbGlkYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxFcnJvciB8fCAhdGhpcy5pc1Jlc2V0dGluZyAmJiAodGhpcy52YWxpZGF0ZU9uQmx1ciA/IHRoaXMuaGFzRm9jdXNlZCAmJiAhdGhpcy5pc0ZvY3VzZWQgOiB0aGlzLmhhc0lucHV0IHx8IHRoaXMuaGFzRm9jdXNlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRpb25zOiBmdW5jdGlvbiB2YWxpZGF0aW9ucygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRpb25UYXJnZXQuc2xpY2UoMCwgdGhpcy5lcnJvckNvdW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGlvblN0YXRlOiBmdW5jdGlvbiB2YWxpZGF0aW9uU3RhdGUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNFcnJvciAmJiB0aGlzLnNob3VsZFZhbGlkYXRlKSByZXR1cm4gJ2Vycm9yJztcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1N1Y2Nlc3MpIHJldHVybiAnc3VjY2Vzcyc7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNDb2xvcikgcmV0dXJuIHRoaXMuY29sb3I7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGlvblRhcmdldDogZnVuY3Rpb24gdmFsaWRhdGlvblRhcmdldCgpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmludGVybmFsRXJyb3JNZXNzYWdlcy5sZW5ndGggPiAwID8gdGhpcy5lcnJvck1lc3NhZ2VzIDogdGhpcy5zdWNjZXNzTWVzc2FnZXMubGVuZ3RoID4gMCA/IHRoaXMuc3VjY2Vzc01lc3NhZ2VzIDogdGhpcy5tZXNzYWdlcztcbiAgICAgICAgICAgIC8vIFN0cmluZ1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgICAgICAgICAgICAgLy8gQXJyYXkgd2l0aCBpdGVtc1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgLy8gQ3VycmVudGx5IGhhcyB2YWxpZGF0aW9uXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkVmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvckJ1Y2tldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgICBydWxlczoge1xuICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QoX3V0aWxfaGVscGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVlcEVxdWFsXCJdKShuZXdWYWwsIG9sZFZhbCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVlcDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBpbnRlcm5hbFZhbHVlOiBmdW5jdGlvbiBpbnRlcm5hbFZhbHVlKCkge1xuICAgICAgICAgICAgLy8gSWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBzZXR0aW5nIGlucHV0LFxuICAgICAgICAgICAgLy8gbWFyayBpdCB3aXRoIGhhc0lucHV0XG4gICAgICAgICAgICB0aGlzLmhhc0lucHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVPbkJsdXIgfHwgdGhpcy4kbmV4dFRpY2sodGhpcy52YWxpZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRm9jdXNlZDogZnVuY3Rpb24gaXNGb2N1c2VkKHZhbCkge1xuICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBjaGVjayB2YWxpZGF0aW9uXG4gICAgICAgICAgICAvLyBpZiBkaXNhYmxlZCBvciByZWFkb25seVxuICAgICAgICAgICAgaWYgKCF2YWwgJiYgIXRoaXMuZGlzYWJsZWQgJiYgIXRoaXMucmVhZG9ubHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVPbkJsdXIgJiYgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc1Jlc2V0dGluZzogZnVuY3Rpb24gaXNSZXNldHRpbmcoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFzSW5wdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNSZXNldHRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9LFxuICAgICAgICBoYXNFcnJvcjogZnVuY3Rpb24gaGFzRXJyb3IodmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRWYWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTplcnJvcicsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZU1vdW50OiBmdW5jdGlvbiBiZWZvcmVNb3VudCgpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIH0sXG4gICAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy5mb3JtICYmIHRoaXMuZm9ybS5yZWdpc3Rlcih0aGlzKTtcbiAgICB9LFxuICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZm9ybSAmJiB0aGlzLmZvcm0udW5yZWdpc3Rlcih0aGlzKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgLyoqIEBwdWJsaWMgKi9cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy5pc1Jlc2V0dGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSBBcnJheS5pc0FycmF5KHRoaXMuaW50ZXJuYWxWYWx1ZSkgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEBwdWJsaWMgKi9cbiAgICAgICAgcmVzZXRWYWxpZGF0aW9uOiBmdW5jdGlvbiByZXNldFZhbGlkYXRpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVzZXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEBwdWJsaWMgKi9cbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGZvcmNlLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBmb3JjZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW50ZXJuYWxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnJvckJ1Y2tldCA9IFtdO1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB0aGlzLmhhc0lucHV0ID0gdGhpcy5oYXNGb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnJ1bGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBydWxlID0gdGhpcy5ydWxlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkID0gdHlwZW9mIHJ1bGUgPT09ICdmdW5jdGlvbicgPyBydWxlKHZhbHVlKSA6IHJ1bGU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkID09PSBmYWxzZSB8fCB0eXBlb2YgdmFsaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQnVja2V0LnB1c2godmFsaWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsaWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0KF91dGlsX2NvbnNvbGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImNvbnNvbGVFcnJvclwiXSkoXCJSdWxlcyBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIG9yIGJvb2xlYW4sIHJlY2VpdmVkICdcIiArICh0eXBlb2YgdmFsaWQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbGlkKSkgKyBcIicgaW5zdGVhZFwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yQnVja2V0ID0gZXJyb3JCdWNrZXQ7XG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gZXJyb3JCdWNrZXQubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWQ7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2FwcC5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvYXBwLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fYWxlcnRzLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19hbGVydHMuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19hcHAuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2FwcC5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2F1dG9jb21wbGV0ZXMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19hdXRvY29tcGxldGVzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2F2YXRhcnMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19hdmF0YXJzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2JhZGdlcy5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fYmFkZ2VzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fYm90dG9tLW5hdnMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fYm90dG9tLW5hdnMuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2JvdHRvbS1zaGVldHMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19ib3R0b20tc2hlZXRzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2JyZWFkY3J1bWJzLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2JyZWFkY3J1bWJzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19idXR0b24tdG9nZ2xlLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fYnV0dG9uLXRvZ2dsZS5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19idXR0b25zLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fYnV0dG9ucy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19jYXJkcy5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19jYXJkcy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fY2Fyb3VzZWwuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fY2Fyb3VzZWwuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2NoaXBzLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2NoaXBzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19jb250ZW50LnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fY29udGVudC5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19jb3VudGVycy5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19jb3VudGVycy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZGF0YS1pdGVyYXRvci5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2RhdGEtaXRlcmF0b3Iuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZGF0YS10YWJsZS5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2RhdGEtdGFibGUuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZGF0ZS1waWNrZXItaGVhZGVyLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19kYXRlLXBpY2tlci1oZWFkZXIuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19kYXRlLXBpY2tlci10YWJsZS5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19kYXRlLXBpY2tlci10YWJsZS5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZGF0ZS1waWNrZXItdGl0bGUuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZGF0ZS1waWNrZXItdGl0bGUuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2RhdGUtcGlja2VyLXllYXJzLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2RhdGUtcGlja2VyLXllYXJzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19kaWFsb2dzLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZGlhbG9ncy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19kaXZpZGVycy5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19kaXZpZGVycy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZXhwYW5zaW9uLXBhbmVsLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19leHBhbnNpb24tcGFuZWwuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19mb290ZXIuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2Zvb3Rlci5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2Zvcm1zLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2Zvcm1zLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19ncmlkLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fZ3JpZC5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19pY29ucy5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19pY29ucy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9faW1hZ2VzLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19pbWFnZXMuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19pbnB1dHMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2lucHV0cy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2l0ZW0tZ3JvdXAuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19pdGVtLWdyb3VwLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2p1bWJvdHJvbnMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19qdW1ib3Ryb25zLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX2xhYmVscy5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fbGFiZWxzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fbGlzdHMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fbGlzdHMuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX21lbnVzLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX21lbnVzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19tZXNzYWdlcy5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19tZXNzYWdlcy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fbmF2aWdhdGlvbi1kcmF3ZXIuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fbmF2aWdhdGlvbi1kcmF3ZXIuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX292ZXJmbG93LWJ1dHRvbnMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19vdmVyZmxvdy1idXR0b25zLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX292ZXJsYXkuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19vdmVybGF5LnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3BhZ2luYXRpb24uc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19wYWdpbmF0aW9uLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3BhcmFsbGF4LnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3BhcmFsbGF4LnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19waWNrZXJzLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fcGlja2Vycy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19wcm9ncmVzcy1jaXJjdWxhci5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19wcm9ncmVzcy1jaXJjdWxhci5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fcHJvZ3Jlc3MtbGluZWFyLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19wcm9ncmVzcy1saW5lYXIuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19yYWRpby1ncm91cC5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19yYWRpby1ncm91cC5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fcmFkaW9zLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19yYWRpb3Muc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19yYW5nZS1zbGlkZXJzLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fcmFuZ2Utc2xpZGVycy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19yYXRpbmcuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3JhdGluZy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3Jlc3BvbnNpdmUuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19yZXNwb25zaXZlLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3NlbGVjdC5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc2VsZWN0LnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc2VsZWN0aW9uLWNvbnRyb2xzLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19zZWxlY3Rpb24tY29udHJvbHMuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19zbGlkZXJzLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc2xpZGVycy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19zbWFsbC1kaWFsb2cuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3NtYWxsLWRpYWxvZy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3NuYWNrYmFycy5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc25hY2tiYXJzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc3BlZWQtZGlhbC5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3NwZWVkLWRpYWwuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc3RlcHBlcnMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc3RlcHBlcnMuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3N1YmhlYWRlcnMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL19zdWJoZWFkZXJzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3N3aXRjaC5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc3dpdGNoLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc3lzdGVtLWJhcnMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fc3lzdGVtLWJhcnMuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3RhYmxlcy5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdGFibGVzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdGFicy5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3RhYnMuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdGV4dC1maWVsZHMuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdGV4dC1maWVsZHMuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3RleHRhcmVhLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3RleHRhcmVhLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL190aW1lLXBpY2tlci1jbG9jay5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL190aW1lLXBpY2tlci1jbG9jay5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdGltZS1waWNrZXItdGl0bGUuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdGltZS1waWNrZXItdGl0bGUuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3RpbWVsaW5lLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3RpbWVsaW5lLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL190b29sYmFyLnN0eWxcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdG9vbGJhci5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3N0eWx1cy9jb21wb25lbnRzL190b29sdGlwcy5zdHlsXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL190b29sdGlwcy5zdHlsICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdHJlZXZpZXcuc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9zdHlsdXMvY29tcG9uZW50cy9fdHJlZXZpZXcuc3R5bCAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvc3R5bHVzL2NvbXBvbmVudHMvX3dpbmRvd3Muc3R5bFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3N0eWx1cy9jb21wb25lbnRzL193aW5kb3dzLnN0eWwgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9UaGVtZVByb3ZpZGVyLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL1RoZW1lUHJvdmlkZXIudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL21peGlucy90aGVtZWFibGUgKi8gXCIuL3NyYy9taXhpbnMvdGhlbWVhYmxlLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWl4aW5zICovIFwiLi9zcmMvdXRpbC9taXhpbnMudHNcIik7XG5cblxuLyogQHZ1ZS9jb21wb25lbnQgKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoT2JqZWN0KF9taXhpbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImRlZmF1bHRcIl0pKF9taXhpbnNfdGhlbWVhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKS5leHRlbmQoe1xuICAgIG5hbWU6ICd0aGVtZS1wcm92aWRlcicsXG4gICAgcHJvcHM6IHtcbiAgICAgICAgcm9vdDogQm9vbGVhblxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaXNEYXJrOiBmdW5jdGlvbiBpc0RhcmsoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290ID8gdGhpcy5yb290SXNEYXJrIDogX21peGluc190aGVtZWFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0ub3B0aW9ucy5jb21wdXRlZC5pc0RhcmsuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzbG90cy5kZWZhdWx0ICYmIHRoaXMuJHNsb3RzLmRlZmF1bHQuZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICFub2RlLmlzQ29tbWVudCAmJiBub2RlLnRleHQgIT09ICcgJztcbiAgICAgICAgfSk7XG4gICAgfVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2NvbG9yL3RyYW5zZm9ybUNJRUxBQi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2NvbG9yL3RyYW5zZm9ybUNJRUxBQi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBmcm9tWFlaLCB0b1hZWiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmcm9tWFlaXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZnJvbVhZWjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwidG9YWVpcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB0b1hZWjsgfSk7XG52YXIgZGVsdGEgPSAwLjIwNjg5NjU1MTcyNDEzNzkzOyAvLyA2w7cyOVxudmFyIGNpZWxhYkZvcndhcmRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjaWVsYWJGb3J3YXJkVHJhbnNmb3JtKHQpIHtcbiAgICByZXR1cm4gdCA+IE1hdGgucG93KGRlbHRhLCAzKSA/IE1hdGguY2JydCh0KSA6IHQgLyAoMyAqIE1hdGgucG93KGRlbHRhLCAyKSkgKyA0IC8gMjk7XG59O1xudmFyIGNpZWxhYlJldmVyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjaWVsYWJSZXZlcnNlVHJhbnNmb3JtKHQpIHtcbiAgICByZXR1cm4gdCA+IGRlbHRhID8gTWF0aC5wb3codCwgMykgOiAzICogTWF0aC5wb3coZGVsdGEsIDIpICogKHQgLSA0IC8gMjkpO1xufTtcbmZ1bmN0aW9uIGZyb21YWVooeHl6KSB7XG4gICAgdmFyIHRyYW5zZm9ybSA9IGNpZWxhYkZvcndhcmRUcmFuc2Zvcm07XG4gICAgdmFyIHRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybSh4eXpbMV0pO1xuICAgIHJldHVybiBbMTE2ICogdHJhbnNmb3JtZWRZIC0gMTYsIDUwMCAqICh0cmFuc2Zvcm0oeHl6WzBdIC8gMC45NTA0NykgLSB0cmFuc2Zvcm1lZFkpLCAyMDAgKiAodHJhbnNmb3JtZWRZIC0gdHJhbnNmb3JtKHh5elsyXSAvIDEuMDg4ODMpKV07XG59XG5mdW5jdGlvbiB0b1hZWihsYWIpIHtcbiAgICB2YXIgdHJhbnNmb3JtID0gY2llbGFiUmV2ZXJzZVRyYW5zZm9ybTtcbiAgICB2YXIgTG4gPSAobGFiWzBdICsgMTYpIC8gMTE2O1xuICAgIHJldHVybiBbdHJhbnNmb3JtKExuICsgbGFiWzFdIC8gNTAwKSAqIDAuOTUwNDcsIHRyYW5zZm9ybShMbiksIHRyYW5zZm9ybShMbiAtIGxhYlsyXSAvIDIwMCkgKiAxLjA4ODgzXTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9jb2xvci90cmFuc2Zvcm1TUkdCLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2NvbG9yL3RyYW5zZm9ybVNSR0IudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGZyb21YWVosIHRvWFlaICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZyb21YWVpcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmcm9tWFlaOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ0b1hZWlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRvWFlaOyB9KTtcbi8vIEZvciBjb252ZXJ0aW5nIFhZWiB0byBzUkdCXG52YXIgc3JnYkZvcndhcmRNYXRyaXggPSBbWzMuMjQwNiwgLTEuNTM3MiwgLTAuNDk4Nl0sIFstMC45Njg5LCAxLjg3NTgsIDAuMDQxNV0sIFswLjA1NTcsIC0wLjIwNDAsIDEuMDU3MF1dO1xuLy8gRm9yd2FyZCBnYW1tYSBhZGp1c3RcbnZhciBzcmdiRm9yd2FyZFRyYW5zZm9ybSA9IGZ1bmN0aW9uIHNyZ2JGb3J3YXJkVHJhbnNmb3JtKEMpIHtcbiAgICByZXR1cm4gQyA8PSAwLjAwMzEzMDggPyBDICogMTIuOTIgOiAxLjA1NSAqIE1hdGgucG93KEMsIDEgLyAyLjQpIC0gMC4wNTU7XG59O1xuLy8gRm9yIGNvbnZlcnRpbmcgc1JHQiB0byBYWVpcbnZhciBzcmdiUmV2ZXJzZU1hdHJpeCA9IFtbMC40MTI0LCAwLjM1NzYsIDAuMTgwNV0sIFswLjIxMjYsIDAuNzE1MiwgMC4wNzIyXSwgWzAuMDE5MywgMC4xMTkyLCAwLjk1MDVdXTtcbi8vIFJldmVyc2UgZ2FtbWEgYWRqdXN0XG52YXIgc3JnYlJldmVyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBzcmdiUmV2ZXJzZVRyYW5zZm9ybShDKSB7XG4gICAgcmV0dXJuIEMgPD0gMC4wNDA0NSA/IEMgLyAxMi45MiA6IE1hdGgucG93KChDICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59O1xuZnVuY3Rpb24gY2xhbXAodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGZyb21YWVooeHl6KSB7XG4gICAgdmFyIHJnYiA9IEFycmF5KDMpO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBzcmdiRm9yd2FyZFRyYW5zZm9ybTtcbiAgICB2YXIgbWF0cml4ID0gc3JnYkZvcndhcmRNYXRyaXg7XG4gICAgLy8gTWF0cml4IHRyYW5zZm9ybSwgdGhlbiBnYW1tYSBhZGp1c3RtZW50XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgcmdiW2ldID0gTWF0aC5yb3VuZChjbGFtcCh0cmFuc2Zvcm0obWF0cml4W2ldWzBdICogeHl6WzBdICsgbWF0cml4W2ldWzFdICogeHl6WzFdICsgbWF0cml4W2ldWzJdICogeHl6WzJdKSkgKiAyNTUpO1xuICAgIH1cbiAgICAvLyBSZXNjYWxlIGJhY2sgdG8gWzAsIDI1NV1cbiAgICByZXR1cm4gKHJnYlswXSA8PCAxNikgKyAocmdiWzFdIDw8IDgpICsgKHJnYlsyXSA8PCAwKTtcbn1cbmZ1bmN0aW9uIHRvWFlaKHJnYikge1xuICAgIHZhciB4eXogPSBbMCwgMCwgMF07XG4gICAgdmFyIHRyYW5zZm9ybSA9IHNyZ2JSZXZlcnNlVHJhbnNmb3JtO1xuICAgIHZhciBtYXRyaXggPSBzcmdiUmV2ZXJzZU1hdHJpeDtcbiAgICAvLyBSZXNjYWxlIGZyb20gWzAsIDI1NV0gdG8gWzAsIDFdIHRoZW4gYWRqdXN0IHNSR0IgZ2FtbWEgdG8gbGluZWFyIFJHQlxuICAgIHZhciByID0gdHJhbnNmb3JtKChyZ2IgPj4gMTYgJiAweGZmKSAvIDI1NSk7XG4gICAgdmFyIGcgPSB0cmFuc2Zvcm0oKHJnYiA+PiA4ICYgMHhmZikgLyAyNTUpO1xuICAgIHZhciBiID0gdHJhbnNmb3JtKChyZ2IgPj4gMCAmIDB4ZmYpIC8gMjU1KTtcbiAgICAvLyBNYXRyaXggY29sb3Igc3BhY2UgdHJhbnNmb3JtXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgeHl6W2ldID0gbWF0cml4W2ldWzBdICogciArIG1hdHJpeFtpXVsxXSAqIGcgKyBtYXRyaXhbaV1bMl0gKiBiO1xuICAgIH1cbiAgICByZXR1cm4geHl6O1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2NvbG9yVXRpbHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvY29sb3JVdGlscy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogY29sb3JUb0ludCwgaW50VG9IZXgsIGNvbG9yVG9IZXggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY29sb3JUb0ludFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNvbG9yVG9JbnQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImludFRvSGV4XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaW50VG9IZXg7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNvbG9yVG9IZXhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb2xvclRvSGV4OyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25zb2xlICovIFwiLi9zcmMvdXRpbC9jb25zb2xlLnRzXCIpO1xuXG5mdW5jdGlvbiBjb2xvclRvSW50KGNvbG9yKSB7XG4gICAgdmFyIHJnYjtcbiAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnbnVtYmVyJykge1xuICAgICAgICByZ2IgPSBjb2xvcjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGMgPSBjb2xvclswXSA9PT0gJyMnID8gY29sb3Iuc3Vic3RyaW5nKDEpIDogY29sb3I7XG4gICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgYyA9IGMuc3BsaXQoJycpLm1hcChmdW5jdGlvbiAoY2hhcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFyICsgY2hhcjtcbiAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjLmxlbmd0aCAhPT0gNikge1xuICAgICAgICAgICAgT2JqZWN0KF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjb25zb2xlV2FyblwiXSkoXCInXCIgKyBjb2xvciArIFwiJyBpcyBub3QgYSB2YWxpZCByZ2IgY29sb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmdiID0gcGFyc2VJbnQoYywgMTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb2xvcnMgY2FuIG9ubHkgYmUgbnVtYmVycyBvciBzdHJpbmdzLCByZWNpZXZlZCBcIiArIChjb2xvciA9PSBudWxsID8gY29sb3IgOiBjb2xvci5jb25zdHJ1Y3Rvci5uYW1lKSArIFwiIGluc3RlYWRcIik7XG4gICAgfVxuICAgIGlmIChyZ2IgPCAwKSB7XG4gICAgICAgIE9iamVjdChfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY29uc29sZVdhcm5cIl0pKFwiQ29sb3JzIGNhbm5vdCBiZSBuZWdhdGl2ZTogJ1wiICsgY29sb3IgKyBcIidcIik7XG4gICAgICAgIHJnYiA9IDA7XG4gICAgfSBlbHNlIGlmIChyZ2IgPiAweGZmZmZmZiB8fCBpc05hTihyZ2IpKSB7XG4gICAgICAgIE9iamVjdChfY29uc29sZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiY29uc29sZVdhcm5cIl0pKFwiJ1wiICsgY29sb3IgKyBcIicgaXMgbm90IGEgdmFsaWQgcmdiIGNvbG9yXCIpO1xuICAgICAgICByZ2IgPSAweGZmZmZmZjtcbiAgICB9XG4gICAgcmV0dXJuIHJnYjtcbn1cbmZ1bmN0aW9uIGludFRvSGV4KGNvbG9yKSB7XG4gICAgdmFyIGhleENvbG9yID0gY29sb3IudG9TdHJpbmcoMTYpO1xuICAgIGlmIChoZXhDb2xvci5sZW5ndGggPCA2KSBoZXhDb2xvciA9ICcwJy5yZXBlYXQoNiAtIGhleENvbG9yLmxlbmd0aCkgKyBoZXhDb2xvcjtcbiAgICByZXR1cm4gJyMnICsgaGV4Q29sb3I7XG59XG5mdW5jdGlvbiBjb2xvclRvSGV4KGNvbG9yKSB7XG4gICAgcmV0dXJuIGludFRvSGV4KGNvbG9yVG9JbnQoY29sb3IpKTtcbn1cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9jb25zb2xlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2NvbnNvbGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGNvbnNvbGVJbmZvLCBjb25zb2xlV2FybiwgY29uc29sZUVycm9yLCBkZXByZWNhdGUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY29uc29sZUluZm9cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb25zb2xlSW5mbzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY29uc29sZVdhcm5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjb25zb2xlV2FybjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY29uc29sZUVycm9yXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29uc29sZUVycm9yOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZXByZWNhdGVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBkZXByZWNhdGU7IH0pO1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZShtZXNzYWdlLCB2bSwgcGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICB2bSA9IHtcbiAgICAgICAgICAgIF9pc1Z1ZTogdHJ1ZSxcbiAgICAgICAgICAgICRwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICAgICRvcHRpb25zOiB2bVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodm0pIHtcbiAgICAgICAgLy8gT25seSBzaG93IGVhY2ggbWVzc2FnZSBvbmNlIHBlciBpbnN0YW5jZVxuICAgICAgICB2bS4kX2FscmVhZHlXYXJuZWQgPSB2bS4kX2FscmVhZHlXYXJuZWQgfHwgW107XG4gICAgICAgIGlmICh2bS4kX2FscmVhZHlXYXJuZWQuaW5jbHVkZXMobWVzc2FnZSkpIHJldHVybjtcbiAgICAgICAgdm0uJF9hbHJlYWR5V2FybmVkLnB1c2gobWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBcIltWdWV0aWZ5XSBcIiArIG1lc3NhZ2UgKyAodm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnKTtcbn1cbmZ1bmN0aW9uIGNvbnNvbGVJbmZvKG1lc3NhZ2UsIHZtLCBwYXJlbnQpIHtcbiAgICB2YXIgbmV3TWVzc2FnZSA9IGNyZWF0ZU1lc3NhZ2UobWVzc2FnZSwgdm0sIHBhcmVudCk7XG4gICAgbmV3TWVzc2FnZSAhPSBudWxsICYmIGNvbnNvbGUuaW5mbyhuZXdNZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGNvbnNvbGVXYXJuKG1lc3NhZ2UsIHZtLCBwYXJlbnQpIHtcbiAgICB2YXIgbmV3TWVzc2FnZSA9IGNyZWF0ZU1lc3NhZ2UobWVzc2FnZSwgdm0sIHBhcmVudCk7XG4gICAgbmV3TWVzc2FnZSAhPSBudWxsICYmIGNvbnNvbGUud2FybihuZXdNZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGNvbnNvbGVFcnJvcihtZXNzYWdlLCB2bSwgcGFyZW50KSB7XG4gICAgdmFyIG5ld01lc3NhZ2UgPSBjcmVhdGVNZXNzYWdlKG1lc3NhZ2UsIHZtLCBwYXJlbnQpO1xuICAgIG5ld01lc3NhZ2UgIT0gbnVsbCAmJiBjb25zb2xlLmVycm9yKG5ld01lc3NhZ2UpO1xufVxuZnVuY3Rpb24gZGVwcmVjYXRlKG9yaWdpbmFsLCByZXBsYWNlbWVudCwgdm0sIHBhcmVudCkge1xuICAgIGNvbnNvbGVXYXJuKFwiJ1wiICsgb3JpZ2luYWwgKyBcIicgaXMgZGVwcmVjYXRlZCwgdXNlICdcIiArIHJlcGxhY2VtZW50ICsgXCInIGluc3RlYWRcIiwgdm0sIHBhcmVudCk7XG59XG4vKipcbiAqIFNoYW1lbGVzc2x5IHN0b2xlbiBmcm9tIHZ1ZWpzL3Z1ZS9ibG9iL2Rldi9zcmMvY29yZS91dGlsL2RlYnVnLmpzXG4gKi9cbnZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xudmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gY2xhc3NpZnkoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjLnRvVXBwZXJDYXNlKCk7XG4gICAgfSkucmVwbGFjZSgvWy1fXS9nLCAnJyk7XG59O1xuZnVuY3Rpb24gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICAgIHJldHVybiAnPFJvb3Q+JztcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGwgPyB2bS5vcHRpb25zIDogdm0uX2lzVnVlID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9ucyA6IHZtIHx8IHt9O1xuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuICAgIHJldHVybiAobmFtZSA/IFwiPFwiICsgY2xhc3NpZnkobmFtZSkgKyBcIj5cIiA6IFwiPEFub255bW91cz5cIikgKyAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyBcIiBhdCBcIiArIGZpbGUgOiAnJyk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICAgIHZhciB0cmVlID0gW107XG4gICAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlLm1hcChmdW5jdGlvbiAodm0sIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogJyAnLnJlcGVhdCg1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKSA/IGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pICsgXCIuLi4gKFwiICsgdm1bMV0gKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSk7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlxcblxcbihmb3VuZCBpbiBcIiArIGZvcm1hdENvbXBvbmVudE5hbWUodm0pICsgXCIpXCI7XG4gICAgfVxufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2RlZHVwZU1vZGVsTGlzdGVuZXJzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9kZWR1cGVNb2RlbExpc3RlbmVycy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVmYXVsdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZHVwZU1vZGVsTGlzdGVuZXJzOyB9KTtcbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGUgYEBpbnB1dGAgbGlzdGVuZXJzIHdoZW5cbiAqIHVzaW5nIHYtbW9kZWwgd2l0aCBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92dWV0aWZ5anMvdnVldGlmeS9pc3N1ZXMvNDQ2MFxuICovXG5mdW5jdGlvbiBkZWR1cGVNb2RlbExpc3RlbmVycyhkYXRhKSB7XG4gICAgaWYgKGRhdGEubW9kZWwgJiYgZGF0YS5vbiAmJiBkYXRhLm9uLmlucHV0KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEub24uaW5wdXQpKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGRhdGEub24uaW5wdXQuaW5kZXhPZihkYXRhLm1vZGVsLmNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIGRhdGEub24uaW5wdXQuc3BsaWNlKGksIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEub24uaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvZWFzaW5nLXBhdHRlcm5zLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvZWFzaW5nLXBhdHRlcm5zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGxpbmVhciwgZWFzZUluUXVhZCwgZWFzZU91dFF1YWQsIGVhc2VJbk91dFF1YWQsIGVhc2VJbkN1YmljLCBlYXNlT3V0Q3ViaWMsIGVhc2VJbk91dEN1YmljLCBlYXNlSW5RdWFydCwgZWFzZU91dFF1YXJ0LCBlYXNlSW5PdXRRdWFydCwgZWFzZUluUXVpbnQsIGVhc2VPdXRRdWludCwgZWFzZUluT3V0UXVpbnQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibGluZWFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZWFyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlSW5RdWFkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZWFzZUluUXVhZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZU91dFF1YWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlYXNlT3V0UXVhZDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZUluT3V0UXVhZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGVhc2VJbk91dFF1YWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VJbkN1YmljXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZWFzZUluQ3ViaWM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VPdXRDdWJpY1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGVhc2VPdXRDdWJpYzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZUluT3V0Q3ViaWNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlYXNlSW5PdXRDdWJpYzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZUluUXVhcnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlYXNlSW5RdWFydDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZWFzZU91dFF1YXJ0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZWFzZU91dFF1YXJ0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlSW5PdXRRdWFydFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGVhc2VJbk91dFF1YXJ0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlSW5RdWludFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGVhc2VJblF1aW50OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlYXNlT3V0UXVpbnRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBlYXNlT3V0UXVpbnQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVhc2VJbk91dFF1aW50XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZWFzZUluT3V0UXVpbnQ7IH0pO1xuLy8gbGluZWFyXG52YXIgbGluZWFyID0gZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgcmV0dXJuIHQ7XG59O1xuLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VJblF1YWQgPSBmdW5jdGlvbiBlYXNlSW5RdWFkKHQpIHtcbiAgcmV0dXJuIHQgKiB0O1xufTtcbi8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG52YXIgZWFzZU91dFF1YWQgPSBmdW5jdGlvbiBlYXNlT3V0UXVhZCh0KSB7XG4gIHJldHVybiB0ICogKDIgLSB0KTtcbn07XG4vLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbnZhciBlYXNlSW5PdXRRdWFkID0gZnVuY3Rpb24gZWFzZUluT3V0UXVhZCh0KSB7XG4gIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG59O1xuLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VJbkN1YmljID0gZnVuY3Rpb24gZWFzZUluQ3ViaWModCkge1xuICByZXR1cm4gdCAqIHQgKiB0O1xufTtcbi8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG52YXIgZWFzZU91dEN1YmljID0gZnVuY3Rpb24gZWFzZU91dEN1YmljKHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn07XG4vLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbnZhciBlYXNlSW5PdXRDdWJpYyA9IGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQpIHtcbiAgcmV0dXJuIHQgPCAwLjUgPyA0ICogdCAqIHQgKiB0IDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxO1xufTtcbi8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbnZhciBlYXNlSW5RdWFydCA9IGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdCAqIHQ7XG59O1xuLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbnZhciBlYXNlT3V0UXVhcnQgPSBmdW5jdGlvbiBlYXNlT3V0UXVhcnQodCkge1xuICByZXR1cm4gMSAtIC0tdCAqIHQgKiB0ICogdDtcbn07XG4vLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbnZhciBlYXNlSW5PdXRRdWFydCA9IGZ1bmN0aW9uIGVhc2VJbk91dFF1YXJ0KHQpIHtcbiAgcmV0dXJuIHQgPCAwLjUgPyA4ICogdCAqIHQgKiB0ICogdCA6IDEgLSA4ICogLS10ICogdCAqIHQgKiB0O1xufTtcbi8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbnZhciBlYXNlSW5RdWludCA9IGZ1bmN0aW9uIGVhc2VJblF1aW50KHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xufTtcbi8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG52YXIgZWFzZU91dFF1aW50ID0gZnVuY3Rpb24gZWFzZU91dFF1aW50KHQpIHtcbiAgcmV0dXJuIDEgKyAtLXQgKiB0ICogdCAqIHQgKiB0O1xufTtcbi8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxudmFyIGVhc2VJbk91dFF1aW50ID0gZnVuY3Rpb24gZWFzZUluT3V0UXVpbnQodCkge1xuICByZXR1cm4gdCA8IDAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAtLXQgKiB0ICogdCAqIHQgKiB0O1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9oZWxwZXJzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2hlbHBlcnMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGNyZWF0ZVNpbXBsZUZ1bmN0aW9uYWwsIGNyZWF0ZVNpbXBsZVRyYW5zaXRpb24sIGNyZWF0ZUphdmFTY3JpcHRUcmFuc2l0aW9uLCBkaXJlY3RpdmVDb25maWcsIGFkZE9uY2VFdmVudExpc3RlbmVyLCBnZXROZXN0ZWRWYWx1ZSwgZGVlcEVxdWFsLCBnZXRPYmplY3RWYWx1ZUJ5UGF0aCwgZ2V0UHJvcGVydHlGcm9tSXRlbSwgY3JlYXRlUmFuZ2UsIGdldFpJbmRleCwgZXNjYXBlSFRNTCwgZmlsdGVyT2JqZWN0T25LZXlzLCBmaWx0ZXJDaGlsZHJlbiwgY29udmVydFRvVW5pdCwga2ViYWJDYXNlLCBpc09iamVjdCwga2V5Q29kZXMsIHJlbWFwSW50ZXJuYWxJY29uLCBrZXlzLCBjYW1lbGl6ZSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjcmVhdGVTaW1wbGVGdW5jdGlvbmFsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlU2ltcGxlRnVuY3Rpb25hbDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3JlYXRlU2ltcGxlVHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNyZWF0ZVNpbXBsZVRyYW5zaXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNyZWF0ZUphdmFTY3JpcHRUcmFuc2l0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY3JlYXRlSmF2YVNjcmlwdFRyYW5zaXRpb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRpcmVjdGl2ZUNvbmZpZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRpcmVjdGl2ZUNvbmZpZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYWRkT25jZUV2ZW50TGlzdGVuZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBhZGRPbmNlRXZlbnRMaXN0ZW5lcjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0TmVzdGVkVmFsdWVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXROZXN0ZWRWYWx1ZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVlcEVxdWFsXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVlcEVxdWFsOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRPYmplY3RWYWx1ZUJ5UGF0aFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldE9iamVjdFZhbHVlQnlQYXRoOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRQcm9wZXJ0eUZyb21JdGVtXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0UHJvcGVydHlGcm9tSXRlbTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3JlYXRlUmFuZ2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjcmVhdGVSYW5nZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0WkluZGV4XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0WkluZGV4OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJlc2NhcGVIVE1MXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZXNjYXBlSFRNTDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmlsdGVyT2JqZWN0T25LZXlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmlsdGVyT2JqZWN0T25LZXlzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJmaWx0ZXJDaGlsZHJlblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZpbHRlckNoaWxkcmVuOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjb252ZXJ0VG9Vbml0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gY29udmVydFRvVW5pdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwia2ViYWJDYXNlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4ga2ViYWJDYXNlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc09iamVjdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlzT2JqZWN0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJrZXlDb2Rlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGtleUNvZGVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJyZW1hcEludGVybmFsSWNvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlbWFwSW50ZXJuYWxJY29uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJrZXlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4ga2V5czsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY2FtZWxpemVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjYW1lbGl6ZTsgfSk7XG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfX2Fzc2lnbiA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hc3NpZ24gfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVNpbXBsZUZ1bmN0aW9uYWwoYywgZWwsIG5hbWUpIHtcbiAgICBpZiAoZWwgPT09IHZvaWQgMCkge1xuICAgICAgICBlbCA9ICdkaXYnO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lIHx8IGMucmVwbGFjZSgvX18vZywgJy0nKSxcbiAgICAgICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgX2EpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gX2EuZGF0YSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgICAgICAgICAgZGF0YS5zdGF0aWNDbGFzcyA9IChjICsgXCIgXCIgKyAoZGF0YS5zdGF0aWNDbGFzcyB8fCAnJykpLnRyaW0oKTtcbiAgICAgICAgICAgIHJldHVybiBoKGVsLCBkYXRhLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VUcmFuc2l0aW9ucyh0cmFuc2l0aW9ucywgYXJyYXkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2l0aW9ucykpIHJldHVybiB0cmFuc2l0aW9ucy5jb25jYXQoYXJyYXkpO1xuICAgIGlmICh0cmFuc2l0aW9ucykgYXJyYXkucHVzaCh0cmFuc2l0aW9ucyk7XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gY3JlYXRlU2ltcGxlVHJhbnNpdGlvbihuYW1lLCBvcmlnaW4sIG1vZGUpIHtcbiAgICBpZiAob3JpZ2luID09PSB2b2lkIDApIHtcbiAgICAgICAgb3JpZ2luID0gJ3RvcCBjZW50ZXIgMCc7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGZ1bmN0aW9uYWw6IHRydWUsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBncm91cDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWRlT25MZWF2ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWF2ZUFic29sdXRlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbW9kZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9yaWdpbjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBvcmlnaW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IFwidHJhbnNpdGlvblwiICsgKGNvbnRleHQucHJvcHMuZ3JvdXAgPyAnLWdyb3VwJyA6ICcnKTtcbiAgICAgICAgICAgIGNvbnRleHQuZGF0YSA9IGNvbnRleHQuZGF0YSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnRleHQuZGF0YS5wcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIG1vZGU6IGNvbnRleHQucHJvcHMubW9kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRleHQuZGF0YS5vbiA9IGNvbnRleHQuZGF0YS5vbiB8fCB7fTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LmlzRXh0ZW5zaWJsZShjb250ZXh0LmRhdGEub24pKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kYXRhLm9uID0gX19hc3NpZ24oe30sIGNvbnRleHQuZGF0YS5vbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3VyQmVmb3JlRW50ZXIgPSBbXTtcbiAgICAgICAgICAgIHZhciBvdXJMZWF2ZSA9IFtdO1xuICAgICAgICAgICAgdmFyIGFic29sdXRlID0gZnVuY3Rpb24gYWJzb2x1dGUoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG91ckJlZm9yZUVudGVyLnB1c2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY29udGV4dC5wcm9wcy5vcmlnaW47XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gY29udGV4dC5wcm9wcy5vcmlnaW47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnByb3BzLmxlYXZlQWJzb2x1dGUpIG91ckxlYXZlLnB1c2goYWJzb2x1dGUpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQucHJvcHMuaGlkZU9uTGVhdmUpIHtcbiAgICAgICAgICAgICAgICBvdXJMZWF2ZS5wdXNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYSA9IGNvbnRleHQuZGF0YS5vbixcbiAgICAgICAgICAgICAgICBiZWZvcmVFbnRlciA9IF9hLmJlZm9yZUVudGVyLFxuICAgICAgICAgICAgICAgIGxlYXZlID0gX2EubGVhdmU7XG4gICAgICAgICAgICAvLyBUeXBlIHNheXMgRnVuY3Rpb24gfCBGdW5jdGlvbltdIGJ1dFxuICAgICAgICAgICAgLy8gd2lsbCBvbmx5IHdvcmsgaWYgcHJvdmlkZWQgYSBmdW5jdGlvblxuICAgICAgICAgICAgY29udGV4dC5kYXRhLm9uLmJlZm9yZUVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZVRyYW5zaXRpb25zKGJlZm9yZUVudGVyLCBvdXJCZWZvcmVFbnRlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGV4dC5kYXRhLm9uLmxlYXZlID0gbWVyZ2VUcmFuc2l0aW9ucyhsZWF2ZSwgb3VyTGVhdmUpO1xuICAgICAgICAgICAgcmV0dXJuIGgodGFnLCBjb250ZXh0LmRhdGEsIGNvbnRleHQuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUphdmFTY3JpcHRUcmFuc2l0aW9uKG5hbWUsIGZ1bmN0aW9ucywgbW9kZSkge1xuICAgIGlmIChtb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgbW9kZSA9ICdpbi1vdXQnO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBtb2RlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHByb3BzOiBfX2Fzc2lnbih7fSwgY29udGV4dC5wcm9wcywgeyBuYW1lOiBuYW1lIH0pLFxuICAgICAgICAgICAgICAgIG9uOiBmdW5jdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaCgndHJhbnNpdGlvbicsIGRhdGEsIGNvbnRleHQuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRpcmVjdGl2ZUNvbmZpZyhiaW5kaW5nLCBkZWZhdWx0cykge1xuICAgIGlmIChkZWZhdWx0cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlZmF1bHRzID0ge307XG4gICAgfVxuICAgIHJldHVybiBfX2Fzc2lnbih7fSwgZGVmYXVsdHMsIGJpbmRpbmcubW9kaWZpZXJzLCB7IHZhbHVlOiBiaW5kaW5nLmFyZyB9LCBiaW5kaW5nLnZhbHVlIHx8IHt9KTtcbn1cbmZ1bmN0aW9uIGFkZE9uY2VFdmVudExpc3RlbmVyKGVsLCBldmVudCwgY2IpIHtcbiAgICB2YXIgb25jZSA9IGZ1bmN0aW9uIG9uY2UoKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uY2UsIGZhbHNlKTtcbiAgICB9O1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uY2UsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGdldE5lc3RlZFZhbHVlKG9iaiwgcGF0aCwgZmFsbGJhY2spIHtcbiAgICB2YXIgbGFzdCA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA8IDApIHJldHVybiBvYmogPT09IHVuZGVmaW5lZCA/IGZhbGxiYWNrIDogb2JqO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcbiAgICB9XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsbGJhY2s7XG4gICAgcmV0dXJuIG9ialtwYXRoW2xhc3RdXSA9PT0gdW5kZWZpbmVkID8gZmFsbGJhY2sgOiBvYmpbcGF0aFtsYXN0XV07XG59XG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlcyBhcmUgRGF0ZSwgdGhleSB3ZXJlIGNvbnZlcnQgdG8gdGltZXN0YW1wIHdpdGggZ2V0VGltZSBhbmQgY29tcGFyZSBpdFxuICAgICAgICBpZiAoYS5nZXRUaW1lKCkgIT09IGIuZ2V0VGltZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhICE9PSBPYmplY3QoYSkgfHwgYiAhPT0gT2JqZWN0KGIpKSB7XG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZXMgYXJlbid0IG9iamVjdHMsIHRoZXkgd2VyZSBhbHJlYWR5IGNoZWNrZWQgZm9yIGVxdWFsaXR5XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgaWYgKHByb3BzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSB7XG4gICAgICAgIC8vIERpZmZlcmVudCBudW1iZXIgb2YgcHJvcHMsIGRvbid0IGJvdGhlciB0byBjaGVja1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcy5ldmVyeShmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gZGVlcEVxdWFsKGFbcF0sIGJbcF0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0T2JqZWN0VmFsdWVCeVBhdGgob2JqLCBwYXRoLCBmYWxsYmFjaykge1xuICAgIC8vIGNyZWRpdDogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NDkxNDYzL2FjY2Vzc2luZy1uZXN0ZWQtamF2YXNjcmlwdC1vYmplY3RzLXdpdGgtc3RyaW5nLWtleSNjb21tZW50NTUyNzg0MTNfNjQ5MTYyMVxuICAgIGlmICghcGF0aCB8fCBwYXRoLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcpIHJldHVybiBmYWxsYmFjaztcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFsoXFx3KylcXF0vZywgJy4kMScpOyAvLyBjb252ZXJ0IGluZGV4ZXMgdG8gcHJvcGVydGllc1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC4vLCAnJyk7IC8vIHN0cmlwIGEgbGVhZGluZyBkb3RcbiAgICByZXR1cm4gZ2V0TmVzdGVkVmFsdWUob2JqLCBwYXRoLnNwbGl0KCcuJyksIGZhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5RnJvbUl0ZW0oaXRlbSwgcHJvcGVydHksIGZhbGxiYWNrKSB7XG4gICAgaWYgKHByb3BlcnR5ID09IG51bGwpIHJldHVybiBpdGVtID09PSB1bmRlZmluZWQgPyBmYWxsYmFjayA6IGl0ZW07XG4gICAgaWYgKGl0ZW0gIT09IE9iamVjdChpdGVtKSkgcmV0dXJuIGZhbGxiYWNrID09PSB1bmRlZmluZWQgPyBpdGVtIDogZmFsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpIHJldHVybiBnZXRPYmplY3RWYWx1ZUJ5UGF0aChpdGVtLCBwcm9wZXJ0eSwgZmFsbGJhY2spO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5KSkgcmV0dXJuIGdldE5lc3RlZFZhbHVlKGl0ZW0sIHByb3BlcnR5LCBmYWxsYmFjayk7XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbGxiYWNrO1xuICAgIHZhciB2YWx1ZSA9IHByb3BlcnR5KGl0ZW0sIGZhbGxiYWNrKTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGZhbGxiYWNrIDogdmFsdWU7XG59XG5mdW5jdGlvbiBjcmVhdGVSYW5nZShsZW5ndGgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogbGVuZ3RoIH0sIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHJldHVybiBrO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0WkluZGV4KGVsKSB7XG4gICAgaWYgKCFlbCB8fCBlbC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHJldHVybiAwO1xuICAgIHZhciBpbmRleCA9ICt3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnei1pbmRleCcpO1xuICAgIGlmIChpc05hTihpbmRleCkpIHJldHVybiBnZXRaSW5kZXgoZWwucGFyZW50Tm9kZSk7XG4gICAgcmV0dXJuIGluZGV4O1xufVxudmFyIHRhZ3NUb1JlcGxhY2UgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnXG59O1xuZnVuY3Rpb24gZXNjYXBlSFRNTChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1smPD5dL2csIGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgcmV0dXJuIHRhZ3NUb1JlcGxhY2VbdGFnXSB8fCB0YWc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaWx0ZXJPYmplY3RPbktleXMob2JqLCBrZXlzKSB7XG4gICAgdmFyIGZpbHRlcmVkID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIG9ialtrZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZmlsdGVyZWRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZDtcbn1cbmZ1bmN0aW9uIGZpbHRlckNoaWxkcmVuKGFycmF5LCB0YWcpIHtcbiAgICBpZiAoYXJyYXkgPT09IHZvaWQgMCkge1xuICAgICAgICBhcnJheSA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQuY29tcG9uZW50T3B0aW9ucyAmJiBjaGlsZC5jb21wb25lbnRPcHRpb25zLkN0b3Iub3B0aW9ucy5uYW1lID09PSB0YWc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Vbml0KHN0ciwgdW5pdCkge1xuICAgIGlmICh1bml0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdW5pdCA9ICdweCc7XG4gICAgfVxuICAgIGlmIChzdHIgPT0gbnVsbCB8fCBzdHIgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChpc05hTigrc3RyKSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBOdW1iZXIoc3RyKSArIHVuaXQ7XG4gICAgfVxufVxuZnVuY3Rpb24ga2ViYWJDYXNlKHN0cikge1xuICAgIHJldHVybiAoc3RyIHx8ICcnKS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09ICdvYmplY3QnO1xufVxuLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbnZhciBrZXlDb2RlcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGVudGVyOiAxMyxcbiAgICB0YWI6IDksXG4gICAgZGVsZXRlOiA0NixcbiAgICBlc2M6IDI3LFxuICAgIHNwYWNlOiAzMixcbiAgICB1cDogMzgsXG4gICAgZG93bjogNDAsXG4gICAgbGVmdDogMzcsXG4gICAgcmlnaHQ6IDM5LFxuICAgIGVuZDogMzUsXG4gICAgaG9tZTogMzYsXG4gICAgZGVsOiA0NixcbiAgICBiYWNrc3BhY2U6IDgsXG4gICAgaW5zZXJ0OiA0NSxcbiAgICBwYWdldXA6IDMzLFxuICAgIHBhZ2Vkb3duOiAzNFxufSk7XG52YXIgSUNPTlNfUFJFRklYID0gJyR2dWV0aWZ5Lmljb25zLic7XG4vLyBUaGlzIHJlbWFwcyBpbnRlcm5hbCBuYW1lcyBsaWtlICckdnVldGlmeS5pY29ucy5jYW5jZWwnIHRvIHRoZSBjdXJyZW50IG5hbWVcbi8vIGZvciB0aGF0IGljb24uXG5mdW5jdGlvbiByZW1hcEludGVybmFsSWNvbih2bSwgaWNvbk5hbWUpIHtcbiAgICBpZiAoIWljb25OYW1lLnN0YXJ0c1dpdGgoSUNPTlNfUFJFRklYKSkge1xuICAgICAgICByZXR1cm4gaWNvbk5hbWU7XG4gICAgfVxuICAgIC8vIE5vdyBsb29rIHVwIGljb24gaW5kaXJlY3Rpb24gbmFtZSwgZS5nLiAnJHZ1ZXRpZnkuaWNvbnMuY2FuY2VsJ1xuICAgIHJldHVybiBnZXRPYmplY3RWYWx1ZUJ5UGF0aCh2bSwgaWNvbk5hbWUsIGljb25OYW1lKTtcbn1cbmZ1bmN0aW9uIGtleXMobykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvKTtcbn1cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBmdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICB9KTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvbWFzay5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9tYXNrLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0RGVsaW1pdGVycywgaXNNYXNrRGVsaW1pdGVyLCBtYXNrVGV4dCwgdW5tYXNrVGV4dCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0RGVsaW1pdGVyc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZmF1bHREZWxpbWl0ZXJzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc01hc2tEZWxpbWl0ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc01hc2tEZWxpbWl0ZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1hc2tUZXh0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFza1RleHQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInVubWFza1RleHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB1bm1hc2tUZXh0OyB9KTtcbi8qKlxuICogRGVmYXVsdCBkZWxpbWl0ZXIgUmVnRXhwXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIGRlZmF1bHREZWxpbWl0ZXJzID0gL1stISQlXiYqKClfK3x+PWB7fVtcXF06XCI7Jzw+PywuL1xcXFwgXS87XG4vKipcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY2hhclxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc01hc2tEZWxpbWl0ZXIgPSBmdW5jdGlvbiBpc01hc2tEZWxpbWl0ZXIoY2hhcikge1xuICAgIHJldHVybiBjaGFyICYmIGRlZmF1bHREZWxpbWl0ZXJzLnRlc3QoY2hhcik7XG59O1xuLyoqXG4gKiBNYXNrIGtleXNcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgYWxsb3dlZE1hc2tzID0ge1xuICAgICcjJzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KGNoYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyLm1hdGNoKC9bMC05XS8pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAnQSc6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gdGVzdChjaGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhci5tYXRjaCgvW0EtWl0vaSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uIGNvbnZlcnQoY2hhcikge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgJ2EnOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIHRlc3QoY2hhcikge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXIubWF0Y2goL1thLXpdL2kpO1xuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbiBjb252ZXJ0KGNoYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgICdOJzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KGNoYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyLm1hdGNoKC9bMC05QS1aXS9pKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydDogZnVuY3Rpb24gY29udmVydChjaGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAnbic6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gdGVzdChjaGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhci5tYXRjaCgvWzAtOWEtel0vaSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uIGNvbnZlcnQoY2hhcikge1xuICAgICAgICAgICAgcmV0dXJuIGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgJ1gnOiB7XG4gICAgICAgIHRlc3Q6IGlzTWFza0RlbGltaXRlclxuICAgIH1cbn07XG4vKipcbiAqIElzIENoYXJhY3RlciBtYXNrXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBjaGFyXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzTWFzayA9IGZ1bmN0aW9uIGlzTWFzayhjaGFyKSB7XG4gICAgcmV0dXJuIGFsbG93ZWRNYXNrcy5oYXNPd25Qcm9wZXJ0eShjaGFyKTtcbn07XG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgY29udmVydCBjaGFyIGNhc2VcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1hc2tcbiAqIEBwYXJhbSAge1N0cmluZ30gY2hhclxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIGNvbnZlcnQgPSBmdW5jdGlvbiBjb252ZXJ0KG1hc2ssIGNoYXIpIHtcbiAgICByZXR1cm4gYWxsb3dlZE1hc2tzW21hc2tdLmNvbnZlcnQgPyBhbGxvd2VkTWFza3NbbWFza10uY29udmVydChjaGFyKSA6IGNoYXI7XG59O1xuLyoqXG4gKiBNYXNrIFZhbGlkYXRpb25cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1hc2tcbiAqIEBwYXJhbSAge1N0cmluZ30gY2hhclxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBtYXNrVmFsaWRhdGVzID0gZnVuY3Rpb24gbWFza1ZhbGlkYXRlcyhtYXNrLCBjaGFyKSB7XG4gICAgaWYgKGNoYXIgPT0gbnVsbCB8fCAhaXNNYXNrKG1hc2spKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGFsbG93ZWRNYXNrc1ttYXNrXS50ZXN0KGNoYXIpO1xufTtcbi8qKlxuICogTWFzayBUZXh0XG4gKlxuICogVGFrZXMgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgY2hhcmFjdGVyc1xuICogYW5kIHJldHVybnMgYSBtYXNrZWQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0XG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gbWFza2VkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtkb250RmlsbE1hc2tCbGFua3NdXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgbWFza1RleHQgPSBmdW5jdGlvbiBtYXNrVGV4dCh0ZXh0LCBtYXNrZWQsIGRvbnRGaWxsTWFza0JsYW5rcykge1xuICAgIGlmICh0ZXh0ID09IG51bGwpIHJldHVybiAnJztcbiAgICB0ZXh0ID0gU3RyaW5nKHRleHQpO1xuICAgIGlmICghbWFza2VkLmxlbmd0aCB8fCAhdGV4dC5sZW5ndGgpIHJldHVybiB0ZXh0O1xuICAgIGlmICghQXJyYXkuaXNBcnJheShtYXNrZWQpKSBtYXNrZWQgPSBtYXNrZWQuc3BsaXQoJycpO1xuICAgIHZhciB0ZXh0SW5kZXggPSAwO1xuICAgIHZhciBtYXNrSW5kZXggPSAwO1xuICAgIHZhciBuZXdUZXh0ID0gJyc7XG4gICAgd2hpbGUgKG1hc2tJbmRleCA8IG1hc2tlZC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG1hc2sgPSBtYXNrZWRbbWFza0luZGV4XTtcbiAgICAgICAgLy8gQXNzaWduIHRoZSBuZXh0IGNoYXJhY3RlclxuICAgICAgICB2YXIgY2hhciA9IHRleHRbdGV4dEluZGV4XTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbWFzayBpcyBkZWxpbWl0ZXJcbiAgICAgICAgLy8gYW5kIGN1cnJlbnQgY2hhciBtYXRjaGVzXG4gICAgICAgIGlmICghaXNNYXNrKG1hc2spICYmIGNoYXIgPT09IG1hc2spIHtcbiAgICAgICAgICAgIG5ld1RleHQgKz0gbWFzaztcbiAgICAgICAgICAgIHRleHRJbmRleCsrO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbm90IG1hc2tcbiAgICAgICAgfSBlbHNlIGlmICghaXNNYXNrKG1hc2spICYmICFkb250RmlsbE1hc2tCbGFua3MpIHtcbiAgICAgICAgICAgIG5ld1RleHQgKz0gbWFzaztcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGlzIG1hc2sgYW5kIHZhbGlkYXRlc1xuICAgICAgICB9IGVsc2UgaWYgKG1hc2tWYWxpZGF0ZXMobWFzaywgY2hhcikpIHtcbiAgICAgICAgICAgIG5ld1RleHQgKz0gY29udmVydChtYXNrLCBjaGFyKTtcbiAgICAgICAgICAgIHRleHRJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgbWFza0luZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiBuZXdUZXh0O1xufTtcbi8qKlxuICogVW5tYXNrIFRleHRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHVubWFza1RleHQgPSBmdW5jdGlvbiB1bm1hc2tUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGV4dCA/IFN0cmluZyh0ZXh0KS5yZXBsYWNlKG5ldyBSZWdFeHAoZGVmYXVsdERlbGltaXRlcnMsICdnJyksICcnKSA6IHRleHQ7XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL21peGlucy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL21peGlucy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBtaXhpbnM7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdnVlICovIFwidnVlXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4sIGltcG9ydC9leHBvcnQsIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5cbmZ1bmN0aW9uIG1peGlucygpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHZ1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5leHRlbmQoeyBtaXhpbnM6IGFyZ3MgfSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvcmVidWlsZEZ1bmN0aW9uYWxTbG90cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9yZWJ1aWxkRnVuY3Rpb25hbFNsb3RzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiByZWJ1aWxkRnVuY3Rpb25hbFNsb3RzOyB9KTtcbi8qKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzbG90c1xuICogQHBhcmFtIHtmdW5jdGlvbn0gaFxuICogQHJldHVybnMge2FycmF5fVxuICovXG5mdW5jdGlvbiByZWJ1aWxkRnVuY3Rpb25hbFNsb3RzKHNsb3RzLCBoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgZm9yICh2YXIgc2xvdCBpbiBzbG90cykge1xuICAgICAgICBpZiAoc2xvdHMuaGFzT3duUHJvcGVydHkoc2xvdCkpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goaCgndGVtcGxhdGUnLCB7IHNsb3Q6IHNsb3QgfSwgc2xvdHNbc2xvdF0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvdGhlbWUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL3RoZW1lLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcGFyc2UsIGdlblN0eWxlcywgZ2VuVmFyaWF0aW9ucyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJwYXJzZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhcnNlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZW5TdHlsZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZW5TdHlsZXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdlblZhcmlhdGlvbnNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZW5WYXJpYXRpb25zOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29sb3JVdGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb2xvclV0aWxzICovIFwiLi9zcmMvdXRpbC9jb2xvclV0aWxzLnRzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb2xvcl90cmFuc2Zvcm1TUkdCX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbG9yL3RyYW5zZm9ybVNSR0IgKi8gXCIuL3NyYy91dGlsL2NvbG9yL3RyYW5zZm9ybVNSR0IudHNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbG9yX3RyYW5zZm9ybUNJRUxBQl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb2xvci90cmFuc2Zvcm1DSUVMQUIgKi8gXCIuL3NyYy91dGlsL2NvbG9yL3RyYW5zZm9ybUNJRUxBQi50c1wiKTtcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9fcmVhZCA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19yZWFkIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksXG4gICAgICAgIHIsXG4gICAgICAgIGFyID0gW10sXG4gICAgICAgIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGFyLnB1c2goci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlID0geyBlcnJvcjogZXJyb3IgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZSkgdGhyb3cgZS5lcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuXG5cblxuZnVuY3Rpb24gcGFyc2UodGhlbWUsIGlzSXRlbSkge1xuICAgIGlmIChpc0l0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgICBpc0l0ZW0gPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNvbG9ycyA9IE9iamVjdC5rZXlzKHRoZW1lKTtcbiAgICB2YXIgcGFyc2VkVGhlbWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbmFtZSA9IGNvbG9yc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhlbWVbbmFtZV07XG4gICAgICAgIGlmIChpc0l0ZW0pIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnYmFzZScgfHwgbmFtZS5zdGFydHNXaXRoKCdsaWdodGVuJykgfHwgbmFtZS5zdGFydHNXaXRoKCdkYXJrZW4nKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZFRoZW1lW25hbWVdID0gT2JqZWN0KF9jb2xvclV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjb2xvclRvSGV4XCJdKSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHZhbHVlKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBwYXJzZWRUaGVtZVtuYW1lXSA9IHBhcnNlKHZhbHVlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZFRoZW1lW25hbWVdID0gZ2VuVmFyaWF0aW9ucyhuYW1lLCBPYmplY3QoX2NvbG9yVXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImNvbG9yVG9JbnRcIl0pKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZFRoZW1lO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgQ1NTIGZvciBhIGJhc2UgY29sb3IgKC5wcmltYXJ5KVxuICovXG52YXIgZ2VuQmFzZUNvbG9yID0gZnVuY3Rpb24gZ2VuQmFzZUNvbG9yKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFwiXFxuLlwiICsgbmFtZSArIFwiIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IFwiICsgdmFsdWUgKyBcIiAhaW1wb3J0YW50O1xcbiAgYm9yZGVyLWNvbG9yOiBcIiArIHZhbHVlICsgXCIgIWltcG9ydGFudDtcXG59XFxuLlwiICsgbmFtZSArIFwiLS10ZXh0IHtcXG4gIGNvbG9yOiBcIiArIHZhbHVlICsgXCIgIWltcG9ydGFudDtcXG4gIGNhcmV0LWNvbG9yOiBcIiArIHZhbHVlICsgXCIgIWltcG9ydGFudDtcXG59XCI7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgQ1NTIGZvciBhIHZhcmlhbnQgY29sb3IgKC5wcmltYXJ5LmRhcmtlbi0yKVxuICovXG52YXIgZ2VuVmFyaWFudENvbG9yID0gZnVuY3Rpb24gZ2VuVmFyaWFudENvbG9yKG5hbWUsIHZhcmlhbnQsIHZhbHVlKSB7XG4gICAgdmFyIF9hID0gX19yZWFkKHZhcmlhbnQuc3BsaXQoLyhcXGQpLywgMiksIDIpLFxuICAgICAgICB0eXBlID0gX2FbMF0sXG4gICAgICAgIG4gPSBfYVsxXTtcbiAgICByZXR1cm4gXCJcXG4uXCIgKyBuYW1lICsgXCIuXCIgKyB0eXBlICsgXCItXCIgKyBuICsgXCIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogXCIgKyB2YWx1ZSArIFwiICFpbXBvcnRhbnQ7XFxuICBib3JkZXItY29sb3I6IFwiICsgdmFsdWUgKyBcIiAhaW1wb3J0YW50O1xcbn1cXG4uXCIgKyBuYW1lICsgXCItLXRleHQudGV4dC0tXCIgKyB0eXBlICsgXCItXCIgKyBuICsgXCIge1xcbiAgY29sb3I6IFwiICsgdmFsdWUgKyBcIiAhaW1wb3J0YW50O1xcbiAgY2FyZXQtY29sb3I6IFwiICsgdmFsdWUgKyBcIiAhaW1wb3J0YW50O1xcbn1cIjtcbn07XG52YXIgZ2VuQ29sb3JWYXJpYWJsZU5hbWUgPSBmdW5jdGlvbiBnZW5Db2xvclZhcmlhYmxlTmFtZShuYW1lLCB2YXJpYW50KSB7XG4gICAgaWYgKHZhcmlhbnQgPT09IHZvaWQgMCkge1xuICAgICAgICB2YXJpYW50ID0gJ2Jhc2UnO1xuICAgIH1cbiAgICByZXR1cm4gXCItLXYtXCIgKyBuYW1lICsgXCItXCIgKyB2YXJpYW50O1xufTtcbnZhciBnZW5Db2xvclZhcmlhYmxlID0gZnVuY3Rpb24gZ2VuQ29sb3JWYXJpYWJsZShuYW1lLCB2YXJpYW50KSB7XG4gICAgaWYgKHZhcmlhbnQgPT09IHZvaWQgMCkge1xuICAgICAgICB2YXJpYW50ID0gJ2Jhc2UnO1xuICAgIH1cbiAgICByZXR1cm4gXCJ2YXIoXCIgKyBnZW5Db2xvclZhcmlhYmxlTmFtZShuYW1lLCB2YXJpYW50KSArIFwiKVwiO1xufTtcbmZ1bmN0aW9uIGdlblN0eWxlcyh0aGVtZSwgY3NzVmFyKSB7XG4gICAgaWYgKGNzc1ZhciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNzc1ZhciA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY29sb3JzID0gT2JqZWN0LmtleXModGhlbWUpO1xuICAgIGlmICghY29sb3JzLmxlbmd0aCkgcmV0dXJuICcnO1xuICAgIHZhciB2YXJpYWJsZXNDc3MgPSAnJztcbiAgICB2YXIgY3NzID0gJyc7XG4gICAgdmFyIGFDb2xvciA9IGNzc1ZhciA/IGdlbkNvbG9yVmFyaWFibGUoJ3ByaW1hcnknKSA6IHRoZW1lLnByaW1hcnkuYmFzZTtcbiAgICBjc3MgKz0gXCJhIHsgY29sb3I6IFwiICsgYUNvbG9yICsgXCI7IH1cIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbmFtZSA9IGNvbG9yc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhlbWVbbmFtZV07XG4gICAgICAgIGlmICgodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodmFsdWUpKSAhPT0gJ29iamVjdCcpIGNvbnRpbnVlO1xuICAgICAgICBjc3MgKz0gZ2VuQmFzZUNvbG9yKG5hbWUsIGNzc1ZhciA/IGdlbkNvbG9yVmFyaWFibGUobmFtZSkgOiB2YWx1ZS5iYXNlKTtcbiAgICAgICAgY3NzVmFyICYmICh2YXJpYWJsZXNDc3MgKz0gXCIgIFwiICsgZ2VuQ29sb3JWYXJpYWJsZU5hbWUobmFtZSkgKyBcIjogXCIgKyB2YWx1ZS5iYXNlICsgXCI7XFxuXCIpO1xuICAgICAgICB2YXIgdmFyaWFudHMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IHZhcmlhbnRzLmxlbmd0aDsgKytpXzEpIHtcbiAgICAgICAgICAgIHZhciB2YXJpYW50ID0gdmFyaWFudHNbaV8xXTtcbiAgICAgICAgICAgIHZhciB2YXJpYW50VmFsdWUgPSB2YWx1ZVt2YXJpYW50XTtcbiAgICAgICAgICAgIGlmICh2YXJpYW50ID09PSAnYmFzZScpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY3NzICs9IGdlblZhcmlhbnRDb2xvcihuYW1lLCB2YXJpYW50LCBjc3NWYXIgPyBnZW5Db2xvclZhcmlhYmxlKG5hbWUsIHZhcmlhbnQpIDogdmFyaWFudFZhbHVlKTtcbiAgICAgICAgICAgIGNzc1ZhciAmJiAodmFyaWFibGVzQ3NzICs9IFwiICBcIiArIGdlbkNvbG9yVmFyaWFibGVOYW1lKG5hbWUsIHZhcmlhbnQpICsgXCI6IFwiICsgdmFyaWFudFZhbHVlICsgXCI7XFxuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjc3NWYXIpIHtcbiAgICAgICAgdmFyaWFibGVzQ3NzID0gXCI6cm9vdCB7XFxuXCIgKyB2YXJpYWJsZXNDc3MgKyBcIn1cXG5cXG5cIjtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhYmxlc0NzcyArIGNzcztcbn1cbmZ1bmN0aW9uIGdlblZhcmlhdGlvbnMobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgdmFsdWVzID0ge1xuICAgICAgICBiYXNlOiBPYmplY3QoX2NvbG9yVXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImludFRvSGV4XCJdKSh2YWx1ZSlcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSA1OyBpID4gMDsgLS1pKSB7XG4gICAgICAgIHZhbHVlc1tcImxpZ2h0ZW5cIiArIGldID0gT2JqZWN0KF9jb2xvclV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJpbnRUb0hleFwiXSkobGlnaHRlbih2YWx1ZSwgaSkpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSA0OyArK2kpIHtcbiAgICAgICAgdmFsdWVzW1wiZGFya2VuXCIgKyBpXSA9IE9iamVjdChfY29sb3JVdGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiaW50VG9IZXhcIl0pKGRhcmtlbih2YWx1ZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gbGlnaHRlbih2YWx1ZSwgYW1vdW50KSB7XG4gICAgdmFyIGxhYiA9IF9jb2xvcl90cmFuc2Zvcm1DSUVMQUJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImZyb21YWVpcIl0oX2NvbG9yX3RyYW5zZm9ybVNSR0JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInRvWFlaXCJdKHZhbHVlKSk7XG4gICAgbGFiWzBdID0gbGFiWzBdICsgYW1vdW50ICogMTA7XG4gICAgcmV0dXJuIF9jb2xvcl90cmFuc2Zvcm1TUkdCX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJmcm9tWFlaXCJdKF9jb2xvcl90cmFuc2Zvcm1DSUVMQUJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInRvWFlaXCJdKGxhYikpO1xufVxuZnVuY3Rpb24gZGFya2VuKHZhbHVlLCBhbW91bnQpIHtcbiAgICB2YXIgbGFiID0gX2NvbG9yX3RyYW5zZm9ybUNJRUxBQl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZnJvbVhZWlwiXShfY29sb3JfdHJhbnNmb3JtU1JHQl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1widG9YWVpcIl0odmFsdWUpKTtcbiAgICBsYWJbMF0gPSBsYWJbMF0gLSBhbW91bnQgKiAxMDtcbiAgICByZXR1cm4gX2NvbG9yX3RyYW5zZm9ybVNSR0JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImZyb21YWVpcIl0oX2NvbG9yX3RyYW5zZm9ybUNJRUxBQl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1widG9YWVpcIl0obGFiKSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcInZ1ZVwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJ2dWVcIixcImNvbW1vbmpzMlwiOlwidnVlXCIsXCJhbWRcIjpcInZ1ZVwiLFwicm9vdFwiOlwiVnVlXCJ9ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3Z1ZV9fO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KVtcImRlZmF1bHRcIl07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZ1ZXRpZnkuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function("return this")() || (1, eval)("this");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||\n            (typeof self !== "undefined" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(6);\n// On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||\n                       (typeof global !== "undefined" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||\n                         (typeof global !== "undefined" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLENBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4), __webpack_require__(7)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n')},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(9);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = __webpack_require__(12).default\nvar update = add(\"3ec25810\", content, false, {});\n// Hot Module Replacement\nif(false) {}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NYWluLnZ1ZT9jYTViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLENBQStUO0FBQ3JWLDRDQUE0QyxRQUFTO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsRUFBNkQ7QUFDL0UsK0NBQStDO0FBQy9DO0FBQ0EsR0FBRyxLQUFVLEVBQUUiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi01NGQzYTUyZVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL01haW4udnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciBhZGQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikuZGVmYXVsdFxudmFyIHVwZGF0ZSA9IGFkZChcIjNlYzI1ODEwXCIsIGNvbnRlbnQsIGZhbHNlLCB7fSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJvcHRpb25zSWRcXFwiOlxcXCIwXFxcIixcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi01NGQzYTUyZVxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwic291cmNlTWFwXFxcIjp0cnVlfSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL01haW4udnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTU0ZDNhNTJlXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJzb3VyY2VNYXBcXFwiOnRydWV9IS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vTWFpbi52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(10)(false);\n// imports\n\n\n// module\nexports.push([module.i, "", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NYWluLnZ1ZT9iMzVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLEVBQStDO0FBQ2xGOzs7QUFHQTtBQUNBLGNBQWMsUUFBUzs7QUFFdkIiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n')},function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn "@media " + item[2] + "{" + content + "}";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join("");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === "string")\n\t\t\tmodules = [[null, modules, ""]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === "number")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || \'\';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === \'function\') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn \'/*# sourceURL=\' + cssMapping.sourceRoot + source + \' */\'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n\t}\n\n\treturn [content].join(\'\\n\');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = \'sourceMappingURL=data:application/json;charset=utf-8;base64,\' + base64;\n\n\treturn \'/*# \' + data + \' */\';\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.esm.js\nvar vue_esm = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/vuex/dist/vuex.esm.js\n/**\n * vuex v3.0.1\n * (c) 2017 Evan You\n * @license MIT\n */\nvar applyMixin = function (Vue) {\n  var version = Number(Vue.version.split('.')[0]);\n\n  if (version >= 2) {\n    Vue.mixin({ beforeCreate: vuexInit });\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    var _init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      if ( options === void 0 ) options = {};\n\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit;\n      _init.call(this, options);\n    };\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    var options = this.$options;\n    // store injection\n    if (options.store) {\n      this.$store = typeof options.store === 'function'\n        ? options.store()\n        : options.store;\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store;\n    }\n  }\n};\n\nvar devtoolHook =\n  typeof window !== 'undefined' &&\n  window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\nfunction devtoolPlugin (store) {\n  if (!devtoolHook) { return }\n\n  store._devtoolHook = devtoolHook;\n\n  devtoolHook.emit('vuex:init', store);\n\n  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n    store.replaceState(targetState);\n  });\n\n  store.subscribe(function (mutation, state) {\n    devtoolHook.emit('vuex:mutation', mutation, state);\n  });\n}\n\n/**\n * Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}\n */\n/**\n * Deep copy the given object considering circular structure.\n * This function caches all nested objects and its copies.\n * If it detects circular structure, use cached copy to avoid infinite loop.\n *\n * @param {*} obj\n * @param {Array<Object>} cache\n * @return {*}\n */\n\n\n/**\n * forEach for object\n */\nfunction forEachValue (obj, fn) {\n  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });\n}\n\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nfunction isPromise (val) {\n  return val && typeof val.then === 'function'\n}\n\nfunction assert (condition, msg) {\n  if (!condition) { throw new Error((\"[vuex] \" + msg)) }\n}\n\nvar Module = function Module (rawModule, runtime) {\n  this.runtime = runtime;\n  this._children = Object.create(null);\n  this._rawModule = rawModule;\n  var rawState = rawModule.state;\n  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};\n};\n\nvar prototypeAccessors$1 = { namespaced: { configurable: true } };\n\nprototypeAccessors$1.namespaced.get = function () {\n  return !!this._rawModule.namespaced\n};\n\nModule.prototype.addChild = function addChild (key, module) {\n  this._children[key] = module;\n};\n\nModule.prototype.removeChild = function removeChild (key) {\n  delete this._children[key];\n};\n\nModule.prototype.getChild = function getChild (key) {\n  return this._children[key]\n};\n\nModule.prototype.update = function update (rawModule) {\n  this._rawModule.namespaced = rawModule.namespaced;\n  if (rawModule.actions) {\n    this._rawModule.actions = rawModule.actions;\n  }\n  if (rawModule.mutations) {\n    this._rawModule.mutations = rawModule.mutations;\n  }\n  if (rawModule.getters) {\n    this._rawModule.getters = rawModule.getters;\n  }\n};\n\nModule.prototype.forEachChild = function forEachChild (fn) {\n  forEachValue(this._children, fn);\n};\n\nModule.prototype.forEachGetter = function forEachGetter (fn) {\n  if (this._rawModule.getters) {\n    forEachValue(this._rawModule.getters, fn);\n  }\n};\n\nModule.prototype.forEachAction = function forEachAction (fn) {\n  if (this._rawModule.actions) {\n    forEachValue(this._rawModule.actions, fn);\n  }\n};\n\nModule.prototype.forEachMutation = function forEachMutation (fn) {\n  if (this._rawModule.mutations) {\n    forEachValue(this._rawModule.mutations, fn);\n  }\n};\n\nObject.defineProperties( Module.prototype, prototypeAccessors$1 );\n\nvar ModuleCollection = function ModuleCollection (rawRootModule) {\n  // register root module (Vuex.Store options)\n  this.register([], rawRootModule, false);\n};\n\nModuleCollection.prototype.get = function get (path) {\n  return path.reduce(function (module, key) {\n    return module.getChild(key)\n  }, this.root)\n};\n\nModuleCollection.prototype.getNamespace = function getNamespace (path) {\n  var module = this.root;\n  return path.reduce(function (namespace, key) {\n    module = module.getChild(key);\n    return namespace + (module.namespaced ? key + '/' : '')\n  }, '')\n};\n\nModuleCollection.prototype.update = function update$1 (rawRootModule) {\n  update([], this.root, rawRootModule);\n};\n\nModuleCollection.prototype.register = function register (path, rawModule, runtime) {\n    var this$1 = this;\n    if ( runtime === void 0 ) runtime = true;\n\n  if (false) {}\n\n  var newModule = new Module(rawModule, runtime);\n  if (path.length === 0) {\n    this.root = newModule;\n  } else {\n    var parent = this.get(path.slice(0, -1));\n    parent.addChild(path[path.length - 1], newModule);\n  }\n\n  // register nested modules\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, function (rawChildModule, key) {\n      this$1.register(path.concat(key), rawChildModule, runtime);\n    });\n  }\n};\n\nModuleCollection.prototype.unregister = function unregister (path) {\n  var parent = this.get(path.slice(0, -1));\n  var key = path[path.length - 1];\n  if (!parent.getChild(key).runtime) { return }\n\n  parent.removeChild(key);\n};\n\nfunction update (path, targetModule, newModule) {\n  if (false) {}\n\n  // update target module\n  targetModule.update(newModule);\n\n  // update nested modules\n  if (newModule.modules) {\n    for (var key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        if (false) {}\n        return\n      }\n      update(\n        path.concat(key),\n        targetModule.getChild(key),\n        newModule.modules[key]\n      );\n    }\n  }\n}\n\nvar functionAssert = {\n  assert: function (value) { return typeof value === 'function'; },\n  expected: 'function'\n};\n\nvar objectAssert = {\n  assert: function (value) { return typeof value === 'function' ||\n    (typeof value === 'object' && typeof value.handler === 'function'); },\n  expected: 'function or object with \"handler\" function'\n};\n\nvar assertTypes = {\n  getters: functionAssert,\n  mutations: functionAssert,\n  actions: objectAssert\n};\n\nfunction assertRawModule (path, rawModule) {\n  Object.keys(assertTypes).forEach(function (key) {\n    if (!rawModule[key]) { return }\n\n    var assertOptions = assertTypes[key];\n\n    forEachValue(rawModule[key], function (value, type) {\n      assert(\n        assertOptions.assert(value),\n        makeAssertionMessage(path, key, type, value, assertOptions.expected)\n      );\n    });\n  });\n}\n\nfunction makeAssertionMessage (path, key, type, value, expected) {\n  var buf = key + \" should be \" + expected + \" but \\\"\" + key + \".\" + type + \"\\\"\";\n  if (path.length > 0) {\n    buf += \" in module \\\"\" + (path.join('.')) + \"\\\"\";\n  }\n  buf += \" is \" + (JSON.stringify(value)) + \".\";\n  return buf\n}\n\nvar Vue; // bind on install\n\nvar Store = function Store (options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  // Auto install if it is not done yet and `window` has `Vue`.\n  // To allow users to avoid auto-installation in some cases,\n  // this code should be placed here. See #731\n  if (!Vue && typeof window !== 'undefined' && window.Vue) {\n    install(window.Vue);\n  }\n\n  if (false) {}\n\n  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n  var strict = options.strict; if ( strict === void 0 ) strict = false;\n\n  var state = options.state; if ( state === void 0 ) state = {};\n  if (typeof state === 'function') {\n    state = state() || {};\n  }\n\n  // store internal state\n  this._committing = false;\n  this._actions = Object.create(null);\n  this._actionSubscribers = [];\n  this._mutations = Object.create(null);\n  this._wrappedGetters = Object.create(null);\n  this._modules = new ModuleCollection(options);\n  this._modulesNamespaceMap = Object.create(null);\n  this._subscribers = [];\n  this._watcherVM = new Vue();\n\n  // bind commit and dispatch to self\n  var store = this;\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n  this.dispatch = function boundDispatch (type, payload) {\n    return dispatch.call(store, type, payload)\n  };\n  this.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n  };\n\n  // strict mode\n  this.strict = strict;\n\n  // init root module.\n  // this also recursively registers all sub-modules\n  // and collects all module getters inside this._wrappedGetters\n  installModule(this, state, [], this._modules.root);\n\n  // initialize the store vm, which is responsible for the reactivity\n  // (also registers _wrappedGetters as computed properties)\n  resetStoreVM(this, state);\n\n  // apply plugins\n  plugins.forEach(function (plugin) { return plugin(this$1); });\n\n  if (Vue.config.devtools) {\n    devtoolPlugin(this);\n  }\n};\n\nvar prototypeAccessors = { state: { configurable: true } };\n\nprototypeAccessors.state.get = function () {\n  return this._vm._data.$$state\n};\n\nprototypeAccessors.state.set = function (v) {\n  if (false) {}\n};\n\nStore.prototype.commit = function commit (_type, _payload, _options) {\n    var this$1 = this;\n\n  // check object-style commit\n  var ref = unifyObjectStyle(_type, _payload, _options);\n    var type = ref.type;\n    var payload = ref.payload;\n    var options = ref.options;\n\n  var mutation = { type: type, payload: payload };\n  var entry = this._mutations[type];\n  if (!entry) {\n    if (false) {}\n    return\n  }\n  this._withCommit(function () {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload);\n    });\n  });\n  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });\n\n  if (\n    false\n  ) {}\n};\n\nStore.prototype.dispatch = function dispatch (_type, _payload) {\n    var this$1 = this;\n\n  // check object-style dispatch\n  var ref = unifyObjectStyle(_type, _payload);\n    var type = ref.type;\n    var payload = ref.payload;\n\n  var action = { type: type, payload: payload };\n  var entry = this._actions[type];\n  if (!entry) {\n    if (false) {}\n    return\n  }\n\n  this._actionSubscribers.forEach(function (sub) { return sub(action, this$1.state); });\n\n  return entry.length > 1\n    ? Promise.all(entry.map(function (handler) { return handler(payload); }))\n    : entry[0](payload)\n};\n\nStore.prototype.subscribe = function subscribe (fn) {\n  return genericSubscribe(fn, this._subscribers)\n};\n\nStore.prototype.subscribeAction = function subscribeAction (fn) {\n  return genericSubscribe(fn, this._actionSubscribers)\n};\n\nStore.prototype.watch = function watch (getter, cb, options) {\n    var this$1 = this;\n\n  if (false) {}\n  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)\n};\n\nStore.prototype.replaceState = function replaceState (state) {\n    var this$1 = this;\n\n  this._withCommit(function () {\n    this$1._vm._data.$$state = state;\n  });\n};\n\nStore.prototype.registerModule = function registerModule (path, rawModule, options) {\n    if ( options === void 0 ) options = {};\n\n  if (typeof path === 'string') { path = [path]; }\n\n  if (false) {}\n\n  this._modules.register(path, rawModule);\n  installModule(this, this.state, path, this._modules.get(path), options.preserveState);\n  // reset store to update getters...\n  resetStoreVM(this, this.state);\n};\n\nStore.prototype.unregisterModule = function unregisterModule (path) {\n    var this$1 = this;\n\n  if (typeof path === 'string') { path = [path]; }\n\n  if (false) {}\n\n  this._modules.unregister(path);\n  this._withCommit(function () {\n    var parentState = getNestedState(this$1.state, path.slice(0, -1));\n    Vue.delete(parentState, path[path.length - 1]);\n  });\n  resetStore(this);\n};\n\nStore.prototype.hotUpdate = function hotUpdate (newOptions) {\n  this._modules.update(newOptions);\n  resetStore(this, true);\n};\n\nStore.prototype._withCommit = function _withCommit (fn) {\n  var committing = this._committing;\n  this._committing = true;\n  fn();\n  this._committing = committing;\n};\n\nObject.defineProperties( Store.prototype, prototypeAccessors );\n\nfunction genericSubscribe (fn, subs) {\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn);\n  }\n  return function () {\n    var i = subs.indexOf(fn);\n    if (i > -1) {\n      subs.splice(i, 1);\n    }\n  }\n}\n\nfunction resetStore (store, hot) {\n  store._actions = Object.create(null);\n  store._mutations = Object.create(null);\n  store._wrappedGetters = Object.create(null);\n  store._modulesNamespaceMap = Object.create(null);\n  var state = store.state;\n  // init all modules\n  installModule(store, state, [], store._modules.root, true);\n  // reset vm\n  resetStoreVM(store, state, hot);\n}\n\nfunction resetStoreVM (store, state, hot) {\n  var oldVm = store._vm;\n\n  // bind store public getters\n  store.getters = {};\n  var wrappedGetters = store._wrappedGetters;\n  var computed = {};\n  forEachValue(wrappedGetters, function (fn, key) {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = function () { return fn(store); };\n    Object.defineProperty(store.getters, key, {\n      get: function () { return store._vm[key]; },\n      enumerable: true // for local getters\n    });\n  });\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  var silent = Vue.config.silent;\n  Vue.config.silent = true;\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed: computed\n  });\n  Vue.config.silent = silent;\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store);\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(function () {\n        oldVm._data.$$state = null;\n      });\n    }\n    Vue.nextTick(function () { return oldVm.$destroy(); });\n  }\n}\n\nfunction installModule (store, rootState, path, module, hot) {\n  var isRoot = !path.length;\n  var namespace = store._modules.getNamespace(path);\n\n  // register in namespace map\n  if (module.namespaced) {\n    store._modulesNamespaceMap[namespace] = module;\n  }\n\n  // set state\n  if (!isRoot && !hot) {\n    var parentState = getNestedState(rootState, path.slice(0, -1));\n    var moduleName = path[path.length - 1];\n    store._withCommit(function () {\n      Vue.set(parentState, moduleName, module.state);\n    });\n  }\n\n  var local = module.context = makeLocalContext(store, namespace, path);\n\n  module.forEachMutation(function (mutation, key) {\n    var namespacedType = namespace + key;\n    registerMutation(store, namespacedType, mutation, local);\n  });\n\n  module.forEachAction(function (action, key) {\n    var type = action.root ? key : namespace + key;\n    var handler = action.handler || action;\n    registerAction(store, type, handler, local);\n  });\n\n  module.forEachGetter(function (getter, key) {\n    var namespacedType = namespace + key;\n    registerGetter(store, namespacedType, getter, local);\n  });\n\n  module.forEachChild(function (child, key) {\n    installModule(store, rootState, path.concat(key), child, hot);\n  });\n}\n\n/**\n * make localized dispatch, commit, getters and state\n * if there is no namespace, just use root ones\n */\nfunction makeLocalContext (store, namespace, path) {\n  var noNamespace = namespace === '';\n\n  var local = {\n    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (false) {}\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (false) {}\n      }\n\n      store.commit(type, payload, options);\n    }\n  };\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace\n        ? function () { return store.getters; }\n        : function () { return makeLocalGetters(store, namespace); }\n    },\n    state: {\n      get: function () { return getNestedState(store.state, path); }\n    }\n  });\n\n  return local\n}\n\nfunction makeLocalGetters (store, namespace) {\n  var gettersProxy = {};\n\n  var splitPos = namespace.length;\n  Object.keys(store.getters).forEach(function (type) {\n    // skip if the target getter is not match this namespace\n    if (type.slice(0, splitPos) !== namespace) { return }\n\n    // extract local getter type\n    var localType = type.slice(splitPos);\n\n    // Add a port to the getters proxy.\n    // Define as getter property because\n    // we do not want to evaluate the getters in this time.\n    Object.defineProperty(gettersProxy, localType, {\n      get: function () { return store.getters[type]; },\n      enumerable: true\n    });\n  });\n\n  return gettersProxy\n}\n\nfunction registerMutation (store, type, handler, local) {\n  var entry = store._mutations[type] || (store._mutations[type] = []);\n  entry.push(function wrappedMutationHandler (payload) {\n    handler.call(store, local.state, payload);\n  });\n}\n\nfunction registerAction (store, type, handler, local) {\n  var entry = store._actions[type] || (store._actions[type] = []);\n  entry.push(function wrappedActionHandler (payload, cb) {\n    var res = handler.call(store, {\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb);\n    if (!isPromise(res)) {\n      res = Promise.resolve(res);\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit('vuex:error', err);\n        throw err\n      })\n    } else {\n      return res\n    }\n  });\n}\n\nfunction registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    if (false) {}\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    return rawGetter(\n      local.state, // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  };\n}\n\nfunction enableStrictMode (store) {\n  store._vm.$watch(function () { return this._data.$$state }, function () {\n    if (false) {}\n  }, { deep: true, sync: true });\n}\n\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce(function (state, key) { return state[key]; }, state)\n    : state\n}\n\nfunction unifyObjectStyle (type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload;\n    payload = type;\n    type = type.type;\n  }\n\n  if (false) {}\n\n  return { type: type, payload: payload, options: options }\n}\n\nfunction install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    if (false) {}\n    return\n  }\n  Vue = _Vue;\n  applyMixin(Vue);\n}\n\nvar mapState = normalizeNamespace(function (namespace, states) {\n  var res = {};\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedState () {\n      var state = this.$store.state;\n      var getters = this.$store.getters;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapState', namespace);\n        if (!module) {\n          return\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      return typeof val === 'function'\n        ? val.call(this, state, getters)\n        : state[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\nvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n  var res = {};\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedMutation () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      var commit = this.$store.commit;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);\n        if (!module) {\n          return\n        }\n        commit = module.context.commit;\n      }\n      return typeof val === 'function'\n        ? val.apply(this, [commit].concat(args))\n        : commit.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\nvar mapGetters = normalizeNamespace(function (namespace, getters) {\n  var res = {};\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedGetter () {\n      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {\n        return\n      }\n      if (false) {}\n      return this.$store.getters[val]\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res\n});\n\nvar mapActions = normalizeNamespace(function (namespace, actions) {\n  var res = {};\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedAction () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      var dispatch = this.$store.dispatch;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);\n        if (!module) {\n          return\n        }\n        dispatch = module.context.dispatch;\n      }\n      return typeof val === 'function'\n        ? val.apply(this, [dispatch].concat(args))\n        : dispatch.apply(this.$store, [val].concat(args))\n    };\n  });\n  return res\n});\n\nvar createNamespacedHelpers = function (namespace) { return ({\n  mapState: mapState.bind(null, namespace),\n  mapGetters: mapGetters.bind(null, namespace),\n  mapMutations: mapMutations.bind(null, namespace),\n  mapActions: mapActions.bind(null, namespace)\n}); };\n\nfunction normalizeMap (map) {\n  return Array.isArray(map)\n    ? map.map(function (key) { return ({ key: key, val: key }); })\n    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })\n}\n\nfunction normalizeNamespace (fn) {\n  return function (namespace, map) {\n    if (typeof namespace !== 'string') {\n      map = namespace;\n      namespace = '';\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/';\n    }\n    return fn(namespace, map)\n  }\n}\n\nfunction getModuleByNamespace (store, helper, namespace) {\n  var module = store._modulesNamespaceMap[namespace];\n  if (false) {}\n  return module\n}\n\nvar index_esm = {\n  Store: Store,\n  install: install,\n  version: '3.0.1',\n  mapState: mapState,\n  mapMutations: mapMutations,\n  mapGetters: mapGetters,\n  mapActions: mapActions,\n  createNamespacedHelpers: createNamespacedHelpers\n};\n\n\n/* harmony default export */ var vuex_esm = (index_esm);\n\n// CONCATENATED MODULE: ./node_modules/vue-router/dist/vue-router.esm.js\n/**\n  * vue-router v3.0.1\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction vue_router_esm_assert (condition, message) {\n  if (!condition) {\n    throw new Error((\"[vue-router] \" + message))\n  }\n}\n\nfunction warn (condition, message) {\n  if (false) {}\n}\n\nfunction isError (err) {\n  return Object.prototype.toString.call(err).indexOf('Error') > -1\n}\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render (_, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true;\n\n    // directly use parent context's createElement() function\n    // so that components rendered by router-view can resolve named slots\n    var h = parent.$createElement;\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent && parent._routerRoot !== parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      if (parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children)\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h()\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // attach instance registration hook\n    // this will be called in the instance's injected lifecycle hooks\n    data.registerRouteInstance = function (vm, val) {\n      // val could be undefined for unregistration\n      var current = matched.instances[name];\n      if (\n        (val && current !== vm) ||\n        (!val && current === vm)\n      ) {\n        matched.instances[name] = val;\n      }\n    }\n\n    // also register instance in prepatch hook\n    // in case the same component instance is reused across different routes\n    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n      matched.instances[name] = vnode.componentInstance;\n    };\n\n    // resolve props\n    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);\n    if (propsToPass) {\n      // clone to prevent mutation\n      propsToPass = data.props = extend({}, propsToPass);\n      // pass non-declared props as attrs\n      var attrs = data.attrs = data.attrs || {};\n      for (var key in propsToPass) {\n        if (!component.props || !(key in component.props)) {\n          attrs[key] = propsToPass[key];\n          delete propsToPass[key];\n        }\n      }\n    }\n\n    return h(component, data, children)\n  }\n};\n\nfunction resolveProps (route, config) {\n  switch (typeof config) {\n    case 'undefined':\n      return\n    case 'object':\n      return config\n    case 'function':\n      return config(route)\n    case 'boolean':\n      return config ? route.params : undefined\n    default:\n      if (false) {}\n  }\n}\n\nfunction extend (to, from) {\n  for (var key in from) {\n    to[key] = from[key];\n  }\n  return to\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function (str) { return encodeURIComponent(str)\n  .replace(encodeReserveRE, encodeReserveReplacer)\n  .replace(commaRE, ','); };\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery (\n  query,\n  extraQuery,\n  _parseQuery\n) {\n  if ( extraQuery === void 0 ) extraQuery = {};\n\n  var parse = _parseQuery || parseQuery;\n  var parsedQuery;\n  try {\n    parsedQuery = parse(query || '');\n  } catch (e) {\n     false && false;\n    parsedQuery = {};\n  }\n  for (var key in extraQuery) {\n    parsedQuery[key] = extraQuery[key];\n  }\n  return parsedQuery\n}\n\nfunction parseQuery (query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0\n      ? decode(parts.join('='))\n      : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res\n}\n\nfunction stringifyQuery (obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return ''\n    }\n\n    if (val === null) {\n      return encode(key)\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.forEach(function (val2) {\n        if (val2 === undefined) {\n          return\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&')\n    }\n\n    return encode(key) + '=' + encode(val)\n  }).filter(function (x) { return x.length > 0; }).join('&') : null;\n  return res ? (\"?\" + res) : ''\n}\n\n/*  */\n\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute (\n  record,\n  location,\n  redirectedFrom,\n  router\n) {\n  var stringifyQuery$$1 = router && router.options.stringifyQuery;\n\n  var query = location.query || {};\n  try {\n    query = clone(query);\n  } catch (e) {}\n\n  var route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery$$1),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\n  }\n  return Object.freeze(route)\n}\n\nfunction clone (value) {\n  if (Array.isArray(value)) {\n    return value.map(clone)\n  } else if (value && typeof value === 'object') {\n    var res = {};\n    for (var key in value) {\n      res[key] = clone(value[key]);\n    }\n    return res\n  } else {\n    return value\n  }\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch (record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res\n}\n\nfunction getFullPath (\n  ref,\n  _stringifyQuery\n) {\n  var path = ref.path;\n  var query = ref.query; if ( query === void 0 ) query = {};\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n  var stringify = _stringifyQuery || stringifyQuery;\n  return (path || '/') + stringify(query) + hash\n}\n\nfunction isSameRoute (a, b) {\n  if (b === START) {\n    return a === b\n  } else if (!b) {\n    return false\n  } else if (a.path && b.path) {\n    return (\n      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query)\n    )\n  } else if (a.name && b.name) {\n    return (\n      a.name === b.name &&\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query) &&\n      isObjectEqual(a.params, b.params)\n    )\n  } else {\n    return false\n  }\n}\n\nfunction isObjectEqual (a, b) {\n  if ( a === void 0 ) a = {};\n  if ( b === void 0 ) b = {};\n\n  // handle null value #1566\n  if (!a || !b) { return a === b }\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false\n  }\n  return aKeys.every(function (key) {\n    var aVal = a[key];\n    var bVal = b[key];\n    // check nested equality\n    if (typeof aVal === 'object' && typeof bVal === 'object') {\n      return isObjectEqual(aVal, bVal)\n    }\n    return String(aVal) === String(bVal)\n  })\n}\n\nfunction isIncludedRoute (current, target) {\n  return (\n    current.path.replace(trailingSlashRE, '/').indexOf(\n      target.path.replace(trailingSlashRE, '/')\n    ) === 0 &&\n    (!target.hash || current.hash === target.hash) &&\n    queryIncludes(current.query, target.query)\n  )\n}\n\nfunction queryIncludes (current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false\n    }\n  }\n  return true\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n\n    var classes = {};\n    var globalActiveClass = router.options.linkActiveClass;\n    var globalExactActiveClass = router.options.linkExactActiveClass;\n    // Support global empty active class\n    var activeClassFallback = globalActiveClass == null\n            ? 'router-link-active'\n            : globalActiveClass;\n    var exactActiveClassFallback = globalExactActiveClass == null\n            ? 'router-link-exact-active'\n            : globalExactActiveClass;\n    var activeClass = this.activeClass == null\n            ? activeClassFallback\n            : this.activeClass;\n    var exactActiveClass = this.exactActiveClass == null\n            ? exactActiveClassFallback\n            : this.exactActiveClass;\n    var compareTarget = location.path\n      ? createRoute(null, location, null, router)\n      : route;\n\n    classes[exactActiveClass] = isSameRoute(current, compareTarget);\n    classes[activeClass] = this.exact\n      ? classes[exactActiveClass]\n      : isIncludedRoute(current, compareTarget);\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) { on[e] = handler; });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var extend = _Vue.util.extend;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default)\n  }\n};\n\nfunction guardEvent (e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) { return }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) { return }\n  // don't redirect if `target=\"_blank\"`\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    var target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) { return }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true\n}\n\nfunction findAnchor (children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction vue_router_esm_install (Vue) {\n  if (vue_router_esm_install.installed && _Vue === Vue) { return }\n  vue_router_esm_install.installed = true;\n\n  _Vue = Vue;\n\n  var isDef = function (v) { return v !== undefined; };\n\n  var registerInstance = function (vm, callVal) {\n    var i = vm.$options._parentVnode;\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal);\n    }\n  };\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate () {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this;\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      } else {\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;\n      }\n      registerInstance(this, this);\n    },\n    destroyed: function destroyed () {\n      registerInstance(this);\n    }\n  });\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get () { return this._routerRoot._router }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get () { return this._routerRoot._route }\n  });\n\n  Vue.component('router-view', View);\n  Vue.component('router-link', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath (\n  relative,\n  base,\n  append\n) {\n  var firstChar = relative.charAt(0);\n  if (firstChar === '/') {\n    return relative\n  }\n\n  if (firstChar === '?' || firstChar === '#') {\n    return base + relative\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '..') {\n      stack.pop();\n    } else if (segment !== '.') {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/')\n}\n\nfunction parsePath (path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction cleanPath (path) {\n  return path.replace(/\\/\\//g, '/')\n}\n\nvar isarray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar pathToRegexp_1 = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\npathToRegexp_1.parse = parse_1;\npathToRegexp_1.compile = compile_1;\npathToRegexp_1.tokensToFunction = tokensToFunction_1;\npathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\n// $flow-disable-line\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams (\n  path,\n  params,\n  routeMsg\n) {\n  try {\n    var filler =\n      regexpCompileCache[path] ||\n      (regexpCompileCache[path] = pathToRegexp_1.compile(path));\n    return filler(params || {}, { pretty: true })\n  } catch (e) {\n    if (false) {}\n    return ''\n  }\n}\n\n/*  */\n\nfunction createRouteMap (\n  routes,\n  oldPathList,\n  oldPathMap,\n  oldNameMap\n) {\n  // the path list is used to control path matching priority\n  var pathList = oldPathList || [];\n  // $flow-disable-line\n  var pathMap = oldPathMap || Object.create(null);\n  // $flow-disable-line\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathList, pathMap, nameMap, route);\n  });\n\n  // ensure wildcard routes are always at the end\n  for (var i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0]);\n      l--;\n      i--;\n    }\n  }\n\n  return {\n    pathList: pathList,\n    pathMap: pathMap,\n    nameMap: nameMap\n  }\n}\n\nfunction addRouteRecord (\n  pathList,\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  var path = route.path;\n  var name = route.name;\n  if (false) {}\n\n  var pathToRegexpOptions = route.pathToRegexpOptions || {};\n  var normalizedPath = normalizePath(\n    path,\n    parent,\n    pathToRegexpOptions.strict\n  );\n\n  if (typeof route.caseSensitive === 'boolean') {\n    pathToRegexpOptions.sensitive = route.caseSensitive;\n  }\n\n  var record = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null\n      ? {}\n      : route.components\n        ? route.props\n        : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named, does not redirect and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (false) {}\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs\n        ? cleanPath((matchAs + \"/\" + (child.path)))\n        : undefined;\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    var aliases = Array.isArray(route.alias)\n      ? route.alias\n      : [route.alias];\n\n    aliases.forEach(function (alias) {\n      var aliasRoute = {\n        path: alias,\n        children: route.children\n      };\n      addRouteRecord(\n        pathList,\n        pathMap,\n        nameMap,\n        aliasRoute,\n        parent,\n        record.path || '/' // matchAs\n      );\n    });\n  }\n\n  if (!pathMap[record.path]) {\n    pathList.push(record.path);\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if (false) {}\n  }\n}\n\nfunction compileRouteRegex (path, pathToRegexpOptions) {\n  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);\n  if (false) { var keys; }\n  return regex\n}\n\nfunction normalizePath (path, parent, strict) {\n  if (!strict) { path = path.replace(/\\/$/, ''); }\n  if (path[0] === '/') { return path }\n  if (parent == null) { return path }\n  return cleanPath(((parent.path) + \"/\" + path))\n}\n\n/*  */\n\n\nfunction normalizeLocation (\n  raw,\n  current,\n  append,\n  router\n) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next.name || next._normalized) {\n    return next\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = vue_router_esm_assign({}, next);\n    next._normalized = true;\n    var params = vue_router_esm_assign(vue_router_esm_assign({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched.length) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, (\"path \" + (current.path)));\n    } else if (false) {}\n    return next\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = (current && current.path) || '/';\n  var path = parsedPath.path\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\n    : basePath;\n\n  var query = resolveQuery(\n    parsedPath.query,\n    next.query,\n    router && router.options.parseQuery\n  );\n\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction vue_router_esm_assign (a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a\n}\n\n/*  */\n\n\nfunction createMatcher (\n  routes,\n  router\n) {\n  var ref = createRouteMap(routes);\n  var pathList = ref.pathList;\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes (routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap);\n  }\n\n  function match (\n    raw,\n    currentRoute,\n    redirectedFrom\n  ) {\n    var location = normalizeLocation(raw, currentRoute, false, router);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (false) {}\n      if (!record) { return _createRoute(null, location) }\n      var paramNames = record.regex.keys\n        .filter(function (key) { return !key.optional; })\n        .map(function (key) { return key.name; });\n\n      if (typeof location.params !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n        return _createRoute(record, location, redirectedFrom)\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var i = 0; i < pathList.length; i++) {\n        var path = pathList[i];\n        var record$1 = pathMap[path];\n        if (matchRoute(record$1.regex, location.path, location.params)) {\n          return _createRoute(record$1, location, redirectedFrom)\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location)\n  }\n\n  function redirect (\n    record,\n    location\n  ) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function'\n        ? originalRedirect(createRoute(record, location, null, router))\n        : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      if (false) {}\n      return _createRoute(null, location)\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (false) {}\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location)\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location)\n    } else {\n      if (false) {}\n      return _createRoute(null, location)\n    }\n  }\n\n  function alias (\n    record,\n    location,\n    matchAs\n  ) {\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location)\n    }\n    return _createRoute(null, location)\n  }\n\n  function _createRoute (\n    record,\n    location,\n    redirectedFrom\n  ) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom, router)\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  }\n}\n\nfunction matchRoute (\n  regex,\n  path,\n  params\n) {\n  var m = path.match(regex);\n\n  if (!m) {\n    return false\n  } else if (!params) {\n    return true\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = regex.keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) {\n      params[key.name] = val;\n    }\n  }\n\n  return true\n}\n\nfunction resolveRecordPath (path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n}\n\n/*  */\n\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll () {\n  // Fix for #1585 for Firefox\n  window.history.replaceState({ key: getStateKey() }, '');\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll (\n  router,\n  to,\n  from,\n  isPop\n) {\n  if (!router.app) {\n    return\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return\n  }\n\n  if (false) {}\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior(to, from, isPop ? position : null);\n\n    if (!shouldScroll) {\n      return\n    }\n\n    if (typeof shouldScroll.then === 'function') {\n      shouldScroll.then(function (shouldScroll) {\n        scrollToPosition((shouldScroll), position);\n      }).catch(function (err) {\n        if (false) {}\n      });\n    } else {\n      scrollToPosition(shouldScroll, position);\n    }\n  });\n}\n\nfunction saveScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key]\n  }\n}\n\nfunction getElementPosition (el, offset) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left - offset.x,\n    y: elRect.top - docRect.top - offset.y\n  }\n}\n\nfunction isValidPosition (obj) {\n  return isNumber(obj.x) || isNumber(obj.y)\n}\n\nfunction normalizePosition (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  }\n}\n\nfunction normalizeOffset (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : 0,\n    y: isNumber(obj.y) ? obj.y : 0\n  }\n}\n\nfunction isNumber (v) {\n  return typeof v === 'number'\n}\n\nfunction scrollToPosition (shouldScroll, position) {\n  var isObject = typeof shouldScroll === 'object';\n  if (isObject && typeof shouldScroll.selector === 'string') {\n    var el = document.querySelector(shouldScroll.selector);\n    if (el) {\n      var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};\n      offset = normalizeOffset(offset);\n      position = getElementPosition(el, offset);\n    } else if (isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n  } else if (isObject && isValidPosition(shouldScroll)) {\n    position = normalizePosition(shouldScroll);\n  }\n\n  if (position) {\n    window.scrollTo(position.x, position.y);\n  }\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && (function () {\n  var ua = window.navigator.userAgent;\n\n  if (\n    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n    ua.indexOf('Mobile Safari') !== -1 &&\n    ua.indexOf('Chrome') === -1 &&\n    ua.indexOf('Windows Phone') === -1\n  ) {\n    return false\n  }\n\n  return window.history && 'pushState' in window.history\n})();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now\n  ? window.performance\n  : Date;\n\nvar _key = genKey();\n\nfunction genKey () {\n  return Time.now().toFixed(3)\n}\n\nfunction getStateKey () {\n  return _key\n}\n\nfunction setStateKey (key) {\n  _key = key;\n}\n\nfunction pushState (url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue (queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\nfunction resolveAsyncComponents (matched) {\n  return function (to, from, next) {\n    var hasAsync = false;\n    var pending = 0;\n    var error = null;\n\n    flatMapComponents(matched, function (def, _, match, key) {\n      // if it's a function and doesn't have cid attached,\n      // assume it's an async component resolve function.\n      // we are not using Vue's default async resolving mechanism because\n      // we want to halt the navigation until the incoming component has been\n      // resolved.\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true;\n        pending++;\n\n        var resolve = once(function (resolvedDef) {\n          if (isESModule(resolvedDef)) {\n            resolvedDef = resolvedDef.default;\n          }\n          // save resolved on async factory in case it's used elsewhere\n          def.resolved = typeof resolvedDef === 'function'\n            ? resolvedDef\n            : _Vue.extend(resolvedDef);\n          match.components[key] = resolvedDef;\n          pending--;\n          if (pending <= 0) {\n            next();\n          }\n        });\n\n        var reject = once(function (reason) {\n          var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n           false && false;\n          if (!error) {\n            error = isError(reason)\n              ? reason\n              : new Error(msg);\n            next(error);\n          }\n        });\n\n        var res;\n        try {\n          res = def(resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject);\n          } else {\n            // new syntax in Vue 2.3\n            var comp = res.component;\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject);\n            }\n          }\n        }\n      }\n    });\n\n    if (!hasAsync) { next(); }\n  }\n}\n\nfunction flatMapComponents (\n  matched,\n  fn\n) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) { return fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ); })\n  }))\n}\n\nfunction flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\nvar hasSymbol =\n  typeof Symbol === 'function' &&\n  typeof Symbol.toStringTag === 'symbol';\n\nfunction isESModule (obj) {\n  return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once (fn) {\n  var called = false;\n  return function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    if (called) { return }\n    called = true;\n    return fn.apply(this, args)\n  }\n}\n\n/*  */\n\nvar History = function History (router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n  this.readyErrorCbs = [];\n  this.errorCbs = [];\n};\n\nHistory.prototype.listen = function listen (cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady (cb, errorCb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n    if (errorCb) {\n      this.readyErrorCbs.push(errorCb);\n    }\n  }\n};\n\nHistory.prototype.onError = function onError (errorCb) {\n  this.errorCbs.push(errorCb);\n};\n\nHistory.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) { cb(route); });\n    }\n  }, function (err) {\n    if (onAbort) {\n      onAbort(err);\n    }\n    if (err && !this$1.ready) {\n      this$1.ready = true;\n      this$1.readyErrorCbs.forEach(function (cb) { cb(err); });\n    }\n  });\n};\n\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n    var this$1 = this;\n\n  var current = this.current;\n  var abort = function (err) {\n    if (isError(err)) {\n      if (this$1.errorCbs.length) {\n        this$1.errorCbs.forEach(function (cb) { cb(err); });\n      } else {\n        warn(false, 'uncaught error during route navigation:');\n        console.error(err);\n      }\n    }\n    onAbort && onAbort(err);\n  };\n  if (\n    isSameRoute(route, current) &&\n    // in the case the route map has been dynamically appended to\n    route.matched.length === current.matched.length\n  ) {\n    this.ensureURL();\n    return abort()\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n    var updated = ref.updated;\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n\n  var queue = [].concat(\n    // in-component leave guards\n    extractLeaveGuards(deactivated),\n    // global before hooks\n    this.router.beforeHooks,\n    // in-component update hooks\n    extractUpdateHooks(updated),\n    // in-config enter guards\n    activated.map(function (m) { return m.beforeEnter; }),\n    // async components\n    resolveAsyncComponents(activated)\n  );\n\n  this.pending = route;\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort()\n    }\n    try {\n      hook(route, current, function (to) {\n        if (to === false || isError(to)) {\n          // next(false) -> abort navigation, ensure current URL\n          this$1.ensureURL(true);\n          abort(to);\n        } else if (\n          typeof to === 'string' ||\n          (typeof to === 'object' && (\n            typeof to.path === 'string' ||\n            typeof to.name === 'string'\n          ))\n        ) {\n          // next('/') or next({ path: '/' }) -> redirect\n          abort();\n          if (typeof to === 'object' && to.replace) {\n            this$1.replace(to);\n          } else {\n            this$1.push(to);\n          }\n        } else {\n          // confirm transition and pass on the value\n          next(to);\n        }\n      });\n    } catch (e) {\n      abort(e);\n    }\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function () { return this$1.current === route; };\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\n    runQueue(queue, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort()\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) { cb(); });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute (route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase (base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = (baseEl && baseEl.getAttribute('href')) || '/';\n      // strip full URL origin\n      base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '')\n}\n\nfunction resolveQueue (\n  current,\n  next\n) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse\n) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n        : bind(guard, instance, match, key)\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nfunction extractGuard (\n  def,\n  key\n) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key]\n}\n\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n\nfunction extractUpdateHooks (updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n\nfunction bindGuard (guard, instance) {\n  if (instance) {\n    return function boundRouteGuard () {\n      return guard.apply(instance, arguments)\n    }\n  }\n}\n\nfunction extractEnterGuards (\n  activated,\n  cbs,\n  isValid\n) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid)\n  })\n}\n\nfunction bindEnterGuard (\n  guard,\n  match,\n  key,\n  cbs,\n  isValid\n) {\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    })\n  }\n}\n\nfunction poll (\n  cb, // somehow flow cannot infer this is a function\n  instances,\n  key,\n  isValid\n) {\n  if (instances[key]) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\n/*  */\n\n\nvar HTML5History = (function (History$$1) {\n  function HTML5History (router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n\n    if (expectScroll) {\n      setupScroll();\n    }\n\n    var initLocation = getLocation(this.base);\n    window.addEventListener('popstate', function (e) {\n      var current = this$1.current;\n\n      // Avoiding first `popstate` event dispatched in some browsers but first\n      // history route not updated since async guard at the same time.\n      var location = getLocation(this$1.base);\n      if (this$1.current === START && location === initLocation) {\n        return\n      }\n\n      this$1.transitionTo(location, function (route) {\n        if (expectScroll) {\n          handleScroll(router, route, current, true);\n        }\n      });\n    });\n  }\n\n  if ( History$$1 ) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getLocation(this.base)\n  };\n\n  return HTML5History;\n}(History));\n\nfunction getLocation (base) {\n  var path = window.location.pathname;\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash\n}\n\n/*  */\n\n\nvar HashHistory = (function (History$$1) {\n  function HashHistory (router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    ensureSlash();\n  }\n\n  if ( History$$1 ) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners () {\n    var this$1 = this;\n\n    var router = this.router;\n    var expectScroll = router.options.scrollBehavior;\n    var supportsScroll = supportsPushState && expectScroll;\n\n    if (supportsScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {\n      var current = this$1.current;\n      if (!ensureSlash()) {\n        return\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        if (supportsScroll) {\n          handleScroll(this$1.router, route, current, true);\n        }\n        if (!supportsPushState) {\n          replaceHash(route.fullPath);\n        }\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getHash()\n  };\n\n  return HashHistory;\n}(History));\n\nfunction checkFallback (base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(\n      cleanPath(base + '/#' + location)\n    );\n    return true\n  }\n}\n\nfunction ensureSlash () {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path);\n  return false\n}\n\nfunction getHash () {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : href.slice(index + 1)\n}\n\nfunction getUrl (path) {\n  var href = window.location.href;\n  var i = href.indexOf('#');\n  var base = i >= 0 ? href.slice(0, i) : href;\n  return (base + \"#\" + path)\n}\n\nfunction pushHash (path) {\n  if (supportsPushState) {\n    pushState(getUrl(path));\n  } else {\n    window.location.hash = path;\n  }\n}\n\nfunction replaceHash (path) {\n  if (supportsPushState) {\n    replaceState(getUrl(path));\n  } else {\n    window.location.replace(getUrl(path));\n  }\n}\n\n/*  */\n\n\nvar AbstractHistory = (function (History$$1) {\n  function AbstractHistory (router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go (n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/'\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History));\n\n/*  */\n\nvar VueRouter = function VueRouter (options) {\n  if ( options === void 0 ) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.resolveHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || [], this);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break\n    default:\n      if (false) {}\n  }\n};\n\nvar vue_router_esm_prototypeAccessors = { currentRoute: { configurable: true } };\n\nVueRouter.prototype.match = function match (\n  raw,\n  current,\n  redirectedFrom\n) {\n  return this.matcher.match(raw, current, redirectedFrom)\n};\n\nvue_router_esm_prototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current\n};\n\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\n    var this$1 = this;\n\n   false && false;\n\n  this.apps.push(app);\n\n  // main app already initialized.\n  if (this.app) {\n    return\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function () {\n      history.setupListeners();\n    };\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupHashListener,\n      setupHashListener\n    );\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\n  return registerHook(this.beforeHooks, fn)\n};\n\nVueRouter.prototype.beforeResolve = function beforeResolve (fn) {\n  return registerHook(this.resolveHooks, fn)\n};\n\nVueRouter.prototype.afterEach = function afterEach (fn) {\n  return registerHook(this.afterHooks, fn)\n};\n\nVueRouter.prototype.onReady = function onReady (cb, errorCb) {\n  this.history.onReady(cb, errorCb);\n};\n\nVueRouter.prototype.onError = function onError (errorCb) {\n  this.history.onError(errorCb);\n};\n\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go (n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back () {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward () {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n  var route = to\n    ? to.matched\n      ? to\n      : this.resolve(to).route\n    : this.currentRoute;\n  if (!route) {\n    return []\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key]\n    })\n  }))\n};\n\nVueRouter.prototype.resolve = function resolve (\n  to,\n  current,\n  append\n) {\n  var location = normalizeLocation(\n    to,\n    current || this.history.current,\n    append,\n    this\n  );\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  }\n};\n\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties( VueRouter.prototype, vue_router_esm_prototypeAccessors );\n\nfunction registerHook (list, fn) {\n  list.push(fn);\n  return function () {\n    var i = list.indexOf(fn);\n    if (i > -1) { list.splice(i, 1); }\n  }\n}\n\nfunction createHref (base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path\n}\n\nVueRouter.install = vue_router_esm_install;\nVueRouter.version = '3.0.1';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\n/* harmony default export */ var vue_router_esm = (VueRouter);\n\n// CONCATENATED MODULE: ./src/router.ts\n\n\n/* harmony default export */ var router = (new vue_router_esm({\n    mode: 'history',\n    routes: [\n        {\n            path: '/',\n            component: Main\n        }\n    ]\n}));\n\n// EXTERNAL MODULE: ./node_modules/webfontloader/webfontloader.js\nvar webfontloader = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./node_modules/vuetify/dist/vuetify.js\nvar vuetify = __webpack_require__(3);\nvar vuetify_default = /*#__PURE__*/__webpack_require__.n(vuetify);\n\n// EXTERNAL MODULE: ./node_modules/vue-lazyload/vue-lazyload.js\nvar vue_lazyload = __webpack_require__(2);\nvar vue_lazyload_default = /*#__PURE__*/__webpack_require__.n(vue_lazyload);\n\n// CONCATENATED MODULE: ./node_modules/ts-loader!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/Main.vue\n\n\n\n\n\n\n\n// import store from './store'\n\nvue_esm[\"default\"].config.productionTip = true;\nvue_esm[\"default\"].use(vuex_esm);\nvue_esm[\"default\"].use(vue_router_esm);\nvue_esm[\"default\"].use(vuetify_default.a);\nvue_esm[\"default\"].use(vue_lazyload_default.a, {\n    lazyComponent: true\n});\n// load webfonts asynchronously\nif (window) {\n    webfontloader[\"load\"]({\n        custom: {\n            families: ['HKGrotesk']\n        }\n    });\n}\n/* tslint:disable */\nnew vue_esm[\"default\"]({\n    el: '#app',\n    render: function (h) { return h(Main); },\n    router: router,\n});\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-54d3a52e\",\"hasScoped\":true,\"optionsId\":\"0\",\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/components/Main.vue\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", [_c(\"h1\", [_vm._v(\"Test\")])])\n  }\n]\nrender._withStripped = true\n\nif (false) {}\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/component-normalizer.js\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  scriptExports = scriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof scriptExports.default\n  if (type === 'object' || type === 'function') {\n    scriptExports = scriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n// CONCATENATED MODULE: ./src/components/Main.vue\nvar disposed = false\nfunction injectStyle (context) {\n  if (disposed) return\n  __webpack_require__(8)\n}\n/* script */\n\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-54d3a52e\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\n\nvar Component = normalizeComponent(\n  /* Cannot get final name for export \"default\" in \"./node_modules/ts-loader!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/Main.vue\" (known exports: , known reexports: ) */ undefined,\n  render,\n  staticRenderFns,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\nComponent.options.__file = \"src/components/Main.vue\"\n\n/* hot reload */\nif (false) {}\n\n/* harmony default export */ var Main = (Component.exports);\n\n// CONCATENATED MODULE: ./src/index.ts\n\n\n\n\n\n\n\n// import store from './store'\n\nvue_esm[\"default\"].config.productionTip = true;\nvue_esm[\"default\"].use(vuex_esm);\nvue_esm[\"default\"].use(vue_router_esm);\nvue_esm[\"default\"].use(vuetify_default.a);\nvue_esm[\"default\"].use(vue_lazyload_default.a, {\n    lazyComponent: true\n});\n// load webfonts asynchronously\nif (window) {\n    webfontloader[\"load\"]({\n        custom: {\n            families: ['HKGrotesk']\n        }\n    });\n}\n/* tslint:disable */\nnew vue_esm[\"default\"]({\n    el: '#app',\n    render: function (h) { return h(Main); },\n    router: router,\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVleC9kaXN0L3Z1ZXguZXNtLmpzPzJmNjIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcz84YzRmIiwid2VicGFjazovLy8uL3NyYy9yb3V0ZXIudHM/NWY4NiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NYWluLnZ1ZT9lNzA5Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01haW4udnVlPzRiOTMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50LW5vcm1hbGl6ZXIuanM/MjQ1NSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9NYWluLnZ1ZT82NGYxIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cz9mZmI0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLGNBQWM7QUFDekIsWUFBWTtBQUNaOzs7QUFH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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sS0FBcUMsRUFBRSxFQUUxQzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFlBQVksS0FBcUMsRUFBRSxFQUUxQztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTSxFQUFFO0FBQ3RELFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBDQUEwQyxFQUFFO0FBQ2xGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUMsRUFBRSxFQUUxQztBQUNQO0FBQ0E7O0FBRUEsSUFBSSxpQ0FBa0IsSUFBSSxnQkFBZ0IscUJBQXFCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUUsTUFBcUMsSUFBSSxLQUl4Qzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0E7QUFDZ0c7QUFDaEcsZ0JBQWdCLGtCQUFrQjtBQUNsQyxFQUFFLHFOQUFjO0FBQ2hCLEVBQUUsTUFBYztBQUNoQixFQUFFLGVBQXlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBVSxFQUFFLEVBYVg7O0FBRVUsMERBQWlCOzs7QUM5Q1g7QUFDa0I7QUFDaEI7QUFDUztBQUNFO0FBQ1M7QUFDZDtBQUM3Qiw4QkFBOEI7QUFDUTtBQUV0QyxrQkFBRyxDQUFDLE1BQU0sQ0FBQyxhQUFhLEdBQUcsSUFBSTtBQUUvQixrQkFBRyxDQUFDLEdBQUcsQ0FBQyxRQUFJLENBQUM7QUFFYixrQkFBRyxDQUFDLEdBQUcsQ0FBQyxjQUFTLENBQUM7QUFFbEIsa0JBQUcsQ0FBQyxHQUFHLENBQUMsaUJBQU8sQ0FBQztBQUNoQixrQkFBRyxDQUFDLEdBQUcsQ0FBQyxzQkFBVyxFQUFFO0lBQ25CLGFBQWEsRUFBRyxJQUFJO0NBQ3JCLENBQUM7QUFDRiwrQkFBK0I7QUFDL0IsSUFBSSxNQUFNLEVBQUU7SUFDVixxQkFBZSxDQUFDO1FBQ2QsTUFBTSxFQUFFO1lBQ04sUUFBUSxFQUFHLENBQUMsV0FBVyxDQUFDO1NBQ3pCO0tBQ0YsQ0FBQztDQUNIO0FBRUQsb0JBQW9CO0FBQ3BCLElBQUksa0JBQUcsQ0FBQztJQUNKLEVBQUUsRUFBRyxNQUFNO0lBQ1gsTUFBTSxFQUFHLFdBQUMsSUFBSSxRQUFDLENBQUMsSUFBSSxDQUFDLEVBQVAsQ0FBTztJQUNyQixNQUFNO0NBRVQsQ0FBQyIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdnVleCB2My4wLjFcbiAqIChjKSAyMDE3IEV2YW4gWW91XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xudmFyIGFwcGx5TWl4aW4gPSBmdW5jdGlvbiAoVnVlKSB7XG4gIHZhciB2ZXJzaW9uID0gTnVtYmVyKFZ1ZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pO1xuXG4gIGlmICh2ZXJzaW9uID49IDIpIHtcbiAgICBWdWUubWl4aW4oeyBiZWZvcmVDcmVhdGU6IHZ1ZXhJbml0IH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG92ZXJyaWRlIGluaXQgYW5kIGluamVjdCB2dWV4IGluaXQgcHJvY2VkdXJlXG4gICAgLy8gZm9yIDEueCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICB2YXIgX2luaXQgPSBWdWUucHJvdG90eXBlLl9pbml0O1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgICAgIG9wdGlvbnMuaW5pdCA9IG9wdGlvbnMuaW5pdFxuICAgICAgICA/IFt2dWV4SW5pdF0uY29uY2F0KG9wdGlvbnMuaW5pdClcbiAgICAgICAgOiB2dWV4SW5pdDtcbiAgICAgIF9pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWdWV4IGluaXQgaG9vaywgaW5qZWN0ZWQgaW50byBlYWNoIGluc3RhbmNlcyBpbml0IGhvb2tzIGxpc3QuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHZ1ZXhJbml0ICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgLy8gc3RvcmUgaW5qZWN0aW9uXG4gICAgaWYgKG9wdGlvbnMuc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gdHlwZW9mIG9wdGlvbnMuc3RvcmUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBvcHRpb25zLnN0b3JlKClcbiAgICAgICAgOiBvcHRpb25zLnN0b3JlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQuJHN0b3JlKSB7XG4gICAgICB0aGlzLiRzdG9yZSA9IG9wdGlvbnMucGFyZW50LiRzdG9yZTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZXZ0b29sSG9vayA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG5mdW5jdGlvbiBkZXZ0b29sUGx1Z2luIChzdG9yZSkge1xuICBpZiAoIWRldnRvb2xIb29rKSB7IHJldHVybiB9XG5cbiAgc3RvcmUuX2RldnRvb2xIb29rID0gZGV2dG9vbEhvb2s7XG5cbiAgZGV2dG9vbEhvb2suZW1pdCgndnVleDppbml0Jywgc3RvcmUpO1xuXG4gIGRldnRvb2xIb29rLm9uKCd2dWV4OnRyYXZlbC10by1zdGF0ZScsIGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZSh0YXJnZXRTdGF0ZSk7XG4gIH0pO1xuXG4gIHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAobXV0YXRpb24sIHN0YXRlKSB7XG4gICAgZGV2dG9vbEhvb2suZW1pdCgndnVleDptdXRhdGlvbicsIG11dGF0aW9uLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgaXRlbSB0aGF0IHBhc3MgdGhlIHRlc3RcbiAqIGJ5IHNlY29uZCBhcmd1bWVudCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEByZXR1cm4geyp9XG4gKi9cbi8qKlxuICogRGVlcCBjb3B5IHRoZSBnaXZlbiBvYmplY3QgY29uc2lkZXJpbmcgY2lyY3VsYXIgc3RydWN0dXJlLlxuICogVGhpcyBmdW5jdGlvbiBjYWNoZXMgYWxsIG5lc3RlZCBvYmplY3RzIGFuZCBpdHMgY29waWVzLlxuICogSWYgaXQgZGV0ZWN0cyBjaXJjdWxhciBzdHJ1Y3R1cmUsIHVzZSBjYWNoZWQgY29weSB0byBhdm9pZCBpbmZpbml0ZSBsb29wLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGNhY2hlXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cblxuLyoqXG4gKiBmb3JFYWNoIGZvciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaFZhbHVlIChvYmosIGZuKSB7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihvYmpba2V5XSwga2V5KTsgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbXNnKSB7XG4gIGlmICghY29uZGl0aW9uKSB7IHRocm93IG5ldyBFcnJvcigoXCJbdnVleF0gXCIgKyBtc2cpKSB9XG59XG5cbnZhciBNb2R1bGUgPSBmdW5jdGlvbiBNb2R1bGUgKHJhd01vZHVsZSwgcnVudGltZSkge1xuICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICB0aGlzLl9jaGlsZHJlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3Jhd01vZHVsZSA9IHJhd01vZHVsZTtcbiAgdmFyIHJhd1N0YXRlID0gcmF3TW9kdWxlLnN0YXRlO1xuICB0aGlzLnN0YXRlID0gKHR5cGVvZiByYXdTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IHJhd1N0YXRlKCkgOiByYXdTdGF0ZSkgfHwge307XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7IG5hbWVzcGFjZWQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEubmFtZXNwYWNlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIXRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGtleSwgbW9kdWxlKSB7XG4gIHRoaXMuX2NoaWxkcmVuW2tleV0gPSBtb2R1bGU7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGtleSkge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5ba2V5XTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiBnZXRDaGlsZCAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAocmF3TW9kdWxlKSB7XG4gIHRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkID0gcmF3TW9kdWxlLm5hbWVzcGFjZWQ7XG4gIGlmIChyYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zID0gcmF3TW9kdWxlLmFjdGlvbnM7XG4gIH1cbiAgaWYgKHJhd01vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zID0gcmF3TW9kdWxlLm11dGF0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycyA9IHJhd01vZHVsZS5nZXR0ZXJzO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIGZvckVhY2hDaGlsZCAoZm4pIHtcbiAgZm9yRWFjaFZhbHVlKHRoaXMuX2NoaWxkcmVuLCBmbik7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hHZXR0ZXIgPSBmdW5jdGlvbiBmb3JFYWNoR2V0dGVyIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoQWN0aW9uID0gZnVuY3Rpb24gZm9yRWFjaEFjdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zLCBmbik7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaE11dGF0aW9uID0gZnVuY3Rpb24gZm9yRWFjaE11dGF0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zLCBmbik7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNb2R1bGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG52YXIgTW9kdWxlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIE1vZHVsZUNvbGxlY3Rpb24gKHJhd1Jvb3RNb2R1bGUpIHtcbiAgLy8gcmVnaXN0ZXIgcm9vdCBtb2R1bGUgKFZ1ZXguU3RvcmUgb3B0aW9ucylcbiAgdGhpcy5yZWdpc3RlcihbXSwgcmF3Um9vdE1vZHVsZSwgZmFsc2UpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobW9kdWxlLCBrZXkpIHtcbiAgICByZXR1cm4gbW9kdWxlLmdldENoaWxkKGtleSlcbiAgfSwgdGhpcy5yb290KVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24gZ2V0TmFtZXNwYWNlIChwYXRoKSB7XG4gIHZhciBtb2R1bGUgPSB0aGlzLnJvb3Q7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBrZXkpIHtcbiAgICBtb2R1bGUgPSBtb2R1bGUuZ2V0Q2hpbGQoa2V5KTtcbiAgICByZXR1cm4gbmFtZXNwYWNlICsgKG1vZHVsZS5uYW1lc3BhY2VkID8ga2V5ICsgJy8nIDogJycpXG4gIH0sICcnKVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlJDEgKHJhd1Jvb3RNb2R1bGUpIHtcbiAgdXBkYXRlKFtdLCB0aGlzLnJvb3QsIHJhd1Jvb3RNb2R1bGUpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlciAocGF0aCwgcmF3TW9kdWxlLCBydW50aW1lKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgaWYgKCBydW50aW1lID09PSB2b2lkIDAgKSBydW50aW1lID0gdHJ1ZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFJhd01vZHVsZShwYXRoLCByYXdNb2R1bGUpO1xuICB9XG5cbiAgdmFyIG5ld01vZHVsZSA9IG5ldyBNb2R1bGUocmF3TW9kdWxlLCBydW50aW1lKTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5yb290ID0gbmV3TW9kdWxlO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgcGFyZW50LmFkZENoaWxkKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgbmV3TW9kdWxlKTtcbiAgfVxuXG4gIC8vIHJlZ2lzdGVyIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdNb2R1bGUubW9kdWxlcywgZnVuY3Rpb24gKHJhd0NoaWxkTW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3RlcihwYXRoLmNvbmNhdChrZXkpLCByYXdDaGlsZE1vZHVsZSwgcnVudGltZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyIChwYXRoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmICghcGFyZW50LmdldENoaWxkKGtleSkucnVudGltZSkgeyByZXR1cm4gfVxuXG4gIHBhcmVudC5yZW1vdmVDaGlsZChrZXkpO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlIChwYXRoLCB0YXJnZXRNb2R1bGUsIG5ld01vZHVsZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFJhd01vZHVsZShwYXRoLCBuZXdNb2R1bGUpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHRhcmdldCBtb2R1bGVcbiAgdGFyZ2V0TW9kdWxlLnVwZGF0ZShuZXdNb2R1bGUpO1xuXG4gIC8vIHVwZGF0ZSBuZXN0ZWQgbW9kdWxlc1xuICBpZiAobmV3TW9kdWxlLm1vZHVsZXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmV3TW9kdWxlLm1vZHVsZXMpIHtcbiAgICAgIGlmICghdGFyZ2V0TW9kdWxlLmdldENoaWxkKGtleSkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIlt2dWV4XSB0cnlpbmcgdG8gYWRkIGEgbmV3IG1vZHVsZSAnXCIgKyBrZXkgKyBcIicgb24gaG90IHJlbG9hZGluZywgXCIgK1xuICAgICAgICAgICAgJ21hbnVhbCByZWxvYWQgaXMgbmVlZGVkJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUoXG4gICAgICAgIHBhdGguY29uY2F0KGtleSksXG4gICAgICAgIHRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpLFxuICAgICAgICBuZXdNb2R1bGUubW9kdWxlc1trZXldXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZnVuY3Rpb25Bc3NlcnQgPSB7XG4gIGFzc2VydDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7IH0sXG4gIGV4cGVjdGVkOiAnZnVuY3Rpb24nXG59O1xuXG52YXIgb2JqZWN0QXNzZXJ0ID0ge1xuICBhc3NlcnQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLmhhbmRsZXIgPT09ICdmdW5jdGlvbicpOyB9LFxuICBleHBlY3RlZDogJ2Z1bmN0aW9uIG9yIG9iamVjdCB3aXRoIFwiaGFuZGxlclwiIGZ1bmN0aW9uJ1xufTtcblxudmFyIGFzc2VydFR5cGVzID0ge1xuICBnZXR0ZXJzOiBmdW5jdGlvbkFzc2VydCxcbiAgbXV0YXRpb25zOiBmdW5jdGlvbkFzc2VydCxcbiAgYWN0aW9uczogb2JqZWN0QXNzZXJ0XG59O1xuXG5mdW5jdGlvbiBhc3NlcnRSYXdNb2R1bGUgKHBhdGgsIHJhd01vZHVsZSkge1xuICBPYmplY3Qua2V5cyhhc3NlcnRUeXBlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFyYXdNb2R1bGVba2V5XSkgeyByZXR1cm4gfVxuXG4gICAgdmFyIGFzc2VydE9wdGlvbnMgPSBhc3NlcnRUeXBlc1trZXldO1xuXG4gICAgZm9yRWFjaFZhbHVlKHJhd01vZHVsZVtrZXldLCBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgYXNzZXJ0T3B0aW9ucy5hc3NlcnQodmFsdWUpLFxuICAgICAgICBtYWtlQXNzZXJ0aW9uTWVzc2FnZShwYXRoLCBrZXksIHR5cGUsIHZhbHVlLCBhc3NlcnRPcHRpb25zLmV4cGVjdGVkKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VBc3NlcnRpb25NZXNzYWdlIChwYXRoLCBrZXksIHR5cGUsIHZhbHVlLCBleHBlY3RlZCkge1xuICB2YXIgYnVmID0ga2V5ICsgXCIgc2hvdWxkIGJlIFwiICsgZXhwZWN0ZWQgKyBcIiBidXQgXFxcIlwiICsga2V5ICsgXCIuXCIgKyB0eXBlICsgXCJcXFwiXCI7XG4gIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICBidWYgKz0gXCIgaW4gbW9kdWxlIFxcXCJcIiArIChwYXRoLmpvaW4oJy4nKSkgKyBcIlxcXCJcIjtcbiAgfVxuICBidWYgKz0gXCIgaXMgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSArIFwiLlwiO1xuICByZXR1cm4gYnVmXG59XG5cbnZhciBWdWU7IC8vIGJpbmQgb24gaW5zdGFsbFxuXG52YXIgU3RvcmUgPSBmdW5jdGlvbiBTdG9yZSAob3B0aW9ucykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgLy8gQXV0byBpbnN0YWxsIGlmIGl0IGlzIG5vdCBkb25lIHlldCBhbmQgYHdpbmRvd2AgaGFzIGBWdWVgLlxuICAvLyBUbyBhbGxvdyB1c2VycyB0byBhdm9pZCBhdXRvLWluc3RhbGxhdGlvbiBpbiBzb21lIGNhc2VzLFxuICAvLyB0aGlzIGNvZGUgc2hvdWxkIGJlIHBsYWNlZCBoZXJlLiBTZWUgIzczMVxuICBpZiAoIVZ1ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgaW5zdGFsbCh3aW5kb3cuVnVlKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KFZ1ZSwgXCJtdXN0IGNhbGwgVnVlLnVzZShWdWV4KSBiZWZvcmUgY3JlYXRpbmcgYSBzdG9yZSBpbnN0YW5jZS5cIik7XG4gICAgYXNzZXJ0KHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJywgXCJ2dWV4IHJlcXVpcmVzIGEgUHJvbWlzZSBwb2x5ZmlsbCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuICAgIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgU3RvcmUsIFwiU3RvcmUgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yLlwiKTtcbiAgfVxuXG4gIHZhciBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zOyBpZiAoIHBsdWdpbnMgPT09IHZvaWQgMCApIHBsdWdpbnMgPSBbXTtcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0OyBpZiAoIHN0cmljdCA9PT0gdm9pZCAwICkgc3RyaWN0ID0gZmFsc2U7XG5cbiAgdmFyIHN0YXRlID0gb3B0aW9ucy5zdGF0ZTsgaWYgKCBzdGF0ZSA9PT0gdm9pZCAwICkgc3RhdGUgPSB7fTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0YXRlID0gc3RhdGUoKSB8fCB7fTtcbiAgfVxuXG4gIC8vIHN0b3JlIGludGVybmFsIHN0YXRlXG4gIHRoaXMuX2NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgdGhpcy5fYWN0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX2FjdGlvblN1YnNjcmliZXJzID0gW107XG4gIHRoaXMuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3dyYXBwZWRHZXR0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fbW9kdWxlcyA9IG5ldyBNb2R1bGVDb2xsZWN0aW9uKG9wdGlvbnMpO1xuICB0aGlzLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcbiAgdGhpcy5fd2F0Y2hlclZNID0gbmV3IFZ1ZSgpO1xuXG4gIC8vIGJpbmQgY29tbWl0IGFuZCBkaXNwYXRjaCB0byBzZWxmXG4gIHZhciBzdG9yZSA9IHRoaXM7XG4gIHZhciByZWYgPSB0aGlzO1xuICB2YXIgZGlzcGF0Y2ggPSByZWYuZGlzcGF0Y2g7XG4gIHZhciBjb21taXQgPSByZWYuY29tbWl0O1xuICB0aGlzLmRpc3BhdGNoID0gZnVuY3Rpb24gYm91bmREaXNwYXRjaCAodHlwZSwgcGF5bG9hZCkge1xuICAgIHJldHVybiBkaXNwYXRjaC5jYWxsKHN0b3JlLCB0eXBlLCBwYXlsb2FkKVxuICB9O1xuICB0aGlzLmNvbW1pdCA9IGZ1bmN0aW9uIGJvdW5kQ29tbWl0ICh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNvbW1pdC5jYWxsKHN0b3JlLCB0eXBlLCBwYXlsb2FkLCBvcHRpb25zKVxuICB9O1xuXG4gIC8vIHN0cmljdCBtb2RlXG4gIHRoaXMuc3RyaWN0ID0gc3RyaWN0O1xuXG4gIC8vIGluaXQgcm9vdCBtb2R1bGUuXG4gIC8vIHRoaXMgYWxzbyByZWN1cnNpdmVseSByZWdpc3RlcnMgYWxsIHN1Yi1tb2R1bGVzXG4gIC8vIGFuZCBjb2xsZWN0cyBhbGwgbW9kdWxlIGdldHRlcnMgaW5zaWRlIHRoaXMuX3dyYXBwZWRHZXR0ZXJzXG4gIGluc3RhbGxNb2R1bGUodGhpcywgc3RhdGUsIFtdLCB0aGlzLl9tb2R1bGVzLnJvb3QpO1xuXG4gIC8vIGluaXRpYWxpemUgdGhlIHN0b3JlIHZtLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHJlYWN0aXZpdHlcbiAgLy8gKGFsc28gcmVnaXN0ZXJzIF93cmFwcGVkR2V0dGVycyBhcyBjb21wdXRlZCBwcm9wZXJ0aWVzKVxuICByZXNldFN0b3JlVk0odGhpcywgc3RhdGUpO1xuXG4gIC8vIGFwcGx5IHBsdWdpbnNcbiAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHsgcmV0dXJuIHBsdWdpbih0aGlzJDEpOyB9KTtcblxuICBpZiAoVnVlLmNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xQbHVnaW4odGhpcyk7XG4gIH1cbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHN0YXRlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5zdGF0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl92bS5fZGF0YS4kJHN0YXRlXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc3RhdGUuc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoZmFsc2UsIFwiVXNlIHN0b3JlLnJlcGxhY2VTdGF0ZSgpIHRvIGV4cGxpY2l0IHJlcGxhY2Ugc3RvcmUgc3RhdGUuXCIpO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gY29tbWl0IChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGNvbW1pdFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG4gICAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcblxuICB2YXIgbXV0YXRpb24gPSB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fbXV0YXRpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIHVua25vd24gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIGVudHJ5LmZvckVhY2goZnVuY3Rpb24gY29tbWl0SXRlcmF0b3IgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIocGF5bG9hZCk7XG4gICAgfSk7XG4gIH0pO1xuICB0aGlzLl9zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1YihtdXRhdGlvbiwgdGhpcyQxLnN0YXRlKTsgfSk7XG5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBvcHRpb25zICYmIG9wdGlvbnMuc2lsZW50XG4gICkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiW3Z1ZXhdIG11dGF0aW9uIHR5cGU6IFwiICsgdHlwZSArIFwiLiBTaWxlbnQgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIFwiICtcbiAgICAgICdVc2UgdGhlIGZpbHRlciBmdW5jdGlvbmFsaXR5IGluIHRoZSB2dWUtZGV2dG9vbHMnXG4gICAgKTtcbiAgfVxufTtcblxuU3RvcmUucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2ggKF90eXBlLCBfcGF5bG9hZCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIC8vIGNoZWNrIG9iamVjdC1zdHlsZSBkaXNwYXRjaFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcblxuICB2YXIgYWN0aW9uID0geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkIH07XG4gIHZhciBlbnRyeSA9IHRoaXMuX2FjdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5fYWN0aW9uU3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIoYWN0aW9uLCB0aGlzJDEuc3RhdGUpOyB9KTtcblxuICByZXR1cm4gZW50cnkubGVuZ3RoID4gMVxuICAgID8gUHJvbWlzZS5hbGwoZW50cnkubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKHBheWxvYWQpOyB9KSlcbiAgICA6IGVudHJ5WzBdKHBheWxvYWQpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlIChmbikge1xuICByZXR1cm4gZ2VuZXJpY1N1YnNjcmliZShmbiwgdGhpcy5fc3Vic2NyaWJlcnMpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuc3Vic2NyaWJlQWN0aW9uID0gZnVuY3Rpb24gc3Vic2NyaWJlQWN0aW9uIChmbikge1xuICByZXR1cm4gZ2VuZXJpY1N1YnNjcmliZShmbiwgdGhpcy5fYWN0aW9uU3Vic2NyaWJlcnMpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiB3YXRjaCAoZ2V0dGVyLCBjYiwgb3B0aW9ucykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBnZXR0ZXIgPT09ICdmdW5jdGlvbicsIFwic3RvcmUud2F0Y2ggb25seSBhY2NlcHRzIGEgZnVuY3Rpb24uXCIpO1xuICB9XG4gIHJldHVybiB0aGlzLl93YXRjaGVyVk0uJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldHRlcih0aGlzJDEuc3RhdGUsIHRoaXMkMS5nZXR0ZXJzKTsgfSwgY2IsIG9wdGlvbnMpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gcmVwbGFjZVN0YXRlIChzdGF0ZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS5fdm0uX2RhdGEuJCRzdGF0ZSA9IHN0YXRlO1xuICB9KTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlIChwYXRoLCByYXdNb2R1bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7IHBhdGggPSBbcGF0aF07IH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICAgIGFzc2VydChwYXRoLmxlbmd0aCA+IDAsICdjYW5ub3QgcmVnaXN0ZXIgdGhlIHJvb3QgbW9kdWxlIGJ5IHVzaW5nIHJlZ2lzdGVyTW9kdWxlLicpO1xuICB9XG5cbiAgdGhpcy5fbW9kdWxlcy5yZWdpc3RlcihwYXRoLCByYXdNb2R1bGUpO1xuICBpbnN0YWxsTW9kdWxlKHRoaXMsIHRoaXMuc3RhdGUsIHBhdGgsIHRoaXMuX21vZHVsZXMuZ2V0KHBhdGgpLCBvcHRpb25zLnByZXNlcnZlU3RhdGUpO1xuICAvLyByZXNldCBzdG9yZSB0byB1cGRhdGUgZ2V0dGVycy4uLlxuICByZXNldFN0b3JlVk0odGhpcywgdGhpcy5zdGF0ZSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUudW5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJNb2R1bGUgKHBhdGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7IHBhdGggPSBbcGF0aF07IH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgdGhpcy5fbW9kdWxlcy51bnJlZ2lzdGVyKHBhdGgpO1xuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50U3RhdGUgPSBnZXROZXN0ZWRTdGF0ZSh0aGlzJDEuc3RhdGUsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBWdWUuZGVsZXRlKHBhcmVudFN0YXRlLCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0pO1xuICB9KTtcbiAgcmVzZXRTdG9yZSh0aGlzKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5ob3RVcGRhdGUgPSBmdW5jdGlvbiBob3RVcGRhdGUgKG5ld09wdGlvbnMpIHtcbiAgdGhpcy5fbW9kdWxlcy51cGRhdGUobmV3T3B0aW9ucyk7XG4gIHJlc2V0U3RvcmUodGhpcywgdHJ1ZSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuX3dpdGhDb21taXQgPSBmdW5jdGlvbiBfd2l0aENvbW1pdCAoZm4pIHtcbiAgdmFyIGNvbW1pdHRpbmcgPSB0aGlzLl9jb21taXR0aW5nO1xuICB0aGlzLl9jb21taXR0aW5nID0gdHJ1ZTtcbiAgZm4oKTtcbiAgdGhpcy5fY29tbWl0dGluZyA9IGNvbW1pdHRpbmc7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggU3RvcmUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gZ2VuZXJpY1N1YnNjcmliZSAoZm4sIHN1YnMpIHtcbiAgaWYgKHN1YnMuaW5kZXhPZihmbikgPCAwKSB7XG4gICAgc3Vicy5wdXNoKGZuKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gc3Vicy5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBzdWJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZSAoc3RvcmUsIGhvdCkge1xuICBzdG9yZS5fYWN0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tdXRhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdG9yZS5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBzdGF0ZSA9IHN0b3JlLnN0YXRlO1xuICAvLyBpbml0IGFsbCBtb2R1bGVzXG4gIGluc3RhbGxNb2R1bGUoc3RvcmUsIHN0YXRlLCBbXSwgc3RvcmUuX21vZHVsZXMucm9vdCwgdHJ1ZSk7XG4gIC8vIHJlc2V0IHZtXG4gIHJlc2V0U3RvcmVWTShzdG9yZSwgc3RhdGUsIGhvdCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3RvcmVWTSAoc3RvcmUsIHN0YXRlLCBob3QpIHtcbiAgdmFyIG9sZFZtID0gc3RvcmUuX3ZtO1xuXG4gIC8vIGJpbmQgc3RvcmUgcHVibGljIGdldHRlcnNcbiAgc3RvcmUuZ2V0dGVycyA9IHt9O1xuICB2YXIgd3JhcHBlZEdldHRlcnMgPSBzdG9yZS5fd3JhcHBlZEdldHRlcnM7XG4gIHZhciBjb21wdXRlZCA9IHt9O1xuICBmb3JFYWNoVmFsdWUod3JhcHBlZEdldHRlcnMsIGZ1bmN0aW9uIChmbiwga2V5KSB7XG4gICAgLy8gdXNlIGNvbXB1dGVkIHRvIGxldmVyYWdlIGl0cyBsYXp5LWNhY2hpbmcgbWVjaGFuaXNtXG4gICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuKHN0b3JlKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUuZ2V0dGVycywga2V5LCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLl92bVtrZXldOyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSAvLyBmb3IgbG9jYWwgZ2V0dGVyc1xuICAgIH0pO1xuICB9KTtcblxuICAvLyB1c2UgYSBWdWUgaW5zdGFuY2UgdG8gc3RvcmUgdGhlIHN0YXRlIHRyZWVcbiAgLy8gc3VwcHJlc3Mgd2FybmluZ3MganVzdCBpbiBjYXNlIHRoZSB1c2VyIGhhcyBhZGRlZFxuICAvLyBzb21lIGZ1bmt5IGdsb2JhbCBtaXhpbnNcbiAgdmFyIHNpbGVudCA9IFZ1ZS5jb25maWcuc2lsZW50O1xuICBWdWUuY29uZmlnLnNpbGVudCA9IHRydWU7XG4gIHN0b3JlLl92bSA9IG5ldyBWdWUoe1xuICAgIGRhdGE6IHtcbiAgICAgICQkc3RhdGU6IHN0YXRlXG4gICAgfSxcbiAgICBjb21wdXRlZDogY29tcHV0ZWRcbiAgfSk7XG4gIFZ1ZS5jb25maWcuc2lsZW50ID0gc2lsZW50O1xuXG4gIC8vIGVuYWJsZSBzdHJpY3QgbW9kZSBmb3IgbmV3IHZtXG4gIGlmIChzdG9yZS5zdHJpY3QpIHtcbiAgICBlbmFibGVTdHJpY3RNb2RlKHN0b3JlKTtcbiAgfVxuXG4gIGlmIChvbGRWbSkge1xuICAgIGlmIChob3QpIHtcbiAgICAgIC8vIGRpc3BhdGNoIGNoYW5nZXMgaW4gYWxsIHN1YnNjcmliZWQgd2F0Y2hlcnNcbiAgICAgIC8vIHRvIGZvcmNlIGdldHRlciByZS1ldmFsdWF0aW9uIGZvciBob3QgcmVsb2FkaW5nLlxuICAgICAgc3RvcmUuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBvbGRWbS5fZGF0YS4kJHN0YXRlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBWdWUubmV4dFRpY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gb2xkVm0uJGRlc3Ryb3koKTsgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbE1vZHVsZSAoc3RvcmUsIHJvb3RTdGF0ZSwgcGF0aCwgbW9kdWxlLCBob3QpIHtcbiAgdmFyIGlzUm9vdCA9ICFwYXRoLmxlbmd0aDtcbiAgdmFyIG5hbWVzcGFjZSA9IHN0b3JlLl9tb2R1bGVzLmdldE5hbWVzcGFjZShwYXRoKTtcblxuICAvLyByZWdpc3RlciBpbiBuYW1lc3BhY2UgbWFwXG4gIGlmIChtb2R1bGUubmFtZXNwYWNlZCkge1xuICAgIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV0gPSBtb2R1bGU7XG4gIH1cblxuICAvLyBzZXQgc3RhdGVcbiAgaWYgKCFpc1Jvb3QgJiYgIWhvdCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHJvb3RTdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIHZhciBtb2R1bGVOYW1lID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHN0b3JlLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgIFZ1ZS5zZXQocGFyZW50U3RhdGUsIG1vZHVsZU5hbWUsIG1vZHVsZS5zdGF0ZSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbG9jYWwgPSBtb2R1bGUuY29udGV4dCA9IG1ha2VMb2NhbENvbnRleHQoc3RvcmUsIG5hbWVzcGFjZSwgcGF0aCk7XG5cbiAgbW9kdWxlLmZvckVhY2hNdXRhdGlvbihmdW5jdGlvbiAobXV0YXRpb24sIGtleSkge1xuICAgIHZhciBuYW1lc3BhY2VkVHlwZSA9IG5hbWVzcGFjZSArIGtleTtcbiAgICByZWdpc3Rlck11dGF0aW9uKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgbXV0YXRpb24sIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hBY3Rpb24oZnVuY3Rpb24gKGFjdGlvbiwga2V5KSB7XG4gICAgdmFyIHR5cGUgPSBhY3Rpb24ucm9vdCA/IGtleSA6IG5hbWVzcGFjZSArIGtleTtcbiAgICB2YXIgaGFuZGxlciA9IGFjdGlvbi5oYW5kbGVyIHx8IGFjdGlvbjtcbiAgICByZWdpc3RlckFjdGlvbihzdG9yZSwgdHlwZSwgaGFuZGxlciwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEdldHRlcihmdW5jdGlvbiAoZ2V0dGVyLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJHZXR0ZXIoc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBnZXR0ZXIsIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGtleSkge1xuICAgIGluc3RhbGxNb2R1bGUoc3RvcmUsIHJvb3RTdGF0ZSwgcGF0aC5jb25jYXQoa2V5KSwgY2hpbGQsIGhvdCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIG1ha2UgbG9jYWxpemVkIGRpc3BhdGNoLCBjb21taXQsIGdldHRlcnMgYW5kIHN0YXRlXG4gKiBpZiB0aGVyZSBpcyBubyBuYW1lc3BhY2UsIGp1c3QgdXNlIHJvb3Qgb25lc1xuICovXG5mdW5jdGlvbiBtYWtlTG9jYWxDb250ZXh0IChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKSB7XG4gIHZhciBub05hbWVzcGFjZSA9IG5hbWVzcGFjZSA9PT0gJyc7XG5cbiAgdmFyIGxvY2FsID0ge1xuICAgIGRpc3BhdGNoOiBub05hbWVzcGFjZSA/IHN0b3JlLmRpc3BhdGNoIDogZnVuY3Rpb24gKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICAgIHZhciBwYXlsb2FkID0gYXJncy5wYXlsb2FkO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnM7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3MudHlwZTtcblxuICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnJvb3QpIHtcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZSArIHR5cGU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdG9yZS5fYWN0aW9uc1t0eXBlXSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIHVua25vd24gbG9jYWwgYWN0aW9uIHR5cGU6IFwiICsgKGFyZ3MudHlwZSkgKyBcIiwgZ2xvYmFsIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCh0eXBlLCBwYXlsb2FkKVxuICAgIH0sXG5cbiAgICBjb21taXQ6IG5vTmFtZXNwYWNlID8gc3RvcmUuY29tbWl0IDogZnVuY3Rpb24gKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICAgIHZhciBwYXlsb2FkID0gYXJncy5wYXlsb2FkO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnM7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3MudHlwZTtcblxuICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnJvb3QpIHtcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZSArIHR5cGU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdG9yZS5fbXV0YXRpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBtdXRhdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9yZS5jb21taXQodHlwZSwgcGF5bG9hZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGdldHRlcnMgYW5kIHN0YXRlIG9iamVjdCBtdXN0IGJlIGdvdHRlbiBsYXppbHlcbiAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgY2hhbmdlZCBieSB2bSB1cGRhdGVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobG9jYWwsIHtcbiAgICBnZXR0ZXJzOiB7XG4gICAgICBnZXQ6IG5vTmFtZXNwYWNlXG4gICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyczsgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VMb2NhbEdldHRlcnMoc3RvcmUsIG5hbWVzcGFjZSk7IH1cbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldE5lc3RlZFN0YXRlKHN0b3JlLnN0YXRlLCBwYXRoKTsgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxvY2FsXG59XG5cbmZ1bmN0aW9uIG1ha2VMb2NhbEdldHRlcnMgKHN0b3JlLCBuYW1lc3BhY2UpIHtcbiAgdmFyIGdldHRlcnNQcm94eSA9IHt9O1xuXG4gIHZhciBzcGxpdFBvcyA9IG5hbWVzcGFjZS5sZW5ndGg7XG4gIE9iamVjdC5rZXlzKHN0b3JlLmdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvLyBza2lwIGlmIHRoZSB0YXJnZXQgZ2V0dGVyIGlzIG5vdCBtYXRjaCB0aGlzIG5hbWVzcGFjZVxuICAgIGlmICh0eXBlLnNsaWNlKDAsIHNwbGl0UG9zKSAhPT0gbmFtZXNwYWNlKSB7IHJldHVybiB9XG5cbiAgICAvLyBleHRyYWN0IGxvY2FsIGdldHRlciB0eXBlXG4gICAgdmFyIGxvY2FsVHlwZSA9IHR5cGUuc2xpY2Uoc3BsaXRQb3MpO1xuXG4gICAgLy8gQWRkIGEgcG9ydCB0byB0aGUgZ2V0dGVycyBwcm94eS5cbiAgICAvLyBEZWZpbmUgYXMgZ2V0dGVyIHByb3BlcnR5IGJlY2F1c2VcbiAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBldmFsdWF0ZSB0aGUgZ2V0dGVycyBpbiB0aGlzIHRpbWUuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldHRlcnNQcm94eSwgbG9jYWxUeXBlLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLmdldHRlcnNbdHlwZV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBnZXR0ZXJzUHJveHlcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gfHwgKHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZE11dGF0aW9uSGFuZGxlciAocGF5bG9hZCkge1xuICAgIGhhbmRsZXIuY2FsbChzdG9yZSwgbG9jYWwuc3RhdGUsIHBheWxvYWQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJBY3Rpb24gKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCkge1xuICB2YXIgZW50cnkgPSBzdG9yZS5fYWN0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX2FjdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZEFjdGlvbkhhbmRsZXIgKHBheWxvYWQsIGNiKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuY2FsbChzdG9yZSwge1xuICAgICAgZGlzcGF0Y2g6IGxvY2FsLmRpc3BhdGNoLFxuICAgICAgY29tbWl0OiBsb2NhbC5jb21taXQsXG4gICAgICBnZXR0ZXJzOiBsb2NhbC5nZXR0ZXJzLFxuICAgICAgc3RhdGU6IGxvY2FsLnN0YXRlLFxuICAgICAgcm9vdEdldHRlcnM6IHN0b3JlLmdldHRlcnMsXG4gICAgICByb290U3RhdGU6IHN0b3JlLnN0YXRlXG4gICAgfSwgcGF5bG9hZCwgY2IpO1xuICAgIGlmICghaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcyA9IFByb21pc2UucmVzb2x2ZShyZXMpO1xuICAgIH1cbiAgICBpZiAoc3RvcmUuX2RldnRvb2xIb29rKSB7XG4gICAgICByZXR1cm4gcmVzLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc3RvcmUuX2RldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6ZXJyb3InLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckdldHRlciAoc3RvcmUsIHR5cGUsIHJhd0dldHRlciwgbG9jYWwpIHtcbiAgaWYgKHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSBkdXBsaWNhdGUgZ2V0dGVyIGtleTogXCIgKyB0eXBlKSk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSA9IGZ1bmN0aW9uIHdyYXBwZWRHZXR0ZXIgKHN0b3JlKSB7XG4gICAgcmV0dXJuIHJhd0dldHRlcihcbiAgICAgIGxvY2FsLnN0YXRlLCAvLyBsb2NhbCBzdGF0ZVxuICAgICAgbG9jYWwuZ2V0dGVycywgLy8gbG9jYWwgZ2V0dGVyc1xuICAgICAgc3RvcmUuc3RhdGUsIC8vIHJvb3Qgc3RhdGVcbiAgICAgIHN0b3JlLmdldHRlcnMgLy8gcm9vdCBnZXR0ZXJzXG4gICAgKVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmFibGVTdHJpY3RNb2RlIChzdG9yZSkge1xuICBzdG9yZS5fdm0uJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEuJCRzdGF0ZSB9LCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydChzdG9yZS5fY29tbWl0dGluZywgXCJEbyBub3QgbXV0YXRlIHZ1ZXggc3RvcmUgc3RhdGUgb3V0c2lkZSBtdXRhdGlvbiBoYW5kbGVycy5cIik7XG4gICAgfVxuICB9LCB7IGRlZXA6IHRydWUsIHN5bmM6IHRydWUgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE5lc3RlZFN0YXRlIChzdGF0ZSwgcGF0aCkge1xuICByZXR1cm4gcGF0aC5sZW5ndGhcbiAgICA/IHBhdGgucmVkdWNlKGZ1bmN0aW9uIChzdGF0ZSwga2V5KSB7IHJldHVybiBzdGF0ZVtrZXldOyB9LCBzdGF0ZSlcbiAgICA6IHN0YXRlXG59XG5cbmZ1bmN0aW9uIHVuaWZ5T2JqZWN0U3R5bGUgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgaWYgKGlzT2JqZWN0KHR5cGUpICYmIHR5cGUudHlwZSkge1xuICAgIG9wdGlvbnMgPSBwYXlsb2FkO1xuICAgIHBheWxvYWQgPSB0eXBlO1xuICAgIHR5cGUgPSB0eXBlLnR5cGU7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycsIChcIkV4cGVjdHMgc3RyaW5nIGFzIHRoZSB0eXBlLCBidXQgZm91bmQgXCIgKyAodHlwZW9mIHR5cGUpICsgXCIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQsIG9wdGlvbnM6IG9wdGlvbnMgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsIChfVnVlKSB7XG4gIGlmIChWdWUgJiYgX1Z1ZSA9PT0gVnVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgVnVlID0gX1Z1ZTtcbiAgYXBwbHlNaXhpbihWdWUpO1xufVxuXG52YXIgbWFwU3RhdGUgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgc3RhdGVzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKHN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZFN0YXRlICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHN0b3JlLnN0YXRlO1xuICAgICAgdmFyIGdldHRlcnMgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBTdGF0ZScsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBtb2R1bGUuY29udGV4dC5zdGF0ZTtcbiAgICAgICAgZ2V0dGVycyA9IG1vZHVsZS5jb250ZXh0LmdldHRlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5jYWxsKHRoaXMsIHN0YXRlLCBnZXR0ZXJzKVxuICAgICAgICA6IHN0YXRlW3ZhbF1cbiAgICB9O1xuICAgIC8vIG1hcmsgdnVleCBnZXR0ZXIgZm9yIGRldnRvb2xzXG4gICAgcmVzW2tleV0udnVleCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIG1hcE11dGF0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBtdXRhdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAobXV0YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkTXV0YXRpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIHZhciBjb21taXQgPSB0aGlzLiRzdG9yZS5jb21taXQ7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcE11dGF0aW9ucycsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY29tbWl0ID0gbW9kdWxlLmNvbnRleHQuY29tbWl0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB2YWwuYXBwbHkodGhpcywgW2NvbW1pdF0uY29uY2F0KGFyZ3MpKVxuICAgICAgICA6IGNvbW1pdC5hcHBseSh0aGlzLiRzdG9yZSwgW3ZhbF0uY29uY2F0KGFyZ3MpKVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIG1hcEdldHRlcnMgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgZ2V0dGVycykge1xuICB2YXIgcmVzID0ge307XG4gIG5vcm1hbGl6ZU1hcChnZXR0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHZhbCA9IG5hbWVzcGFjZSArIHZhbDtcbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZEdldHRlciAoKSB7XG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEdldHRlcnMnLCBuYW1lc3BhY2UpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgISh2YWwgaW4gdGhpcy4kc3RvcmUuZ2V0dGVycykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBnZXR0ZXI6IFwiICsgdmFsKSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwQWN0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBhY3Rpb25zKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRBY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIHZhciBkaXNwYXRjaCA9IHRoaXMuJHN0b3JlLmRpc3BhdGNoO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBBY3Rpb25zJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCA9IG1vZHVsZS5jb250ZXh0LmRpc3BhdGNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB2YWwuYXBwbHkodGhpcywgW2Rpc3BhdGNoXS5jb25jYXQoYXJncykpXG4gICAgICAgIDogZGlzcGF0Y2guYXBwbHkodGhpcy4kc3RvcmUsIFt2YWxdLmNvbmNhdChhcmdzKSlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbnZhciBjcmVhdGVOYW1lc3BhY2VkSGVscGVycyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UpIHsgcmV0dXJuICh7XG4gIG1hcFN0YXRlOiBtYXBTdGF0ZS5iaW5kKG51bGwsIG5hbWVzcGFjZSksXG4gIG1hcEdldHRlcnM6IG1hcEdldHRlcnMuYmluZChudWxsLCBuYW1lc3BhY2UpLFxuICBtYXBNdXRhdGlvbnM6IG1hcE11dGF0aW9ucy5iaW5kKG51bGwsIG5hbWVzcGFjZSksXG4gIG1hcEFjdGlvbnM6IG1hcEFjdGlvbnMuYmluZChudWxsLCBuYW1lc3BhY2UpXG59KTsgfTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTWFwIChtYXApIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobWFwKVxuICAgID8gbWFwLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoeyBrZXk6IGtleSwgdmFsOiBrZXkgfSk7IH0pXG4gICAgOiBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoeyBrZXk6IGtleSwgdmFsOiBtYXBba2V5XSB9KTsgfSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZXNwYWNlIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWFwKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICBtYXAgPSBuYW1lc3BhY2U7XG4gICAgICBuYW1lc3BhY2UgPSAnJztcbiAgICB9IGVsc2UgaWYgKG5hbWVzcGFjZS5jaGFyQXQobmFtZXNwYWNlLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgIG5hbWVzcGFjZSArPSAnLyc7XG4gICAgfVxuICAgIHJldHVybiBmbihuYW1lc3BhY2UsIG1hcClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNb2R1bGVCeU5hbWVzcGFjZSAoc3RvcmUsIGhlbHBlciwgbmFtZXNwYWNlKSB7XG4gIHZhciBtb2R1bGUgPSBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcFtuYW1lc3BhY2VdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhbW9kdWxlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gbW9kdWxlIG5hbWVzcGFjZSBub3QgZm91bmQgaW4gXCIgKyBoZWxwZXIgKyBcIigpOiBcIiArIG5hbWVzcGFjZSkpO1xuICB9XG4gIHJldHVybiBtb2R1bGVcbn1cblxudmFyIGluZGV4X2VzbSA9IHtcbiAgU3RvcmU6IFN0b3JlLFxuICBpbnN0YWxsOiBpbnN0YWxsLFxuICB2ZXJzaW9uOiAnMy4wLjEnLFxuICBtYXBTdGF0ZTogbWFwU3RhdGUsXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLFxuICBtYXBHZXR0ZXJzOiBtYXBHZXR0ZXJzLFxuICBtYXBBY3Rpb25zOiBtYXBBY3Rpb25zLFxuICBjcmVhdGVOYW1lc3BhY2VkSGVscGVyczogY3JlYXRlTmFtZXNwYWNlZEhlbHBlcnNcbn07XG5cbmV4cG9ydCB7IFN0b3JlLCBpbnN0YWxsLCBtYXBTdGF0ZSwgbWFwTXV0YXRpb25zLCBtYXBHZXR0ZXJzLCBtYXBBY3Rpb25zLCBjcmVhdGVOYW1lc3BhY2VkSGVscGVycyB9O1xuZXhwb3J0IGRlZmF1bHQgaW5kZXhfZXNtO1xuIiwiLyoqXG4gICogdnVlLXJvdXRlciB2My4wLjFcbiAgKiAoYykgMjAxNyBFdmFuIFlvdVxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuLyogICovXG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm4gKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZGl0aW9uKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFcnJvciAoZXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKS5pbmRleE9mKCdFcnJvcicpID4gLTFcbn1cblxudmFyIFZpZXcgPSB7XG4gIG5hbWU6ICdyb3V0ZXItdmlldycsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoXywgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuXG4gICAgZGF0YS5yb3V0ZXJWaWV3ID0gdHJ1ZTtcblxuICAgIC8vIGRpcmVjdGx5IHVzZSBwYXJlbnQgY29udGV4dCdzIGNyZWF0ZUVsZW1lbnQoKSBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgY29tcG9uZW50cyByZW5kZXJlZCBieSByb3V0ZXItdmlldyBjYW4gcmVzb2x2ZSBuYW1lZCBzbG90c1xuICAgIHZhciBoID0gcGFyZW50LiRjcmVhdGVFbGVtZW50O1xuICAgIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgICB2YXIgcm91dGUgPSBwYXJlbnQuJHJvdXRlO1xuICAgIHZhciBjYWNoZSA9IHBhcmVudC5fcm91dGVyVmlld0NhY2hlIHx8IChwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSA9IHt9KTtcblxuICAgIC8vIGRldGVybWluZSBjdXJyZW50IHZpZXcgZGVwdGgsIGFsc28gY2hlY2sgdG8gc2VlIGlmIHRoZSB0cmVlXG4gICAgLy8gaGFzIGJlZW4gdG9nZ2xlZCBpbmFjdGl2ZSBidXQga2VwdC1hbGl2ZS5cbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBpbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Ll9yb3V0ZXJSb290ICE9PSBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuJHZub2RlICYmIHBhcmVudC4kdm5vZGUuZGF0YS5yb3V0ZXJWaWV3KSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Ll9pbmFjdGl2ZSkge1xuICAgICAgICBpbmFjdGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgZGF0YS5yb3V0ZXJWaWV3RGVwdGggPSBkZXB0aDtcblxuICAgIC8vIHJlbmRlciBwcmV2aW91cyB2aWV3IGlmIHRoZSB0cmVlIGlzIGluYWN0aXZlIGFuZCBrZXB0LWFsaXZlXG4gICAgaWYgKGluYWN0aXZlKSB7XG4gICAgICByZXR1cm4gaChjYWNoZVtuYW1lXSwgZGF0YSwgY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWQgPSByb3V0ZS5tYXRjaGVkW2RlcHRoXTtcbiAgICAvLyByZW5kZXIgZW1wdHkgbm9kZSBpZiBubyBtYXRjaGVkIHJvdXRlXG4gICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICBjYWNoZVtuYW1lXSA9IG51bGw7XG4gICAgICByZXR1cm4gaCgpXG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudCA9IGNhY2hlW25hbWVdID0gbWF0Y2hlZC5jb21wb25lbnRzW25hbWVdO1xuXG4gICAgLy8gYXR0YWNoIGluc3RhbmNlIHJlZ2lzdHJhdGlvbiBob29rXG4gICAgLy8gdGhpcyB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBpbmplY3RlZCBsaWZlY3ljbGUgaG9va3NcbiAgICBkYXRhLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgdmFsKSB7XG4gICAgICAvLyB2YWwgY291bGQgYmUgdW5kZWZpbmVkIGZvciB1bnJlZ2lzdHJhdGlvblxuICAgICAgdmFyIGN1cnJlbnQgPSBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgKHZhbCAmJiBjdXJyZW50ICE9PSB2bSkgfHxcbiAgICAgICAgKCF2YWwgJiYgY3VycmVudCA9PT0gdm0pXG4gICAgICApIHtcbiAgICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWxzbyByZWdpc3RlciBpbnN0YW5jZSBpbiBwcmVwYXRjaCBob29rXG4gICAgLy8gaW4gY2FzZSB0aGUgc2FtZSBjb21wb25lbnQgaW5zdGFuY2UgaXMgcmV1c2VkIGFjcm9zcyBkaWZmZXJlbnQgcm91dGVzXG4gICAgOyhkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KSkucHJlcGF0Y2ggPSBmdW5jdGlvbiAoXywgdm5vZGUpIHtcbiAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgfTtcblxuICAgIC8vIHJlc29sdmUgcHJvcHNcbiAgICB2YXIgcHJvcHNUb1Bhc3MgPSBkYXRhLnByb3BzID0gcmVzb2x2ZVByb3BzKHJvdXRlLCBtYXRjaGVkLnByb3BzICYmIG1hdGNoZWQucHJvcHNbbmFtZV0pO1xuICAgIGlmIChwcm9wc1RvUGFzcykge1xuICAgICAgLy8gY2xvbmUgdG8gcHJldmVudCBtdXRhdGlvblxuICAgICAgcHJvcHNUb1Bhc3MgPSBkYXRhLnByb3BzID0gZXh0ZW5kKHt9LCBwcm9wc1RvUGFzcyk7XG4gICAgICAvLyBwYXNzIG5vbi1kZWNsYXJlZCBwcm9wcyBhcyBhdHRyc1xuICAgICAgdmFyIGF0dHJzID0gZGF0YS5hdHRycyA9IGRhdGEuYXR0cnMgfHwge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHNUb1Bhc3MpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQucHJvcHMgfHwgIShrZXkgaW4gY29tcG9uZW50LnByb3BzKSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSBwcm9wc1RvUGFzc1trZXldO1xuICAgICAgICAgIGRlbGV0ZSBwcm9wc1RvUGFzc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGgoY29tcG9uZW50LCBkYXRhLCBjaGlsZHJlbilcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVByb3BzIChyb3V0ZSwgY29uZmlnKSB7XG4gIHN3aXRjaCAodHlwZW9mIGNvbmZpZykge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBjb25maWcocm91dGUpXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY29uZmlnID8gcm91dGUucGFyYW1zIDogdW5kZWZpbmVkXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJwcm9wcyBpbiBcXFwiXCIgKyAocm91dGUucGF0aCkgKyBcIlxcXCIgaXMgYSBcIiArICh0eXBlb2YgY29uZmlnKSArIFwiLCBcIiArXG4gICAgICAgICAgXCJleHBlY3RpbmcgYW4gb2JqZWN0LCBmdW5jdGlvbiBvciBib29sZWFuLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0ZW5kICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qICAqL1xuXG52YXIgZW5jb2RlUmVzZXJ2ZVJFID0gL1shJygpKl0vZztcbnZhciBlbmNvZGVSZXNlcnZlUmVwbGFjZXIgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTsgfTtcbnZhciBjb21tYVJFID0gLyUyQy9nO1xuXG4vLyBmaXhlZCBlbmNvZGVVUklDb21wb25lbnQgd2hpY2ggaXMgbW9yZSBjb25mb3JtYW50IHRvIFJGQzM5ODY6XG4vLyAtIGVzY2FwZXMgWyEnKCkqXVxuLy8gLSBwcmVzZXJ2ZSBjb21tYXNcbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKVxuICAucmVwbGFjZShlbmNvZGVSZXNlcnZlUkUsIGVuY29kZVJlc2VydmVSZXBsYWNlcilcbiAgLnJlcGxhY2UoY29tbWFSRSwgJywnKTsgfTtcblxudmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXJ5IChcbiAgcXVlcnksXG4gIGV4dHJhUXVlcnksXG4gIF9wYXJzZVF1ZXJ5XG4pIHtcbiAgaWYgKCBleHRyYVF1ZXJ5ID09PSB2b2lkIDAgKSBleHRyYVF1ZXJ5ID0ge307XG5cbiAgdmFyIHBhcnNlID0gX3BhcnNlUXVlcnkgfHwgcGFyc2VRdWVyeTtcbiAgdmFyIHBhcnNlZFF1ZXJ5O1xuICB0cnkge1xuICAgIHBhcnNlZFF1ZXJ5ID0gcGFyc2UocXVlcnkgfHwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBlLm1lc3NhZ2UpO1xuICAgIHBhcnNlZFF1ZXJ5ID0ge307XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGV4dHJhUXVlcnkpIHtcbiAgICBwYXJzZWRRdWVyeVtrZXldID0gZXh0cmFRdWVyeVtrZXldO1xuICB9XG4gIHJldHVybiBwYXJzZWRRdWVyeVxufVxuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5IChxdWVyeSkge1xuICB2YXIgcmVzID0ge307XG5cbiAgcXVlcnkgPSBxdWVyeS50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0cy5zaGlmdCgpKTtcbiAgICB2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMFxuICAgICAgPyBkZWNvZGUocGFydHMuam9pbignPScpKVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKHJlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc1trZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXNba2V5XSkpIHtcbiAgICAgIHJlc1trZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2tleV0gPSBbcmVzW2tleV0sIHZhbF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5IChvYmopIHtcbiAgdmFyIHJlcyA9IG9iaiA/IE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoa2V5KVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfSkuam9pbignJicpIDogbnVsbDtcbiAgcmV0dXJuIHJlcyA/IChcIj9cIiArIHJlcykgOiAnJ1xufVxuXG4vKiAgKi9cblxuXG52YXIgdHJhaWxpbmdTbGFzaFJFID0gL1xcLz8kLztcblxuZnVuY3Rpb24gY3JlYXRlUm91dGUgKFxuICByZWNvcmQsXG4gIGxvY2F0aW9uLFxuICByZWRpcmVjdGVkRnJvbSxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHN0cmluZ2lmeVF1ZXJ5JCQxID0gcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuXG4gIHZhciBxdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5IHx8IHt9O1xuICB0cnkge1xuICAgIHF1ZXJ5ID0gY2xvbmUocXVlcnkpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByb3V0ZSA9IHtcbiAgICBuYW1lOiBsb2NhdGlvbi5uYW1lIHx8IChyZWNvcmQgJiYgcmVjb3JkLm5hbWUpLFxuICAgIG1ldGE6IChyZWNvcmQgJiYgcmVjb3JkLm1ldGEpIHx8IHt9LFxuICAgIHBhdGg6IGxvY2F0aW9uLnBhdGggfHwgJy8nLFxuICAgIGhhc2g6IGxvY2F0aW9uLmhhc2ggfHwgJycsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHBhcmFtczogbG9jYXRpb24ucGFyYW1zIHx8IHt9LFxuICAgIGZ1bGxQYXRoOiBnZXRGdWxsUGF0aChsb2NhdGlvbiwgc3RyaW5naWZ5UXVlcnkkJDEpLFxuICAgIG1hdGNoZWQ6IHJlY29yZCA/IGZvcm1hdE1hdGNoKHJlY29yZCkgOiBbXVxuICB9O1xuICBpZiAocmVkaXJlY3RlZEZyb20pIHtcbiAgICByb3V0ZS5yZWRpcmVjdGVkRnJvbSA9IGdldEZ1bGxQYXRoKHJlZGlyZWN0ZWRGcm9tLCBzdHJpbmdpZnlRdWVyeSQkMSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUocm91dGUpXG59XG5cbmZ1bmN0aW9uIGNsb25lICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKGNsb25lKVxuICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICByZXNba2V5XSA9IGNsb25lKHZhbHVlW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cblxuLy8gdGhlIHN0YXJ0aW5nIHJvdXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5pdGlhbCBzdGF0ZVxudmFyIFNUQVJUID0gY3JlYXRlUm91dGUobnVsbCwge1xuICBwYXRoOiAnLydcbn0pO1xuXG5mdW5jdGlvbiBmb3JtYXRNYXRjaCAocmVjb3JkKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgd2hpbGUgKHJlY29yZCkge1xuICAgIHJlcy51bnNoaWZ0KHJlY29yZCk7XG4gICAgcmVjb3JkID0gcmVjb3JkLnBhcmVudDtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoIChcbiAgcmVmLFxuICBfc3RyaW5naWZ5UXVlcnlcbikge1xuICB2YXIgcGF0aCA9IHJlZi5wYXRoO1xuICB2YXIgcXVlcnkgPSByZWYucXVlcnk7IGlmICggcXVlcnkgPT09IHZvaWQgMCApIHF1ZXJ5ID0ge307XG4gIHZhciBoYXNoID0gcmVmLmhhc2g7IGlmICggaGFzaCA9PT0gdm9pZCAwICkgaGFzaCA9ICcnO1xuXG4gIHZhciBzdHJpbmdpZnkgPSBfc3RyaW5naWZ5UXVlcnkgfHwgc3RyaW5naWZ5UXVlcnk7XG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgc3RyaW5naWZ5KHF1ZXJ5KSArIGhhc2hcbn1cblxuZnVuY3Rpb24gaXNTYW1lUm91dGUgKGEsIGIpIHtcbiAgaWYgKGIgPT09IFNUQVJUKSB7XG4gICAgcmV0dXJuIGEgPT09IGJcbiAgfSBlbHNlIGlmICghYikge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGEucGF0aCAmJiBiLnBhdGgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgPT09IGIucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpICYmXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnF1ZXJ5LCBiLnF1ZXJ5KVxuICAgIClcbiAgfSBlbHNlIGlmIChhLm5hbWUgJiYgYi5uYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEubmFtZSA9PT0gYi5uYW1lICYmXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnF1ZXJ5LCBiLnF1ZXJ5KSAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnBhcmFtcywgYi5wYXJhbXMpXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0RXF1YWwgKGEsIGIpIHtcbiAgaWYgKCBhID09PSB2b2lkIDAgKSBhID0ge307XG4gIGlmICggYiA9PT0gdm9pZCAwICkgYiA9IHt9O1xuXG4gIC8vIGhhbmRsZSBudWxsIHZhbHVlICMxNTY2XG4gIGlmICghYSB8fCAhYikgeyByZXR1cm4gYSA9PT0gYiB9XG4gIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgYVZhbCA9IGFba2V5XTtcbiAgICB2YXIgYlZhbCA9IGJba2V5XTtcbiAgICAvLyBjaGVjayBuZXN0ZWQgZXF1YWxpdHlcbiAgICBpZiAodHlwZW9mIGFWYWwgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiVmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0RXF1YWwoYVZhbCwgYlZhbClcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhVmFsKSA9PT0gU3RyaW5nKGJWYWwpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzSW5jbHVkZWRSb3V0ZSAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiAoXG4gICAgY3VycmVudC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpLmluZGV4T2YoXG4gICAgICB0YXJnZXQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKVxuICAgICkgPT09IDAgJiZcbiAgICAoIXRhcmdldC5oYXNoIHx8IGN1cnJlbnQuaGFzaCA9PT0gdGFyZ2V0Lmhhc2gpICYmXG4gICAgcXVlcnlJbmNsdWRlcyhjdXJyZW50LnF1ZXJ5LCB0YXJnZXQucXVlcnkpXG4gIClcbn1cblxuZnVuY3Rpb24gcXVlcnlJbmNsdWRlcyAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBpZiAoIShrZXkgaW4gY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKiAgKi9cblxuLy8gd29yayBhcm91bmQgd2VpcmQgZmxvdyBidWdcbnZhciB0b1R5cGVzID0gW1N0cmluZywgT2JqZWN0XTtcbnZhciBldmVudFR5cGVzID0gW1N0cmluZywgQXJyYXldO1xuXG52YXIgTGluayA9IHtcbiAgbmFtZTogJ3JvdXRlci1saW5rJyxcbiAgcHJvcHM6IHtcbiAgICB0bzoge1xuICAgICAgdHlwZTogdG9UeXBlcyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdhJ1xuICAgIH0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IGV2ZW50VHlwZXMsXG4gICAgICBkZWZhdWx0OiAnY2xpY2snXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuJHJvdXRlcjtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuJHJvdXRlO1xuICAgIHZhciByZWYgPSByb3V0ZXIucmVzb2x2ZSh0aGlzLnRvLCBjdXJyZW50LCB0aGlzLmFwcGVuZCk7XG4gICAgdmFyIGxvY2F0aW9uID0gcmVmLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZSA9IHJlZi5yb3V0ZTtcbiAgICB2YXIgaHJlZiA9IHJlZi5ocmVmO1xuXG4gICAgdmFyIGNsYXNzZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsQWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rRXhhY3RBY3RpdmVDbGFzcztcbiAgICAvLyBTdXBwb3J0IGdsb2JhbCBlbXB0eSBhY3RpdmUgY2xhc3NcbiAgICB2YXIgYWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gJ3JvdXRlci1saW5rLWFjdGl2ZSdcbiAgICAgICAgICAgIDogZ2xvYmFsQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyAncm91dGVyLWxpbmstZXhhY3QtYWN0aXZlJ1xuICAgICAgICAgICAgOiBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzO1xuICAgIHZhciBhY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyBhY3RpdmVDbGFzc0ZhbGxiYWNrXG4gICAgICAgICAgICA6IHRoaXMuYWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3MgPSB0aGlzLmV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2tcbiAgICAgICAgICAgIDogdGhpcy5leGFjdEFjdGl2ZUNsYXNzO1xuICAgIHZhciBjb21wYXJlVGFyZ2V0ID0gbG9jYXRpb24ucGF0aFxuICAgICAgPyBjcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKVxuICAgICAgOiByb3V0ZTtcblxuICAgIGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc10gPSBpc1NhbWVSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcbiAgICBjbGFzc2VzW2FjdGl2ZUNsYXNzXSA9IHRoaXMuZXhhY3RcbiAgICAgID8gY2xhc3Nlc1tleGFjdEFjdGl2ZUNsYXNzXVxuICAgICAgOiBpc0luY2x1ZGVkUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZ3VhcmRFdmVudChlKSkge1xuICAgICAgICBpZiAodGhpcyQxLnJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXIucmVwbGFjZShsb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyLnB1c2gobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvbiA9IHsgY2xpY2s6IGd1YXJkRXZlbnQgfTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmV2ZW50KSkge1xuICAgICAgdGhpcy5ldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IG9uW2VdID0gaGFuZGxlcjsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uW3RoaXMuZXZlbnRdID0gaGFuZGxlcjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGNsYXNzOiBjbGFzc2VzXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnRhZyA9PT0gJ2EnKSB7XG4gICAgICBkYXRhLm9uID0gb247XG4gICAgICBkYXRhLmF0dHJzID0geyBocmVmOiBocmVmIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IDxhPiBjaGlsZCBhbmQgYXBwbHkgbGlzdGVuZXIgYW5kIGhyZWZcbiAgICAgIHZhciBhID0gZmluZEFuY2hvcih0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIDxhPiBpcyBhIHN0YXRpYyBub2RlXG4gICAgICAgIGEuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4dGVuZCA9IF9WdWUudXRpbC5leHRlbmQ7XG4gICAgICAgIHZhciBhRGF0YSA9IGEuZGF0YSA9IGV4dGVuZCh7fSwgYS5kYXRhKTtcbiAgICAgICAgYURhdGEub24gPSBvbjtcbiAgICAgICAgdmFyIGFBdHRycyA9IGEuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYS5kYXRhLmF0dHJzKTtcbiAgICAgICAgYUF0dHJzLmhyZWYgPSBocmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIDxhPiBjaGlsZCwgYXBwbHkgbGlzdGVuZXIgdG8gc2VsZlxuICAgICAgICBkYXRhLm9uID0gb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGhpcy50YWcsIGRhdGEsIHRoaXMuJHNsb3RzLmRlZmF1bHQpXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGd1YXJkRXZlbnQgKGUpIHtcbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2l0aCBjb250cm9sIGtleXNcbiAgaWYgKGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCB3aGVuIHByZXZlbnREZWZhdWx0IGNhbGxlZFxuICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IG9uIHJpZ2h0IGNsaWNrXG4gIGlmIChlLmJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9uICE9PSAwKSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IGlmIGB0YXJnZXQ9XCJfYmxhbmtcImBcbiAgaWYgKGUuY3VycmVudFRhcmdldCAmJiBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKSB7XG4gICAgdmFyIHRhcmdldCA9IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgIGlmICgvXFxiX2JsYW5rXFxiL2kudGVzdCh0YXJnZXQpKSB7IHJldHVybiB9XG4gIH1cbiAgLy8gdGhpcyBtYXkgYmUgYSBXZWV4IGV2ZW50IHdoaWNoIGRvZXNuJ3QgaGF2ZSB0aGlzIG1ldGhvZFxuICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaW5kQW5jaG9yIChjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgY2hpbGQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICdhJykge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbiAmJiAoY2hpbGQgPSBmaW5kQW5jaG9yKGNoaWxkLmNoaWxkcmVuKSkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBfVnVlO1xuXG5mdW5jdGlvbiBpbnN0YWxsIChWdWUpIHtcbiAgaWYgKGluc3RhbGwuaW5zdGFsbGVkICYmIF9WdWUgPT09IFZ1ZSkgeyByZXR1cm4gfVxuICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWU7XG5cbiAgX1Z1ZSA9IFZ1ZTtcblxuICB2YXIgaXNEZWYgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9O1xuXG4gIHZhciByZWdpc3Rlckluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCBjYWxsVmFsKSB7XG4gICAgdmFyIGkgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gICAgaWYgKGlzRGVmKGkpICYmIGlzRGVmKGkgPSBpLmRhdGEpICYmIGlzRGVmKGkgPSBpLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSkpIHtcbiAgICAgIGkodm0sIGNhbGxWYWwpO1xuICAgIH1cbiAgfTtcblxuICBWdWUubWl4aW4oe1xuICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlICgpIHtcbiAgICAgIGlmIChpc0RlZih0aGlzLiRvcHRpb25zLnJvdXRlcikpIHtcbiAgICAgICAgdGhpcy5fcm91dGVyUm9vdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IHRoaXMuJG9wdGlvbnMucm91dGVyO1xuICAgICAgICB0aGlzLl9yb3V0ZXIuaW5pdCh0aGlzKTtcbiAgICAgICAgVnVlLnV0aWwuZGVmaW5lUmVhY3RpdmUodGhpcywgJ19yb3V0ZScsIHRoaXMuX3JvdXRlci5oaXN0b3J5LmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcm91dGVyUm9vdCA9ICh0aGlzLiRwYXJlbnQgJiYgdGhpcy4kcGFyZW50Ll9yb3V0ZXJSb290KSB8fCB0aGlzO1xuICAgICAgfVxuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCB0aGlzKTtcbiAgICB9LFxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcyk7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyUm9vdC5fcm91dGVyIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyUm9vdC5fcm91dGUgfVxuICB9KTtcblxuICBWdWUuY29tcG9uZW50KCdyb3V0ZXItdmlldycsIFZpZXcpO1xuICBWdWUuY29tcG9uZW50KCdyb3V0ZXItbGluaycsIExpbmspO1xuXG4gIHZhciBzdHJhdHMgPSBWdWUuY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcbiAgLy8gdXNlIHRoZSBzYW1lIGhvb2sgbWVyZ2luZyBzdHJhdGVneSBmb3Igcm91dGUgaG9va3NcbiAgc3RyYXRzLmJlZm9yZVJvdXRlRW50ZXIgPSBzdHJhdHMuYmVmb3JlUm91dGVMZWF2ZSA9IHN0cmF0cy5iZWZvcmVSb3V0ZVVwZGF0ZSA9IHN0cmF0cy5jcmVhdGVkO1xufVxuXG4vKiAgKi9cblxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGggKFxuICByZWxhdGl2ZSxcbiAgYmFzZSxcbiAgYXBwZW5kXG4pIHtcbiAgdmFyIGZpcnN0Q2hhciA9IHJlbGF0aXZlLmNoYXJBdCgwKTtcbiAgaWYgKGZpcnN0Q2hhciA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlXG4gIH1cblxuICBpZiAoZmlyc3RDaGFyID09PSAnPycgfHwgZmlyc3RDaGFyID09PSAnIycpIHtcbiAgICByZXR1cm4gYmFzZSArIHJlbGF0aXZlXG4gIH1cblxuICB2YXIgc3RhY2sgPSBiYXNlLnNwbGl0KCcvJyk7XG5cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlZ21lbnQgaWY6XG4gIC8vIC0gbm90IGFwcGVuZGluZ1xuICAvLyAtIGFwcGVuZGluZyB0byB0cmFpbGluZyBzbGFzaCAobGFzdCBzZWdtZW50IGlzIGVtcHR5KVxuICBpZiAoIWFwcGVuZCB8fCAhc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8vIHJlc29sdmUgcmVsYXRpdmUgcGF0aFxuICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09ICcuJykge1xuICAgICAgc3RhY2sucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBlbnN1cmUgbGVhZGluZyBzbGFzaFxuICBpZiAoc3RhY2tbMF0gIT09ICcnKSB7XG4gICAgc3RhY2sudW5zaGlmdCgnJyk7XG4gIH1cblxuICByZXR1cm4gc3RhY2suam9pbignLycpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICB2YXIgaGFzaCA9ICcnO1xuICB2YXIgcXVlcnkgPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgIGhhc2ggPSBwYXRoLnNsaWNlKGhhc2hJbmRleCk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxdWVyeUluZGV4ID49IDApIHtcbiAgICBxdWVyeSA9IHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHF1ZXJ5SW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5QYXRoIChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycpXG59XG5cbnZhciBpc2FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbnZhciBwYXRoVG9SZWdleHBfMSA9IHBhdGhUb1JlZ2V4cDtcbnZhciBwYXJzZV8xID0gcGFyc2U7XG52YXIgY29tcGlsZV8xID0gY29tcGlsZTtcbnZhciB0b2tlbnNUb0Z1bmN0aW9uXzEgPSB0b2tlbnNUb0Z1bmN0aW9uO1xudmFyIHRva2Vuc1RvUmVnRXhwXzEgPSB0b2tlbnNUb1JlZ0V4cDtcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIga2V5ID0gMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHBhdGggPSAnJztcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJztcbiAgdmFyIHJlcztcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdO1xuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdO1xuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXg7XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldCk7XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aDtcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV07XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XTtcbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdO1xuICAgIHZhciBuYW1lID0gcmVzWzNdO1xuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdO1xuICAgIHZhciBncm91cCA9IHJlc1s1XTtcbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl07XG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddO1xuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gICAgICBwYXRoID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4O1xuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlcjtcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXA7XG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KTtcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aCk7XG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnO1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9O1xuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuO1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XG4gICAgICB2YXIgc2VnbWVudDtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSk7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKTtcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5cztcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSk7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlO1xuICB2YXIgcm91dGUgPSAnJztcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeCk7XG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJztcblxuICAgICAga2V5cy5wdXNoKHRva2VuKTtcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJztcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJyk7XG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyO1xuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nO1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJztcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaXNhcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cblxucGF0aFRvUmVnZXhwXzEucGFyc2UgPSBwYXJzZV8xO1xucGF0aFRvUmVnZXhwXzEuY29tcGlsZSA9IGNvbXBpbGVfMTtcbnBhdGhUb1JlZ2V4cF8xLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXzE7XG5wYXRoVG9SZWdleHBfMS50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXzE7XG5cbi8qICAqL1xuXG4vLyAkZmxvdy1kaXNhYmxlLWxpbmVcbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBmaWxsUGFyYW1zIChcbiAgcGF0aCxcbiAgcGFyYW1zLFxuICByb3V0ZU1zZ1xuKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZpbGxlciA9XG4gICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcbiAgICAgIChyZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gPSBwYXRoVG9SZWdleHBfMS5jb21waWxlKHBhdGgpKTtcbiAgICByZXR1cm4gZmlsbGVyKHBhcmFtcyB8fCB7fSwgeyBwcmV0dHk6IHRydWUgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJtaXNzaW5nIHBhcmFtIGZvciBcIiArIHJvdXRlTXNnICsgXCI6IFwiICsgKGUubWVzc2FnZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTWFwIChcbiAgcm91dGVzLFxuICBvbGRQYXRoTGlzdCxcbiAgb2xkUGF0aE1hcCxcbiAgb2xkTmFtZU1hcFxuKSB7XG4gIC8vIHRoZSBwYXRoIGxpc3QgaXMgdXNlZCB0byBjb250cm9sIHBhdGggbWF0Y2hpbmcgcHJpb3JpdHlcbiAgdmFyIHBhdGhMaXN0ID0gb2xkUGF0aExpc3QgfHwgW107XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgcGF0aE1hcCA9IG9sZFBhdGhNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciBuYW1lTWFwID0gb2xkTmFtZU1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCByb3V0ZSk7XG4gIH0pO1xuXG4gIC8vIGVuc3VyZSB3aWxkY2FyZCByb3V0ZXMgYXJlIGFsd2F5cyBhdCB0aGUgZW5kXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aExpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHBhdGhMaXN0W2ldID09PSAnKicpIHtcbiAgICAgIHBhdGhMaXN0LnB1c2gocGF0aExpc3Quc3BsaWNlKGksIDEpWzBdKTtcbiAgICAgIGwtLTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhMaXN0OiBwYXRoTGlzdCxcbiAgICBwYXRoTWFwOiBwYXRoTWFwLFxuICAgIG5hbWVNYXA6IG5hbWVNYXBcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb3V0ZVJlY29yZCAoXG4gIHBhdGhMaXN0LFxuICBwYXRoTWFwLFxuICBuYW1lTWFwLFxuICByb3V0ZSxcbiAgcGFyZW50LFxuICBtYXRjaEFzXG4pIHtcbiAgdmFyIHBhdGggPSByb3V0ZS5wYXRoO1xuICB2YXIgbmFtZSA9IHJvdXRlLm5hbWU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHBhdGggIT0gbnVsbCwgXCJcXFwicGF0aFxcXCIgaXMgcmVxdWlyZWQgaW4gYSByb3V0ZSBjb25maWd1cmF0aW9uLlwiKTtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlb2Ygcm91dGUuY29tcG9uZW50ICE9PSAnc3RyaW5nJyxcbiAgICAgIFwicm91dGUgY29uZmlnIFxcXCJjb21wb25lbnRcXFwiIGZvciBwYXRoOiBcIiArIChTdHJpbmcocGF0aCB8fCBuYW1lKSkgKyBcIiBjYW5ub3QgYmUgYSBcIiArXG4gICAgICBcInN0cmluZyBpZC4gVXNlIGFuIGFjdHVhbCBjb21wb25lbnQgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cblxuICB2YXIgcGF0aFRvUmVnZXhwT3B0aW9ucyA9IHJvdXRlLnBhdGhUb1JlZ2V4cE9wdGlvbnMgfHwge307XG4gIHZhciBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgoXG4gICAgcGF0aCxcbiAgICBwYXJlbnQsXG4gICAgcGF0aFRvUmVnZXhwT3B0aW9ucy5zdHJpY3RcbiAgKTtcblxuICBpZiAodHlwZW9mIHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09ICdib29sZWFuJykge1xuICAgIHBhdGhUb1JlZ2V4cE9wdGlvbnMuc2Vuc2l0aXZlID0gcm91dGUuY2FzZVNlbnNpdGl2ZTtcbiAgfVxuXG4gIHZhciByZWNvcmQgPSB7XG4gICAgcGF0aDogbm9ybWFsaXplZFBhdGgsXG4gICAgcmVnZXg6IGNvbXBpbGVSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRQYXRoLCBwYXRoVG9SZWdleHBPcHRpb25zKSxcbiAgICBjb21wb25lbnRzOiByb3V0ZS5jb21wb25lbnRzIHx8IHsgZGVmYXVsdDogcm91dGUuY29tcG9uZW50IH0sXG4gICAgaW5zdGFuY2VzOiB7fSxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIG1hdGNoQXM6IG1hdGNoQXMsXG4gICAgcmVkaXJlY3Q6IHJvdXRlLnJlZGlyZWN0LFxuICAgIGJlZm9yZUVudGVyOiByb3V0ZS5iZWZvcmVFbnRlcixcbiAgICBtZXRhOiByb3V0ZS5tZXRhIHx8IHt9LFxuICAgIHByb3BzOiByb3V0ZS5wcm9wcyA9PSBudWxsXG4gICAgICA/IHt9XG4gICAgICA6IHJvdXRlLmNvbXBvbmVudHNcbiAgICAgICAgPyByb3V0ZS5wcm9wc1xuICAgICAgICA6IHsgZGVmYXVsdDogcm91dGUucHJvcHMgfVxuICB9O1xuXG4gIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgIC8vIFdhcm4gaWYgcm91dGUgaXMgbmFtZWQsIGRvZXMgbm90IHJlZGlyZWN0IGFuZCBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLlxuICAgIC8vIElmIHVzZXJzIG5hdmlnYXRlIHRvIHRoaXMgcm91dGUgYnkgbmFtZSwgdGhlIGRlZmF1bHQgY2hpbGQgd2lsbFxuICAgIC8vIG5vdCBiZSByZW5kZXJlZCAoR0ggSXNzdWUgIzYyOSlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHJvdXRlLm5hbWUgJiYgIXJvdXRlLnJlZGlyZWN0ICYmIHJvdXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvXlxcLz8kLy50ZXN0KGNoaWxkLnBhdGgpOyB9KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiTmFtZWQgUm91dGUgJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuIFwiICtcbiAgICAgICAgICBcIldoZW4gbmF2aWdhdGluZyB0byB0aGlzIG5hbWVkIHJvdXRlICg6dG89XFxcIntuYW1lOiAnXCIgKyAocm91dGUubmFtZSkgKyBcIidcXFwiKSwgXCIgK1xuICAgICAgICAgIFwidGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgd2lsbCBub3QgYmUgcmVuZGVyZWQuIFJlbW92ZSB0aGUgbmFtZSBmcm9tIFwiICtcbiAgICAgICAgICBcInRoaXMgcm91dGUgYW5kIHVzZSB0aGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSBmb3IgbmFtZWQgXCIgK1xuICAgICAgICAgIFwibGlua3MgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWF0Y2hBcyA9IG1hdGNoQXNcbiAgICAgICAgPyBjbGVhblBhdGgoKG1hdGNoQXMgKyBcIi9cIiArIChjaGlsZC5wYXRoKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIGNoaWxkLCByZWNvcmQsIGNoaWxkTWF0Y2hBcyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocm91dGUuYWxpYXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBhbGlhc2VzID0gQXJyYXkuaXNBcnJheShyb3V0ZS5hbGlhcylcbiAgICAgID8gcm91dGUuYWxpYXNcbiAgICAgIDogW3JvdXRlLmFsaWFzXTtcblxuICAgIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgIHZhciBhbGlhc1JvdXRlID0ge1xuICAgICAgICBwYXRoOiBhbGlhcyxcbiAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXG4gICAgICB9O1xuICAgICAgYWRkUm91dGVSZWNvcmQoXG4gICAgICAgIHBhdGhMaXN0LFxuICAgICAgICBwYXRoTWFwLFxuICAgICAgICBuYW1lTWFwLFxuICAgICAgICBhbGlhc1JvdXRlLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHJlY29yZC5wYXRoIHx8ICcvJyAvLyBtYXRjaEFzXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFwYXRoTWFwW3JlY29yZC5wYXRoXSkge1xuICAgIHBhdGhMaXN0LnB1c2gocmVjb3JkLnBhdGgpO1xuICAgIHBhdGhNYXBbcmVjb3JkLnBhdGhdID0gcmVjb3JkO1xuICB9XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBpZiAoIW5hbWVNYXBbbmFtZV0pIHtcbiAgICAgIG5hbWVNYXBbbmFtZV0gPSByZWNvcmQ7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFtYXRjaEFzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJEdXBsaWNhdGUgbmFtZWQgcm91dGVzIGRlZmluaXRpb246IFwiICtcbiAgICAgICAgXCJ7IG5hbWU6IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIHBhdGg6IFxcXCJcIiArIChyZWNvcmQucGF0aCkgKyBcIlxcXCIgfVwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21waWxlUm91dGVSZWdleCAocGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucykge1xuICB2YXIgcmVnZXggPSBwYXRoVG9SZWdleHBfMShwYXRoLCBbXSwgcGF0aFRvUmVnZXhwT3B0aW9ucyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJlZ2V4LmtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB3YXJuKCFrZXlzW2tleS5uYW1lXSwgKFwiRHVwbGljYXRlIHBhcmFtIGtleXMgaW4gcm91dGUgd2l0aCBwYXRoOiBcXFwiXCIgKyBwYXRoICsgXCJcXFwiXCIpKTtcbiAgICAgIGtleXNba2V5Lm5hbWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVnZXhcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUGF0aCAocGF0aCwgcGFyZW50LCBzdHJpY3QpIHtcbiAgaWYgKCFzdHJpY3QpIHsgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTsgfVxuICBpZiAocGF0aFswXSA9PT0gJy8nKSB7IHJldHVybiBwYXRoIH1cbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7IHJldHVybiBwYXRoIH1cbiAgcmV0dXJuIGNsZWFuUGF0aCgoKHBhcmVudC5wYXRoKSArIFwiL1wiICsgcGF0aCkpXG59XG5cbi8qICAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICBhcHBlbmQsXG4gIHJvdXRlclxuKSB7XG4gIHZhciBuZXh0ID0gdHlwZW9mIHJhdyA9PT0gJ3N0cmluZycgPyB7IHBhdGg6IHJhdyB9IDogcmF3O1xuICAvLyBuYW1lZCB0YXJnZXRcbiAgaWYgKG5leHQubmFtZSB8fCBuZXh0Ll9ub3JtYWxpemVkKSB7XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIC8vIHJlbGF0aXZlIHBhcmFtc1xuICBpZiAoIW5leHQucGF0aCAmJiBuZXh0LnBhcmFtcyAmJiBjdXJyZW50KSB7XG4gICAgbmV4dCA9IGFzc2lnbih7fSwgbmV4dCk7XG4gICAgbmV4dC5fbm9ybWFsaXplZCA9IHRydWU7XG4gICAgdmFyIHBhcmFtcyA9IGFzc2lnbihhc3NpZ24oe30sIGN1cnJlbnQucGFyYW1zKSwgbmV4dC5wYXJhbXMpO1xuICAgIGlmIChjdXJyZW50Lm5hbWUpIHtcbiAgICAgIG5leHQubmFtZSA9IGN1cnJlbnQubmFtZTtcbiAgICAgIG5leHQucGFyYW1zID0gcGFyYW1zO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5tYXRjaGVkLmxlbmd0aCkge1xuICAgICAgdmFyIHJhd1BhdGggPSBjdXJyZW50Lm1hdGNoZWRbY3VycmVudC5tYXRjaGVkLmxlbmd0aCAtIDFdLnBhdGg7XG4gICAgICBuZXh0LnBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicGF0aCBcIiArIChjdXJyZW50LnBhdGgpKSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCBcInJlbGF0aXZlIHBhcmFtcyBuYXZpZ2F0aW9uIHJlcXVpcmVzIGEgY3VycmVudCByb3V0ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICB2YXIgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChuZXh0LnBhdGggfHwgJycpO1xuICB2YXIgYmFzZVBhdGggPSAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJztcbiAgdmFyIHBhdGggPSBwYXJzZWRQYXRoLnBhdGhcbiAgICA/IHJlc29sdmVQYXRoKHBhcnNlZFBhdGgucGF0aCwgYmFzZVBhdGgsIGFwcGVuZCB8fCBuZXh0LmFwcGVuZClcbiAgICA6IGJhc2VQYXRoO1xuXG4gIHZhciBxdWVyeSA9IHJlc29sdmVRdWVyeShcbiAgICBwYXJzZWRQYXRoLnF1ZXJ5LFxuICAgIG5leHQucXVlcnksXG4gICAgcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnBhcnNlUXVlcnlcbiAgKTtcblxuICB2YXIgaGFzaCA9IG5leHQuaGFzaCB8fCBwYXJzZWRQYXRoLmhhc2g7XG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHtcbiAgICBoYXNoID0gXCIjXCIgKyBoYXNoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduIChhLCBiKSB7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgYVtrZXldID0gYltrZXldO1xuICB9XG4gIHJldHVybiBhXG59XG5cbi8qICAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIgKFxuICByb3V0ZXMsXG4gIHJvdXRlclxuKSB7XG4gIHZhciByZWYgPSBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMpO1xuICB2YXIgcGF0aExpc3QgPSByZWYucGF0aExpc3Q7XG4gIHZhciBwYXRoTWFwID0gcmVmLnBhdGhNYXA7XG4gIHZhciBuYW1lTWFwID0gcmVmLm5hbWVNYXA7XG5cbiAgZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgICBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMsIHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoIChcbiAgICByYXcsXG4gICAgY3VycmVudFJvdXRlLFxuICAgIHJlZGlyZWN0ZWRGcm9tXG4gICkge1xuICAgIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKHJhdywgY3VycmVudFJvdXRlLCBmYWxzZSwgcm91dGVyKTtcbiAgICB2YXIgbmFtZSA9IGxvY2F0aW9uLm5hbWU7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdmFyIHJlY29yZCA9IG5hbWVNYXBbbmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKHJlY29yZCwgKFwiUm91dGUgd2l0aCBuYW1lICdcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3RcIikpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZWNvcmQpIHsgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbikgfVxuICAgICAgdmFyIHBhcmFtTmFtZXMgPSByZWNvcmQucmVnZXgua2V5c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFrZXkub3B0aW9uYWw7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5Lm5hbWU7IH0pO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uLnBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50Um91dGUgJiYgdHlwZW9mIGN1cnJlbnRSb3V0ZS5wYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50Um91dGUucGFyYW1zKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGxvY2F0aW9uLnBhcmFtcykgJiYgcGFyYW1OYW1lcy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgbG9jYXRpb24ucGFyYW1zW2tleV0gPSBjdXJyZW50Um91dGUucGFyYW1zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgbG9jYXRpb24ucGF0aCA9IGZpbGxQYXJhbXMocmVjb3JkLnBhdGgsIGxvY2F0aW9uLnBhcmFtcywgKFwibmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRoKSB7XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoTGlzdFtpXTtcbiAgICAgICAgdmFyIHJlY29yZCQxID0gcGF0aE1hcFtwYXRoXTtcbiAgICAgICAgaWYgKG1hdGNoUm91dGUocmVjb3JkJDEucmVnZXgsIGxvY2F0aW9uLnBhdGgsIGxvY2F0aW9uLnBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCQxLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm8gbWF0Y2hcbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkaXJlY3QgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvblxuICApIHtcbiAgICB2YXIgb3JpZ2luYWxSZWRpcmVjdCA9IHJlY29yZC5yZWRpcmVjdDtcbiAgICB2YXIgcmVkaXJlY3QgPSB0eXBlb2Ygb3JpZ2luYWxSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9yaWdpbmFsUmVkaXJlY3QoY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKSlcbiAgICAgICAgOiBvcmlnaW5hbFJlZGlyZWN0O1xuXG4gICAgaWYgKHR5cGVvZiByZWRpcmVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlZGlyZWN0ID0geyBwYXRoOiByZWRpcmVjdCB9O1xuICAgIH1cblxuICAgIGlmICghcmVkaXJlY3QgfHwgdHlwZW9mIHJlZGlyZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICAgIH1cblxuICAgIHZhciByZSA9IHJlZGlyZWN0O1xuICAgIHZhciBuYW1lID0gcmUubmFtZTtcbiAgICB2YXIgcGF0aCA9IHJlLnBhdGg7XG4gICAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBwYXJhbXMgPSBsb2NhdGlvbi5wYXJhbXM7XG4gICAgcXVlcnkgPSByZS5oYXNPd25Qcm9wZXJ0eSgncXVlcnknKSA/IHJlLnF1ZXJ5IDogcXVlcnk7XG4gICAgaGFzaCA9IHJlLmhhc093blByb3BlcnR5KCdoYXNoJykgPyByZS5oYXNoIDogaGFzaDtcbiAgICBwYXJhbXMgPSByZS5oYXNPd25Qcm9wZXJ0eSgncGFyYW1zJykgPyByZS5wYXJhbXMgOiBwYXJhbXM7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgLy8gcmVzb2x2ZWQgbmFtZWQgZGlyZWN0XG4gICAgICB2YXIgdGFyZ2V0UmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydCh0YXJnZXRSZWNvcmQsIChcInJlZGlyZWN0IGZhaWxlZDogbmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBub3QgZm91bmQuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICB9LCB1bmRlZmluZWQsIGxvY2F0aW9uKVxuICAgIH0gZWxzZSBpZiAocGF0aCkge1xuICAgICAgLy8gMS4gcmVzb2x2ZSByZWxhdGl2ZSByZWRpcmVjdFxuICAgICAgdmFyIHJhd1BhdGggPSByZXNvbHZlUmVjb3JkUGF0aChwYXRoLCByZWNvcmQpO1xuICAgICAgLy8gMi4gcmVzb2x2ZSBwYXJhbXNcbiAgICAgIHZhciByZXNvbHZlZFBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicmVkaXJlY3Qgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIHJhd1BhdGggKyBcIlxcXCJcIikpO1xuICAgICAgLy8gMy4gcmVtYXRjaCB3aXRoIGV4aXN0aW5nIHF1ZXJ5IGFuZCBoYXNoXG4gICAgICByZXR1cm4gbWF0Y2goe1xuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgICAgcGF0aDogcmVzb2x2ZWRQYXRoLFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIGhhc2g6IGhhc2hcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsaWFzIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgbWF0Y2hBc1xuICApIHtcbiAgICB2YXIgYWxpYXNlZFBhdGggPSBmaWxsUGFyYW1zKG1hdGNoQXMsIGxvY2F0aW9uLnBhcmFtcywgKFwiYWxpYXNlZCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgbWF0Y2hBcyArIFwiXFxcIlwiKSk7XG4gICAgdmFyIGFsaWFzZWRNYXRjaCA9IG1hdGNoKHtcbiAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgcGF0aDogYWxpYXNlZFBhdGhcbiAgICB9KTtcbiAgICBpZiAoYWxpYXNlZE1hdGNoKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IGFsaWFzZWRNYXRjaC5tYXRjaGVkO1xuICAgICAgdmFyIGFsaWFzZWRSZWNvcmQgPSBtYXRjaGVkW21hdGNoZWQubGVuZ3RoIC0gMV07XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSBhbGlhc2VkTWF0Y2gucGFyYW1zO1xuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShhbGlhc2VkUmVjb3JkLCBsb2NhdGlvbilcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVSb3V0ZSAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uLFxuICAgIHJlZGlyZWN0ZWRGcm9tXG4gICkge1xuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLnJlZGlyZWN0KSB7XG4gICAgICByZXR1cm4gcmVkaXJlY3QocmVjb3JkLCByZWRpcmVjdGVkRnJvbSB8fCBsb2NhdGlvbilcbiAgICB9XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQubWF0Y2hBcykge1xuICAgICAgcmV0dXJuIGFsaWFzKHJlY29yZCwgbG9jYXRpb24sIHJlY29yZC5tYXRjaEFzKVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20sIHJvdXRlcilcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIGFkZFJvdXRlczogYWRkUm91dGVzXG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZSAoXG4gIHJlZ2V4LFxuICBwYXRoLFxuICBwYXJhbXNcbikge1xuICB2YXIgbSA9IHBhdGgubWF0Y2gocmVnZXgpO1xuXG4gIGlmICghbSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IG0ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIga2V5ID0gcmVnZXgua2V5c1tpIC0gMV07XG4gICAgdmFyIHZhbCA9IHR5cGVvZiBtW2ldID09PSAnc3RyaW5nJyA/IGRlY29kZVVSSUNvbXBvbmVudChtW2ldKSA6IG1baV07XG4gICAgaWYgKGtleSkge1xuICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVjb3JkUGF0aCAocGF0aCwgcmVjb3JkKSB7XG4gIHJldHVybiByZXNvbHZlUGF0aChwYXRoLCByZWNvcmQucGFyZW50ID8gcmVjb3JkLnBhcmVudC5wYXRoIDogJy8nLCB0cnVlKVxufVxuXG4vKiAgKi9cblxuXG52YXIgcG9zaXRpb25TdG9yZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIHNldHVwU2Nyb2xsICgpIHtcbiAgLy8gRml4IGZvciAjMTU4NSBmb3IgRmlyZWZveFxuICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IGdldFN0YXRlS2V5KCkgfSwgJycpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAgIGlmIChlLnN0YXRlICYmIGUuc3RhdGUua2V5KSB7XG4gICAgICBzZXRTdGF0ZUtleShlLnN0YXRlLmtleSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsIChcbiAgcm91dGVyLFxuICB0byxcbiAgZnJvbSxcbiAgaXNQb3Bcbikge1xuICBpZiAoIXJvdXRlci5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiZWhhdmlvciA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICBpZiAoIWJlaGF2aW9yKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydCh0eXBlb2YgYmVoYXZpb3IgPT09ICdmdW5jdGlvbicsIFwic2Nyb2xsQmVoYXZpb3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgLy8gd2FpdCB1bnRpbCByZS1yZW5kZXIgZmluaXNoZXMgYmVmb3JlIHNjcm9sbGluZ1xuICByb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB2YXIgc2hvdWxkU2Nyb2xsID0gYmVoYXZpb3IodG8sIGZyb20sIGlzUG9wID8gcG9zaXRpb24gOiBudWxsKTtcblxuICAgIGlmICghc2hvdWxkU2Nyb2xsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNob3VsZFNjcm9sbC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzaG91bGRTY3JvbGwudGhlbihmdW5jdGlvbiAoc2hvdWxkU2Nyb2xsKSB7XG4gICAgICAgIHNjcm9sbFRvUG9zaXRpb24oKHNob3VsZFNjcm9sbCksIHBvc2l0aW9uKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBhc3NlcnQoZmFsc2UsIGVyci50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcm9sbFRvUG9zaXRpb24oc2hvdWxkU2Nyb2xsLCBwb3NpdGlvbik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uICgpIHtcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XG4gIGlmIChrZXkpIHtcbiAgICBwb3NpdGlvblN0b3JlW2tleV0gPSB7XG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBvc2l0aW9uICgpIHtcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XG4gIGlmIChrZXkpIHtcbiAgICByZXR1cm4gcG9zaXRpb25TdG9yZVtrZXldXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFBvc2l0aW9uIChlbCwgb2Zmc2V0KSB7XG4gIHZhciBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGRvY1JlY3QgPSBkb2NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHg6IGVsUmVjdC5sZWZ0IC0gZG9jUmVjdC5sZWZ0IC0gb2Zmc2V0LngsXG4gICAgeTogZWxSZWN0LnRvcCAtIGRvY1JlY3QudG9wIC0gb2Zmc2V0LnlcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4gaXNOdW1iZXIob2JqLngpIHx8IGlzTnVtYmVyKG9iai55KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgeTogaXNOdW1iZXIob2JqLnkpID8gb2JqLnkgOiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPZmZzZXQgKG9iaikge1xuICByZXR1cm4ge1xuICAgIHg6IGlzTnVtYmVyKG9iai54KSA/IG9iai54IDogMCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBpc051bWJlciAodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHNjcm9sbFRvUG9zaXRpb24gKHNob3VsZFNjcm9sbCwgcG9zaXRpb24pIHtcbiAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIHNob3VsZFNjcm9sbCA9PT0gJ29iamVjdCc7XG4gIGlmIChpc09iamVjdCAmJiB0eXBlb2Ygc2hvdWxkU2Nyb2xsLnNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2hvdWxkU2Nyb2xsLnNlbGVjdG9yKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBzaG91bGRTY3JvbGwub2Zmc2V0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwub2Zmc2V0ID09PSAnb2JqZWN0JyA/IHNob3VsZFNjcm9sbC5vZmZzZXQgOiB7fTtcbiAgICAgIG9mZnNldCA9IG5vcm1hbGl6ZU9mZnNldChvZmZzZXQpO1xuICAgICAgcG9zaXRpb24gPSBnZXRFbGVtZW50UG9zaXRpb24oZWwsIG9mZnNldCk7XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCAmJiBpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgfVxuXG4gIGlmIChwb3NpdGlvbikge1xuICAgIHdpbmRvdy5zY3JvbGxUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHN1cHBvcnRzUHVzaFN0YXRlID0gaW5Ccm93c2VyICYmIChmdW5jdGlvbiAoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmIChcbiAgICAodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiZcbiAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmXG4gICAgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMVxuICApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeVxufSkoKTtcblxuLy8gdXNlIFVzZXIgVGltaW5nIGFwaSAoaWYgcHJlc2VudCkgZm9yIG1vcmUgYWNjdXJhdGUga2V5IHByZWNpc2lvblxudmFyIFRpbWUgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3dcbiAgPyB3aW5kb3cucGVyZm9ybWFuY2VcbiAgOiBEYXRlO1xuXG52YXIgX2tleSA9IGdlbktleSgpO1xuXG5mdW5jdGlvbiBnZW5LZXkgKCkge1xuICByZXR1cm4gVGltZS5ub3coKS50b0ZpeGVkKDMpXG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlS2V5ICgpIHtcbiAgcmV0dXJuIF9rZXlcbn1cblxuZnVuY3Rpb24gc2V0U3RhdGVLZXkgKGtleSkge1xuICBfa2V5ID0ga2V5O1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhdGUgKHVybCwgcmVwbGFjZSkge1xuICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgLy8gdHJ5Li4uY2F0Y2ggdGhlIHB1c2hTdGF0ZSBjYWxsIHRvIGdldCBhcm91bmQgU2FmYXJpXG4gIC8vIERPTSBFeGNlcHRpb24gMTggd2hlcmUgaXQgbGltaXRzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHNcbiAgdmFyIGhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdHJ5IHtcbiAgICBpZiAocmVwbGFjZSkge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9rZXkgPSBnZW5LZXkoKTtcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbltyZXBsYWNlID8gJ3JlcGxhY2UnIDogJ2Fzc2lnbiddKHVybCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZVN0YXRlICh1cmwpIHtcbiAgcHVzaFN0YXRlKHVybCwgdHJ1ZSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBydW5RdWV1ZSAocXVldWUsIGZuLCBjYikge1xuICB2YXIgc3RlcCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChxdWV1ZVtpbmRleF0pIHtcbiAgICAgICAgZm4ocXVldWVbaW5kZXhdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0ZXAoMCk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnRzIChtYXRjaGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodG8sIGZyb20sIG5leHQpIHtcbiAgICB2YXIgaGFzQXN5bmMgPSBmYWxzZTtcbiAgICB2YXIgcGVuZGluZyA9IDA7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcblxuICAgIGZsYXRNYXBDb21wb25lbnRzKG1hdGNoZWQsIGZ1bmN0aW9uIChkZWYsIF8sIG1hdGNoLCBrZXkpIHtcbiAgICAgIC8vIGlmIGl0J3MgYSBmdW5jdGlvbiBhbmQgZG9lc24ndCBoYXZlIGNpZCBhdHRhY2hlZCxcbiAgICAgIC8vIGFzc3VtZSBpdCdzIGFuIGFzeW5jIGNvbXBvbmVudCByZXNvbHZlIGZ1bmN0aW9uLlxuICAgICAgLy8gd2UgYXJlIG5vdCB1c2luZyBWdWUncyBkZWZhdWx0IGFzeW5jIHJlc29sdmluZyBtZWNoYW5pc20gYmVjYXVzZVxuICAgICAgLy8gd2Ugd2FudCB0byBoYWx0IHRoZSBuYXZpZ2F0aW9uIHVudGlsIHRoZSBpbmNvbWluZyBjb21wb25lbnQgaGFzIGJlZW5cbiAgICAgIC8vIHJlc29sdmVkLlxuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZGVmLmNpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhhc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgcGVuZGluZysrO1xuXG4gICAgICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzb2x2ZWREZWYpIHtcbiAgICAgICAgICBpZiAoaXNFU01vZHVsZShyZXNvbHZlZERlZikpIHtcbiAgICAgICAgICAgIHJlc29sdmVkRGVmID0gcmVzb2x2ZWREZWYuZGVmYXVsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc2F2ZSByZXNvbHZlZCBvbiBhc3luYyBmYWN0b3J5IGluIGNhc2UgaXQncyB1c2VkIGVsc2V3aGVyZVxuICAgICAgICAgIGRlZi5yZXNvbHZlZCA9IHR5cGVvZiByZXNvbHZlZERlZiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyByZXNvbHZlZERlZlxuICAgICAgICAgICAgOiBfVnVlLmV4dGVuZChyZXNvbHZlZERlZik7XG4gICAgICAgICAgbWF0Y2guY29tcG9uZW50c1trZXldID0gcmVzb2x2ZWREZWY7XG4gICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgIGlmIChwZW5kaW5nIDw9IDApIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICB2YXIgbXNnID0gXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQgXCIgKyBrZXkgKyBcIjogXCIgKyByZWFzb247XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBtc2cpO1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gaXNFcnJvcihyZWFzb24pXG4gICAgICAgICAgICAgID8gcmVhc29uXG4gICAgICAgICAgICAgIDogbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICBuZXh0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gZGVmKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5ldyBzeW50YXggaW4gVnVlIDIuM1xuICAgICAgICAgICAgdmFyIGNvbXAgPSByZXMuY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXAgJiYgdHlwZW9mIGNvbXAudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjb21wLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghaGFzQXN5bmMpIHsgbmV4dCgpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdE1hcENvbXBvbmVudHMgKFxuICBtYXRjaGVkLFxuICBmblxuKSB7XG4gIHJldHVybiBmbGF0dGVuKG1hdGNoZWQubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKFxuICAgICAgbS5jb21wb25lbnRzW2tleV0sXG4gICAgICBtLmluc3RhbmNlc1trZXldLFxuICAgICAgbSwga2V5XG4gICAgKTsgfSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4gKGFycikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxuZnVuY3Rpb24gaXNFU01vZHVsZSAob2JqKSB7XG4gIHJldHVybiBvYmouX19lc01vZHVsZSB8fCAoaGFzU3ltYm9sICYmIG9ialtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbn1cblxuLy8gaW4gV2VicGFjayAyLCByZXF1aXJlLmVuc3VyZSBub3cgYWxzbyByZXR1cm5zIGEgUHJvbWlzZVxuLy8gc28gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9ucyBtYXkgZ2V0IGNhbGxlZCBhbiBleHRyYSB0aW1lXG4vLyBpZiB0aGUgdXNlciB1c2VzIGFuIGFycm93IGZ1bmN0aW9uIHNob3J0aGFuZCB0aGF0IGhhcHBlbnMgdG9cbi8vIHJldHVybiB0aGF0IFByb21pc2UuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaWYgKGNhbGxlZCkgeyByZXR1cm4gfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBIaXN0b3J5ID0gZnVuY3Rpb24gSGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gIHRoaXMucm91dGVyID0gcm91dGVyO1xuICB0aGlzLmJhc2UgPSBub3JtYWxpemVCYXNlKGJhc2UpO1xuICAvLyBzdGFydCB3aXRoIGEgcm91dGUgb2JqZWN0IHRoYXQgc3RhbmRzIGZvciBcIm5vd2hlcmVcIlxuICB0aGlzLmN1cnJlbnQgPSBTVEFSVDtcbiAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICB0aGlzLnJlYWR5Q2JzID0gW107XG4gIHRoaXMucmVhZHlFcnJvckNicyA9IFtdO1xuICB0aGlzLmVycm9yQ2JzID0gW107XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4gKGNiKSB7XG4gIHRoaXMuY2IgPSBjYjtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYiwgZXJyb3JDYikge1xuICBpZiAodGhpcy5yZWFkeSkge1xuICAgIGNiKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWFkeUNicy5wdXNoKGNiKTtcbiAgICBpZiAoZXJyb3JDYikge1xuICAgICAgdGhpcy5yZWFkeUVycm9yQ2JzLnB1c2goZXJyb3JDYik7XG4gICAgfVxuICB9XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvciAoZXJyb3JDYikge1xuICB0aGlzLmVycm9yQ2JzLnB1c2goZXJyb3JDYik7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS50cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiB0cmFuc2l0aW9uVG8gKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHJvdXRlID0gdGhpcy5yb3V0ZXIubWF0Y2gobG9jYXRpb24sIHRoaXMuY3VycmVudCk7XG4gIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgdGhpcyQxLmVuc3VyZVVSTCgpO1xuXG4gICAgLy8gZmlyZSByZWFkeSBjYnMgb25jZVxuICAgIGlmICghdGhpcyQxLnJlYWR5KSB7XG4gICAgICB0aGlzJDEucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcyQxLnJlYWR5Q2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKHJvdXRlKTsgfSk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKG9uQWJvcnQpIHtcbiAgICAgIG9uQWJvcnQoZXJyKTtcbiAgICB9XG4gICAgaWYgKGVyciAmJiAhdGhpcyQxLnJlYWR5KSB7XG4gICAgICB0aGlzJDEucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcyQxLnJlYWR5RXJyb3JDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoZXJyKTsgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmNvbmZpcm1UcmFuc2l0aW9uID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb24gKHJvdXRlLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoaXNFcnJvcihlcnIpKSB7XG4gICAgICBpZiAodGhpcyQxLmVycm9yQ2JzLmxlbmd0aCkge1xuICAgICAgICB0aGlzJDEuZXJyb3JDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoZXJyKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGZhbHNlLCAndW5jYXVnaHQgZXJyb3IgZHVyaW5nIHJvdXRlIG5hdmlnYXRpb246Jyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25BYm9ydCAmJiBvbkFib3J0KGVycik7XG4gIH07XG4gIGlmIChcbiAgICBpc1NhbWVSb3V0ZShyb3V0ZSwgY3VycmVudCkgJiZcbiAgICAvLyBpbiB0aGUgY2FzZSB0aGUgcm91dGUgbWFwIGhhcyBiZWVuIGR5bmFtaWNhbGx5IGFwcGVuZGVkIHRvXG4gICAgcm91dGUubWF0Y2hlZC5sZW5ndGggPT09IGN1cnJlbnQubWF0Y2hlZC5sZW5ndGhcbiAgKSB7XG4gICAgdGhpcy5lbnN1cmVVUkwoKTtcbiAgICByZXR1cm4gYWJvcnQoKVxuICB9XG5cbiAgdmFyIHJlZiA9IHJlc29sdmVRdWV1ZSh0aGlzLmN1cnJlbnQubWF0Y2hlZCwgcm91dGUubWF0Y2hlZCk7XG4gICAgdmFyIHVwZGF0ZWQgPSByZWYudXBkYXRlZDtcbiAgICB2YXIgZGVhY3RpdmF0ZWQgPSByZWYuZGVhY3RpdmF0ZWQ7XG4gICAgdmFyIGFjdGl2YXRlZCA9IHJlZi5hY3RpdmF0ZWQ7XG5cbiAgdmFyIHF1ZXVlID0gW10uY29uY2F0KFxuICAgIC8vIGluLWNvbXBvbmVudCBsZWF2ZSBndWFyZHNcbiAgICBleHRyYWN0TGVhdmVHdWFyZHMoZGVhY3RpdmF0ZWQpLFxuICAgIC8vIGdsb2JhbCBiZWZvcmUgaG9va3NcbiAgICB0aGlzLnJvdXRlci5iZWZvcmVIb29rcyxcbiAgICAvLyBpbi1jb21wb25lbnQgdXBkYXRlIGhvb2tzXG4gICAgZXh0cmFjdFVwZGF0ZUhvb2tzKHVwZGF0ZWQpLFxuICAgIC8vIGluLWNvbmZpZyBlbnRlciBndWFyZHNcbiAgICBhY3RpdmF0ZWQubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmJlZm9yZUVudGVyOyB9KSxcbiAgICAvLyBhc3luYyBjb21wb25lbnRzXG4gICAgcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyhhY3RpdmF0ZWQpXG4gICk7XG5cbiAgdGhpcy5wZW5kaW5nID0gcm91dGU7XG4gIHZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIChob29rLCBuZXh0KSB7XG4gICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgcmV0dXJuIGFib3J0KClcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGhvb2socm91dGUsIGN1cnJlbnQsIGZ1bmN0aW9uICh0bykge1xuICAgICAgICBpZiAodG8gPT09IGZhbHNlIHx8IGlzRXJyb3IodG8pKSB7XG4gICAgICAgICAgLy8gbmV4dChmYWxzZSkgLT4gYWJvcnQgbmF2aWdhdGlvbiwgZW5zdXJlIGN1cnJlbnQgVVJMXG4gICAgICAgICAgdGhpcyQxLmVuc3VyZVVSTCh0cnVlKTtcbiAgICAgICAgICBhYm9ydCh0byk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgdHlwZW9mIHRvID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmIChcbiAgICAgICAgICAgIHR5cGVvZiB0by5wYXRoID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHRvLm5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gbmV4dCgnLycpIG9yIG5leHQoeyBwYXRoOiAnLycgfSkgLT4gcmVkaXJlY3RcbiAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmIHRvLnJlcGxhY2UpIHtcbiAgICAgICAgICAgIHRoaXMkMS5yZXBsYWNlKHRvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcyQxLnB1c2godG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25maXJtIHRyYW5zaXRpb24gYW5kIHBhc3Mgb24gdGhlIHZhbHVlXG4gICAgICAgICAgbmV4dCh0byk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGFib3J0KGUpO1xuICAgIH1cbiAgfTtcblxuICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zdEVudGVyQ2JzID0gW107XG4gICAgdmFyIGlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuY3VycmVudCA9PT0gcm91dGU7IH07XG4gICAgLy8gd2FpdCB1bnRpbCBhc3luYyBjb21wb25lbnRzIGFyZSByZXNvbHZlZCBiZWZvcmVcbiAgICAvLyBleHRyYWN0aW5nIGluLWNvbXBvbmVudCBlbnRlciBndWFyZHNcbiAgICB2YXIgZW50ZXJHdWFyZHMgPSBleHRyYWN0RW50ZXJHdWFyZHMoYWN0aXZhdGVkLCBwb3N0RW50ZXJDYnMsIGlzVmFsaWQpO1xuICAgIHZhciBxdWV1ZSA9IGVudGVyR3VhcmRzLmNvbmNhdCh0aGlzJDEucm91dGVyLnJlc29sdmVIb29rcyk7XG4gICAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBhYm9ydCgpXG4gICAgICB9XG4gICAgICB0aGlzJDEucGVuZGluZyA9IG51bGw7XG4gICAgICBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICAgIGlmICh0aGlzJDEucm91dGVyLmFwcCkge1xuICAgICAgICB0aGlzJDEucm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBvc3RFbnRlckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYigpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudXBkYXRlUm91dGUgPSBmdW5jdGlvbiB1cGRhdGVSb3V0ZSAocm91dGUpIHtcbiAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gIHRoaXMuY3VycmVudCA9IHJvdXRlO1xuICB0aGlzLmNiICYmIHRoaXMuY2Iocm91dGUpO1xuICB0aGlzLnJvdXRlci5hZnRlckhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rICYmIGhvb2socm91dGUsIHByZXYpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2UgKGJhc2UpIHtcbiAgaWYgKCFiYXNlKSB7XG4gICAgaWYgKGluQnJvd3Nlcikge1xuICAgICAgLy8gcmVzcGVjdCA8YmFzZT4gdGFnXG4gICAgICB2YXIgYmFzZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgICAgYmFzZSA9IChiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB8fCAnLyc7XG4gICAgICAvLyBzdHJpcCBmdWxsIFVSTCBvcmlnaW5cbiAgICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UoL15odHRwcz86XFwvXFwvW15cXC9dKy8sICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9ICcvJztcbiAgICB9XG4gIH1cbiAgLy8gbWFrZSBzdXJlIHRoZXJlJ3MgdGhlIHN0YXJ0aW5nIHNsYXNoXG4gIGlmIChiYXNlLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgYmFzZSA9ICcvJyArIGJhc2U7XG4gIH1cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gIHJldHVybiBiYXNlLnJlcGxhY2UoL1xcLyQvLCAnJylcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXVlIChcbiAgY3VycmVudCxcbiAgbmV4dFxuKSB7XG4gIHZhciBpO1xuICB2YXIgbWF4ID0gTWF0aC5tYXgoY3VycmVudC5sZW5ndGgsIG5leHQubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgaWYgKGN1cnJlbnRbaV0gIT09IG5leHRbaV0pIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdXBkYXRlZDogbmV4dC5zbGljZSgwLCBpKSxcbiAgICBhY3RpdmF0ZWQ6IG5leHQuc2xpY2UoaSksXG4gICAgZGVhY3RpdmF0ZWQ6IGN1cnJlbnQuc2xpY2UoaSlcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmRzIChcbiAgcmVjb3JkcyxcbiAgbmFtZSxcbiAgYmluZCxcbiAgcmV2ZXJzZVxuKSB7XG4gIHZhciBndWFyZHMgPSBmbGF0TWFwQ29tcG9uZW50cyhyZWNvcmRzLCBmdW5jdGlvbiAoZGVmLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSkge1xuICAgIHZhciBndWFyZCA9IGV4dHJhY3RHdWFyZChkZWYsIG5hbWUpO1xuICAgIGlmIChndWFyZCkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZ3VhcmQpXG4gICAgICAgID8gZ3VhcmQubWFwKGZ1bmN0aW9uIChndWFyZCkgeyByZXR1cm4gYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpOyB9KVxuICAgICAgICA6IGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmbGF0dGVuKHJldmVyc2UgPyBndWFyZHMucmV2ZXJzZSgpIDogZ3VhcmRzKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmQgKFxuICBkZWYsXG4gIGtleVxuKSB7XG4gIGlmICh0eXBlb2YgZGVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZXh0ZW5kIG5vdyBzbyB0aGF0IGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQuXG4gICAgZGVmID0gX1Z1ZS5leHRlbmQoZGVmKTtcbiAgfVxuICByZXR1cm4gZGVmLm9wdGlvbnNba2V5XVxufVxuXG5mdW5jdGlvbiBleHRyYWN0TGVhdmVHdWFyZHMgKGRlYWN0aXZhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGRlYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVMZWF2ZScsIGJpbmRHdWFyZCwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFVwZGF0ZUhvb2tzICh1cGRhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKHVwZGF0ZWQsICdiZWZvcmVSb3V0ZVVwZGF0ZScsIGJpbmRHdWFyZClcbn1cblxuZnVuY3Rpb24gYmluZEd1YXJkIChndWFyZCwgaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kUm91dGVHdWFyZCAoKSB7XG4gICAgICByZXR1cm4gZ3VhcmQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVudGVyR3VhcmRzIChcbiAgYWN0aXZhdGVkLFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUVudGVyJywgZnVuY3Rpb24gKGd1YXJkLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgcmV0dXJuIGJpbmRFbnRlckd1YXJkKGd1YXJkLCBtYXRjaCwga2V5LCBjYnMsIGlzVmFsaWQpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGJpbmRFbnRlckd1YXJkIChcbiAgZ3VhcmQsXG4gIG1hdGNoLFxuICBrZXksXG4gIGNicyxcbiAgaXNWYWxpZFxuKSB7XG4gIHJldHVybiBmdW5jdGlvbiByb3V0ZUVudGVyR3VhcmQgKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgcmV0dXJuIGd1YXJkKHRvLCBmcm9tLCBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIG5leHQoY2IpO1xuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gIzc1MFxuICAgICAgICAgIC8vIGlmIGEgcm91dGVyLXZpZXcgaXMgd3JhcHBlZCB3aXRoIGFuIG91dC1pbiB0cmFuc2l0aW9uLFxuICAgICAgICAgIC8vIHRoZSBpbnN0YW5jZSBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIGF0IHRoaXMgdGltZS5cbiAgICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgdG8gcG9sbCBmb3IgcmVnaXN0cmF0aW9uIHVudGlsIGN1cnJlbnQgcm91dGVcbiAgICAgICAgICAvLyBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgICAgICAgcG9sbChjYiwgbWF0Y2guaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvbGwgKFxuICBjYiwgLy8gc29tZWhvdyBmbG93IGNhbm5vdCBpbmZlciB0aGlzIGlzIGEgZnVuY3Rpb25cbiAgaW5zdGFuY2VzLFxuICBrZXksXG4gIGlzVmFsaWRcbikge1xuICBpZiAoaW5zdGFuY2VzW2tleV0pIHtcbiAgICBjYihpbnN0YW5jZXNba2V5XSk7XG4gIH0gZWxzZSBpZiAoaXNWYWxpZCgpKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBwb2xsKGNiLCBpbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgfSwgMTYpO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBIVE1MNUhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSFRNTDVIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuXG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuXG4gICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgc2V0dXBTY3JvbGwoKTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdExvY2F0aW9uID0gZ2V0TG9jYXRpb24odGhpcy5iYXNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcblxuICAgICAgLy8gQXZvaWRpbmcgZmlyc3QgYHBvcHN0YXRlYCBldmVudCBkaXNwYXRjaGVkIGluIHNvbWUgYnJvd3NlcnMgYnV0IGZpcnN0XG4gICAgICAvLyBoaXN0b3J5IHJvdXRlIG5vdCB1cGRhdGVkIHNpbmNlIGFzeW5jIGd1YXJkIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbih0aGlzJDEuYmFzZSk7XG4gICAgICBpZiAodGhpcyQxLmN1cnJlbnQgPT09IFNUQVJUICYmIGxvY2F0aW9uID09PSBpbml0TG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAoZXhwZWN0U2Nyb2xsKSB7XG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHJvdXRlciwgcm91dGUsIGN1cnJlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEhUTUw1SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSFRNTDVIaXN0b3J5O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaFN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJlcGxhY2VTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICBpZiAoZ2V0TG9jYXRpb24odGhpcy5iYXNlKSAhPT0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGNsZWFuUGF0aCh0aGlzLmJhc2UgKyB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpO1xuICAgICAgcHVzaCA/IHB1c2hTdGF0ZShjdXJyZW50KSA6IHJlcGxhY2VTdGF0ZShjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRMb2NhdGlvbih0aGlzLmJhc2UpXG4gIH07XG5cbiAgcmV0dXJuIEhUTUw1SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBnZXRMb2NhdGlvbiAoYmFzZSkge1xuICB2YXIgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgaWYgKGJhc2UgJiYgcGF0aC5pbmRleE9mKGJhc2UpID09PSAwKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoXG59XG5cbi8qICAqL1xuXG5cbnZhciBIYXNoSGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBIYXNoSGlzdG9yeSAocm91dGVyLCBiYXNlLCBmYWxsYmFjaykge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIC8vIGNoZWNrIGhpc3RvcnkgZmFsbGJhY2sgZGVlcGxpbmtpbmdcbiAgICBpZiAoZmFsbGJhY2sgJiYgY2hlY2tGYWxsYmFjayh0aGlzLmJhc2UpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZW5zdXJlU2xhc2goKTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEhhc2hIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGFzaEhpc3Rvcnk7XG5cbiAgLy8gdGhpcyBpcyBkZWxheWVkIHVudGlsIHRoZSBhcHAgbW91bnRzXG4gIC8vIHRvIGF2b2lkIHRoZSBoYXNoY2hhbmdlIGxpc3RlbmVyIGJlaW5nIGZpcmVkIHRvbyBlYXJseVxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuc2V0dXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXR1cExpc3RlbmVycyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICAgIHZhciBzdXBwb3J0c1Njcm9sbCA9IHN1cHBvcnRzUHVzaFN0YXRlICYmIGV4cGVjdFNjcm9sbDtcblxuICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgc2V0dXBTY3JvbGwoKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihzdXBwb3J0c1B1c2hTdGF0ZSA/ICdwb3BzdGF0ZScgOiAnaGFzaGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcyQxLmN1cnJlbnQ7XG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldEhhc2goKSwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdXBwb3J0c1B1c2hTdGF0ZSkge1xuICAgICAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudC5mdWxsUGF0aDtcbiAgICBpZiAoZ2V0SGFzaCgpICE9PSBjdXJyZW50KSB7XG4gICAgICBwdXNoID8gcHVzaEhhc2goY3VycmVudCkgOiByZXBsYWNlSGFzaChjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEhhc2goKVxuICB9O1xuXG4gIHJldHVybiBIYXNoSGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBjaGVja0ZhbGxiYWNrIChiYXNlKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdldExvY2F0aW9uKGJhc2UpO1xuICBpZiAoIS9eXFwvIy8udGVzdChsb2NhdGlvbikpIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShcbiAgICAgIGNsZWFuUGF0aChiYXNlICsgJy8jJyArIGxvY2F0aW9uKVxuICAgICk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCAoKSB7XG4gIHZhciBwYXRoID0gZ2V0SGFzaCgpO1xuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmVwbGFjZUhhc2goJy8nICsgcGF0aCk7XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZXRIYXNoICgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zbGljZShpbmRleCArIDEpXG59XG5cbmZ1bmN0aW9uIGdldFVybCAocGF0aCkge1xuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaSA9IGhyZWYuaW5kZXhPZignIycpO1xuICB2YXIgYmFzZSA9IGkgPj0gMCA/IGhyZWYuc2xpY2UoMCwgaSkgOiBocmVmO1xuICByZXR1cm4gKGJhc2UgKyBcIiNcIiArIHBhdGgpXG59XG5cbmZ1bmN0aW9uIHB1c2hIYXNoIChwYXRoKSB7XG4gIGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuICAgIHB1c2hTdGF0ZShnZXRVcmwocGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaCAocGF0aCkge1xuICBpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICByZXBsYWNlU3RhdGUoZ2V0VXJsKHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShnZXRVcmwocGF0aCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBBYnN0cmFjdEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3RIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy5pbmRleCA9IC0xO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgQWJzdHJhY3RIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBYnN0cmFjdEhpc3Rvcnk7XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXggKyAxKS5jb25jYXQocm91dGUpO1xuICAgICAgdGhpcyQxLmluZGV4Kys7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4KS5jb25jYXQocm91dGUpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB0YXJnZXRJbmRleCA9IHRoaXMuaW5kZXggKyBuO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcm91dGUgPSB0aGlzLnN0YWNrW3RhcmdldEluZGV4XTtcbiAgICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEuaW5kZXggPSB0YXJnZXRJbmRleDtcbiAgICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5mdWxsUGF0aCA6ICcvJ1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMICgpIHtcbiAgICAvLyBub29wXG4gIH07XG5cbiAgcmV0dXJuIEFic3RyYWN0SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG4vKiAgKi9cblxudmFyIFZ1ZVJvdXRlciA9IGZ1bmN0aW9uIFZ1ZVJvdXRlciAob3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICB0aGlzLmFwcCA9IG51bGw7XG4gIHRoaXMuYXBwcyA9IFtdO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmJlZm9yZUhvb2tzID0gW107XG4gIHRoaXMucmVzb2x2ZUhvb2tzID0gW107XG4gIHRoaXMuYWZ0ZXJIb29rcyA9IFtdO1xuICB0aGlzLm1hdGNoZXIgPSBjcmVhdGVNYXRjaGVyKG9wdGlvbnMucm91dGVzIHx8IFtdLCB0aGlzKTtcblxuICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAnaGFzaCc7XG4gIHRoaXMuZmFsbGJhY2sgPSBtb2RlID09PSAnaGlzdG9yeScgJiYgIXN1cHBvcnRzUHVzaFN0YXRlICYmIG9wdGlvbnMuZmFsbGJhY2sgIT09IGZhbHNlO1xuICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgIG1vZGUgPSAnaGFzaCc7XG4gIH1cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICBtb2RlID0gJ2Fic3RyYWN0JztcbiAgfVxuICB0aGlzLm1vZGUgPSBtb2RlO1xuXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ2hpc3RvcnknOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhUTUw1SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIYXNoSGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UsIHRoaXMuZmFsbGJhY2spO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdhYnN0cmFjdCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgQWJzdHJhY3RIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIChcImludmFsaWQgbW9kZTogXCIgKyBtb2RlKSk7XG4gICAgICB9XG4gIH1cbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGN1cnJlbnRSb3V0ZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIHJlZGlyZWN0ZWRGcm9tXG4pIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2hlci5tYXRjaChyYXcsIGN1cnJlbnQsIHJlZGlyZWN0ZWRGcm9tKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmN1cnJlbnRSb3V0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LmN1cnJlbnRcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGFwcCAvKiBWdWUgY29tcG9uZW50IGluc3RhbmNlICovKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnQoXG4gICAgaW5zdGFsbC5pbnN0YWxsZWQsXG4gICAgXCJub3QgaW5zdGFsbGVkLiBNYWtlIHN1cmUgdG8gY2FsbCBgVnVlLnVzZShWdWVSb3V0ZXIpYCBcIiArXG4gICAgXCJiZWZvcmUgY3JlYXRpbmcgcm9vdCBpbnN0YW5jZS5cIlxuICApO1xuXG4gIHRoaXMuYXBwcy5wdXNoKGFwcCk7XG5cbiAgLy8gbWFpbiBhcHAgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgaWYgKHRoaXMuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmFwcCA9IGFwcDtcblxuICB2YXIgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcblxuICBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhUTUw1SGlzdG9yeSkge1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9IGVsc2UgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIYXNoSGlzdG9yeSkge1xuICAgIHZhciBzZXR1cEhhc2hMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhpc3Rvcnkuc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKFxuICAgICAgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSxcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXJcbiAgICApO1xuICB9XG5cbiAgaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgdGhpcyQxLmFwcHMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XG4gICAgICBhcHAuX3JvdXRlID0gcm91dGU7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmJlZm9yZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlUmVzb2x2ZSA9IGZ1bmN0aW9uIGJlZm9yZVJlc29sdmUgKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5yZXNvbHZlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5hZnRlckhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiLCBlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uRXJyb3IoZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucHVzaChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgdGhpcy5oaXN0b3J5LmdvKG4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gYmFjayAoKSB7XG4gIHRoaXMuZ28oLTEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gZm9yd2FyZCAoKSB7XG4gIHRoaXMuZ28oMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdldE1hdGNoZWRDb21wb25lbnRzID0gZnVuY3Rpb24gZ2V0TWF0Y2hlZENvbXBvbmVudHMgKHRvKSB7XG4gIHZhciByb3V0ZSA9IHRvXG4gICAgPyB0by5tYXRjaGVkXG4gICAgICA/IHRvXG4gICAgICA6IHRoaXMucmVzb2x2ZSh0bykucm91dGVcbiAgICA6IHRoaXMuY3VycmVudFJvdXRlO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG0uY29tcG9uZW50c1trZXldXG4gICAgfSlcbiAgfSkpXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChcbiAgdG8sXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKFxuICAgIHRvLFxuICAgIGN1cnJlbnQgfHwgdGhpcy5oaXN0b3J5LmN1cnJlbnQsXG4gICAgYXBwZW5kLFxuICAgIHRoaXNcbiAgKTtcbiAgdmFyIHJvdXRlID0gdGhpcy5tYXRjaChsb2NhdGlvbiwgY3VycmVudCk7XG4gIHZhciBmdWxsUGF0aCA9IHJvdXRlLnJlZGlyZWN0ZWRGcm9tIHx8IHJvdXRlLmZ1bGxQYXRoO1xuICB2YXIgYmFzZSA9IHRoaXMuaGlzdG9yeS5iYXNlO1xuICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYoYmFzZSwgZnVsbFBhdGgsIHRoaXMubW9kZSk7XG4gIHJldHVybiB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHJvdXRlOiByb3V0ZSxcbiAgICBocmVmOiBocmVmLFxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgbm9ybWFsaXplZFRvOiBsb2NhdGlvbixcbiAgICByZXNvbHZlZDogcm91dGVcbiAgfVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZXMgPSBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICB0aGlzLm1hdGNoZXIuYWRkUm91dGVzKHJvdXRlcyk7XG4gIGlmICh0aGlzLmhpc3RvcnkuY3VycmVudCAhPT0gU1RBUlQpIHtcbiAgICB0aGlzLmhpc3RvcnkudHJhbnNpdGlvblRvKHRoaXMuaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWdWVSb3V0ZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJIb29rIChsaXN0LCBmbikge1xuICBsaXN0LnB1c2goZm4pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gbGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7IGxpc3Quc3BsaWNlKGksIDEpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZiAoYmFzZSwgZnVsbFBhdGgsIG1vZGUpIHtcbiAgdmFyIHBhdGggPSBtb2RlID09PSAnaGFzaCcgPyAnIycgKyBmdWxsUGF0aCA6IGZ1bGxQYXRoO1xuICByZXR1cm4gYmFzZSA/IGNsZWFuUGF0aChiYXNlICsgJy8nICsgcGF0aCkgOiBwYXRoXG59XG5cblZ1ZVJvdXRlci5pbnN0YWxsID0gaW5zdGFsbDtcblZ1ZVJvdXRlci52ZXJzaW9uID0gJzMuMC4xJztcblxuaWYgKGluQnJvd3NlciAmJiB3aW5kb3cuVnVlKSB7XG4gIHdpbmRvdy5WdWUudXNlKFZ1ZVJvdXRlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZVJvdXRlcjtcbiIsImltcG9ydCBSb3V0ZXIgZnJvbSAndnVlLXJvdXRlcidcbmltcG9ydCBNYWluIGZyb20gJ0Bjb21wb25lbnRzL01haW4udnVlJ1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgUm91dGVyKHtcbiAgbW9kZSA6ICdoaXN0b3J5JyxcbiAgcm91dGVzIDogW1xuICAgIHtcbiAgICAgIHBhdGg6ICAgICAgJy8nLFxuICAgICAgY29tcG9uZW50OiBNYWluXG4gICAgfVxuICBdXG59KVxuIiwiXG5cblxuXG5cblxuaW1wb3J0IHsgVnVlLCBDb21wb25lbnQsIFByb3AsIFdhdGNoIH0gZnJvbSAndnVlLXByb3BlcnR5LWRlY29yYXRvcidcblxuQENvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbiBleHRlbmRzIFZ1ZSB7XG4gIEBQcm9wKCkgcHJvcDogc3RyaW5nfG51bGxcbiAgbW91bnRlZCgpIHsgXG4gIH1cbn1cbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX3ZtLl9tKDApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCBbX2MoXCJoMVwiLCBbX3ZtLl92KFwiVGVzdFwiKV0pXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9XG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTU0ZDNhNTJlXCIsIHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH0pXG4gIH1cbn0iLCIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICBzY3JpcHRFeHBvcnRzID0gc2NyaXB0RXhwb3J0cyB8fCB7fVxuXG4gIC8vIEVTNiBtb2R1bGVzIGludGVyb3BcbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2NyaXB0RXhwb3J0cyA9IHNjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICB9XG5cbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChyZW5kZXIpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zXG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlXG4gIH1cblxuICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChmdW5jdGlvbmFsVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IHNoYWRvd01vZGVcbiAgICAgID8gZnVuY3Rpb24gKCkgeyBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCB0aGlzLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3QpIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgdmFyIG9yaWdpbmFsUmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uIChoLCBjb250ZXh0KSB7XG4gICAgICAgIGhvb2suY2FsbChjb250ZXh0KVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIHZhciBleGlzdGluZyA9IG9wdGlvbnMuYmVmb3JlQ3JlYXRlXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cbiIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoY29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwib3B0aW9uc0lkXFxcIjpcXFwiMFxcXCIsXFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNTRkM2E1MmVcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcInNvdXJjZU1hcFxcXCI6dHJ1ZX0hc2Fzcy1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9NYWluLnZ1ZVwiKVxufVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISF0cy1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9NYWluLnZ1ZVwiXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhdHMtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vTWFpbi52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCB7cmVuZGVyIGFzIF9fdnVlX3JlbmRlcl9fLCBzdGF0aWNSZW5kZXJGbnMgYXMgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfX30gZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNTRkM2E1MmVcXFwiLFxcXCJoYXNTY29wZWRcXFwiOnRydWUsXFxcIm9wdGlvbnNJZFxcXCI6XFxcIjBcXFwiLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9NYWluLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBcImRhdGEtdi01NGQzYTUyZVwiXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxuaW1wb3J0IG5vcm1hbGl6ZUNvbXBvbmVudCBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudC1ub3JtYWxpemVyXCJcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV9yZW5kZXJfXyxcbiAgX192dWVfc3RhdGljX3JlbmRlcl9mbnNfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01haW4udnVlXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTU0ZDNhNTJlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNTRkM2E1MmVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuIiwiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgTWFpbiBmcm9tICdAY29tcG9uZW50cy9NYWluLnZ1ZSdcbmltcG9ydCBWdWV4IGZyb20gJ3Z1ZXgnXG5pbXBvcnQgcm91dGVyIGZyb20gJ0BzcmMvcm91dGVyJ1xuaW1wb3J0IFZ1ZVJvdXRlciBmcm9tICd2dWUtcm91dGVyJ1xuaW1wb3J0ICogYXMgZm9udExvYWRlciBmcm9tICd3ZWJmb250bG9hZGVyJ1xuaW1wb3J0IFZ1ZXRpZnkgZnJvbSAndnVldGlmeSdcbi8vIGltcG9ydCBzdG9yZSBmcm9tICcuL3N0b3JlJ1xuaW1wb3J0IFZ1ZUxhenlsb2FkIGZyb20gJ3Z1ZS1sYXp5bG9hZCdcblxuVnVlLmNvbmZpZy5wcm9kdWN0aW9uVGlwID0gdHJ1ZVxuXG5WdWUudXNlKFZ1ZXgpXG5cblZ1ZS51c2UoVnVlUm91dGVyKVxuXG5WdWUudXNlKFZ1ZXRpZnkpXG5WdWUudXNlKFZ1ZUxhenlsb2FkLCB7XG4gIGxhenlDb21wb25lbnQgOiB0cnVlXG59KVxuLy8gbG9hZCB3ZWJmb250cyBhc3luY2hyb25vdXNseVxuaWYgKHdpbmRvdykge1xuICBmb250TG9hZGVyLmxvYWQoe1xuICAgIGN1c3RvbToge1xuICAgICAgZmFtaWxpZXMgOiBbJ0hLR3JvdGVzayddXG4gICAgfVxuICB9KVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xubmV3IFZ1ZSh7XG4gICAgZWwgOiAnI2FwcCcsXG4gICAgcmVuZGVyIDogaCA9PiBoKE1haW4pLFxuICAgIHJvdXRlcixcbiAgICAvLyBzdG9yZVxufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/listToStyles.js\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nfunction listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n// CONCATENATED MODULE: ./node_modules/vue-style-loader/lib/addStylesClient.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return addStylesClient; });\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\n\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\nvar options = null\nvar ssrIdKey = 'data-vue-ssr-id'\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nfunction addStylesClient (parentId, list, _isProduction, _options) {\n  isProduction = _isProduction\n\n  options = _options || {}\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[' + ssrIdKey + '~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n  if (options.ssrId) {\n    styleElement.setAttribute(ssrIdKey, obj.id)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvbGlzdFRvU3R5bGVzLmpzPzliYmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcz80OTllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5Qzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7O0FBRUE7O0FBRUEsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbGlzdCBmb3JtYXQgcHJvZHVjZWQgYnkgY3NzLWxvYWRlciBpbnRvIHNvbWV0aGluZ1xuICogZWFzaWVyIHRvIG1hbmlwdWxhdGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAocGFyZW50SWQsIGxpc3QpIHtcbiAgdmFyIHN0eWxlcyA9IFtdXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICB2YXIgaWQgPSBpdGVtWzBdXG4gICAgdmFyIGNzcyA9IGl0ZW1bMV1cbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfVxuICAgIGlmICghbmV3U3R5bGVzW2lkXSkge1xuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzXG59XG4iLCIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbmltcG9ydCBsaXN0VG9TdHlsZXMgZnJvbSAnLi9saXN0VG9TdHlsZXMnXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxudmFyIG9wdGlvbnMgPSBudWxsXG52YXIgc3NySWRLZXkgPSAnZGF0YS12dWUtc3NyLWlkJ1xuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRTdHlsZXNDbGllbnQgKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uLCBfb3B0aW9ucykge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgb3B0aW9ucyA9IF9vcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbJyArIHNzcklkS2V5ICsgJ349XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG4gIGlmIChvcHRpb25zLnNzcklkKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShzc3JJZEtleSwgb2JqLmlkKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n")}]);